(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("react-dom")) : typeof define === "function" && define.amd ? define(["exports", "react", "react-dom"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global["Nitro UI"] = {}, global.React, global.ReactDOM));
})(this, function(exports2, React, ReactDOM) {
  "use strict";
  function _interopNamespaceCompat(e) {
    if (e && typeof e === "object" && "default" in e) return e;
    const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      for (const k in e) {
        if (k !== "default") {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceCompat(React);
  const ReactDOM__namespace = /* @__PURE__ */ _interopNamespaceCompat(ReactDOM);
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_production_min;
  function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var f = React__namespace.default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b, d = {}, e = null, h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h = a.ref);
      for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
    }
    reactJsxRuntime_production_min.Fragment = l;
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    return reactJsxRuntime_production_min;
  }
  var reactJsxRuntime_development = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_development;
  function requireReactJsxRuntime_development() {
    if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
    hasRequiredReactJsxRuntime_development = 1;
    if (process.env.NODE_ENV !== "production") {
      (function() {
        var React2 = React__namespace.default;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2) ;
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum();
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
        reactJsxRuntime_development.jsx = jsx;
        reactJsxRuntime_development.jsxs = jsxs;
      })();
    }
    return reactJsxRuntime_development;
  }
  if (process.env.NODE_ENV === "production") {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  } else {
    jsxRuntime.exports = requireReactJsxRuntime_development();
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  const genArc = ({
    center,
    innerRadius,
    largeArc,
    length,
    offset: offset2,
    outerRadius,
    seqLength
  }) => {
    const leftBottom = findCoor({
      index: offset2,
      radius: innerRadius,
      center,
      seqLength
    });
    const leftTop = findCoor({
      index: offset2,
      radius: outerRadius,
      center,
      seqLength
    });
    const rightBottom = findCoor({
      index: length + offset2,
      radius: innerRadius,
      center,
      seqLength
    });
    const rightTop = findCoor({
      index: length + offset2,
      radius: outerRadius,
      center,
      seqLength
    });
    const sFlagF = 1;
    const sFlagR = 0;
    const lArc = largeArc ? 1 : 0;
    return `M ${rightBottom.x} ${rightBottom.y}
      A ${innerRadius} ${innerRadius}, 0, ${lArc}, ${sFlagR}, ${leftBottom.x} ${leftBottom.y}
      L ${leftBottom.x} ${leftBottom.y}
      L ${leftTop.x} ${leftTop.y}
      A ${outerRadius} ${outerRadius}, 0, ${lArc}, ${sFlagF}, ${rightTop.x} ${rightTop.y}
      Z`;
  };
  const findCoor = ({
    index: index2,
    radius,
    center,
    seqLength
  }) => {
    const lengthPerc = index2 / seqLength;
    const lengthPercCentered = lengthPerc - 0.25;
    const radians = lengthPercCentered * Math.PI * 2;
    const xAdjust = Math.cos(radians) * radius;
    const yAdjust = Math.sin(radians) * radius;
    return {
      x: center.x + xAdjust,
      y: center.y + yAdjust
    };
  };
  const findAngleFromCoor = ({
    coor,
    center
  }) => {
    const x = coor.x - center.x;
    const y = coor.y - center.y;
    let radians = Math.atan2(y, x);
    if (radians < 0) {
      radians = radians + Math.PI * 2;
    }
    return radians * (180 / Math.PI);
  };
  const findIndexFromAngle = ({
    angle,
    seqLength
  }) => {
    let effectiveAngle = angle.degrees + 90;
    if (effectiveAngle < 0) {
      effectiveAngle = 360 + effectiveAngle;
    }
    effectiveAngle = effectiveAngle % 360;
    const arcPerc = effectiveAngle / 360;
    const rawBaseIdx = arcPerc * seqLength;
    return Math.round(rawBaseIdx < 0 ? seqLength + rawBaseIdx : rawBaseIdx);
  };
  const clampSlice = ({
    slice,
    firstIdx,
    lastIdx
  }) => {
    if (!slice) {
      return null;
    }
    let { start, end } = slice;
    const outOfBoundsBefore = start < firstIdx && end < firstIdx;
    const outOfBoundsAfter = start > lastIdx && end > lastIdx;
    if (outOfBoundsBefore || outOfBoundsAfter) {
      return null;
    }
    if (start >= end) {
      start = Math.min(start, lastIdx);
      end = Math.max(end, firstIdx);
    } else {
      end = Math.min(end, lastIdx);
      start = Math.max(start, firstIdx);
    }
    return {
      start,
      end,
      direction: slice.direction
    };
  };
  var months = [
    "JAN",
    "FEB",
    "MAR",
    "APR",
    "MAY",
    "JUN",
    "JUL",
    "AUG",
    "SEP",
    "OCT",
    "NOV",
    "DEC"
  ];
  const MONTHS = months;
  function genbankToJson(sequence) {
    if (typeof sequence !== "string") {
      throw new TypeError("input must be a string");
    }
    let resultsArray = [];
    let result;
    let currentFeatureNote;
    let genbankAnnotationKey = {
      // Contains in order: locus name, sequence length, molecule type (e.g. DNA), genbank division (see 1-18 below), modification date
      // locus definition has changed with time, use accession number for a unique identifier
      LOCUS_TAG: "LOCUS",
      DEFINITION_TAG: "DEFINITION",
      // Accession tag
      // Example: Z78533
      ACCESSION_TAG: "ACCESSION",
      // The version tag contains 2 informations
      // The accession number with a revision
      // The GI (GenInfo Identifier), a ncbi sequential number
      // Example: Z78533.1  GI:2765658
      // Unicity garanteed with respect to sequence. If 1 nucleotide changes, the version is different.
      VERSION_TAG: "VERSION",
      KEYWORDS_TAG: "KEYWORDS",
      // SEGMENT_TAG:"SEGMENT"
      // Source is free text
      SOURCE_TAG: "SOURCE",
      ORGANISM_TAG: "ORGANISM",
      REFERENCE_TAG: "REFERENCE",
      FEATURES_TAG: "FEATURES",
      // CONTIG_TAG: "CONTIG"
      ORIGIN_TAG: "ORIGIN",
      END_SEQUENCE_TAG: "//"
    };
    let lines = sequence.split(/\r?\n/);
    let fieldName;
    let subFieldType;
    let featureLocationIndentation;
    let lastLineWasFeaturesTag;
    let lastLineWasLocation;
    let hasFoundLocus = false;
    for (let line of lines) {
      if (line === null) break;
      let lineFieldName = getLineFieldName(line);
      let val = getLineVal(line);
      let isSubKey = isSubKeyword(line);
      let isKey = isKeyword(line);
      if (lineFieldName === genbankAnnotationKey.END_SEQUENCE_TAG || isKey) {
        fieldName = lineFieldName;
        subFieldType = null;
      } else if (isSubKey) {
        subFieldType = lineFieldName;
      }
      if (line.trim() === "" || lineFieldName === ";") {
        continue;
      }
      if (!hasFoundLocus && fieldName !== genbankAnnotationKey.LOCUS_TAG) {
        break;
      }
      switch (fieldName) {
        case genbankAnnotationKey.LOCUS_TAG:
          hasFoundLocus = true;
          parseLocus(line);
          break;
        case genbankAnnotationKey.FEATURES_TAG:
          parseFeatures(line, lineFieldName, val);
          break;
        case genbankAnnotationKey.ORIGIN_TAG:
          parseOrigin(line, lineFieldName);
          break;
        case genbankAnnotationKey.DEFINITION_TAG:
        case genbankAnnotationKey.ACCESSION_TAG:
        case genbankAnnotationKey.VERSION_TAG:
        case genbankAnnotationKey.KEYWORDS_TAG:
          parseMultiLineField(fieldName, line, fieldName.toLowerCase());
          break;
        case genbankAnnotationKey.SOURCE_TAG:
          if (subFieldType === genbankAnnotationKey.ORGANISM_TAG) {
            parseMultiLineField(subFieldType, line, "organism");
          } else {
            parseMultiLineField(lineFieldName, line, "source");
          }
          break;
        case genbankAnnotationKey.REFERENCE_TAG:
          if (lineFieldName === genbankAnnotationKey.REFERENCE_TAG) {
            const ref = result.references || [];
            result.references = ref;
            ref.push({});
          }
          parseReference(line, subFieldType);
          break;
        case genbankAnnotationKey.END_SEQUENCE_TAG:
          endSeq();
          break;
      }
    }
    if (resultsArray[resultsArray.length - 1] !== result) {
      endSeq();
    }
    return resultsArray;
    function endSeq() {
      postProcessCurSeq();
      resultsArray.push(result);
    }
    function getCurrentFeature() {
      return result.features[result.features.length - 1];
    }
    function postProcessCurSeq() {
      if (result && result.features) {
        for (let i = 0; i < result.features.length; i++) {
          result.features[i] = postProcessGenbankFeature(result.features[i]);
        }
      }
    }
    function parseOrigin(line, key) {
      if (key !== genbankAnnotationKey.ORIGIN_TAG) {
        let newLine = line.replace(/[\s]*[0-9]*/g, "");
        result.sequence += newLine;
      }
    }
    function parseLocus(line) {
      result = {
        features: [],
        name: "Untitled sequence",
        sequence: "",
        references: []
      };
      line = removeFieldName(genbankAnnotationKey.LOCUS_TAG, line);
      const m = line.match(
        /^([^\s]+)\s+(\d+)\s+bp\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*([^\s]+)?$/
      );
      let locusName = m[1];
      let size2 = +m[2];
      let moleculeType = m[3];
      let circular = m[4] === "circular";
      const seq = result;
      let dateStr = "";
      if (!m[6]) {
        dateStr = m[5];
      } else {
        seq.genbankDivision = m[5];
        dateStr = m[6];
      }
      seq.circular = circular;
      seq.moleculeType = moleculeType;
      const dateMatch = dateStr.match(/^(\d{2})-(.{3})-(\d{4})$/);
      const date = /* @__PURE__ */ new Date();
      date.setFullYear(+dateMatch[3]);
      date.setUTCMonth(MONTHS.indexOf(dateMatch[2].toUpperCase()));
      date.setDate(+dateMatch[1]);
      date.setUTCHours(12);
      date.setMinutes(0);
      date.setSeconds(0);
      date.setMilliseconds(0);
      seq.date = date.toISOString();
      seq.name = locusName;
      seq.size = size2;
    }
    function removeFieldName(fName, line) {
      line = line.replace(/^\s*/, "");
      if (line.indexOf(fName) === 0) {
        line = line.replace(fName, "");
      }
      return line.trim();
    }
    function parseReference(line, subType) {
      const refs = result.references;
      let lastRef = refs[refs.length - 1];
      if (!subType) {
        parseMultiLineField(
          genbankAnnotationKey.REFERENCE_TAG,
          line,
          "description",
          lastRef
        );
      } else {
        parseMultiLineField(subType, line, subType.toLowerCase(), lastRef);
      }
    }
    function parseFeatures(line, key, val) {
      let strand;
      if (key === genbankAnnotationKey.FEATURES_TAG) {
        lastLineWasFeaturesTag = true;
        return;
      }
      if (lastLineWasFeaturesTag) {
        featureLocationIndentation = getLengthOfWhiteSpaceBeforeStartOfLetters(
          line
        );
        lastLineWasFeaturesTag = false;
      }
      if (isFeatureLineRunon(line, featureLocationIndentation)) {
        if (lastLineWasLocation) {
          parseFeatureLocation(line.trim());
          lastLineWasLocation = true;
        } else {
          if (currentFeatureNote) {
            currentFeatureNote[currentFeatureNote.length - 1] += line.trim().replace(/"/g, "");
          }
          lastLineWasLocation = false;
        }
      } else {
        if (isNote(line)) {
          if (getCurrentFeature()) {
            parseFeatureNote(line);
            lastLineWasLocation = false;
          }
        } else {
          if (val.match(/complement/g)) {
            strand = -1;
          } else {
            strand = 1;
          }
          newFeature();
          let feat = getCurrentFeature();
          feat.type = key;
          feat.strand = strand;
          parseFeatureLocation(val);
          lastLineWasLocation = true;
        }
      }
    }
    function newFeature() {
      result.features.push({
        notes: {}
      });
    }
    function isNote(line) {
      let qual = false;
      if (line.trim().charAt(0).match(/\//)) {
        qual = true;
      } else if (line.match(/^[\s]*\/[\w]+=[\S]+/)) {
        qual = true;
      }
      return qual;
    }
    function parseFeatureLocation(locStr) {
      locStr = locStr.trim();
      let locArr = [];
      locStr.replace(/(\d+)/g, function(string, match) {
        locArr.push(match);
      });
      let feat = getCurrentFeature();
      feat.start = +locArr[0];
      feat.end = locArr[1] === void 0 ? +locArr[0] : +locArr[1];
    }
    function parseFeatureNote(line) {
      let newLine, lineArr;
      newLine = line.trim();
      newLine = newLine.replace(/^\/|"$/g, "");
      lineArr = newLine.split(/="|=/);
      let val = lineArr[1];
      if (val) {
        val = val.replace(/\\/g, " ");
        if (line.match(/="/g)) {
          val = val.replace(/".*/g, "");
        } else if (val.match(/^\d+$/g)) {
          val = +val;
        }
      }
      let key = lineArr[0];
      let currentNotes = getCurrentFeature().notes;
      if (currentNotes[key]) {
        currentNotes[key].push(val);
      } else {
        currentNotes[key] = [val];
      }
      currentFeatureNote = currentNotes[key];
    }
    function getLineFieldName(line) {
      let arr;
      line = line.trim();
      arr = line.split(/[\s]+/);
      return arr[0];
    }
    function parseMultiLineField(fName, line, resultKey, r) {
      r = r || result;
      let fieldValue = removeFieldName(fName, line);
      r[resultKey] = r[resultKey] ? `${r[resultKey]} ` : "";
      r[resultKey] += fieldValue;
    }
    function getLineVal(line) {
      let arr;
      if (line.indexOf("=") < 0) {
        line = line.replace(/^[\s]*[\S]+[\s]+|[\s]+$/, "");
        line = line.trim();
        return line;
      } else {
        arr = line.split(/=/);
        return arr[1];
      }
    }
    function isKeyword(line) {
      let isKey = false;
      if (line.substr(0, 10).match(/^[\S]+/)) {
        isKey = true;
      }
      return isKey;
    }
    function isSubKeyword(line) {
      let isSubKey = false;
      if (line.substr(0, 10).match(/^[\s]+[\S]+/)) {
        isSubKey = true;
      }
      return isSubKey;
    }
    function postProcessGenbankFeature(feat) {
      if (feat.notes.label) {
        feat.name = feat.notes.label[0];
      } else if (feat.notes.gene) {
        feat.name = feat.notes.gene[0];
      } else if (feat.notes.ApEinfo_label) {
        feat.name = feat.notes.ApEinfo_label[0];
      } else if (feat.notes.name) {
        feat.name = feat.notes.name[0];
      } else if (feat.notes.organism) {
        feat.name = feat.notes.organism[0];
      } else if (feat.notes.locus_tag) {
        feat.name = feat.notes.locus_tag[0];
      } else if (feat.notes.note) {
        feat.name = feat.notes.note[0];
      } else {
        feat.name = "Untitled Feature";
      }
      feat.name = typeof feat.name === "string" ? feat.name : String(feat.name);
      return feat;
    }
  }
  function isFeatureLineRunon(line, featureLocationIndentation) {
    let indentationOfLine = getLengthOfWhiteSpaceBeforeStartOfLetters(line);
    if (featureLocationIndentation === indentationOfLine) {
      return false;
    }
    let trimmed = line.trim();
    if (trimmed.charAt(0).match(/\//)) {
      return false;
    }
    return true;
  }
  function getLengthOfWhiteSpaceBeforeStartOfLetters(string) {
    let match = /^\s*/.exec(string);
    if (match !== null) {
      return match[0].length;
    } else {
      return 0;
    }
  }
  var src = genbankToJson;
  const genbankParser = /* @__PURE__ */ getDefaultExportFromCjs(src);
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var _ZodEnum_cache, _ZodNativeEnum_cache;
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      var _a, _b;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      var _a, _b;
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if (!decoded.typ || !decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch (_a) {
      return false;
    }
  }
  function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options2) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
    }
    ip(options2) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
    }
    cidr(options2) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
    }
    datetime(options2) {
      var _a, _b;
      if (typeof options2 === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options2
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
        offset: (_a = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a !== void 0 ? _a : false,
        local: (_b = options2 === null || options2 === void 0 ? void 0 : options2.local) !== null && _b !== void 0 ? _b : false,
        ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options2) {
      if (typeof options2 === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options2
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
        ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options2) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options2 === null || options2 === void 0 ? void 0 : options2.position,
        ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxLength() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max2 = null, min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        } else if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return Number.isFinite(min2) && Number.isFinite(max2);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch (_a) {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min2 === null || ch.value > min2)
            min2 = ch.value;
        }
      }
      return min2 != null ? new Date(min2) : null;
    }
    get maxDate() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2 != null ? new Date(max2) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options2 = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options2.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options2) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options2, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options2) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options: options2,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size2, message) {
      return this.min(size2, message).max(size2, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            var _a2, _b2;
            if (!r2) {
              const params = cleanParams(_params, data);
              const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data);
          const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  const NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
  const coorSchema = z.object({
    x: z.number(),
    y: z.number()
  });
  const angleSchema = z.object({
    degrees: z.number(),
    center: coorSchema
  });
  const annotationTypeSchema = z.union([
    z.literal("CDS"),
    z.literal("enhancer"),
    z.literal("intron"),
    z.literal("misc_feature"),
    z.literal("polyA_signal"),
    z.literal("promoter"),
    z.literal("protein_bind"),
    z.literal("rep_origin"),
    z.literal("LTR"),
    z.string()
  ]);
  const annotationSchema = z.object({
    type: annotationTypeSchema,
    direction: z.union([z.literal("forward"), z.literal("reverse")]),
    start: z.number(),
    end: z.number(),
    className: z.string().optional(),
    text: z.string(),
    onClick: z.function().args(z.any()).optional()
    // circular reference
  });
  const stackedAnnotationSchema = annotationSchema.extend({
    stack: z.number()
  });
  const nuclSchema = z.union([
    z.literal("A"),
    z.literal("C"),
    z.literal("G"),
    z.literal("T")
  ]);
  const aaSchema = z.union([
    // Add all your amino acids literals here
    z.literal("A"),
    z.literal("C"),
    z.literal("D"),
    z.literal("E"),
    z.literal("F"),
    z.literal("G"),
    z.literal("H"),
    z.literal("I"),
    z.literal("K"),
    z.literal("L"),
    z.literal("M"),
    z.literal("N"),
    z.literal("P"),
    z.literal("Q"),
    z.literal("R"),
    z.literal("S"),
    z.literal("T"),
    z.literal("V"),
    z.literal("W"),
    z.literal("Y")
  ]);
  const GapSchema = z.literal("-");
  const StopSchema = z.literal("*");
  const SpaceSchema = z.literal(" ");
  const UnknownSchema = z.literal("?");
  const annotatedBaseSchema = z.object({
    base: z.string().length(1),
    annotations: z.array(stackedAnnotationSchema),
    index: z.number()
  });
  const annotatedSequenceSchema = z.array(annotatedBaseSchema);
  const ariadneSelectionSchema = z.object({
    start: z.number(),
    end: z.number(),
    direction: z.union([z.literal("forward"), z.literal("reverse")])
  });
  const GenbankFeatureSchema = z.object({
    name: z.string().min(1),
    start: z.number(),
    end: z.number(),
    strand: z.union([z.literal(1), z.literal(-1)]),
    type: annotationTypeSchema,
    notes: z.record(z.array(z.string())).optional()
  });
  const genbankToAnnotatedSequence = ({
    genbank,
    annotationOnClick
  }) => {
    const features = genbank.features.map((feature) => {
      return GenbankFeatureSchema.parse(feature);
    });
    const annotations = genbankFeaturesToAnnotations({
      features,
      annotationOnClick
    });
    const stackedAnnotations = stackAnnsByType(annotations);
    const { successes, failures } = safeAnythingToAnnotatedSequences({
      payload: genbank.sequence,
      payloadType: "raw",
      annotations: stackedAnnotations
    });
    if (failures.length > 0) {
      throw new Error(`Failed to parse genbank: ${failures[0]}`);
    }
    if (successes.length !== 1 || successes[0].sequences.length !== 1) {
      throw new Error(`Expected exactly one annotated sequence`);
    }
    return {
      annotatedSequence: annotatedSequenceSchema.parse(successes[0].sequences[0]),
      annotations
    };
  };
  const genbankFeaturesToAnnotations = ({
    features,
    annotationOnClick
  }) => {
    return features.map((feature) => {
      const [start, end] = [feature.start, feature.end];
      return {
        type: feature.type,
        start,
        end,
        label: feature.type,
        text: feature.name,
        direction: feature.strand === 1 ? "forward" : "reverse",
        className: getClassNameFromFeatureType(feature.type),
        onClick: annotationOnClick
      };
    });
  };
  function getClassNameFromFeatureType(annType) {
    const common = "cursor-pointer opacity-60 group-hover:opacity-100 !text-xs hover:opacity-100 pointer-events-all text-white text-clip overflow-hidden whitespace-nowrap";
    const classNameMap = zipArrays(
      [
        "CDS",
        "enhancer",
        "intron",
        "misc_feature",
        "polyA_signal",
        "promoter",
        "protein_bind",
        "rep_origin",
        "LTR",
        "source",
        "insertion"
      ],
      [
        "bg-red-600 fill-red-600 stroke-red-600",
        "bg-blue-600 fill-blue-600 stroke-blue-600",
        "bg-green-600 fill-green-600 stroke-green-600",
        "bg-yellow-600 fill-yellow-600 stroke-yellow-600",
        "bg-orange-600 fill-orange-600 stroke-orange-600",
        "bg-purple-600 fill-purple-600 stroke-purple-600",
        "bg-sky-600 fill-sky-600 stroke-sky-600",
        "bg-teal-600 fill-teal-600 stroke-teal-600",
        "bg-gray-600 fill-gray-600 stroke-gray-600",
        "bg-pink-600 fill-pink-600 stroke-pink-600"
      ]
    );
    if (annType in classNameMap) {
      return `${common} ${classNameMap[annType]}`;
    }
    return common;
  }
  const zipArrays = (keys, values) => {
    return Object.fromEntries(
      keys.map((key, i) => {
        const val = values[i];
        return [key, val];
      })
    );
  };
  const parseGenbank = (genbankString) => {
    const result = genbankParser(genbankString);
    return result;
  };
  const getComplement = (sequence) => {
    const complement = {
      A: "T",
      T: "A",
      C: "G",
      G: "C",
      N: "N"
    };
    return sequence.split("").map((base) => {
      if (base in complement) {
        return complement[base];
      } else {
        return "?";
      }
    }).join("");
  };
  const getAnnotatedSequence = ({
    sequence,
    stackedAnnotations,
    noValidate
  }) => {
    const mapFn = (base, idx) => {
      const annotationsForBase = stackedAnnotations.filter((annotation) => {
        if (annotation.start > annotation.end) {
          const isBetweenAnnotationStartAndEndofSequence = idx >= annotation.start && idx <= sequence.length;
          const isBetweenStartOfSequenceAndAnnotationEnd = idx >= 0 && idx <= annotation.end;
          return isBetweenAnnotationStartAndEndofSequence || isBetweenStartOfSequenceAndAnnotationEnd;
        } else {
          return idx >= annotation.start && idx <= annotation.end;
        }
      });
      return {
        base,
        index: idx,
        annotations: annotationsForBase,
        complement: getComplement(base)
      };
    };
    const raw = sequence.split("").map(mapFn).filter((x) => x.base !== " ");
    const annotatedSequence = annotatedSequenceSchema.safeParse(raw);
    if (noValidate) {
      if (annotatedSequence.success === false) {
        console.warn(annotatedSequence.error);
      }
      return raw;
    }
    if (annotatedSequence.success === false) {
      throw new Error(annotatedSequence.error.message);
    }
    return annotatedSequence.data;
  };
  const stackElements = (elements) => {
    if (elements.length === 0) {
      return [];
    }
    const last = (arr) => arr[arr.length - 1];
    const first = (arr) => arr[0];
    const maxIndex = elements.map((e) => e.end).reduce((a, b) => Math.max(a, b));
    const stack = [];
    elements.forEach((a) => {
      const insertIndex = stack.findIndex((elems) => {
        if (a.end === a.start) {
          return -1;
        }
        if (last(elems).end <= last(elems).start) {
          return last(elems).end + maxIndex <= a.start;
        }
        if (a.end > a.start) {
          return last(elems).end <= a.start;
        }
        return last(elems).end < a.start && a.end < first(elems).start;
      });
      if (insertIndex > -1) {
        stack[insertIndex].push(a);
      } else {
        stack.push([a]);
      }
    });
    return stack.map((row) => row.sort((a, b) => a.start - b.start));
  };
  const getStackedAnnotations = (annotations) => {
    const stackedAnnotations = stackElements(annotations);
    return stackedAnnotations.map((row, idx) => row.map((annotation) => ({ ...annotation, stack: idx }))).flat();
  };
  const baseInSelection = ({
    baseIndex,
    selection,
    sequenceLength
  }) => {
    if (!selection) {
      return false;
    }
    const { start, end } = selection;
    if (start === end) {
      return baseIndex === start;
    }
    if (start < end) {
      return inRange(baseIndex, start, end);
    } else {
      return inRange(baseIndex, start, sequenceLength) || inRange(baseIndex, 0, end);
    }
  };
  const inRange = (value, min2, max2) => {
    return value >= min2 && value <= max2;
  };
  const getSubsequenceLength = ({ start, end }, sequenceLength) => {
    if (start < end) {
      return end - start;
    } else {
      return sequenceLength - start + end;
    }
  };
  const anythingToAnnotatedSequences = ({
    payload,
    payloadType,
    annotations,
    annotationOnClick
  }) => {
    const { successes, failures } = safeAnythingToAnnotatedSequences({
      payload,
      payloadType,
      annotations,
      annotationOnClick
    });
    if (failures.length > 0) {
      const failString = failures.map((f) => f.error).join("\n");
      throw new Error(`Parse failures: ${failString}`);
    }
    const sequences = successes.map((s) => s.sequences).flat();
    const newAnnotations = successes.map((s) => s.annotations).flat();
    const stackedAnnotations = getStackedAnnotations(newAnnotations);
    return { sequences, stackedAnnotations };
  };
  const safeAnythingToAnnotatedSequences = ({
    payload,
    payloadType,
    annotations,
    annotationOnClick
  }) => {
    const successes = [];
    const failures = [];
    switch (payloadType) {
      case "raw": {
        try {
          const sequences = [
            stringToAnnotatedSequence({
              sequence: payload,
              annotations: annotations ?? []
            })
          ];
          successes.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            sequences,
            annotations: annotations ?? []
          });
        } catch (e) {
          failures.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            error: `Failed to parse raw sequence: ${e}`
          });
        }
        break;
      }
      case "parsed-genbank":
      case "genbank": {
        const parsed = payloadType === "parsed-genbank" ? [payload] : genbankParser(payload);
        parsed.forEach((genbank) => {
          try {
            const sequence = genbankToAnnotatedSequence({
              genbank,
              annotationOnClick
            }).annotatedSequence;
            successes.push({
              source: {
                payload,
                annotations,
                annotationOnClick,
                payloadType
              },
              sequences: [sequence],
              annotations: []
            });
          } catch (e) {
            failures.push({
              source: {
                payload,
                annotations,
                annotationOnClick,
                payloadType
              },
              error: `Failed to parse genbank: ${e}`
            });
          }
        });
        break;
      }
      case "fasta": {
        let records;
        if (payloadType === "fasta") {
          records = parseFasta(payload);
        } else {
          records = parseFastq(payload);
        }
        records.forEach((record) => {
          try {
            const res = safeAnythingToAnnotatedSequences({
              payload: record.sequence,
              payloadType: "raw"
            });
            failures.push(...res.failures);
            successes.push(...res.successes);
          } catch (e) {
            failures.push({
              source: {
                payload,
                annotations,
                annotationOnClick,
                payloadType
              },
              error: `Failed to parse ${payloadType}: ${e}`
            });
          }
        });
        break;
      }
      default: {
        failures.push({
          source: {
            payload,
            annotations,
            annotationOnClick,
            payloadType
          },
          error: `Unknown payload type: ${payloadType}`
        });
        break;
      }
    }
    return {
      successes,
      failures
    };
  };
  const stringToAnnotatedSequence = ({
    sequence,
    annotations
  }) => {
    const stackedAnnotations = getStackedAnnotations(annotations ?? []);
    const annotatedSequence = getAnnotatedSequence({
      sequence,
      stackedAnnotations
    });
    return annotatedSequence;
  };
  const annotationsHaveOverlap = (a1, a2, maxLen) => {
    if (baseInSelection({
      baseIndex: a1.start,
      selection: a2,
      sequenceLength: maxLen
    })) {
      return true;
    }
    if (baseInSelection({
      baseIndex: a1.end,
      selection: a2,
      sequenceLength: maxLen
    })) {
      return true;
    }
    if (baseInSelection({
      baseIndex: a2.start,
      selection: a1,
      sequenceLength: maxLen
    })) {
      return true;
    }
    if (baseInSelection({
      baseIndex: a2.end,
      selection: a1,
      sequenceLength: maxLen
    })) {
      return true;
    }
    return false;
  };
  const stackAnnotationsNoOverlap = (annotations, maxLen) => {
    const annotationsByStack = [];
    annotations.map((annotation) => {
      let curStack = 0;
      while (true) {
        const stackAnns = annotationsByStack[curStack];
        if (!stackAnns) {
          annotationsByStack[curStack] = [annotation];
          return;
        }
        let overlap = false;
        for (const stackedAnn of stackAnns) {
          if (annotationsHaveOverlap(annotation, stackedAnn, maxLen)) {
            overlap = true;
            break;
          }
        }
        if (overlap) {
          curStack += 1;
        } else {
          annotationsByStack[curStack].push(annotation);
          return;
        }
      }
    });
    const stackedAnnotations = [];
    annotationsByStack.forEach((stackedAnns, index2) => {
      stackedAnns.forEach((annotation) => {
        stackedAnnotations.push({
          ...annotation,
          stack: index2
        });
      });
    });
    return stackedAnnotations;
  };
  const stackAnnsByType = (annotations) => {
    const annotationMap = annotations.reduce(
      (acc, annotation) => {
        if (acc[annotation.type] === void 0) {
          acc[annotation.type] = [];
        }
        acc[annotation.type].push(annotation);
        return acc;
      },
      {}
    );
    const stacks = Object.values(annotationMap).map((stack, stackIdx) => {
      return stack.map((annotation) => {
        const res = {
          ...annotation,
          stack: stackIdx
        };
        return res;
      });
    }).flat();
    return stacks;
  };
  function parseFastq(data) {
    const lines = data.trim().split("\n");
    const records = [];
    for (let i = 0; i < lines.length; i += 4) {
      const record = {
        id: lines[i].substring(1),
        sequence: lines[i + 1],
        optionalId: lines[i + 2].substring(1),
        quality: lines[i + 3]
      };
      records.push(record);
    }
    return records;
  }
  function parseFasta(data) {
    const lines = data.trim().split("\n");
    const records = [];
    for (let i = 0; i < lines.length; i += 2) {
      const record = {
        id: lines[i].substring(1),
        sequence: lines[i + 1]
      };
      records.push(record);
    }
    return records;
  }
  const useStateRef = (initialValue) => {
    const ref = React.useRef(initialValue);
    const [state, internalSetState] = React.useState(initialValue);
    const setState = React.useCallback((value) => {
      ref.current = value;
      internalSetState(value);
    }, []);
    return [state, setState, ref];
  };
  const useLinearSelectionRect = ({
    ref,
    onMouseUp,
    onMouseDown,
    onMouseMove
  }) => {
    const [start, setStart, startRef] = useStateRef(null);
    const [end, setEnd, endRef] = useStateRef(null);
    const [direction, setDirection] = React.useState("forward");
    const active = React.useRef(false);
    const _onMouseDown = (e) => {
      var _a;
      const { clientX, clientY } = e;
      const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
        left: 0,
        top: 0
      };
      const x = clientX - left;
      const y = clientY - top;
      active.current = true;
      setStart({ x, y });
      setEnd({ x, y });
      onMouseDown == null ? void 0 : onMouseDown({ start: { x, y } });
    };
    const _onMouseUp = () => {
      active.current = false;
      if (startRef.current && endRef.current) {
        onMouseUp == null ? void 0 : onMouseUp({ start: startRef.current, end: endRef.current });
      } else {
        console.error("start or end is null when mouseup");
      }
    };
    const _onMouseMove = (e) => {
      var _a, _b;
      if (active.current) {
        const { clientX, clientY } = e;
        const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
          left: 0,
          top: 0
        };
        const x = clientX - left;
        const y = clientY - top;
        const { startX } = {
          startX: (_b = startRef.current) == null ? void 0 : _b.x
        };
        if (startX && startX > x) {
          setDirection("reverse");
        } else {
          setDirection("forward");
        }
        setEnd({ x, y });
        if (startRef.current && endRef.current) {
          onMouseMove == null ? void 0 : onMouseMove({ start: startRef.current, end: endRef.current });
        } else {
          console.error("start is null when mousemove");
        }
      }
    };
    React.useEffect(() => {
      const node = ref == null ? void 0 : ref.current;
      if (node) {
        node.addEventListener("mousedown", _onMouseDown);
        node.addEventListener("mousemove", _onMouseMove);
      }
      if (window) {
        window.addEventListener("mouseup", _onMouseUp);
      }
      return () => {
        node == null ? void 0 : node.removeEventListener("mousedown", _onMouseDown);
        node == null ? void 0 : node.removeEventListener("mousemove", _onMouseMove);
        window == null ? void 0 : window.removeEventListener("mouseup", _onMouseUp);
      };
    }, [ref]);
    return { start, end, direction };
  };
  const useCircularSelectionRect = (ref) => {
    const [start, setStart, startRef] = useStateRef(null);
    const [end, setEnd] = useStateRef(null);
    const [direction, setDirection] = React.useState(null);
    const ANGLE_DELTA_THRESHOLD_IN_DEGREES = 2;
    const active = React.useRef(false);
    const onMouseDown = (e) => {
      if (ref.current) {
        console.debug("resetting start and end");
        setStart(null);
        setEnd(null);
        setDirection(null);
        active.current = true;
        const { clientX, clientY } = e;
        const { left, top, width, height } = ref.current.getBoundingClientRect();
        const x = clientX - left;
        const y = clientY - top;
        const center = { x: width / 2, y: height / 2 };
        const startAngle = findAngleFromCoor({ coor: { x, y }, center });
        setStart({
          degrees: startAngle,
          center
        });
      }
    };
    const onMouseUp = () => {
      active.current = false;
      setDirection(null);
    };
    const onMouseMove = (e) => {
      if (active.current && ref.current) {
        const { clientX, clientY } = e;
        const { left, top, width, height } = ref.current.getBoundingClientRect();
        const x = clientX - left;
        const y = clientY - top;
        const center = { x: width / 2, y: height / 2 };
        if (Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) < 0.4 * (width / 2)) {
          console.debug("within 0.5 radius of center, not updating selection");
          return;
        }
        const endAngle = findAngleFromCoor({ coor: { x, y }, center });
        if (startRef.current) {
          const startAngle = startRef.current.degrees;
          const endAngleIsNearStartAngle = inRange(
            endAngle,
            startAngle - ANGLE_DELTA_THRESHOLD_IN_DEGREES,
            startAngle + ANGLE_DELTA_THRESHOLD_IN_DEGREES
          );
          if (endAngleIsNearStartAngle) {
            setDirection(null);
          }
        }
        setEnd({
          degrees: endAngle,
          center
        });
      }
    };
    React.useEffect(
      function determineDirection() {
        if (start && end && direction === null) {
          const startAngle = start.degrees;
          const endAngle = end.degrees;
          const delta = endAngle - startAngle;
          const guessedDirection = delta > 0 ? "clockwise" : "counterclockwise";
          setDirection(guessedDirection);
        }
      },
      [start, end]
    );
    React.useEffect(
      function handleEventListeners() {
        const node = ref.current;
        if (node) {
          node.addEventListener("mousedown", onMouseDown);
          node.addEventListener("mousemove", onMouseMove);
          node.addEventListener("mouseup", onMouseUp);
        }
        if (window) {
          window.addEventListener("mouseup", onMouseUp);
        }
        return () => {
          node == null ? void 0 : node.removeEventListener("mousedown", onMouseDown);
          node == null ? void 0 : node.removeEventListener("mousemove", onMouseMove);
          node == null ? void 0 : node.removeEventListener("mouseup", onMouseUp);
          window == null ? void 0 : window.removeEventListener("mouseup", onMouseUp);
        };
      },
      [ref.current, start, direction]
    );
    return { start, end, direction };
  };
  function classNames(...classes) {
    return classes.filter(Boolean).join(" ");
  }
  const cn = classNames;
  const CircularAnnotation = ({
    sequence,
    annotation,
    radius,
    center
  }) => {
    const { x: cx, y: cy } = center;
    const annotationLength = getSubsequenceLength(annotation, sequence.length);
    if (annotationLength > sequence.length) {
      console.error(
        `Annotation ${annotation.text}'s length is greater than sequence length: ${annotationLength} > ${sequence.length}`
      );
    }
    const arcPath = genArc({
      innerRadius: radius,
      outerRadius: radius + 5,
      largeArc: annotationLength > sequence.length / 2,
      length: annotationLength,
      seqLength: sequence.length,
      offset: annotation.start,
      center: { x: cx, y: cy }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        className: classNames(annotation.className),
        onClick: () => {
          var _a;
          (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("path", { d: arcPath, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: annotation.text }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: "Annotation" })
        ] })
      }
    );
  };
  const CircularAnnotationGutter = ({
    stackedAnnotations,
    cx,
    cy,
    radius,
    annotatedSequence
  }) => {
    const gutterRadius = radius * 0.3;
    const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
    const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
    stackedAnnotations = stackedAnnotations.map((annotation) => {
      const clampedBounds = clampSlice({
        slice: annotation,
        firstIdx,
        lastIdx
      });
      if (!clampedBounds) {
        return null;
      }
      return {
        ...annotation,
        start: clampedBounds.start,
        end: clampedBounds.end
      };
    }).filter(Boolean);
    const stacks = [];
    stackedAnnotations.forEach((ann) => {
      stacks[ann.stack] = stacks[ann.stack] || [];
      stacks[ann.stack].push(ann);
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx, cy, r: gutterRadius, fill: "none", strokeWidth: 0.8 }),
      ";",
      stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        CircularAnnotation,
        {
          annotation,
          radius: gutterRadius + stackIdx * 6,
          center: { x: cx, y: cy },
          sequence: annotatedSequence
        },
        `stack-${stackIdx}-${annotation.start}-${annotation.end}-${annotation.text}`
      )) }, `annotation-stack-${stackIdx}`))
    ] });
  };
  const CircularIndex = ({
    annotatedSequence,
    cx,
    cy,
    radius,
    ticks
  }) => {
    const basesPerTick = Math.floor(annotatedSequence.length / ticks);
    if (annotatedSequence.length > 50) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `fill-current`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            cx,
            cy,
            r: radius * 0.75,
            fill: "none",
            stroke: "currentColor",
            strokeWidth: 2
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Ticks,
          {
            cx,
            cy,
            radius: radius * 0.75,
            basesPerTick,
            totalBases: annotatedSequence.length
          }
        )
      ] }) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: annotatedSequence.map(({ base: letter }, index2) => {
      const { x, y } = findCoor({
        index: index2,
        radius: radius * 0.7,
        center: { x: cx, y: cy },
        seqLength: annotatedSequence.length
      });
      const rotateDegrees = index2 / annotatedSequence.length * 360;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "tspan",
        {
          x,
          y,
          transform: `rotate(${rotateDegrees} ${x} ${y})`,
          textAnchor: "middle",
          dominantBaseline: "middle",
          color: "currentColor",
          fill: "currentColor",
          fontSize: "0.5rem",
          fontWeight: "thin",
          fontFamily: "inherit",
          "data-seq-index": index2,
          children: letter
        },
        `base-${index2}`
      );
    }) });
  };
  const Ticks = ({
    radius,
    cx,
    cy,
    basesPerTick,
    totalBases
  }) => {
    const numberOfTicks = Math.floor(totalBases / basesPerTick);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { children: [...Array(numberOfTicks).keys()].map((i) => {
      const { x: x1, y: y1 } = findCoor({
        index: i,
        radius,
        center: { x: cx, y: cy },
        seqLength: totalBases
      });
      const { x: x2, y: y2 } = findCoor({
        index: i,
        radius: radius * 1.1,
        center: { x: cx, y: cy },
        seqLength: totalBases
      });
      const rotateDegrees = i / numberOfTicks * 360;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "line",
          {
            id: `tick-${i}`,
            x1,
            y1,
            x2,
            y2,
            stroke: "currentColor",
            strokeWidth: 1,
            opacity: 0.5,
            transform: `rotate(${rotateDegrees} ${cx} ${cy})`
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "text",
          {
            x: x2,
            y: y2 - 4,
            textAnchor: "middle",
            fontSize: ".8rem",
            transform: `rotate(${rotateDegrees} ${cx} ${cy})`,
            fill: "currentColor",
            opacity: 0.75,
            children: i * basesPerTick
          }
        )
      ] }, `tick-${i}`);
    }) });
  };
  const CircularViewer = ({
    sequence,
    annotations,
    selection,
    setSelection,
    containerClassName,
    svgSizePX = 300,
    svgPadding = 20
  }) => {
    const { cx, cy, sizeX, sizeY, radius } = {
      cx: svgSizePX / 2,
      cy: svgSizePX / 2,
      sizeX: svgSizePX,
      sizeY: svgSizePX,
      radius: (svgSizePX - svgPadding) / 2
    };
    const stackedAnnotations = stackAnnsByType(annotations);
    const annotatedSequence = React.useMemo(
      function memoize() {
        return getAnnotatedSequence({
          sequence,
          stackedAnnotations: getStackedAnnotations(annotations)
        });
      },
      [sequence, annotations]
    );
    if (annotatedSequence && selection && annotatedSequence.length > 0) {
      const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
      const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
      selection = clampSlice({ slice: selection, firstIdx, lastIdx });
    }
    const selectionRef = React.useRef(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames(
          "flex select-none items-center justify-center font-thin",
          containerClassName
        ),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            ref: selectionRef,
            viewBox: `0 0 ${sizeX} ${sizeY}`,
            xmlns: "http://www.w3.org/2000/svg",
            fontFamily: "inherit",
            fontSize: "inherit",
            fontWeight: "inherit",
            className: `stroke-current`,
            width: sizeX,
            height: sizeY,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CircularIndex,
                {
                  cx,
                  cy,
                  radius,
                  annotatedSequence,
                  ticks: 4
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CircularAnnotationGutter,
                {
                  annotatedSequence,
                  stackedAnnotations,
                  cx,
                  cy,
                  radius
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CircularSelection,
                {
                  annotatedSequence,
                  selection,
                  cx,
                  cy,
                  radius,
                  selectionRef,
                  setSelection
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "text",
                {
                  x: cx,
                  y: cy,
                  textAnchor: "middle",
                  fill: "currentColor",
                  stroke: "currentColor",
                  alignmentBaseline: "middle",
                  fontSize: "1rem",
                  children: [
                    annotatedSequence.length,
                    " bp"
                  ]
                }
              )
            ]
          }
        )
      }
    );
  };
  const CircularSelection = ({
    radius,
    cx,
    cy,
    selection,
    selectionRef,
    setSelection,
    annotatedSequence
  }) => {
    var _a, _b;
    const {
      start: internalSelectionStart,
      end: internalSelectionEnd,
      direction: internalDirection
    } = useCircularSelectionRect(selectionRef);
    React.useEffect(
      function propagateSelectionUp() {
        if (selectionRef.current && internalSelectionStart && internalSelectionEnd && internalDirection) {
          const start2 = findIndexFromAngle({
            angle: internalSelectionStart,
            seqLength: annotatedSequence.length
          });
          const end2 = findIndexFromAngle({
            angle: internalSelectionEnd,
            seqLength: annotatedSequence.length
          });
          const direction = internalDirection === "clockwise" ? "forward" : "reverse";
          const prevLength = selection ? Math.abs(selection.end - selection.start) : 0;
          const newLength = getSubsequenceLength(
            { start: start2, end: end2 },
            annotatedSequence.length
          );
          const deltaLength = Math.abs(prevLength - newLength);
          const deltaThreshold = Math.max(0.7 * annotatedSequence.length, 10);
          if (deltaLength > deltaThreshold && selection) {
            setSelection({
              start: start2,
              end: end2,
              direction: selection == null ? void 0 : selection.direction
            });
            return;
          }
          setSelection({
            start: start2,
            end: end2,
            direction
          });
        }
      },
      [internalSelectionStart, internalSelectionEnd]
    );
    if (selection === null) {
      return null;
    }
    const { start, end } = selection;
    if (start === null || end === null) {
      return null;
    }
    const center = { x: cx, y: cy };
    const innerRadius = radius;
    const outerRadius = radius + 10;
    const length = getSubsequenceLength(selection, annotatedSequence.length);
    const [startIdx, endIdx] = [
      (_a = annotatedSequence.at(0)) == null ? void 0 : _a.index,
      (_b = annotatedSequence.at(-1)) == null ? void 0 : _b.index
    ];
    if (startIdx === void 0 || endIdx === void 0) {
      console.error("CircularViewer: sequence has no indices");
      return null;
    }
    const offset2 = start - startIdx;
    const seqLength = annotatedSequence.length;
    const arc = genArc({
      center,
      innerRadius,
      largeArc: length > seqLength / 2,
      length,
      offset: offset2,
      outerRadius,
      seqLength
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: arc,
        fill: "none",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ) });
  };
  const LinearAnnotationGutter = ({
    stackedAnnotations,
    sequence,
    containerClassName
  }) => {
    const stacks = [];
    stackedAnnotations.forEach((ann) => {
      stacks[ann.stack] = stacks[ann.stack] || [];
      stacks[ann.stack].push(ann);
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames(
          "grid-rows-auto block grid grid-cols-1 gap-1",
          containerClassName
        ),
        children: stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-8", children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          LinearAnnotation,
          {
            annotation,
            sequence,
            stackIdx
          },
          `annotation-${annotation.text}-${annotation.start}-${annotation.end}-${annotation.direction}`
        )) }, `annotation-stack-${stackIdx}`))
      }
    );
  };
  const LinearAnnotation = ({
    annotation,
    sequence,
    stackIdx
  }) => {
    const annotationSpansSeam = annotation.start > annotation.end;
    if (annotationSpansSeam) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          LinearAnnotation,
          {
            annotation: {
              ...annotation,
              end: sequence.length,
              onClick: () => {
                var _a;
                (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
              }
            },
            sequence,
            stackIdx
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          LinearAnnotation,
          {
            annotation: {
              ...annotation,
              start: 0,
              onClick: () => {
                var _a;
                (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
              }
            },
            sequence,
            stackIdx
          }
        )
      ] });
    }
    const annotationRectangleWidthPerc = getSubsequenceLength(annotation, sequence.length) / sequence.length * 100;
    const xPerc = Math.min(annotation.start, annotation.end) / sequence.length * 100;
    const forwardClipPath = "polygon(0 0, 90% 0, 100% 50%, 90% 100%, 0 100%)";
    const reverseClipPath = "polygon(0 50%, 10% 0, 100% 0, 100% 100%, 10% 100%)";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "group absolute",
        style: {
          marginLeft: `${xPerc}%`,
          width: `${annotationRectangleWidthPerc}%`
        },
        onClick: () => {
          var _a;
          (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: classNames(
                "px-2",
                annotation.direction === "forward" ? "text-left" : "text-right",
                annotation.className
              ),
              style: {
                clipPath: annotation.direction === "forward" ? forwardClipPath : reverseClipPath
              },
              children: annotation.text
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: classNames(
                "absolute left-1/2 z-10 hidden -translate-x-1/2 translate-y-4 flex-col rounded-md px-2 py-1 text-sm group-hover:flex",
                annotation.className
              ),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.type })
              ]
            }
          )
        ]
      }
    );
  };
  const MISMATCH_DIST_PERC_THRESHOLD = 0.01;
  const LinearViewer = (props) => {
    const {
      sequences,
      selection,
      annotations,
      setSelection,
      onDoubleClick,
      selectionClassName,
      mismatchClassName,
      containerClassName,
      sequenceClassName,
      stackingFn
    } = props;
    const stackedAnnotations = React.useMemo(
      function memoize() {
        return stackingFn ? stackingFn(annotations) : stackAnnotationsNoOverlap(
          annotations,
          Math.max(...sequences.map((seq) => seq.length))
        );
      },
      [annotations]
    );
    const annotatedSequences = React.useMemo(
      function memoize() {
        return sequences.map(
          (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations })
        );
      },
      [sequences, stackedAnnotations]
    );
    const baseSequence = annotatedSequences[0];
    const selectionRef = React.useRef(null);
    const SVG_WIDTH = 500;
    const SVG_HEIGHT = sequences.length * 10 + 10;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClassName || "", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref: selectionRef,
          className: classNames("select-none font-thin"),
          onDoubleClick,
          viewBox: `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`,
          width: "100%",
          height: "100%",
          xmlns: "http://www.w3.org/2000/svg",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: annotatedSequences.map((sequence, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              SequenceLine,
              {
                sequenceClassName,
                baseSequence: sequence,
                alignedSequences: annotatedSequences.filter((_, j) => j !== i),
                sequenceIdx: i,
                mismatchClassName
              }
            ) }, `Sequence-${i}`)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              LinearSelection,
              {
                selectionClassName,
                selectionRef,
                selection,
                setSelection,
                sequence: baseSequence
              }
            )
          ]
        }
      ),
      stackedAnnotations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotationGutter,
        {
          containerClassName: "",
          stackedAnnotations,
          sequence: baseSequence
        }
      )
    ] });
  };
  const SequenceLine = ({
    baseSequence,
    sequenceIdx,
    alignedSequences,
    sequenceClassName,
    mismatchClassName
  }) => {
    var _a, _b;
    const start = (_a = baseSequence[0]) == null ? void 0 : _a.index;
    if (start === void 0) {
      throw new Error(`Sequence must have at least one base ${baseSequence}`);
    }
    const end = (_b = baseSequence[baseSequence.length - 1]) == null ? void 0 : _b.index;
    if (end === void 0) {
      throw new Error(`Sequence must have at least one base ${baseSequence}`);
    }
    let maxEnd = end;
    alignedSequences.forEach((alignedSequence) => {
      var _a2;
      const otherEnd = (_a2 = alignedSequence.at(alignedSequence.length - 1)) == null ? void 0 : _a2.index;
      if (otherEnd === void 0) {
        throw new Error(
          `otherSequence must have at least one base ${alignedSequence}`
        );
      }
      if (otherEnd > maxEnd) {
        maxEnd = otherEnd;
      }
    });
    const startPerc = start / maxEnd;
    const endPerc = end / maxEnd;
    const mismatches = baseSequence.filter((base) => {
      const rootBase = baseSequence.at(base.index);
      return rootBase && rootBase.base !== base.base;
    });
    mismatchClassName = mismatchClassName ?? function mismatchClassName2(mismatch) {
      if (mismatch.base === "-") {
        return "fill-black stroke-black opacity-80";
      } else {
        return "dark:fill-red-600 dark:stroke-red-600 fill-red-700 stroke-red-700";
      }
    };
    let lastXPerc = -1;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          className: classNames("", sequenceClassName({ sequenceIdx })),
          x1: `${startPerc * 100}%`,
          y1: `${sequenceIdx * 10 + 10}`,
          x2: `${endPerc * 100}%`,
          y2: `${sequenceIdx * 10 + 10}`,
          strokeWidth: 5,
          stroke: "currentColor"
        }
      ),
      mismatches.map((base) => {
        const xPerc = base.index / maxEnd * 100;
        const width = Math.max(1 / baseSequence.length * 100, 0.01);
        const diff = xPerc - lastXPerc;
        if (diff < MISMATCH_DIST_PERC_THRESHOLD) {
          return null;
        }
        lastXPerc = xPerc;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "g",
          {
            className: classNames((mismatchClassName == null ? void 0 : mismatchClassName(base)) || "bg-red-400"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "line",
              {
                x1: `${xPerc - width / 2}%`,
                y1: `${sequenceIdx * 10 + 10}`,
                x2: `${xPerc + width / 2}%`,
                y2: `${sequenceIdx * 10 + 10}`,
                strokeWidth: 5
              }
            )
          },
          `sequence-${sequenceIdx}-mismatch-${base.index}`
        );
      })
    ] });
  };
  const LinearSelection = ({
    selection,
    selectionRef,
    setSelection,
    sequence,
    selectionClassName
  }) => {
    const {
      start: internalSelectionStart,
      end: internalSelectionEnd,
      direction: internalDirection
    } = useLinearSelectionRect({ ref: selectionRef });
    React.useEffect(
      function propagateSelectionUp() {
        var _a;
        if (selectionRef.current && internalSelectionStart && internalSelectionEnd) {
          const svgWidth = (_a = selectionRef.current) == null ? void 0 : _a.getBoundingClientRect().width;
          const start2 = Math.floor(
            internalSelectionStart.x / svgWidth * sequence.length
          );
          const end2 = Math.floor(
            internalSelectionEnd.x / svgWidth * sequence.length
          );
          if (selection == null || start2 === end2) {
            setSelection({
              start: start2,
              end: start2 + 1,
              direction: internalDirection
            });
            return;
          } else {
            setSelection({ start: start2, end: end2, direction: internalDirection });
          }
        }
      },
      [internalSelectionStart, internalSelectionEnd]
    );
    if (!selection) {
      return null;
    }
    const { start, end } = selection;
    let firstRectStart = Math.min(start, end) / sequence.length * 100;
    let firstRectWidth = getSubsequenceLength(selection, sequence.length) / sequence.length * 100;
    let secondRectStart = null;
    let secondRectWidth = null;
    const selectionSpansSeam = selection.start > selection.end;
    if (selectionSpansSeam) {
      firstRectStart = 0;
      firstRectWidth = end / sequence.length * 100;
      secondRectStart = start / sequence.length * 100;
      secondRectWidth = (sequence.length - start) / sequence.length * 100;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "g",
      {
        className: classNames(
          "fill-current stroke-current",
          selectionClassName == null ? void 0 : selectionClassName(selection)
        ),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              x: `${firstRectStart}%`,
              width: `${firstRectWidth}%`,
              y: `0%`,
              height: `100%`,
              fill: "currentColor",
              fillOpacity: 0.2,
              strokeWidth: 1.5
            }
          ),
          secondRectStart && secondRectWidth && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              x: `${secondRectStart}%`,
              width: `${secondRectWidth}%`,
              y: `0%`,
              height: `100%`,
              fill: "currentColor",
              fillOpacity: 0.2,
              strokeWidth: 1.5
            }
          )
        ]
      }
    );
  };
  function clamp$1(value, [min2, max2]) {
    return Math.min(max2, Math.max(min2, value));
  }
  function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler == null ? void 0 : originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler == null ? void 0 : ourEventHandler(event);
      }
    };
  }
  function createContextScope(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext3(rootComponentName, defaultContext) {
      const BaseContext = React__namespace.createContext(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      const Provider = (props) => {
        var _a;
        const { scope, children, ...context } = props;
        const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
        const value = React__namespace.useMemo(() => context, Object.values(context));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
      };
      Provider.displayName = rootComponentName + "Provider";
      function useContext2(consumerName, scope) {
        var _a;
        const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
        const context = React__namespace.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return [Provider, useContext2];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return React__namespace.createContext(defaultContext);
      });
      return function useScope(scope) {
        const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
        return React__namespace.useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
          [scope, contexts]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return React__namespace.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }
  function setRef(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef(ref, node);
        if (!hasCleanup && typeof cleanup == "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup == "function") {
              cleanup();
            } else {
              setRef(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return React__namespace.useCallback(composeRefs(...refs), refs);
  }
  var Slot = React__namespace.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React__namespace.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React__namespace.Children.count(newElement) > 1) return React__namespace.Children.only(null);
          return React__namespace.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React__namespace.isValidElement(newElement) ? React__namespace.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot.displayName = "Slot";
  var SlotClone = React__namespace.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React__namespace.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React__namespace.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React__namespace.cloneElement(children, props2);
    }
    return React__namespace.Children.count(children) > 1 ? React__namespace.Children.only(null) : null;
  });
  SlotClone.displayName = "SlotClone";
  var Slottable = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  };
  function isSlottable(child) {
    return React__namespace.isValidElement(child) && child.type === Slottable;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = { ...childProps };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = { ...slotPropValue, ...childPropValue };
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef(element) {
    var _a, _b;
    let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
  function createCollection(name) {
    const PROVIDER_NAME = name + "CollectionProvider";
    const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
      PROVIDER_NAME,
      { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
    );
    const CollectionProvider = (props) => {
      const { scope, children } = props;
      const ref = React__namespace.default.useRef(null);
      const itemMap = React__namespace.default.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
    };
    CollectionProvider.displayName = PROVIDER_NAME;
    const COLLECTION_SLOT_NAME = name + "CollectionSlot";
    const CollectionSlot = React__namespace.default.forwardRef(
      (props, forwardedRef) => {
        const { scope, children } = props;
        const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
        const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
      }
    );
    CollectionSlot.displayName = COLLECTION_SLOT_NAME;
    const ITEM_SLOT_NAME = name + "CollectionItemSlot";
    const ITEM_DATA_ATTR = "data-radix-collection-item";
    const CollectionItemSlot = React__namespace.default.forwardRef(
      (props, forwardedRef) => {
        const { scope, children, ...itemData } = props;
        const ref = React__namespace.default.useRef(null);
        const composedRefs = useComposedRefs(forwardedRef, ref);
        const context = useCollectionContext(ITEM_SLOT_NAME, scope);
        React__namespace.default.useEffect(() => {
          context.itemMap.set(ref, { ref, ...itemData });
          return () => void context.itemMap.delete(ref);
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
      }
    );
    CollectionItemSlot.displayName = ITEM_SLOT_NAME;
    function useCollection2(scope) {
      const context = useCollectionContext(name + "CollectionConsumer", scope);
      const getItems = React__namespace.default.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode) return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort(
          (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
        );
        return orderedItems;
      }, [context.collectionRef, context.itemMap]);
      return getItems;
    }
    return [
      { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
      useCollection2,
      createCollectionScope2
    ];
  }
  var DirectionContext = React__namespace.createContext(void 0);
  function useDirection(localDir) {
    const globalDir = React__namespace.useContext(DirectionContext);
    return localDir || globalDir || "ltr";
  }
  var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var Primitive = NODES.reduce((primitive, node) => {
    const Node2 = React__namespace.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot : node;
      if (typeof window !== "undefined") {
        window[Symbol.for("radix-ui")] = true;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
    });
    Node2.displayName = `Primitive.${node}`;
    return { ...primitive, [node]: Node2 };
  }, {});
  function dispatchDiscreteCustomEvent(target, event) {
    if (target) ReactDOM__namespace.flushSync(() => target.dispatchEvent(event));
  }
  function useCallbackRef$1(callback) {
    const callbackRef = React__namespace.useRef(callback);
    React__namespace.useEffect(() => {
      callbackRef.current = callback;
    });
    return React__namespace.useMemo(() => (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    }, []);
  }
  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
    React__namespace.useEffect(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape") {
          onEscapeKeyDown(event);
        }
      };
      ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
    }, [onEscapeKeyDown, ownerDocument]);
  }
  var DISMISSABLE_LAYER_NAME = "DismissableLayer";
  var CONTEXT_UPDATE = "dismissableLayer.update";
  var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var originalBodyPointerEvents;
  var DismissableLayerContext = React__namespace.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var DismissableLayer = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const {
        disableOutsidePointerEvents = false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        ...layerProps
      } = props;
      const context = React__namespace.useContext(DismissableLayerContext);
      const [node, setNode] = React__namespace.useState(null);
      const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
      const [, force] = React__namespace.useState({});
      const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
      const layers = Array.from(context.layers);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      const index2 = node ? layers.indexOf(node) : -1;
      const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
      const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
      const pointerDownOutside = usePointerDownOutside((event) => {
        const target = event.target;
        const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
        if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
        onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
        onInteractOutside == null ? void 0 : onInteractOutside(event);
        if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
      }, ownerDocument);
      const focusOutside = useFocusOutside((event) => {
        const target = event.target;
        const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
        if (isFocusInBranch) return;
        onFocusOutside == null ? void 0 : onFocusOutside(event);
        onInteractOutside == null ? void 0 : onInteractOutside(event);
        if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
      }, ownerDocument);
      useEscapeKeydown((event) => {
        const isHighestLayer = index2 === context.layers.size - 1;
        if (!isHighestLayer) return;
        onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
        if (!event.defaultPrevented && onDismiss) {
          event.preventDefault();
          onDismiss();
        }
      }, ownerDocument);
      React__namespace.useEffect(() => {
        if (!node) return;
        if (disableOutsidePointerEvents) {
          if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
            originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
            ownerDocument.body.style.pointerEvents = "none";
          }
          context.layersWithOutsidePointerEventsDisabled.add(node);
        }
        context.layers.add(node);
        dispatchUpdate();
        return () => {
          if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
            ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
          }
        };
      }, [node, ownerDocument, disableOutsidePointerEvents, context]);
      React__namespace.useEffect(() => {
        return () => {
          if (!node) return;
          context.layers.delete(node);
          context.layersWithOutsidePointerEventsDisabled.delete(node);
          dispatchUpdate();
        };
      }, [node, context]);
      React__namespace.useEffect(() => {
        const handleUpdate = () => force({});
        document.addEventListener(CONTEXT_UPDATE, handleUpdate);
        return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...layerProps,
          ref: composedRefs,
          style: {
            pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
            ...props.style
          },
          onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
          onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
          onPointerDownCapture: composeEventHandlers(
            props.onPointerDownCapture,
            pointerDownOutside.onPointerDownCapture
          )
        }
      );
    }
  );
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = "DismissableLayerBranch";
  var DismissableLayerBranch = React__namespace.forwardRef((props, forwardedRef) => {
    const context = React__namespace.useContext(DismissableLayerContext);
    const ref = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React__namespace.useEffect(() => {
      const node = ref.current;
      if (node) {
        context.branches.add(node);
        return () => {
          context.branches.delete(node);
        };
      }
    }, [context.branches]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
    const isPointerInsideReactTreeRef = React__namespace.useRef(false);
    const handleClickRef = React__namespace.useRef(() => {
    });
    React__namespace.useEffect(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function() {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              handlePointerDownOutside,
              eventDetail,
              { discrete: true }
            );
          };
          const eventDetail = { originalEvent: event };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
            ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
          } else {
            handleAndDispatchPointerDownOutsideEvent2();
          }
        } else {
          ownerDocument.removeEventListener("click", handleClickRef.current);
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [ownerDocument, handlePointerDownOutside]);
    return {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const handleFocusOutside = useCallbackRef$1(onFocusOutside);
    const isFocusInsideReactTreeRef = React__namespace.useRef(false);
    React__namespace.useEffect(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = { originalEvent: event };
          handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [ownerDocument, handleFocusOutside]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function dispatchUpdate() {
    const event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
    if (handler) target.addEventListener(name, handler, { once: true });
    if (discrete) {
      dispatchDiscreteCustomEvent(target, event);
    } else {
      target.dispatchEvent(event);
    }
  }
  var count$1 = 0;
  function useFocusGuards() {
    React__namespace.useEffect(() => {
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
      document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
      count$1++;
      return () => {
        if (count$1 === 1) {
          document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
        }
        count$1--;
      };
    }, []);
  }
  function createFocusGuard() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.outline = "none";
    element.style.opacity = "0";
    element.style.position = "fixed";
    element.style.pointerEvents = "none";
    return element;
  }
  var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  var EVENT_OPTIONS = { bubbles: false, cancelable: true };
  var FOCUS_SCOPE_NAME = "FocusScope";
  var FocusScope = React__namespace.forwardRef((props, forwardedRef) => {
    const {
      loop = false,
      trapped = false,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      ...scopeProps
    } = props;
    const [container, setContainer] = React__namespace.useState(null);
    const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
    const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
    const lastFocusedElementRef = React__namespace.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
    const focusScope = React__namespace.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    React__namespace.useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = function(event) {
          if (focusScope.paused || !container) return;
          const target = event.target;
          if (container.contains(target)) {
            lastFocusedElementRef.current = target;
          } else {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleFocusOut2 = function(event) {
          if (focusScope.paused || !container) return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null) return;
          if (!container.contains(relatedTarget)) {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleMutations2 = function(mutations) {
          const focusedElement = document.activeElement;
          if (focusedElement !== document.body) return;
          for (const mutation of mutations) {
            if (mutation.removedNodes.length > 0) focus(container);
          }
        };
        document.addEventListener("focusin", handleFocusIn2);
        document.addEventListener("focusout", handleFocusOut2);
        const mutationObserver = new MutationObserver(handleMutations2);
        if (container) mutationObserver.observe(container, { childList: true, subtree: true });
        return () => {
          document.removeEventListener("focusin", handleFocusIn2);
          document.removeEventListener("focusout", handleFocusOut2);
          mutationObserver.disconnect();
        };
      }
    }, [trapped, container, focusScope.paused]);
    React__namespace.useEffect(() => {
      if (container) {
        focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
            if (document.activeElement === previouslyFocusedElement) {
              focus(container);
            }
          }
        }
        return () => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented) {
              focus(previouslyFocusedElement ?? document.body, { select: true });
            }
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    const handleKeyDown = React__namespace.useCallback(
      (event) => {
        if (!loop && !trapped) return;
        if (focusScope.paused) return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container2 = event.currentTarget;
          const [first, last] = getTabbableEdges(container2);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container2) event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop) focus(first, { select: true });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop) focus(last, { select: true });
            }
          }
        }
      },
      [loop, trapped, focusScope.paused]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
  });
  FocusScope.displayName = FOCUS_SCOPE_NAME;
  function focusFirst(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      focus(candidate, { select });
      if (document.activeElement !== previouslyFocusedElement) return;
    }
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function findVisible(elements, container) {
    for (const element of elements) {
      if (!isHidden(element, { upTo: container })) return element;
    }
  }
  function isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden") return true;
    while (node) {
      if (upTo !== void 0 && node === upTo) return false;
      if (getComputedStyle(node).display === "none") return true;
      node = node.parentElement;
    }
    return false;
  }
  function isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({ preventScroll: true });
      if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
        element.select();
    }
  }
  var focusScopesStack = createFocusScopesStack();
  function createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope) {
          activeFocusScope == null ? void 0 : activeFocusScope.pause();
        }
        stack = arrayRemove(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        var _a;
        stack = arrayRemove(stack, focusScope);
        (_a = stack[0]) == null ? void 0 : _a.resume();
      }
    };
  }
  function arrayRemove(array, item) {
    const updatedArray = [...array];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1) {
      updatedArray.splice(index2, 1);
    }
    return updatedArray;
  }
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== "A");
  }
  var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React__namespace.useLayoutEffect : () => {
  };
  var useReactId = React__namespace["useId".toString()] || (() => void 0);
  var count = 0;
  function useId(deterministicId) {
    const [id, setId] = React__namespace.useState(useReactId());
    useLayoutEffect2(() => {
      setId((reactId) => reactId ?? String(count++));
    }, [deterministicId]);
    return id ? `radix-${id}` : "";
  }
  const sides = ["top", "right", "bottom", "left"];
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v) => ({
    x: v,
    y: v
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y
    };
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const {
        name,
        fn
      } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options2) {
    var _await$platform$isEle;
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options2, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const arrow$3 = (options2) => ({
    name: "arrow",
    options: options2,
    async fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options2, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  const flip$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "flip",
      options: options2,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options2, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  const hide$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "hide",
      options: options2,
      async fn(state) {
        const {
          rects
        } = state;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options2, state);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  async function convertValueToCoords(state, options2) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options2, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$2 = function(options2) {
    if (options2 === void 0) {
      options2 = 0;
    }
    return {
      name: "offset",
      options: options2,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options2);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "shift",
      options: options2,
      async fn(state) {
        const {
          x,
          y,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options2, state);
        const coords = {
          x,
          y
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  const limitShift$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      options: options2,
      fn(state) {
        const {
          x,
          y,
          placement,
          rects,
          middlewareData
        } = state;
        const {
          offset: offset2 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options2, state);
        const coords = {
          x,
          y
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset2, state);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = ["top", "left"].includes(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  const size$2 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "size",
      options: options2,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options2, state);
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].includes(getNodeName(element));
  }
  function isTopLayer(element) {
    return [":popover-open", ":modal"].some((selector) => {
      try {
        return element.matches(selector);
      } catch (e) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
    return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element) {
    const css = getComputedStyle$1(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;
    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }
  const noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$1(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x,
      y
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX(documentElement, htmlRect)
    ));
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x,
      y
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$1(body).direction === "rtl") {
      x += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x,
      y
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x,
      y,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle$1(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle$1(element).direction === "rtl";
  }
  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function rectsAreEqual(a, b) {
    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root.clientWidth - (left + width));
      const insetBottom = floor(root.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options2 = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options2,
          // Handle <iframe>s
          root: root.ownerDocument
        });
      } catch (e) {
        io = new IntersectionObserver(handleObserve, options2);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options2;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  const offset$1 = offset$2;
  const shift$1 = shift$2;
  const flip$1 = flip$2;
  const size$1 = size$2;
  const hide$1 = hide$2;
  const arrow$2 = arrow$3;
  const limitShift$1 = limitShift$2;
  const computePosition = (reference, floating, options2) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options2
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  var index = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (typeof a === "function" && a.toString() === b.toString()) {
      return true;
    }
    let length;
    let i;
    let keys;
    if (a && b && typeof a === "object") {
      if (Array.isArray(a)) {
        length = a.length;
        if (length !== b.length) return false;
        for (i = length; i-- !== 0; ) {
          if (!deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (!{}.hasOwnProperty.call(b, keys[i])) {
          return false;
        }
      }
      for (i = length; i-- !== 0; ) {
        const key = keys[i];
        if (key === "_owner" && a.$$typeof) {
          continue;
        }
        if (!deepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    return a !== a && b !== b;
  }
  function getDPR(element) {
    if (typeof window === "undefined") {
      return 1;
    }
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }
  function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
  }
  function useLatestRef(value) {
    const ref = React__namespace.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }
  function useFloating(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2,
      elements: {
        reference: externalReference,
        floating: externalFloating
      } = {},
      transform = true,
      whileElementsMounted,
      open
    } = options2;
    const [data, setData] = React__namespace.useState({
      x: 0,
      y: 0,
      strategy,
      placement,
      middlewareData: {},
      isPositioned: false
    });
    const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);
    if (!deepEqual(latestMiddleware, middleware)) {
      setLatestMiddleware(middleware);
    }
    const [_reference, _setReference] = React__namespace.useState(null);
    const [_floating, _setFloating] = React__namespace.useState(null);
    const setReference = React__namespace.useCallback((node) => {
      if (node !== referenceRef.current) {
        referenceRef.current = node;
        _setReference(node);
      }
    }, []);
    const setFloating = React__namespace.useCallback((node) => {
      if (node !== floatingRef.current) {
        floatingRef.current = node;
        _setFloating(node);
      }
    }, []);
    const referenceEl = externalReference || _reference;
    const floatingEl = externalFloating || _floating;
    const referenceRef = React__namespace.useRef(null);
    const floatingRef = React__namespace.useRef(null);
    const dataRef = React__namespace.useRef(data);
    const hasWhileElementsMounted = whileElementsMounted != null;
    const whileElementsMountedRef = useLatestRef(whileElementsMounted);
    const platformRef = useLatestRef(platform2);
    const openRef = useLatestRef(open);
    const update = React__namespace.useCallback(() => {
      if (!referenceRef.current || !floatingRef.current) {
        return;
      }
      const config = {
        placement,
        strategy,
        middleware: latestMiddleware
      };
      if (platformRef.current) {
        config.platform = platformRef.current;
      }
      computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
        const fullData = {
          ...data2,
          // The floating element's position may be recomputed while it's closed
          // but still mounted (such as when transitioning out). To ensure
          // `isPositioned` will be `false` initially on the next open, avoid
          // setting it to `true` when `open === false` (must be specified).
          isPositioned: openRef.current !== false
        };
        if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
          dataRef.current = fullData;
          ReactDOM__namespace.flushSync(() => {
            setData(fullData);
          });
        }
      });
    }, [latestMiddleware, placement, strategy, platformRef, openRef]);
    index(() => {
      if (open === false && dataRef.current.isPositioned) {
        dataRef.current.isPositioned = false;
        setData((data2) => ({
          ...data2,
          isPositioned: false
        }));
      }
    }, [open]);
    const isMountedRef = React__namespace.useRef(false);
    index(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    index(() => {
      if (referenceEl) referenceRef.current = referenceEl;
      if (floatingEl) floatingRef.current = floatingEl;
      if (referenceEl && floatingEl) {
        if (whileElementsMountedRef.current) {
          return whileElementsMountedRef.current(referenceEl, floatingEl, update);
        }
        update();
      }
    }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
    const refs = React__namespace.useMemo(() => ({
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    }), [setReference, setFloating]);
    const elements = React__namespace.useMemo(() => ({
      reference: referenceEl,
      floating: floatingEl
    }), [referenceEl, floatingEl]);
    const floatingStyles = React__namespace.useMemo(() => {
      const initialStyles = {
        position: strategy,
        left: 0,
        top: 0
      };
      if (!elements.floating) {
        return initialStyles;
      }
      const x = roundByDPR(elements.floating, data.x);
      const y = roundByDPR(elements.floating, data.y);
      if (transform) {
        return {
          ...initialStyles,
          transform: "translate(" + x + "px, " + y + "px)",
          ...getDPR(elements.floating) >= 1.5 && {
            willChange: "transform"
          }
        };
      }
      return {
        position: strategy,
        left: x,
        top: y
      };
    }, [strategy, transform, elements.floating, data.x, data.y]);
    return React__namespace.useMemo(() => ({
      ...data,
      update,
      refs,
      elements,
      floatingStyles
    }), [data, update, refs, elements, floatingStyles]);
  }
  const arrow$1 = (options2) => {
    function isRef(value) {
      return {}.hasOwnProperty.call(value, "current");
    }
    return {
      name: "arrow",
      options: options2,
      fn(state) {
        const {
          element,
          padding
        } = typeof options2 === "function" ? options2(state) : options2;
        if (element && isRef(element)) {
          if (element.current != null) {
            return arrow$2({
              element: element.current,
              padding
            }).fn(state);
          }
          return {};
        }
        if (element) {
          return arrow$2({
            element,
            padding
          }).fn(state);
        }
        return {};
      }
    };
  };
  const offset = (options2, deps) => ({
    ...offset$1(options2),
    options: [options2, deps]
  });
  const shift = (options2, deps) => ({
    ...shift$1(options2),
    options: [options2, deps]
  });
  const limitShift = (options2, deps) => ({
    ...limitShift$1(options2),
    options: [options2, deps]
  });
  const flip = (options2, deps) => ({
    ...flip$1(options2),
    options: [options2, deps]
  });
  const size = (options2, deps) => ({
    ...size$1(options2),
    options: [options2, deps]
  });
  const hide = (options2, deps) => ({
    ...hide$1(options2),
    options: [options2, deps]
  });
  const arrow = (options2, deps) => ({
    ...arrow$1(options2),
    options: [options2, deps]
  });
  var NAME$1 = "Arrow";
  var Arrow$1 = React__namespace.forwardRef((props, forwardedRef) => {
    const { children, width = 10, height = 5, ...arrowProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.svg,
      {
        ...arrowProps,
        ref: forwardedRef,
        width,
        height,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
      }
    );
  });
  Arrow$1.displayName = NAME$1;
  var Root = Arrow$1;
  function useSize(element) {
    const [size2, setSize] = React__namespace.useState(void 0);
    useLayoutEffect2(() => {
      if (element) {
        setSize({ width: element.offsetWidth, height: element.offsetHeight });
        const resizeObserver = new ResizeObserver((entries) => {
          if (!Array.isArray(entries)) {
            return;
          }
          if (!entries.length) {
            return;
          }
          const entry = entries[0];
          let width;
          let height;
          if ("borderBoxSize" in entry) {
            const borderSizeEntry = entry["borderBoxSize"];
            const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
            width = borderSize["inlineSize"];
            height = borderSize["blockSize"];
          } else {
            width = element.offsetWidth;
            height = element.offsetHeight;
          }
          setSize({ width, height });
        });
        resizeObserver.observe(element, { box: "border-box" });
        return () => resizeObserver.unobserve(element);
      } else {
        setSize(void 0);
      }
    }, [element]);
    return size2;
  }
  var POPPER_NAME = "Popper";
  var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
  var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
  var Popper = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = React__namespace.useState(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
  };
  Popper.displayName = POPPER_NAME;
  var ANCHOR_NAME = "PopperAnchor";
  var PopperAnchor = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopePopper, virtualRef, ...anchorProps } = props;
      const context = usePopperContext(ANCHOR_NAME, __scopePopper);
      const ref = React__namespace.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      React__namespace.useEffect(() => {
        context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
      });
      return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
    }
  );
  PopperAnchor.displayName = ANCHOR_NAME;
  var CONTENT_NAME$1 = "PopperContent";
  var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1);
  var PopperContent = React__namespace.forwardRef(
    (props, forwardedRef) => {
      var _a, _b, _c, _d, _e, _f;
      const {
        __scopePopper,
        side = "bottom",
        sideOffset = 0,
        align = "center",
        alignOffset = 0,
        arrowPadding = 0,
        avoidCollisions = true,
        collisionBoundary = [],
        collisionPadding: collisionPaddingProp = 0,
        sticky = "partial",
        hideWhenDetached = false,
        updatePositionStrategy = "optimized",
        onPlaced,
        ...contentProps
      } = props;
      const context = usePopperContext(CONTENT_NAME$1, __scopePopper);
      const [content, setContent] = React__namespace.useState(null);
      const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
      const [arrow$12, setArrow] = React__namespace.useState(null);
      const arrowSize = useSize(arrow$12);
      const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
      const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
      const desiredPlacement = side + (align !== "center" ? "-" + align : "");
      const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
      const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
      const hasExplicitBoundaries = boundary.length > 0;
      const detectOverflowOptions = {
        padding: collisionPadding,
        boundary: boundary.filter(isNotNull),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: hasExplicitBoundaries
      };
      const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: "fixed",
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            animationFrame: updatePositionStrategy === "always"
          });
          return cleanup;
        },
        elements: {
          reference: context.anchor
        },
        middleware: [
          offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
          avoidCollisions && shift({
            mainAxis: true,
            crossAxis: false,
            limiter: sticky === "partial" ? limitShift() : void 0,
            ...detectOverflowOptions
          }),
          avoidCollisions && flip({ ...detectOverflowOptions }),
          size({
            ...detectOverflowOptions,
            apply: ({ elements, rects, availableWidth, availableHeight }) => {
              const { width: anchorWidth, height: anchorHeight } = rects.reference;
              const contentStyle = elements.floating.style;
              contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
              contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
              contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
              contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
            }
          }),
          arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
          transformOrigin({ arrowWidth, arrowHeight }),
          hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
        ]
      });
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const handlePlaced = useCallbackRef$1(onPlaced);
      useLayoutEffect2(() => {
        if (isPositioned) {
          handlePlaced == null ? void 0 : handlePlaced();
        }
      }, [isPositioned, handlePlaced]);
      const arrowX = (_a = middlewareData.arrow) == null ? void 0 : _a.x;
      const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
      const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
      const [contentZIndex, setContentZIndex] = React__namespace.useState();
      useLayoutEffect2(() => {
        if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
      }, [content]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: refs.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...floatingStyles,
            transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
            // keep off the page when measuring
            minWidth: "max-content",
            zIndex: contentZIndex,
            ["--radix-popper-transform-origin"]: [
              (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
              (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
            ].join(" "),
            // hide the content if using the hide middleware and should be hidden
            // set visibility to hidden and disable pointer events so the UI behaves
            // as if the PopperContent isn't there at all
            ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          },
          dir: props.dir,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            PopperContentProvider,
            {
              scope: __scopePopper,
              placedSide,
              onArrowChange: setArrow,
              arrowX,
              arrowY,
              shouldHideArrow: cannotCenterArrow,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Primitive.div,
                {
                  "data-side": placedSide,
                  "data-align": placedAlign,
                  ...contentProps,
                  ref: composedRefs,
                  style: {
                    ...contentProps.style,
                    // if the PopperContent hasn't been placed yet (not all measurements done)
                    // we prevent animations so that users's animation don't kick in too early referring wrong sides
                    animation: !isPositioned ? "none" : void 0
                  }
                }
              )
            }
          )
        }
      );
    }
  );
  PopperContent.displayName = CONTENT_NAME$1;
  var ARROW_NAME$1 = "PopperArrow";
  var OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  };
  var PopperArrow = React__namespace.forwardRef(function PopperArrow2(props, forwardedRef) {
    const { __scopePopper, ...arrowProps } = props;
    const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
    const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
    return (
      // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
      // doesn't report size as we'd expect on SVG elements.
      // it reports their bounding box which is effectively the largest path inside the SVG.
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          ref: contentContext.onArrowChange,
          style: {
            position: "absolute",
            left: contentContext.arrowX,
            top: contentContext.arrowY,
            [baseSide]: 0,
            transformOrigin: {
              top: "",
              right: "0 0",
              bottom: "center 0",
              left: "100% 0"
            }[contentContext.placedSide],
            transform: {
              top: "translateY(100%)",
              right: "translateY(50%) rotate(90deg) translateX(-50%)",
              bottom: `rotate(180deg)`,
              left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[contentContext.placedSide],
            visibility: contentContext.shouldHideArrow ? "hidden" : void 0
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Root,
            {
              ...arrowProps,
              ref: forwardedRef,
              style: {
                ...arrowProps.style,
                // ensures the element can be measured correctly (mostly for if SVG)
                display: "block"
              }
            }
          )
        }
      )
    );
  });
  PopperArrow.displayName = ARROW_NAME$1;
  function isNotNull(value) {
    return value !== null;
  }
  var transformOrigin = (options2) => ({
    name: "transformOrigin",
    options: options2,
    fn(data) {
      var _a, _b, _c;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options2.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options2.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
      const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (placedSide === "bottom") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  });
  function getSideAndAlignFromPlacement(placement) {
    const [side, align = "center"] = placement.split("-");
    return [side, align];
  }
  var Root2$1 = Popper;
  var Anchor = PopperAnchor;
  var Content = PopperContent;
  var Arrow = PopperArrow;
  var PORTAL_NAME$1 = "Portal";
  var Portal$1 = React__namespace.forwardRef((props, forwardedRef) => {
    var _a;
    const { container: containerProp, ...portalProps } = props;
    const [mounted, setMounted] = React__namespace.useState(false);
    useLayoutEffect2(() => setMounted(true), []);
    const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
    return container ? ReactDOM__namespace.default.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
  });
  Portal$1.displayName = PORTAL_NAME$1;
  function useControllableState({
    prop,
    defaultProp,
    onChange = () => {
    }
  }) {
    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
    const isControlled = prop !== void 0;
    const value = isControlled ? prop : uncontrolledProp;
    const handleChange = useCallbackRef$1(onChange);
    const setValue = React__namespace.useCallback(
      (nextValue) => {
        if (isControlled) {
          const setter = nextValue;
          const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
          if (value2 !== prop) handleChange(value2);
        } else {
          setUncontrolledProp(nextValue);
        }
      },
      [isControlled, prop, setUncontrolledProp, handleChange]
    );
    return [value, setValue];
  }
  function useUncontrolledState({
    defaultProp,
    onChange
  }) {
    const uncontrolledState = React__namespace.useState(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = React__namespace.useRef(value);
    const handleChange = useCallbackRef$1(onChange);
    React__namespace.useEffect(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [value, prevValueRef, handleChange]);
    return uncontrolledState;
  }
  function usePrevious(value) {
    const ref = React__namespace.useRef({ value, previous: value });
    return React__namespace.useMemo(() => {
      if (ref.current.value !== value) {
        ref.current.previous = ref.current.value;
        ref.current.value = value;
      }
      return ref.current.previous;
    }, [value]);
  }
  var NAME = "VisuallyHidden";
  var VisuallyHidden = React__namespace.forwardRef(
    (props, forwardedRef) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          ...props,
          ref: forwardedRef,
          style: {
            // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
            position: "absolute",
            border: 0,
            width: 1,
            height: 1,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            wordWrap: "normal",
            ...props.style
          }
        }
      );
    }
  );
  VisuallyHidden.displayName = NAME;
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
  };
  var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target)) {
        return target;
      }
      var correctedTarget = unwrapHost(target);
      if (correctedTarget && parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
      return null;
    }).filter(function(x) {
      return Boolean(x);
    });
  };
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node) {
        if (elementsToKeep.has(node)) {
          deep(node);
        } else {
          try {
            var attr = node.getAttribute(controlAttribute);
            var alreadyHidden = attr !== null && attr !== "false";
            var counterValue = (counterMap.get(node) || 0) + 1;
            var markerValue = (markerCounter.get(node) || 0) + 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            hiddenNodes.push(node);
            if (counterValue === 1 && alreadyHidden) {
              uncontrolledNodes.set(node, true);
            }
            if (markerValue === 1) {
              node.setAttribute(markerName, "true");
            }
            if (!alreadyHidden) {
              node.setAttribute(controlAttribute, "true");
            }
          } catch (e) {
            console.error("aria-hidden: cannot operate on ", node, e);
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node) {
        var counterValue = counterMap.get(node) - 1;
        var markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node)) {
            node.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node);
        }
        if (!markerValue) {
          node.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var zeroRightClassName = "right-scroll-bar-position";
  var fullWidthClassName = "width-before-scroll-bar";
  var noScrollbarsClassName = "with-scroll-bars-hidden";
  var removedBarSizeVariable = "--removed-body-scroll-bar-size";
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }
  function useCallbackRef(initialValue, callback) {
    var ref = React.useState(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }
  var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  var currentValues = /* @__PURE__ */ new WeakMap();
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useCallbackRef(null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
    useIsomorphicLayoutEffect(function() {
      var oldValue = currentValues.get(callbackRef);
      if (oldValue) {
        var prevRefs_1 = new Set(oldValue);
        var nextRefs_1 = new Set(refs);
        var current_1 = callbackRef.current;
        prevRefs_1.forEach(function(ref) {
          if (!nextRefs_1.has(ref)) {
            assignRef(ref, null);
          }
        });
        nextRefs_1.forEach(function(ref) {
          if (!prevRefs_1.has(ref)) {
            assignRef(ref, current_1);
          }
        });
      }
      currentValues.set(callbackRef, refs);
    }, [refs]);
    return callbackRef;
  }
  function ItoI(a) {
    return a;
  }
  function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults;
      },
      useMedium: function(data) {
        var item = middleware(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x) {
            return x !== item;
          });
        };
      },
      assignSyncMedium: function(cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function(x) {
            return cb(x);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x) {
            pendingQueue.push(x);
            cycle();
          },
          filter: function(filter) {
            pendingQueue = pendingQueue.filter(filter);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createSidecarMedium(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options2);
    return medium;
  }
  var SideCar$1 = function(_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar) {
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error("Sidecar medium not found");
    }
    return React__namespace.createElement(Target, __assign({}, rest));
  };
  SideCar$1.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar$1;
  }
  var effectCar = createSidecarMedium();
  var nothing = function() {
    return;
  };
  var RemoveScroll = React__namespace.forwardRef(function(props, parentRef) {
    var ref = React__namespace.useRef(null);
    var _a = React__namespace.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return React__namespace.createElement(
      React__namespace.Fragment,
      null,
      enabled && React__namespace.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
      forwardProps ? React__namespace.cloneElement(React__namespace.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React__namespace.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };
  var getNonce = function() {
    if (typeof __webpack_nonce__ !== "undefined") {
      return __webpack_nonce__;
    }
    return void 0;
  };
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    return tag;
  }
  function injectStyles(tag, css) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css;
    } else {
      tag.appendChild(document.createTextNode(css));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function(style) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function() {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };
  var styleHookSingleton = function() {
    var sheet = stylesheetSingleton();
    return function(styles, isDynamic) {
      React__namespace.useEffect(function() {
        sheet.add(styles);
        return function() {
          sheet.remove();
        };
      }, [styles && isDynamic]);
    };
  };
  var styleSingleton = function() {
    var useStyle = styleHookSingleton();
    var Sheet = function(_a) {
      var styles = _a.styles, dynamic = _a.dynamic;
      useStyle(styles, dynamic);
      return null;
    };
    return Sheet;
  };
  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };
  var parse = function(x) {
    return parseInt(x || "", 10) || 0;
  };
  var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
    var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
    var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse(left), parse(top), parse(right)];
  };
  var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    if (typeof window === "undefined") {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };
  var Style = styleSingleton();
  var lockAttribute = "data-scroll-locked";
  var getStyles = function(_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
      gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
  };
  var getCurrentUseCounter = function() {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(counter) ? counter : 0;
  };
  var useLockAttribute = function() {
    React__namespace.useEffect(function() {
      document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
      return function() {
        var newCounter = getCurrentUseCounter() - 1;
        if (newCounter <= 0) {
          document.body.removeAttribute(lockAttribute);
        } else {
          document.body.setAttribute(lockAttribute, newCounter.toString());
        }
      };
    }, []);
  };
  var RemoveScrollBar = function(_a) {
    var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
    useLockAttribute();
    var gap = React__namespace.useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return React__namespace.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
  };
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      var options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var nonPassive = passiveSupported ? { passive: false } : false;
  var alwaysContainsScroll = function(node) {
    return node.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled = function(node, overflow) {
    if (!(node instanceof Element)) {
      return false;
    }
    var styles = window.getComputedStyle(node);
    return (
      // not-not-scrollable
      styles[overflow] !== "hidden" && // contains scroll inside self
      !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
    );
  };
  var elementCouldBeVScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowY");
  };
  var elementCouldBeHScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowX");
  };
  var locationCouldBeScrolled = function(axis, node) {
    var ownerDocument = node.ownerDocument;
    var current = node;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
        if (scrollHeight > clientHeight) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== ownerDocument.body);
    return false;
  };
  var getVScrollVariables = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled = function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
  };
  var getScrollVariables = function(axis, node) {
    return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
  };
  var getDirectionFactor = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      if (target instanceof ShadowRoot) {
        target = target.host;
      } else {
        target = target.parentNode;
      }
    } while (
      // portaled content
      !targetInLock && target !== document.body || // self content
      targetInLock && (endTarget.contains(target) || endTarget === target)
    );
    if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };
  var getTouchXY = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare = function(x, y) {
    return x[0] === y[0] && x[1] === y[1];
  };
  var generateStyle = function(id) {
    return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = React__namespace.useRef([]);
    var touchStartRef = React__namespace.useRef([0, 0]);
    var activeAxis = React__namespace.useRef();
    var id = React__namespace.useState(idCounter++)[0];
    var Style2 = React__namespace.useState(styleSingleton)[0];
    var lastProps = React__namespace.useRef(props);
    React__namespace.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    React__namespace.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React__namespace.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
    }, []);
    var shouldPrevent = React__namespace.useCallback(function(_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e) {
        return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = React__namespace.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
          return e !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = React__namespace.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = React__namespace.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React__namespace.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React__namespace.useEffect(function() {
      lockStack.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive);
      document.addEventListener("touchmove", shouldPrevent, nonPassive);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive);
      return function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return React__namespace.createElement(
      React__namespace.Fragment,
      null,
      inert ? React__namespace.createElement(Style2, { styles: generateStyle(id) }) : null,
      removeScrollBar ? React__namespace.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
    );
  }
  function getOutermostShadowParent(node) {
    var shadowParent = null;
    while (node !== null) {
      if (node instanceof ShadowRoot) {
        shadowParent = node.host;
        node = node.host;
      }
      node = node.parentNode;
    }
    return shadowParent;
  }
  const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
  var ReactRemoveScroll = React__namespace.forwardRef(function(props, ref) {
    return React__namespace.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
  var SELECTION_KEYS = [" ", "Enter"];
  var SELECT_NAME = "Select";
  var [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);
  var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
    createCollectionScope,
    createPopperScope
  ]);
  var usePopperScope = createPopperScope();
  var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
  var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
  var Select$1 = (props) => {
    const {
      __scopeSelect,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      value: valueProp,
      defaultValue,
      onValueChange,
      dir,
      name,
      autoComplete,
      disabled,
      required,
      form
    } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const [trigger, setTrigger] = React__namespace.useState(null);
    const [valueNode, setValueNode] = React__namespace.useState(null);
    const [valueNodeHasChildren, setValueNodeHasChildren] = React__namespace.useState(false);
    const direction = useDirection(dir);
    const [open = false, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    const triggerPointerDownPosRef = React__namespace.useRef(null);
    const isFormControl = trigger ? form || !!trigger.closest("form") : true;
    const [nativeOptionsSet, setNativeOptionsSet] = React__namespace.useState(/* @__PURE__ */ new Set());
    const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      SelectProvider,
      {
        required,
        scope: __scopeSelect,
        trigger,
        onTriggerChange: setTrigger,
        valueNode,
        onValueNodeChange: setValueNode,
        valueNodeHasChildren,
        onValueNodeHasChildrenChange: setValueNodeHasChildren,
        contentId: useId(),
        value,
        onValueChange: setValue,
        open,
        onOpenChange: setOpen,
        dir: direction,
        triggerPointerDownPosRef,
        disabled,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SelectNativeOptionsProvider,
            {
              scope: props.__scopeSelect,
              onNativeOptionAdd: React__namespace.useCallback((option) => {
                setNativeOptionsSet((prev) => new Set(prev).add(option));
              }, []),
              onNativeOptionRemove: React__namespace.useCallback((option) => {
                setNativeOptionsSet((prev) => {
                  const optionsSet = new Set(prev);
                  optionsSet.delete(option);
                  return optionsSet;
                });
              }, []),
              children
            }
          ) }),
          isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
            BubbleSelect,
            {
              "aria-hidden": true,
              required,
              tabIndex: -1,
              name,
              autoComplete,
              value,
              onChange: (event) => setValue(event.target.value),
              disabled,
              form,
              children: [
                value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
                Array.from(nativeOptionsSet)
              ]
            },
            nativeSelectKey
          ) : null
        ]
      }
    ) });
  };
  Select$1.displayName = SELECT_NAME;
  var TRIGGER_NAME = "SelectTrigger";
  var SelectTrigger$1 = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, disabled = false, ...triggerProps } = props;
      const popperScope = usePopperScope(__scopeSelect);
      const context = useSelectContext(TRIGGER_NAME, __scopeSelect);
      const isDisabled = context.disabled || disabled;
      const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
      const getItems = useCollection(__scopeSelect);
      const pointerTypeRef = React__namespace.useRef("touch");
      const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
        const enabledItems = getItems().filter((item) => !item.disabled);
        const currentItem = enabledItems.find((item) => item.value === context.value);
        const nextItem = findNextItem(enabledItems, search, currentItem);
        if (nextItem !== void 0) {
          context.onValueChange(nextItem.value);
        }
      });
      const handleOpen = (pointerEvent) => {
        if (!isDisabled) {
          context.onOpenChange(true);
          resetTypeahead();
        }
        if (pointerEvent) {
          context.triggerPointerDownPosRef.current = {
            x: Math.round(pointerEvent.pageX),
            y: Math.round(pointerEvent.pageY)
          };
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "combobox",
          "aria-controls": context.contentId,
          "aria-expanded": context.open,
          "aria-required": context.required,
          "aria-autocomplete": "none",
          dir: context.dir,
          "data-state": context.open ? "open" : "closed",
          disabled: isDisabled,
          "data-disabled": isDisabled ? "" : void 0,
          "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
          ...triggerProps,
          ref: composedRefs,
          onClick: composeEventHandlers(triggerProps.onClick, (event) => {
            event.currentTarget.focus();
            if (pointerTypeRef.current !== "mouse") {
              handleOpen(event);
            }
          }),
          onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
            pointerTypeRef.current = event.pointerType;
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) {
              target.releasePointerCapture(event.pointerId);
            }
            if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
              handleOpen(event);
              event.preventDefault();
            }
          }),
          onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
            const isTypingAhead = searchRef.current !== "";
            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
            if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
            if (isTypingAhead && event.key === " ") return;
            if (OPEN_KEYS.includes(event.key)) {
              handleOpen();
              event.preventDefault();
            }
          })
        }
      ) });
    }
  );
  SelectTrigger$1.displayName = TRIGGER_NAME;
  var VALUE_NAME = "SelectValue";
  var SelectValue$1 = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
      const context = useSelectContext(VALUE_NAME, __scopeSelect);
      const { onValueNodeHasChildrenChange } = context;
      const hasChildren = children !== void 0;
      const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
      useLayoutEffect2(() => {
        onValueNodeHasChildrenChange(hasChildren);
      }, [onValueNodeHasChildrenChange, hasChildren]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          ...valueProps,
          ref: composedRefs,
          style: { pointerEvents: "none" },
          children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
        }
      );
    }
  );
  SelectValue$1.displayName = VALUE_NAME;
  var ICON_NAME = "SelectIcon";
  var SelectIcon = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, children, ...iconProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
    }
  );
  SelectIcon.displayName = ICON_NAME;
  var PORTAL_NAME = "SelectPortal";
  var SelectPortal = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { asChild: true, ...props });
  };
  SelectPortal.displayName = PORTAL_NAME;
  var CONTENT_NAME = "SelectContent";
  var SelectContent$1 = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);
      const [fragment, setFragment] = React__namespace.useState();
      useLayoutEffect2(() => {
        setFragment(new DocumentFragment());
      }, []);
      if (!context.open) {
        const frag = fragment;
        return frag ? ReactDOM__namespace.createPortal(
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
          frag
        ) : null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
    }
  );
  SelectContent$1.displayName = CONTENT_NAME;
  var CONTENT_MARGIN = 10;
  var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME);
  var CONTENT_IMPL_NAME = "SelectContentImpl";
  var SelectContentImpl = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeSelect,
        position = "item-aligned",
        onCloseAutoFocus,
        onEscapeKeyDown,
        onPointerDownOutside,
        //
        // PopperContent props
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions,
        //
        ...contentProps
      } = props;
      const context = useSelectContext(CONTENT_NAME, __scopeSelect);
      const [content, setContent] = React__namespace.useState(null);
      const [viewport, setViewport] = React__namespace.useState(null);
      const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
      const [selectedItem, setSelectedItem] = React__namespace.useState(null);
      const [selectedItemText, setSelectedItemText] = React__namespace.useState(
        null
      );
      const getItems = useCollection(__scopeSelect);
      const [isPositioned, setIsPositioned] = React__namespace.useState(false);
      const firstValidItemFoundRef = React__namespace.useRef(false);
      React__namespace.useEffect(() => {
        if (content) return hideOthers(content);
      }, [content]);
      useFocusGuards();
      const focusFirst2 = React__namespace.useCallback(
        (candidates) => {
          const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
          const [lastItem] = restItems.slice(-1);
          const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
          for (const candidate of candidates) {
            if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
            candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
            if (candidate === firstItem && viewport) viewport.scrollTop = 0;
            if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
            candidate == null ? void 0 : candidate.focus();
            if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
          }
        },
        [getItems, viewport]
      );
      const focusSelectedItem = React__namespace.useCallback(
        () => focusFirst2([selectedItem, content]),
        [focusFirst2, selectedItem, content]
      );
      React__namespace.useEffect(() => {
        if (isPositioned) {
          focusSelectedItem();
        }
      }, [isPositioned, focusSelectedItem]);
      const { onOpenChange, triggerPointerDownPosRef } = context;
      React__namespace.useEffect(() => {
        if (content) {
          let pointerMoveDelta = { x: 0, y: 0 };
          const handlePointerMove = (event) => {
            var _a, _b;
            pointerMoveDelta = {
              x: Math.abs(Math.round(event.pageX) - (((_a = triggerPointerDownPosRef.current) == null ? void 0 : _a.x) ?? 0)),
              y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
            };
          };
          const handlePointerUp = (event) => {
            if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
              event.preventDefault();
            } else {
              if (!content.contains(event.target)) {
                onOpenChange(false);
              }
            }
            document.removeEventListener("pointermove", handlePointerMove);
            triggerPointerDownPosRef.current = null;
          };
          if (triggerPointerDownPosRef.current !== null) {
            document.addEventListener("pointermove", handlePointerMove);
            document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
          }
          return () => {
            document.removeEventListener("pointermove", handlePointerMove);
            document.removeEventListener("pointerup", handlePointerUp, { capture: true });
          };
        }
      }, [content, onOpenChange, triggerPointerDownPosRef]);
      React__namespace.useEffect(() => {
        const close = () => onOpenChange(false);
        window.addEventListener("blur", close);
        window.addEventListener("resize", close);
        return () => {
          window.removeEventListener("blur", close);
          window.removeEventListener("resize", close);
        };
      }, [onOpenChange]);
      const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
        const enabledItems = getItems().filter((item) => !item.disabled);
        const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
        const nextItem = findNextItem(enabledItems, search, currentItem);
        if (nextItem) {
          setTimeout(() => nextItem.ref.current.focus());
        }
      });
      const itemRefCallback = React__namespace.useCallback(
        (node, value, disabled) => {
          const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
          const isSelectedItem = context.value !== void 0 && context.value === value;
          if (isSelectedItem || isFirstValidItem) {
            setSelectedItem(node);
            if (isFirstValidItem) firstValidItemFoundRef.current = true;
          }
        },
        [context.value]
      );
      const handleItemLeave = React__namespace.useCallback(() => content == null ? void 0 : content.focus(), [content]);
      const itemTextRefCallback = React__namespace.useCallback(
        (node, value, disabled) => {
          const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
          const isSelectedItem = context.value !== void 0 && context.value === value;
          if (isSelectedItem || isFirstValidItem) {
            setSelectedItemText(node);
          }
        },
        [context.value]
      );
      const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
      const popperContentProps = SelectPosition === SelectPopperPosition ? {
        side,
        sideOffset,
        align,
        alignOffset,
        arrowPadding,
        collisionBoundary,
        collisionPadding,
        sticky,
        hideWhenDetached,
        avoidCollisions
      } : {};
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectContentProvider,
        {
          scope: __scopeSelect,
          content,
          viewport,
          onViewportChange: setViewport,
          itemRefCallback,
          selectedItem,
          onItemLeave: handleItemLeave,
          itemTextRefCallback,
          focusSelectedItem,
          selectedItemText,
          position,
          isPositioned,
          searchRef,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusScope,
            {
              asChild: true,
              trapped: context.open,
              onMountAutoFocus: (event) => {
                event.preventDefault();
              },
              onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
                var _a;
                (_a = context.trigger) == null ? void 0 : _a.focus({ preventScroll: true });
                event.preventDefault();
              }),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DismissableLayer,
                {
                  asChild: true,
                  disableOutsidePointerEvents: true,
                  onEscapeKeyDown,
                  onPointerDownOutside,
                  onFocusOutside: (event) => event.preventDefault(),
                  onDismiss: () => context.onOpenChange(false),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    SelectPosition,
                    {
                      role: "listbox",
                      id: context.contentId,
                      "data-state": context.open ? "open" : "closed",
                      dir: context.dir,
                      onContextMenu: (event) => event.preventDefault(),
                      ...contentProps,
                      ...popperContentProps,
                      onPlaced: () => setIsPositioned(true),
                      ref: composedRefs,
                      style: {
                        // flex layout so we can place the scroll buttons properly
                        display: "flex",
                        flexDirection: "column",
                        // reset the outline by default as the content MAY get focused
                        outline: "none",
                        ...contentProps.style
                      },
                      onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                        const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                        if (event.key === "Tab") event.preventDefault();
                        if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                          const items = getItems().filter((item) => !item.disabled);
                          let candidateNodes = items.map((item) => item.ref.current);
                          if (["ArrowUp", "End"].includes(event.key)) {
                            candidateNodes = candidateNodes.slice().reverse();
                          }
                          if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                            const currentElement = event.target;
                            const currentIndex = candidateNodes.indexOf(currentElement);
                            candidateNodes = candidateNodes.slice(currentIndex + 1);
                          }
                          setTimeout(() => focusFirst2(candidateNodes));
                          event.preventDefault();
                        }
                      })
                    }
                  )
                }
              )
            }
          ) })
        }
      );
    }
  );
  SelectContentImpl.displayName = CONTENT_IMPL_NAME;
  var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
  var SelectItemAlignedPosition = React__namespace.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, onPlaced, ...popperProps } = props;
    const context = useSelectContext(CONTENT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);
    const [contentWrapper, setContentWrapper] = React__namespace.useState(null);
    const [content, setContent] = React__namespace.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const getItems = useCollection(__scopeSelect);
    const shouldExpandOnScrollRef = React__namespace.useRef(false);
    const shouldRepositionRef = React__namespace.useRef(true);
    const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
    const position = React__namespace.useCallback(() => {
      if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
        const triggerRect = context.trigger.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const valueNodeRect = context.valueNode.getBoundingClientRect();
        const itemTextRect = selectedItemText.getBoundingClientRect();
        if (context.dir !== "rtl") {
          const itemTextOffset = itemTextRect.left - contentRect.left;
          const left = valueNodeRect.left - itemTextOffset;
          const leftDelta = triggerRect.left - left;
          const minContentWidth = triggerRect.width + leftDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const rightEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedLeft = clamp$1(left, [
            CONTENT_MARGIN,
            // Prevents the content from going off the starting edge of the
            // viewport. It may still go off the ending edge, but this can be
            // controlled by the user since they may want to manage overflow in a
            // specific way.
            // https://github.com/radix-ui/primitives/issues/2049
            Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
          ]);
          contentWrapper.style.minWidth = minContentWidth + "px";
          contentWrapper.style.left = clampedLeft + "px";
        } else {
          const itemTextOffset = contentRect.right - itemTextRect.right;
          const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
          const rightDelta = window.innerWidth - triggerRect.right - right;
          const minContentWidth = triggerRect.width + rightDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const leftEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedRight = clamp$1(right, [
            CONTENT_MARGIN,
            Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
          ]);
          contentWrapper.style.minWidth = minContentWidth + "px";
          contentWrapper.style.right = clampedRight + "px";
        }
        const items = getItems();
        const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
        const itemsHeight = viewport.scrollHeight;
        const contentStyles = window.getComputedStyle(content);
        const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
        const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
        const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
        const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
        const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
        const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
        const viewportStyles = window.getComputedStyle(viewport);
        const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
        const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
        const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
        const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
        const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
        const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
        const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
        const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
        const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
        if (willAlignWithoutTopOverflow) {
          const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
          contentWrapper.style.bottom = "0px";
          const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
          const clampedTriggerMiddleToBottomEdge = Math.max(
            triggerMiddleToBottomEdge,
            selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
            (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
          );
          const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
          contentWrapper.style.height = height + "px";
        } else {
          const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
          contentWrapper.style.top = "0px";
          const clampedTopEdgeToTriggerMiddle = Math.max(
            topEdgeToTriggerMiddle,
            contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
            (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
          );
          const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
          contentWrapper.style.height = height + "px";
          viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
        }
        contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
        contentWrapper.style.minHeight = minContentHeight + "px";
        contentWrapper.style.maxHeight = availableHeight + "px";
        onPlaced == null ? void 0 : onPlaced();
        requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
      }
    }, [
      getItems,
      context.trigger,
      context.valueNode,
      contentWrapper,
      content,
      viewport,
      selectedItem,
      selectedItemText,
      context.dir,
      onPlaced
    ]);
    useLayoutEffect2(() => position(), [position]);
    const [contentZIndex, setContentZIndex] = React__namespace.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    const handleScrollButtonChange = React__namespace.useCallback(
      (node) => {
        if (node && shouldRepositionRef.current === true) {
          position();
          focusSelectedItem == null ? void 0 : focusSelectedItem();
          shouldRepositionRef.current = false;
        }
      },
      [position, focusSelectedItem]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectViewportProvider,
      {
        scope: __scopeSelect,
        contentWrapper,
        shouldExpandOnScrollRef,
        onScrollButtonChange: handleScrollButtonChange,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ref: setContentWrapper,
            style: {
              display: "flex",
              flexDirection: "column",
              position: "fixed",
              zIndex: contentZIndex
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                ...popperProps,
                ref: composedRefs,
                style: {
                  // When we get the height of the content, it includes borders. If we were to set
                  // the height without having `boxSizing: 'border-box'` it would be too big.
                  boxSizing: "border-box",
                  // We need to ensure the content doesn't get taller than the wrapper
                  maxHeight: "100%",
                  ...popperProps.style
                }
              }
            )
          }
        )
      }
    );
  });
  SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
  var POPPER_POSITION_NAME = "SelectPopperPosition";
  var SelectPopperPosition = React__namespace.forwardRef((props, forwardedRef) => {
    const {
      __scopeSelect,
      align = "start",
      collisionPadding = CONTENT_MARGIN,
      ...popperProps
    } = props;
    const popperScope = usePopperScope(__scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content,
      {
        ...popperScope,
        ...popperProps,
        ref: forwardedRef,
        align,
        collisionPadding,
        style: {
          // Ensure border-box for floating-ui calculations
          boxSizing: "border-box",
          ...popperProps.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-select-content-available-width": "var(--radix-popper-available-width)",
            "--radix-select-content-available-height": "var(--radix-popper-available-height)",
            "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  });
  SelectPopperPosition.displayName = POPPER_POSITION_NAME;
  var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {});
  var VIEWPORT_NAME = "SelectViewport";
  var SelectViewport = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, nonce, ...viewportProps } = props;
      const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
      const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
      const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
      const prevScrollTopRef = React__namespace.useRef(0);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "style",
          {
            dangerouslySetInnerHTML: {
              __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
            },
            nonce
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...viewportProps,
            ref: composedRefs,
            style: {
              // we use position: 'relative' here on the `viewport` so that when we call
              // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
              // (independent of the scrollUpButton).
              position: "relative",
              flex: 1,
              // Viewport should only be scrollable in the vertical direction.
              // This won't work in vertical writing modes, so we'll need to
              // revisit this if/when that is supported
              // https://developer.chrome.com/blog/vertical-form-controls
              overflow: "hidden auto",
              ...viewportProps.style
            },
            onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
              const viewport = event.currentTarget;
              const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
              if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
                const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
                if (scrolledBy > 0) {
                  const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                  const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                  const cssHeight = parseFloat(contentWrapper.style.height);
                  const prevHeight = Math.max(cssMinHeight, cssHeight);
                  if (prevHeight < availableHeight) {
                    const nextHeight = prevHeight + scrolledBy;
                    const clampedNextHeight = Math.min(availableHeight, nextHeight);
                    const heightDiff = nextHeight - clampedNextHeight;
                    contentWrapper.style.height = clampedNextHeight + "px";
                    if (contentWrapper.style.bottom === "0px") {
                      viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                      contentWrapper.style.justifyContent = "flex-end";
                    }
                  }
                }
              }
              prevScrollTopRef.current = viewport.scrollTop;
            })
          }
        ) })
      ] });
    }
  );
  SelectViewport.displayName = VIEWPORT_NAME;
  var GROUP_NAME = "SelectGroup";
  var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
  var SelectGroup = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...groupProps } = props;
      const groupId = useId();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
    }
  );
  SelectGroup.displayName = GROUP_NAME;
  var LABEL_NAME = "SelectLabel";
  var SelectLabel$1 = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...labelProps } = props;
      const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
    }
  );
  SelectLabel$1.displayName = LABEL_NAME;
  var ITEM_NAME = "SelectItem";
  var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
  var SelectItem$1 = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeSelect,
        value,
        disabled = false,
        textValue: textValueProp,
        ...itemProps
      } = props;
      const context = useSelectContext(ITEM_NAME, __scopeSelect);
      const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
      const isSelected = context.value === value;
      const [textValue, setTextValue] = React__namespace.useState(textValueProp ?? "");
      const [isFocused, setIsFocused] = React__namespace.useState(false);
      const composedRefs = useComposedRefs(
        forwardedRef,
        (node) => {
          var _a;
          return (_a = contentContext.itemRefCallback) == null ? void 0 : _a.call(contentContext, node, value, disabled);
        }
      );
      const textId = useId();
      const pointerTypeRef = React__namespace.useRef("touch");
      const handleSelect = () => {
        if (!disabled) {
          context.onValueChange(value);
          context.onOpenChange(false);
        }
      };
      if (value === "") {
        throw new Error(
          "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SelectItemContextProvider,
        {
          scope: __scopeSelect,
          value,
          disabled,
          textId,
          isSelected,
          onItemTextChange: React__namespace.useCallback((node) => {
            setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
          }, []),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Collection.ItemSlot,
            {
              scope: __scopeSelect,
              value,
              disabled,
              textValue,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Primitive.div,
                {
                  role: "option",
                  "aria-labelledby": textId,
                  "data-highlighted": isFocused ? "" : void 0,
                  "aria-selected": isSelected && isFocused,
                  "data-state": isSelected ? "checked" : "unchecked",
                  "aria-disabled": disabled || void 0,
                  "data-disabled": disabled ? "" : void 0,
                  tabIndex: disabled ? void 0 : -1,
                  ...itemProps,
                  ref: composedRefs,
                  onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                  onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                  onClick: composeEventHandlers(itemProps.onClick, () => {
                    if (pointerTypeRef.current !== "mouse") handleSelect();
                  }),
                  onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                    if (pointerTypeRef.current === "mouse") handleSelect();
                  }),
                  onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                    pointerTypeRef.current = event.pointerType;
                  }),
                  onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                    var _a;
                    pointerTypeRef.current = event.pointerType;
                    if (disabled) {
                      (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                    } else if (pointerTypeRef.current === "mouse") {
                      event.currentTarget.focus({ preventScroll: true });
                    }
                  }),
                  onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                    var _a;
                    if (event.currentTarget === document.activeElement) {
                      (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                    }
                  }),
                  onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                    var _a;
                    const isTypingAhead = ((_a = contentContext.searchRef) == null ? void 0 : _a.current) !== "";
                    if (isTypingAhead && event.key === " ") return;
                    if (SELECTION_KEYS.includes(event.key)) handleSelect();
                    if (event.key === " ") event.preventDefault();
                  })
                }
              )
            }
          )
        }
      );
    }
  );
  SelectItem$1.displayName = ITEM_NAME;
  var ITEM_TEXT_NAME = "SelectItemText";
  var SelectItemText = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, className, style, ...itemTextProps } = props;
      const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
      const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
      const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
      const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
      const [itemTextNode, setItemTextNode] = React__namespace.useState(null);
      const composedRefs = useComposedRefs(
        forwardedRef,
        (node) => setItemTextNode(node),
        itemContext.onItemTextChange,
        (node) => {
          var _a;
          return (_a = contentContext.itemTextRefCallback) == null ? void 0 : _a.call(contentContext, node, itemContext.value, itemContext.disabled);
        }
      );
      const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
      const nativeOption = React__namespace.useMemo(
        () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
        [itemContext.disabled, itemContext.value, textContent]
      );
      const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
      useLayoutEffect2(() => {
        onNativeOptionAdd(nativeOption);
        return () => onNativeOptionRemove(nativeOption);
      }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
        itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM__namespace.createPortal(itemTextProps.children, context.valueNode) : null
      ] });
    }
  );
  SelectItemText.displayName = ITEM_TEXT_NAME;
  var ITEM_INDICATOR_NAME = "SelectItemIndicator";
  var SelectItemIndicator = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...itemIndicatorProps } = props;
      const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
      return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
    }
  );
  SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
  var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
  var SelectScrollUpButton$1 = React__namespace.forwardRef((props, forwardedRef) => {
    const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const [canScrollUp, setCanScrollUp] = React__namespace.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
    useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function() {
          const canScrollUp2 = viewport.scrollTop > 0;
          setCanScrollUp(canScrollUp2);
        };
        const viewport = contentContext.viewport;
        handleScroll2();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [contentContext.viewport, contentContext.isPositioned]);
    return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectScrollButtonImpl,
      {
        ...props,
        ref: composedRefs,
        onAutoScroll: () => {
          const { viewport, selectedItem } = contentContext;
          if (viewport && selectedItem) {
            viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
          }
        }
      }
    ) : null;
  });
  SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
  var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
  var SelectScrollDownButton$1 = React__namespace.forwardRef((props, forwardedRef) => {
    const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const [canScrollDown, setCanScrollDown] = React__namespace.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
    useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function() {
          const maxScroll = viewport.scrollHeight - viewport.clientHeight;
          const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
          setCanScrollDown(canScrollDown2);
        };
        const viewport = contentContext.viewport;
        handleScroll2();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [contentContext.viewport, contentContext.isPositioned]);
    return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectScrollButtonImpl,
      {
        ...props,
        ref: composedRefs,
        onAutoScroll: () => {
          const { viewport, selectedItem } = contentContext;
          if (viewport && selectedItem) {
            viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
          }
        }
      }
    ) : null;
  });
  SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
  var SelectScrollButtonImpl = React__namespace.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
    const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
    const autoScrollTimerRef = React__namespace.useRef(null);
    const getItems = useCollection(__scopeSelect);
    const clearAutoScrollTimer = React__namespace.useCallback(() => {
      if (autoScrollTimerRef.current !== null) {
        window.clearInterval(autoScrollTimerRef.current);
        autoScrollTimerRef.current = null;
      }
    }, []);
    React__namespace.useEffect(() => {
      return () => clearAutoScrollTimer();
    }, [clearAutoScrollTimer]);
    useLayoutEffect2(() => {
      var _a;
      const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
      (_a = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
    }, [getItems]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "aria-hidden": true,
        ...scrollIndicatorProps,
        ref: forwardedRef,
        style: { flexShrink: 0, ...scrollIndicatorProps.style },
        onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
          if (autoScrollTimerRef.current === null) {
            autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
          }
        }),
        onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
          var _a;
          (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
          if (autoScrollTimerRef.current === null) {
            autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
          }
        }),
        onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
          clearAutoScrollTimer();
        })
      }
    );
  });
  var SEPARATOR_NAME = "SelectSeparator";
  var SelectSeparator$1 = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...separatorProps } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
    }
  );
  SelectSeparator$1.displayName = SEPARATOR_NAME;
  var ARROW_NAME = "SelectArrow";
  var SelectArrow = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSelect, ...arrowProps } = props;
      const popperScope = usePopperScope(__scopeSelect);
      const context = useSelectContext(ARROW_NAME, __scopeSelect);
      const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
      return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
    }
  );
  SelectArrow.displayName = ARROW_NAME;
  function shouldShowPlaceholder(value) {
    return value === "" || value === void 0;
  }
  var BubbleSelect = React__namespace.forwardRef(
    (props, forwardedRef) => {
      const { value, ...selectProps } = props;
      const ref = React__namespace.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const prevValue = usePrevious(value);
      React__namespace.useEffect(() => {
        const select = ref.current;
        const selectProto = window.HTMLSelectElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(
          selectProto,
          "value"
        );
        const setValue = descriptor.set;
        if (prevValue !== value && setValue) {
          const event = new Event("change", { bubbles: true });
          setValue.call(select, value);
          select.dispatchEvent(event);
        }
      }, [prevValue, value]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
    }
  );
  BubbleSelect.displayName = "BubbleSelect";
  function useTypeaheadSearch(onSearchChange) {
    const handleSearchChange = useCallbackRef$1(onSearchChange);
    const searchRef = React__namespace.useRef("");
    const timerRef = React__namespace.useRef(0);
    const handleTypeaheadSearch = React__namespace.useCallback(
      (key) => {
        const search = searchRef.current + key;
        handleSearchChange(search);
        (function updateSearch(value) {
          searchRef.current = value;
          window.clearTimeout(timerRef.current);
          if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
        })(search);
      },
      [handleSearchChange]
    );
    const resetTypeahead = React__namespace.useCallback(() => {
      searchRef.current = "";
      window.clearTimeout(timerRef.current);
    }, []);
    React__namespace.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    return [searchRef, handleTypeaheadSearch, resetTypeahead];
  }
  function findNextItem(items, search, currentItem) {
    const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
    const normalizedSearch = isRepeated ? search[0] : search;
    const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizedSearch.length === 1;
    if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
    const nextItem = wrappedItems.find(
      (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
    );
    return nextItem !== currentItem ? nextItem : void 0;
  }
  function wrapArray(array, startIndex) {
    return array.map((_, index2) => array[(startIndex + index2) % array.length]);
  }
  var Root2 = Select$1;
  var Trigger = SelectTrigger$1;
  var Value = SelectValue$1;
  var Icon$1 = SelectIcon;
  var Portal = SelectPortal;
  var Content2 = SelectContent$1;
  var Viewport = SelectViewport;
  var Label = SelectLabel$1;
  var Item = SelectItem$1;
  var ItemText = SelectItemText;
  var ItemIndicator = SelectItemIndicator;
  var ScrollUpButton = SelectScrollUpButton$1;
  var ScrollDownButton = SelectScrollDownButton$1;
  var Separator = SelectSeparator$1;
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
  }).join(" ").trim();
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Icon = React.forwardRef(
    ({
      color = "currentColor",
      size: size2 = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode,
      ...rest
    }, ref) => {
      return React.createElement(
        "svg",
        {
          ref,
          ...defaultAttributes,
          width: size2,
          height: size2,
          stroke: color,
          strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
          className: mergeClasses("lucide", className),
          ...rest
        },
        [
          ...iconNode.map(([tag, attrs]) => React.createElement(tag, attrs)),
          ...Array.isArray(children) ? children : [children]
        ]
      );
    }
  );
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const createLucideIcon = (iconName, iconNode) => {
    const Component = React.forwardRef(
      ({ className, ...props }, ref) => React.createElement(Icon, {
        ref,
        iconNode,
        className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
        ...props
      })
    );
    Component.displayName = `${iconName}`;
    return Component;
  };
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ChevronDown = createLucideIcon("ChevronDown", [
    ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
  ]);
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
  /**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Copy = createLucideIcon("Copy", [
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
  ]);
  const Select = Root2;
  const SelectValue = Value;
  const SelectTrigger = React__namespace.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Trigger,
    {
      ref,
      className: cn(
        "ring-offset-background focus:ring-ring flex h-4 w-full items-center justify-between whitespace-nowrap rounded-md bg-transparent px-3 py-2 text-xs focus:outline-none focus:ring-1 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
        "dark:placeholder-text-zinc-600 text-black placeholder:text-noir-400 dark:text-white",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "ml-1 h-4 w-4 text-black opacity-50 dark:text-white" }) })
      ]
    }
  ));
  SelectTrigger.displayName = Trigger.displayName;
  const SelectScrollUpButton = React__namespace.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollUpButton,
    {
      ref,
      className: cn(
        "flex cursor-default items-center justify-center py-1",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-4 w-4" })
    }
  ));
  SelectScrollUpButton.displayName = ScrollUpButton.displayName;
  const SelectScrollDownButton = React__namespace.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollDownButton,
    {
      ref,
      className: cn(
        "flex cursor-default items-center justify-center py-1",
        className
      ),
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4" })
    }
  ));
  SelectScrollDownButton.displayName = ScrollDownButton.displayName;
  const SelectContent = React__namespace.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Content2,
    {
      ref,
      className: cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
        position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      ),
      position,
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Viewport,
          {
            className: cn(
              "p-1",
              position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
            ),
            children
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
      ]
    }
  ) }));
  SelectContent.displayName = Content2.displayName;
  const SelectLabel = React__namespace.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Label,
    {
      ref,
      className: cn("px-2 py-1.5 text-sm font-semibold", className),
      ...props
    }
  ));
  SelectLabel.displayName = Label.displayName;
  const SelectItem = React__namespace.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Item,
    {
      ref,
      className: cn(
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
      ]
    }
  ));
  SelectItem.displayName = Item.displayName;
  const SelectSeparator = React__namespace.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Separator,
    {
      ref,
      className: cn("bg-muted -mx-1 my-1 h-px", className),
      ...props
    }
  ));
  SelectSeparator.displayName = Separator.displayName;
  const CopyButton = ({
    label,
    buttonClassName,
    logoClassName,
    textToCopy,
    disabled
  }) => {
    const [logo, setLogo] = React.useState(
      /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) })
    );
    const [internalLabel, setInternalLabel] = React.useState(label);
    const onClipboardCopy = () => {
      setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: cn("h-3 w-3", logoClassName) }));
      setInternalLabel("Copied!");
      setTimeout(() => {
        setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) }));
        setInternalLabel(label);
      }, 1e3);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        "aria-label": "Copy to clipboard",
        disabled,
        className: cn(
          "flex items-center gap-2 disabled:cursor-not-allowed disabled:text-noir-400 dark:text-noir-100 dark:disabled:text-zinc-600",
          buttonClassName
        ),
        onClick: () => {
          const text = textToCopy();
          navigator.clipboard.writeText(text);
          onClipboardCopy();
        },
        children: [
          logo,
          internalLabel
        ]
      }
    );
  };
  const SequenceViewer = ({
    sequences,
    annotations,
    selection,
    setSelection,
    containerClassName,
    charClassName,
    selectionClassName,
    hideMetadataBar,
    noValidate
  }) => {
    const [hoveredPosition, setHoveredPosition] = React.useState(null);
    const [seqIdxToCopy, setSeqIdxToCopy] = React.useState(0);
    const [activeAnnotation, setActiveAnnotation] = React.useState(
      null
    );
    const stackedAnnotations = React.useMemo(
      function memoize() {
        return stackAnnotationsNoOverlap(
          annotations,
          Math.max(...sequences.map((seq) => seq.length))
        );
      },
      [annotations]
    );
    const annotatedSequences = React.useMemo(
      function memoize() {
        return sequences.map(
          (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations, noValidate })
        );
      },
      [sequences, stackedAnnotations]
    );
    const memoizedSeqContent = React.useMemo(() => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SeqContent,
        {
          annotatedSequences,
          selection,
          setSelection,
          setHoveredPosition,
          setActiveAnnotation,
          stackedAnnotations,
          charClassName,
          selectionClassName
        }
      );
    }, [annotatedSequences, selection, stackedAnnotations]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: classNames(
          "relative isolate flex flex-wrap",
          containerClassName
        ),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SeqMetadataBar,
            {
              hoveredPosition,
              activeAnnotation,
              className: classNames("sticky inset-x-0 top-0 z-[3] w-full px-2 py-1 backdrop-blur-md", hideMetadataBar ? "hidden" : ""),
              annotatedSequences,
              charClassName,
              seqIdxToCopy,
              setSeqIdxToCopy,
              selection
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap px-2", children: memoizedSeqContent })
        ]
      }
    ) });
  };
  const SeqContent = ({
    annotatedSequences,
    selection,
    setSelection,
    setHoveredPosition,
    setActiveAnnotation,
    stackedAnnotations,
    charClassName,
    selectionClassName
  }) => {
    const mouseDown = React.useRef(false);
    const indicesClassName = ({
      base,
      sequenceIdx
    }) => {
      const isNotFirstSeq = sequenceIdx !== 0;
      const isNotMultipleOfTen = base.index % 10 !== 0;
      if (isNotFirstSeq || isNotMultipleOfTen) {
        return "opacity-0";
      }
      return classNames(
        "text-xs z-1",
        // don't allow selection of indices
        "dark:group-hover:text-noir-300 group-hover:text-noir-800",
        baseInSelection({
          baseIndex: base.index,
          selection,
          sequenceLength: annotatedSequences[sequenceIdx].length
        }) ? "text-brand-700 dark:text-brand-300" : "text-noir-400 dark:text-noir-600"
      );
    };
    const handleMouseUp = () => {
      mouseDown.current = false;
    };
    React.useEffect(function addMouseUpListener() {
      document.addEventListener("mouseup", () => {
        handleMouseUp();
      });
      return function removeMouseUpListener() {
        document.removeEventListener("mouseup", () => {
          handleMouseUp();
        });
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: annotatedSequences[0].map(({ index: baseIdx }) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: classNames(
            "relative mt-4 flex flex-col justify-between",
            "group hover:bg-noir-200 dark:hover:bg-noir-600"
          ),
          children: [
            annotatedSequences.map(
              (sequence, sequenceIdx) => {
                const base = sequence.find(
                  (base2) => base2.index === baseIdx
                ) || { base: " ", annotations: [], index: baseIdx };
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: classNames("whitespace-pre text-center"),
                    onMouseEnter: () => {
                      setHoveredPosition(base.index);
                      if (mouseDown.current && selection) {
                        setSelection({
                          ...selection,
                          end: base.index
                        });
                      }
                    },
                    onMouseLeave: () => setHoveredPosition(null),
                    onMouseDown: () => {
                      mouseDown.current = true;
                      setSelection({
                        start: base.index,
                        end: base.index,
                        direction: "forward"
                      });
                    },
                    onMouseUp: handleMouseUp,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        CharComponent,
                        {
                          char: `| ${base.index}`,
                          index: baseIdx,
                          charClassName: classNames(
                            "absolute -top-4 left-0",
                            "group-hover:text-brand-200 border-b border-noir-600 group-hover:border-noir-300",
                            indicesClassName({
                              base,
                              sequenceIdx
                            })
                          )
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        CharComponent,
                        {
                          char: base.base,
                          index: baseIdx,
                          charClassName: classNames(
                            charClassName({
                              base,
                              sequenceIdx
                            }),
                            baseInSelection({
                              baseIndex: baseIdx,
                              selection,
                              sequenceLength: annotatedSequences[sequenceIdx].length
                            }) && base.base !== " " && selectionClassName
                          )
                        }
                      )
                    ]
                  },
                  `sequence-${sequenceIdx}-base-${baseIdx}`
                );
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SequenceAnnotation,
              {
                annotations: stackedAnnotations,
                index: baseIdx,
                maxAnnotationStack: Math.max(
                  1,
                  Math.max(...stackedAnnotations.map((ann) => ann.stack))
                ),
                setHoveredPosition,
                setActiveAnnotation,
                maxSequenceLength: Math.max(
                  ...annotatedSequences.map((seq) => seq.length)
                )
              }
            )
          ]
        },
        `base-${baseIdx}`
      );
    }) });
  };
  const SeqMetadataBar = ({
    hoveredPosition,
    activeAnnotation,
    annotatedSequences,
    charClassName,
    seqIdxToCopy,
    setSeqIdxToCopy,
    selection,
    className
  }) => {
    const annotationDisplay = activeAnnotation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        className: classNames(
          "flex gap-2 rounded-full px-2 py-px text-xs !opacity-100",
          "ml-auto",
          activeAnnotation.className
        ),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "Label: ",
            activeAnnotation.text
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "Type: ",
            activeAnnotation.type
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "Direction: ",
            activeAnnotation.direction
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            "from ",
            activeAnnotation.start,
            " - ",
            activeAnnotation.end
          ] })
        ]
      }
    ) : null;
    const positionDisplay = /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "min-w-16 text-xs text-black dark:text-white", children: [
      "Pos: ",
      hoveredPosition ?? 0
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: classNames(
          "flex h-8 items-center gap-1 py-1 text-xs",
          className
        ),
        children: [
          positionDisplay,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CopyDisplay,
            {
              annotatedSequences,
              charClassName,
              seqIdxToCopy,
              setSeqIdxToCopy,
              selection
            }
          ),
          annotationDisplay
        ]
      }
    );
  };
  const SequenceAnnotation = ({
    annotations,
    maxAnnotationStack,
    index: index2,
    setHoveredPosition,
    setActiveAnnotation,
    maxSequenceLength
  }) => {
    const orderedAnnotations = annotations.sort((a, b) => a.stack - b.stack);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: " ",
        onMouseEnter: () => setHoveredPosition(index2),
        onMouseLeave: () => setHoveredPosition(null),
        children: [...Array(maxAnnotationStack).keys()].map((i) => {
          const annotation = orderedAnnotations.filter(
            (ann) => baseInSelection({
              baseIndex: index2,
              selection: ann,
              sequenceLength: maxSequenceLength
            })
          ).find((ann) => ann.stack === i);
          if (annotation) {
            if (!baseInSelection({
              baseIndex: index2,
              selection: annotation,
              sequenceLength: maxSequenceLength
            })) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "h-3 border-b-2 border-noir-100 opacity-10 "
                },
                `annotation-${index2}-${i}`
              );
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: classNames(
                  "group/annotation h-3 border-black group-hover/annotation:border",
                  annotation.className
                ),
                onClick: () => {
                  var _a;
                  return (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, {
                    start: annotation.start,
                    end: annotation.end,
                    diection: annotation.direction
                  });
                },
                onMouseEnter: () => setActiveAnnotation(annotation),
                onMouseLeave: () => setActiveAnnotation(null)
              },
              `annotation-${index2}-${i}`
            );
          } else {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3" }, `placeholder-${index2}-${i}`);
          }
        })
      },
      `annotation-${index2}`
    );
  };
  const CharComponent = ({ char, charClassName }) => {
    const sharedClassName = "font-mono select-none";
    if (char === " ") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "opacity-20"), children: "." });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "mr-px"), children: char });
  };
  const CopyDisplay = ({
    seqIdxToCopy,
    setSeqIdxToCopy,
    annotatedSequences,
    charClassName,
    selection
  }) => {
    const getStringToCopy = () => {
      if (!selection) {
        return;
      }
      const seq = annotatedSequences[seqIdxToCopy];
      const stringToCopy = seq.filter(
        (base) => baseInSelection({
          baseIndex: base.index,
          selection,
          sequenceLength: annotatedSequences[seqIdxToCopy].length
        })
      ).map((base) => base.base).join("");
      return stringToCopy;
    };
    React.useEffect(function mountCopyHandler() {
      const copyHandler = (e) => {
        var _a;
        const stringToCopy = getStringToCopy();
        if (!stringToCopy) {
          return;
        }
        (_a = e.clipboardData) == null ? void 0 : _a.setData("text/plain", stringToCopy);
        alert("Copied to clipboard!");
        e.preventDefault();
      };
      document.addEventListener("copy", copyHandler);
      return function unmountCopyHandler() {
        document.removeEventListener("copy", copyHandler);
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Select,
        {
          value: seqIdxToCopy.toString(),
          onValueChange: (value) => setSeqIdxToCopy(parseInt(value)),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-fit", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              SelectValue,
              {
                className: charClassName({
                  base: { base: "A", annotations: [], index: 0 },
                  sequenceIdx: seqIdxToCopy
                }),
                children: [
                  "Sequence ",
                  seqIdxToCopy + 1
                ]
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { className: "bg-white dark:bg-black", children: annotatedSequences.map((_, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              SelectItem,
              {
                value: idx.toString(),
                className: charClassName({
                  base: { base: "A", annotations: [], index: 0 },
                  sequenceIdx: idx
                }),
                children: [
                  "Sequence ",
                  idx + 1,
                  " "
                ]
              },
              `sequence-${idx}`
            )) })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CopyButton,
        {
          textToCopy: () => getStringToCopy() ?? "",
          label: "",
          disabled: !selection
        }
      )
    ] });
  };
  const ReferenceTicks = ({
    sequence,
    className
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("overflow-hiddentext-white flex", className), children: sequence.map((nucl, i) => {
      const showTicks = nucl.base !== "-" && (nucl.index + 1) % 10 === 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "relative flex h-12 flex-col items-end justify-end",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: classNames(
                  "font-mono ",
                  "absolute bottom-0 left-0 right-0",
                  showTicks ? "opacity-100" : "opacity-0",
                  nucl.base === "G" && "text-red-500",
                  nucl.base === "A" && "text-yellow-500",
                  nucl.base === "T" && "text-green-500",
                  nucl.base === "C" && "text-blue-500"
                ),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs", children: [
                    " ",
                    nucl.index + 1
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mx-auto text-xs", children: "|" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("mr-px font-mono opacity-0"), children: nucl.base })
          ]
        },
        `base-${i}-index-wrapper`
      );
    }) });
  };
  exports2.CircularViewer = CircularViewer;
  exports2.GapSchema = GapSchema;
  exports2.GenbankFeatureSchema = GenbankFeatureSchema;
  exports2.LinearAnnotationGutter = LinearAnnotationGutter;
  exports2.LinearViewer = LinearViewer;
  exports2.ReferenceTicks = ReferenceTicks;
  exports2.SequenceViewer = SequenceViewer;
  exports2.SpaceSchema = SpaceSchema;
  exports2.StopSchema = StopSchema;
  exports2.UnknownSchema = UnknownSchema;
  exports2.aaSchema = aaSchema;
  exports2.angleSchema = angleSchema;
  exports2.annotatedBaseSchema = annotatedBaseSchema;
  exports2.annotatedSequenceSchema = annotatedSequenceSchema;
  exports2.annotationSchema = annotationSchema;
  exports2.annotationTypeSchema = annotationTypeSchema;
  exports2.annotationsHaveOverlap = annotationsHaveOverlap;
  exports2.anythingToAnnotatedSequences = anythingToAnnotatedSequences;
  exports2.ariadneSelectionSchema = ariadneSelectionSchema;
  exports2.baseInSelection = baseInSelection;
  exports2.coorSchema = coorSchema;
  exports2.genbankFeaturesToAnnotations = genbankFeaturesToAnnotations;
  exports2.genbankToAnnotatedSequence = genbankToAnnotatedSequence;
  exports2.getAnnotatedSequence = getAnnotatedSequence;
  exports2.getClassNameFromFeatureType = getClassNameFromFeatureType;
  exports2.getComplement = getComplement;
  exports2.getStackedAnnotations = getStackedAnnotations;
  exports2.getSubsequenceLength = getSubsequenceLength;
  exports2.inRange = inRange;
  exports2.nuclSchema = nuclSchema;
  exports2.parseFasta = parseFasta;
  exports2.parseFastq = parseFastq;
  exports2.parseGenbank = parseGenbank;
  exports2.safeAnythingToAnnotatedSequences = safeAnythingToAnnotatedSequences;
  exports2.stackAnnotationsNoOverlap = stackAnnotationsNoOverlap;
  exports2.stackAnnsByType = stackAnnsByType;
  exports2.stackElements = stackElements;
  exports2.stackedAnnotationSchema = stackedAnnotationSchema;
  exports2.stringToAnnotatedSequence = stringToAnnotatedSequence;
  exports2.useCircularSelectionRect = useCircularSelectionRect;
  exports2.useLinearSelectionRect = useLinearSelectionRect;
  exports2.zipArrays = zipArrays;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibml0cm8tdWkudW1kLmpzIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtcnVudGltZS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvY2lyY3VsYXJVdGlscy50cyIsIi4uL25vZGVfbW9kdWxlcy9nZW5iYW5rLXBhcnNlci9zcmMvdXRpbHMvbW9udGhzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2dlbmJhbmstcGFyc2VyL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy96b2QvbGliL2luZGV4Lm1qcyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvc2NoZW1hcy50cyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvZ2VuYmFua1V0aWxzLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS91dGlscy50cyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvaG9va3MvdXNlU3RhdGVSZWYudHMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL2hvb2tzL3VzZVNlbGVjdGlvbi50cyIsIi4uL3NyYy91dGlscy9zdHJpbmdVdGlscy50cyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvQ2lyY3VsYXJBbm5vdGF0aW9ucy9DaXJjdWxhckFubm90YXRpb24udHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9DaXJjdWxhclZpZXdlci9DaXJjdWxhckFubm90YXRpb25zL0NpcmN1bGFyQW5ub3RhdGlvbkd1dHRlci50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0NpcmN1bGFyVmlld2VyL0NpcmN1bGFySW5kZXgvQ2lyY3VsYXJJbmRleC50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0NpcmN1bGFyVmlld2VyL0NpcmN1bGFyVmlld2VyLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvTGluZWFyVmlld2VyL0xpbmVhckFubm90YXRpb25HdXR0ZXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9MaW5lYXJWaWV3ZXIvTGluZWFyVmlld2VyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvbnVtYmVyL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9wcmltaXRpdmUvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWNvbnRleHQvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWNvbXBvc2UtcmVmcy9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3Qtc2xvdC9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29sbGVjdGlvbi9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtZGlyZWN0aW9uL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1wcmltaXRpdmUvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1jYWxsYmFjay1yZWYvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1lc2NhcGUta2V5ZG93bi9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtZGlzbWlzc2FibGUtbGF5ZXIvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWZvY3VzLWd1YXJkcy9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtZm9jdXMtc2NvcGUvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0L2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1pZC9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanMiLCIuLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5kb20ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC1kb20vZGlzdC9mbG9hdGluZy11aS5yZWFjdC1kb20ubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1hcnJvdy9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLXNpemUvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXBvcHBlci9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcG9ydGFsL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2UtY29udHJvbGxhYmxlLXN0YXRlL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2UtcHJldmlvdXMvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXZpc3VhbGx5LWhpZGRlbi9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9hcmlhLWhpZGRlbi9kaXN0L2VzMjAxNS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyL2Rpc3QvZXMyMDE1L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy91c2UtY2FsbGJhY2stcmVmL2Rpc3QvZXMyMDE1L2Fzc2lnblJlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy91c2UtY2FsbGJhY2stcmVmL2Rpc3QvZXMyMDE1L3VzZVJlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy91c2UtY2FsbGJhY2stcmVmL2Rpc3QvZXMyMDE1L3VzZU1lcmdlUmVmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1zaWRlY2FyL2Rpc3QvZXMyMDE1L21lZGl1bS5qcyIsIi4uL25vZGVfbW9kdWxlcy91c2Utc2lkZWNhci9kaXN0L2VzMjAxNS9leHBvcnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvbWVkaXVtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvVUkuanMiLCIuLi9ub2RlX21vZHVsZXMvZ2V0LW5vbmNlL2Rpc3QvZXMyMDE1L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXN0eWxlLXNpbmdsZXRvbi9kaXN0L2VzMjAxNS9zaW5nbGV0b24uanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3R5bGUtc2luZ2xldG9uL2Rpc3QvZXMyMDE1L2hvb2suanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3R5bGUtc2luZ2xldG9uL2Rpc3QvZXMyMDE1L2NvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsLWJhci9kaXN0L2VzMjAxNS91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsLWJhci9kaXN0L2VzMjAxNS9jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9hZ2dyZXNpdmVDYXB0dXJlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvaGFuZGxlU2Nyb2xsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvU2lkZUVmZmVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L3NpZGVjYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9Db21iaW5hdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3Qtc2VsZWN0L2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9zaGFyZWQvc3JjL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9kZWZhdWx0QXR0cmlidXRlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vSWNvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2hlY2suanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2NoZXZyb24tZG93bi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2hldnJvbi11cC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY29weS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL3VpL3NlbGVjdC50c3giLCIuLi9zcmMvY29tcG9uZW50cy91aS9jb3B5LWJ1dHRvbi50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL1NlcXVlbmNlVmlld2VyL1NlcXVlbmNlVmlld2VyLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvUmVmZXJlbmNlVGlja3MvUmVmZXJlbmNlVGlja3MudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZj1yZXF1aXJlKFwicmVhY3RcIiksaz1TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxsPVN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxtPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksbj1mLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLHA9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIHEoYyxhLGcpe3ZhciBiLGQ9e30sZT1udWxsLGg9bnVsbDt2b2lkIDAhPT1nJiYoZT1cIlwiK2cpO3ZvaWQgMCE9PWEua2V5JiYoZT1cIlwiK2Eua2V5KTt2b2lkIDAhPT1hLnJlZiYmKGg9YS5yZWYpO2ZvcihiIGluIGEpbS5jYWxsKGEsYikmJiFwLmhhc093blByb3BlcnR5KGIpJiYoZFtiXT1hW2JdKTtpZihjJiZjLmRlZmF1bHRQcm9wcylmb3IoYiBpbiBhPWMuZGVmYXVsdFByb3BzLGEpdm9pZCAwPT09ZFtiXSYmKGRbYl09YVtiXSk7cmV0dXJueyQkdHlwZW9mOmssdHlwZTpjLGtleTplLHJlZjpoLHByb3BzOmQsX293bmVyOm4uY3VycmVudH19ZXhwb3J0cy5GcmFnbWVudD1sO2V4cG9ydHMuanN4PXE7ZXhwb3J0cy5qc3hzPXE7XG4iLCIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSAganN4V2l0aFZhbGlkYXRpb25EeW5hbWljIDsgLy8gd2UgbWF5IHdhbnQgdG8gc3BlY2lhbCBjYXNlIGpzeHMgaW50ZXJuYWxseSB0byB0YWtlIGFkdmFudGFnZSBvZiBzdGF0aWMgY2hpbGRyZW4uXG4vLyBmb3Igbm93IHdlIGNhbiBzaGlwIGlkZW50aWNhbCBwcm9kIGZ1bmN0aW9uc1xuXG52YXIganN4cyA9ICBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3ggPSBqc3g7XG5leHBvcnRzLmpzeHMgPSBqc3hzO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgeyBBbmdsZSwgQXJpYWRuZVNlbGVjdGlvbiwgQ29vciB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG4vKipcbiAqIFRha2VuIGZyb20gc2Vxdml6XG4gKiBHaXZlbiBhbiBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudCwgcmV0dXJuIHRoZVxuICogcGF0aCBmb3IgYW4gYXJjIHRoYXQgY2lyY2xlcyB0aGUgcGxhc21pZC4gVGhlIG9wdGlvbmFsIHBhcmFtdGVycyBzd2VlcEZXRCBhbmQgc3dlZXBSRVZcbiAqIGFyZSBuZWVkZWQgZm9yIHNlbGVjdGlvbiBhcmNzICh3aGVyZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcmMgaXNuJ3Qga25vd24gYmVmb3JlaGFuZClcbiAqIGFuZCBhcnJvd0ZXRCBhbmQgYXJyb3dSRVYgYXJlIG5lZWRlZCBmb3IgYW5ub3RhdGlvbnMsIHdoZXJlIHRoZXJlIG1heSBiZSBkaXJlY3Rpb25hbGl0eVxuICovXG5leHBvcnQgY29uc3QgZ2VuQXJjID0gKHtcbiAgY2VudGVyLFxuICBpbm5lclJhZGl1cyxcbiAgbGFyZ2VBcmMsXG4gIGxlbmd0aCxcbiAgb2Zmc2V0LFxuICBvdXRlclJhZGl1cyxcbiAgc2VxTGVuZ3RoLFxufToge1xuICBjZW50ZXI6IENvb3I7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIGxhcmdlQXJjOiBib29sZWFuO1xuICBsZW5ndGg6IG51bWJlcjtcbiAgb2Zmc2V0OiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGxlZnRCb3R0b20gPSBmaW5kQ29vcih7XG4gICAgaW5kZXg6IG9mZnNldCxcbiAgICByYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIGNlbnRlcixcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICBjb25zdCBsZWZ0VG9wID0gZmluZENvb3Ioe1xuICAgIGluZGV4OiBvZmZzZXQsXG4gICAgcmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICBjZW50ZXIsXG4gICAgc2VxTGVuZ3RoLFxuICB9KTtcbiAgY29uc3QgcmlnaHRCb3R0b20gPSBmaW5kQ29vcih7XG4gICAgaW5kZXg6IGxlbmd0aCArIG9mZnNldCxcbiAgICByYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIGNlbnRlcixcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICBjb25zdCByaWdodFRvcCA9IGZpbmRDb29yKHtcbiAgICBpbmRleDogbGVuZ3RoICsgb2Zmc2V0LFxuICAgIHJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgY2VudGVyLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIGNvbnN0IHNGbGFnRiA9IDE7XG4gIGNvbnN0IHNGbGFnUiA9IDA7XG5cbiAgY29uc3QgbEFyYyA9IGxhcmdlQXJjID8gMSA6IDA7XG5cbiAgcmV0dXJuIGBNICR7cmlnaHRCb3R0b20ueH0gJHtyaWdodEJvdHRvbS55fVxuICAgICAgQSAke2lubmVyUmFkaXVzfSAke2lubmVyUmFkaXVzfSwgMCwgJHtsQXJjfSwgJHtzRmxhZ1J9LCAke2xlZnRCb3R0b20ueH0gJHtsZWZ0Qm90dG9tLnl9XG4gICAgICBMICR7bGVmdEJvdHRvbS54fSAke2xlZnRCb3R0b20ueX1cbiAgICAgIEwgJHtsZWZ0VG9wLnh9ICR7bGVmdFRvcC55fVxuICAgICAgQSAke291dGVyUmFkaXVzfSAke291dGVyUmFkaXVzfSwgMCwgJHtsQXJjfSwgJHtzRmxhZ0Z9LCAke3JpZ2h0VG9wLnh9ICR7cmlnaHRUb3AueX1cbiAgICAgIFpgO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbmRleCBhbG9uZyB0aGUgcGxhc21pZCBhbmQgaXRzIHJhZGl1cywgZmluZCBzdmcgY29vcmRpbmF0ZVxuICogZnJvbSBzZXF2aXpcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRDb29yID0gKHtcbiAgaW5kZXgsXG4gIHJhZGl1cyxcbiAgY2VudGVyLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICBjZW50ZXI6IENvb3I7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IENvb3IgPT4ge1xuICBjb25zdCBsZW5ndGhQZXJjID0gaW5kZXggLyBzZXFMZW5ndGg7XG4gIGNvbnN0IGxlbmd0aFBlcmNDZW50ZXJlZCA9IGxlbmd0aFBlcmMgLSAwLjI1O1xuICBjb25zdCByYWRpYW5zID0gbGVuZ3RoUGVyY0NlbnRlcmVkICogTWF0aC5QSSAqIDI7XG4gIGNvbnN0IHhBZGp1c3QgPSBNYXRoLmNvcyhyYWRpYW5zKSAqIHJhZGl1cztcbiAgY29uc3QgeUFkanVzdCA9IE1hdGguc2luKHJhZGlhbnMpICogcmFkaXVzO1xuXG4gIHJldHVybiB7XG4gICAgeDogY2VudGVyLnggKyB4QWRqdXN0LFxuICAgIHk6IGNlbnRlci55ICsgeUFkanVzdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaW5kSW5kZXhGcm9tQ29vciA9ICh7XG4gIGNvb3IsXG4gIGNlbnRlcixcbiAgc2VxTGVuZ3RoLFxufToge1xuICBjb29yOiBDb29yO1xuICBjZW50ZXI6IENvb3I7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHggPSBjb29yLnggLSBjZW50ZXIueDtcbiAgY29uc3QgeSA9IGNvb3IueSAtIGNlbnRlci55O1xuICBjb25zdCByYWRpYW5zID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgY29uc3QgbGVuZ3RoUGVyYyA9IHJhZGlhbnMgLyAoTWF0aC5QSSAqIDIpICsgMC4yNTtcbiAgY29uc3QgcmF3QmFzZUlkeCA9IGxlbmd0aFBlcmMgKiBzZXFMZW5ndGg7XG4gIC8vIGlmIHdlJ3JlIGluIG5lZ2F0aXZlIGluZGljZXMsIGNvbnZlcnQgdG8gdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2VcbiAgcmV0dXJuIE1hdGgucm91bmQocmF3QmFzZUlkeCA8IDAgPyBzZXFMZW5ndGggKyByYXdCYXNlSWR4IDogcmF3QmFzZUlkeCk7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZEFuZ2xlRnJvbUNvb3IgPSAoe1xuICBjb29yLFxuICBjZW50ZXIsXG59OiB7XG4gIGNvb3I6IENvb3I7XG4gIGNlbnRlcjogQ29vcjtcbn0pOiBudW1iZXIgPT4ge1xuICBjb25zdCB4ID0gY29vci54IC0gY2VudGVyLng7XG4gIGNvbnN0IHkgPSBjb29yLnkgLSBjZW50ZXIueTtcbiAgbGV0IHJhZGlhbnMgPSBNYXRoLmF0YW4yKHksIHgpO1xuICBpZiAocmFkaWFucyA8IDApIHtcbiAgICByYWRpYW5zID0gcmFkaWFucyArIE1hdGguUEkgKiAyO1xuICB9XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIE1hdGguUEkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRBbmdsZUJldHdlZW5Db29ycyA9ICh7XG4gIGNvb3IxLFxuICBjb29yMixcbiAgY2VudGVyLFxufToge1xuICBjb29yMTogQ29vcjtcbiAgY29vcjI6IENvb3I7XG4gIGNlbnRlcjogQ29vcjtcbn0pOiBudW1iZXIgPT4ge1xuICBjb25zdCBhbmdsZTEgPSBmaW5kQW5nbGVGcm9tQ29vcih7IGNvb3I6IGNvb3IxLCBjZW50ZXIgfSk7XG4gIGNvbnN0IGFuZ2xlMiA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogY29vcjIsIGNlbnRlciB9KTtcbiAgY29uc3QgYW5nbGUgPSBhbmdsZTIgLSBhbmdsZTE7XG4gIHJldHVybiBhbmdsZTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaW5kSW5kZXhGcm9tQW5nbGUgPSAoe1xuICBhbmdsZSxcbiAgc2VxTGVuZ3RoLFxufToge1xuICBhbmdsZTogQW5nbGU7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IG51bWJlciA9PiB7XG4gIC8vIHplcm8gZGVncmVzcyBpcyAyNSUgb2YgdGhlIHNlcXVlbmNlLCBhbmQgd2Ugd2FudCBrZWVwIGRlZ3JlZXMgYmV0d2VlbiAwIGFuZCAzNjBcbiAgbGV0IGVmZmVjdGl2ZUFuZ2xlID0gYW5nbGUuZGVncmVlcyArIDkwO1xuICBpZiAoZWZmZWN0aXZlQW5nbGUgPCAwKSB7XG4gICAgZWZmZWN0aXZlQW5nbGUgPSAzNjAgKyBlZmZlY3RpdmVBbmdsZTtcbiAgfVxuICBlZmZlY3RpdmVBbmdsZSA9IGVmZmVjdGl2ZUFuZ2xlICUgMzYwO1xuICBjb25zdCBhcmNQZXJjID0gZWZmZWN0aXZlQW5nbGUgLyAzNjA7XG5cbiAgY29uc3QgcmF3QmFzZUlkeCA9IGFyY1BlcmMgKiBzZXFMZW5ndGg7XG4gIHJldHVybiBNYXRoLnJvdW5kKHJhd0Jhc2VJZHggPCAwID8gc2VxTGVuZ3RoICsgcmF3QmFzZUlkeCA6IHJhd0Jhc2VJZHgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsYW1wU2xpY2UgPSAoe1xuICBzbGljZSxcbiAgZmlyc3RJZHgsXG4gIGxhc3RJZHgsXG59OiB7XG4gIHNsaWNlOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgZmlyc3RJZHg6IG51bWJlcjtcbiAgbGFzdElkeDogbnVtYmVyO1xufSk6IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsID0+IHtcbiAgaWYgKCFzbGljZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHNsaWNlO1xuXG4gIGNvbnN0IG91dE9mQm91bmRzQmVmb3JlID0gc3RhcnQgPCBmaXJzdElkeCAmJiBlbmQgPCBmaXJzdElkeDtcbiAgY29uc3Qgb3V0T2ZCb3VuZHNBZnRlciA9IHN0YXJ0ID4gbGFzdElkeCAmJiBlbmQgPiBsYXN0SWR4O1xuXG4gIGlmIChvdXRPZkJvdW5kc0JlZm9yZSB8fCBvdXRPZkJvdW5kc0FmdGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbGFzdElkeCk7XG4gICAgZW5kID0gTWF0aC5tYXgoZW5kLCBmaXJzdElkeCk7XG4gIH0gZWxzZSB7XG4gICAgZW5kID0gTWF0aC5taW4oZW5kLCBsYXN0SWR4KTtcbiAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBmaXJzdElkeCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgZGlyZWN0aW9uOiBzbGljZS5kaXJlY3Rpb24sXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ0pBTicsXG4gICdGRUInLFxuICAnTUFSJyxcbiAgJ0FQUicsXG4gICdNQVknLFxuICAnSlVOJyxcbiAgJ0pVTCcsXG4gICdBVUcnLFxuICAnU0VQJyxcbiAgJ09DVCcsXG4gICdOT1YnLFxuICAnREVDJyxcbl07XG4iLCIvKiBlc2xpbnQgbm8tZGl2LXJlZ2V4OiAwKi9cbi8qIGVzbGludCBwcmVmZXItbmFtZWQtY2FwdHVyZS1ncm91cDogMCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1PTlRIUyA9IHJlcXVpcmUoJy4vdXRpbHMvbW9udGhzJyk7XG5cbmZ1bmN0aW9uIGdlbmJhbmtUb0pzb24oc2VxdWVuY2UpIHtcbiAgaWYgKHR5cGVvZiBzZXF1ZW5jZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBsZXQgcmVzdWx0c0FycmF5ID0gW107XG4gIGxldCByZXN1bHQ7XG4gIGxldCBjdXJyZW50RmVhdHVyZU5vdGU7XG5cbiAgLy8gR2VuYmFuayBzcGVjaWZpY2F0aW9uOiBodHRwczovL3d3dy5uY2JpLm5sbS5uaWguZ292L1NpdGVtYXAvc2FtcGxlcmVjb3JkLmh0bWxcbiAgbGV0IGdlbmJhbmtBbm5vdGF0aW9uS2V5ID0ge1xuICAgIC8vIENvbnRhaW5zIGluIG9yZGVyOiBsb2N1cyBuYW1lLCBzZXF1ZW5jZSBsZW5ndGgsIG1vbGVjdWxlIHR5cGUgKGUuZy4gRE5BKSwgZ2VuYmFuayBkaXZpc2lvbiAoc2VlIDEtMTggYmVsb3cpLCBtb2RpZmljYXRpb24gZGF0ZVxuICAgIC8vIGxvY3VzIGRlZmluaXRpb24gaGFzIGNoYW5nZWQgd2l0aCB0aW1lLCB1c2UgYWNjZXNzaW9uIG51bWJlciBmb3IgYSB1bmlxdWUgaWRlbnRpZmllclxuICAgIExPQ1VTX1RBRzogJ0xPQ1VTJyxcbiAgICBERUZJTklUSU9OX1RBRzogJ0RFRklOSVRJT04nLFxuICAgIC8vIEFjY2Vzc2lvbiB0YWdcbiAgICAvLyBFeGFtcGxlOiBaNzg1MzNcbiAgICBBQ0NFU1NJT05fVEFHOiAnQUNDRVNTSU9OJyxcbiAgICAvLyBUaGUgdmVyc2lvbiB0YWcgY29udGFpbnMgMiBpbmZvcm1hdGlvbnNcbiAgICAvLyBUaGUgYWNjZXNzaW9uIG51bWJlciB3aXRoIGEgcmV2aXNpb25cbiAgICAvLyBUaGUgR0kgKEdlbkluZm8gSWRlbnRpZmllciksIGEgbmNiaSBzZXF1ZW50aWFsIG51bWJlclxuICAgIC8vIEV4YW1wbGU6IFo3ODUzMy4xICBHSToyNzY1NjU4XG4gICAgLy8gVW5pY2l0eSBnYXJhbnRlZWQgd2l0aCByZXNwZWN0IHRvIHNlcXVlbmNlLiBJZiAxIG51Y2xlb3RpZGUgY2hhbmdlcywgdGhlIHZlcnNpb24gaXMgZGlmZmVyZW50LlxuICAgIFZFUlNJT05fVEFHOiAnVkVSU0lPTicsXG4gICAgS0VZV09SRFNfVEFHOiAnS0VZV09SRFMnLFxuICAgIC8vIFNFR01FTlRfVEFHOlwiU0VHTUVOVFwiXG4gICAgLy8gU291cmNlIGlzIGZyZWUgdGV4dFxuICAgIFNPVVJDRV9UQUc6ICdTT1VSQ0UnLFxuICAgIE9SR0FOSVNNX1RBRzogJ09SR0FOSVNNJyxcbiAgICBSRUZFUkVOQ0VfVEFHOiAnUkVGRVJFTkNFJyxcbiAgICBBVVRIT1JTX1RBRzogJ0FVVEhPUlMnLFxuICAgIENPTlNPUlRJVU1fVEFHOiAnQ09OU1JUTScsXG4gICAgVElUTEVfVEFHOiAnVElUTEUnLFxuICAgIC8vIENhbiBiZSBtdWx0aXBsZSBqb3VybmFsIHRhZ3NcbiAgICBKT1VSTkFMX1RBRzogJ0pPVVJOQUwnLFxuICAgIFBVQk1FRF9UQUc6ICdQVUJNRUQnLFxuICAgIFJFTUFSS19UQUc6ICdSRU1BUksnLFxuICAgIEZFQVRVUkVTX1RBRzogJ0ZFQVRVUkVTJyxcbiAgICBCQVNFX0NPVU5UX1RBRzogJ0JBU0UgQ09VTlQnLFxuICAgIC8vIENPTlRJR19UQUc6IFwiQ09OVElHXCJcbiAgICBPUklHSU5fVEFHOiAnT1JJR0lOJyxcbiAgICBFTkRfU0VRVUVOQ0VfVEFHOiAnLy8nLFxuICB9O1xuXG4gIC8vIEdlbmJhbmsgZGl2aXNpb25zXG4gIC8vICAgMS4gUFJJIC0gcHJpbWF0ZSBzZXF1ZW5jZXNcbiAgLy8gICAyLiBST0QgLSByb2RlbnQgc2VxdWVuY2VzXG4gIC8vICAgMy4gTUFNIC0gb3RoZXIgbWFtbWFsaWFuIHNlcXVlbmNlc1xuICAvLyAgIDQuIFZSVCAtIG90aGVyIHZlcnRlYnJhdGUgc2VxdWVuY2VzXG4gIC8vICAgNS4gSU5WIC0gaW52ZXJ0ZWJyYXRlIHNlcXVlbmNlc1xuICAvLyAgIDYuIFBMTiAtIHBsYW50LCBmdW5nYWwsIGFuZCBhbGdhbCBzZXF1ZW5jZXNcbiAgLy8gICA3LiBCQ1QgLSBiYWN0ZXJpYWwgc2VxdWVuY2VzXG4gIC8vICAgOC4gVlJMIC0gdmlyYWwgc2VxdWVuY2VzXG4gIC8vICAgOS4gUEhHIC0gYmFjdGVyaW9waGFnZSBzZXF1ZW5jZXNcbiAgLy8gMTAuIFNZTiAtIHN5bnRoZXRpYyBzZXF1ZW5jZXNcbiAgLy8gMTEuIFVOQSAtIHVuYW5ub3RhdGVkIHNlcXVlbmNlc1xuICAvLyAxMi4gRVNUIC0gRVNUIHNlcXVlbmNlcyAoZXhwcmVzc2VkIHNlcXVlbmNlIHRhZ3MpXG4gIC8vIDEzLiBQQVQgLSBwYXRlbnQgc2VxdWVuY2VzXG4gIC8vIDE0LiBTVFMgLSBTVFMgc2VxdWVuY2VzIChzZXF1ZW5jZSB0YWdnZWQgc2l0ZXMpXG4gIC8vIDE1LiBHU1MgLSBHU1Mgc2VxdWVuY2VzIChnZW5vbWUgc3VydmV5IHNlcXVlbmNlcylcbiAgLy8gMTYuIEhURyAtIEhURyBzZXF1ZW5jZXMgKGhpZ2gtdGhyb3VnaHB1dCBnZW5vbWljIHNlcXVlbmNlcylcbiAgLy8gMTcuIEhUQyAtIHVuZmluaXNoZWQgaGlnaC10aHJvdWdocHV0IGNETkEgc2VxdWVuY2luZ1xuICAvLyAxOC4gRU5WIC0gZW52aXJvbm1lbnRhbCBzYW1wbGluZyBzZXF1ZW5jZXNcblxuICBsZXQgbGluZXMgPSBzZXF1ZW5jZS5zcGxpdCgvXFxyP1xcbi8pO1xuICBsZXQgZmllbGROYW1lO1xuICBsZXQgc3ViRmllbGRUeXBlO1xuICBsZXQgZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb247XG4gIGxldCBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnO1xuICBsZXQgbGFzdExpbmVXYXNMb2NhdGlvbjtcblxuICBsZXQgaGFzRm91bmRMb2N1cyA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBpZiAobGluZSA9PT0gbnVsbCkgYnJlYWs7XG4gICAgbGV0IGxpbmVGaWVsZE5hbWUgPSBnZXRMaW5lRmllbGROYW1lKGxpbmUpO1xuICAgIGxldCB2YWwgPSBnZXRMaW5lVmFsKGxpbmUpO1xuICAgIGxldCBpc1N1YktleSA9IGlzU3ViS2V5d29yZChsaW5lKTtcbiAgICBsZXQgaXNLZXkgPSBpc0tleXdvcmQobGluZSk7XG5cbiAgICBpZiAobGluZUZpZWxkTmFtZSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuRU5EX1NFUVVFTkNFX1RBRyB8fCBpc0tleSkge1xuICAgICAgZmllbGROYW1lID0gbGluZUZpZWxkTmFtZTtcbiAgICAgIHN1YkZpZWxkVHlwZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChpc1N1YktleSkge1xuICAgICAgc3ViRmllbGRUeXBlID0gbGluZUZpZWxkTmFtZTtcbiAgICB9XG4gICAgLy8gSUdOT1JFIExJTkVTOiBETyBOT1QgRVZFTiBQUk9DRVNTXG4gICAgaWYgKGxpbmUudHJpbSgpID09PSAnJyB8fCBsaW5lRmllbGROYW1lID09PSAnOycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghaGFzRm91bmRMb2N1cyAmJiBmaWVsZE5hbWUgIT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5LkxPQ1VTX1RBRykge1xuICAgICAgLy8gJ0dlbmJhbmsgZmlsZXMgbXVzdCBzdGFydCB3aXRoIGEgTE9DVVMgdGFnIHNvIHRoaXMgbXVzdCBub3QgYmUgYSBnZW5iYW5rJ1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmaWVsZE5hbWUpIHtcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuTE9DVVNfVEFHOlxuICAgICAgICBoYXNGb3VuZExvY3VzID0gdHJ1ZTtcbiAgICAgICAgcGFyc2VMb2N1cyhsaW5lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LkZFQVRVUkVTX1RBRzpcbiAgICAgICAgcGFyc2VGZWF0dXJlcyhsaW5lLCBsaW5lRmllbGROYW1lLCB2YWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuT1JJR0lOX1RBRzpcbiAgICAgICAgcGFyc2VPcmlnaW4obGluZSwgbGluZUZpZWxkTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5ERUZJTklUSU9OX1RBRzpcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuQUNDRVNTSU9OX1RBRzpcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuVkVSU0lPTl9UQUc6XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LktFWVdPUkRTX1RBRzpcbiAgICAgICAgcGFyc2VNdWx0aUxpbmVGaWVsZChmaWVsZE5hbWUsIGxpbmUsIGZpZWxkTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LlNPVVJDRV9UQUc6XG4gICAgICAgIGlmIChzdWJGaWVsZFR5cGUgPT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5Lk9SR0FOSVNNX1RBRykge1xuICAgICAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQoc3ViRmllbGRUeXBlLCBsaW5lLCAnb3JnYW5pc20nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZU11bHRpTGluZUZpZWxkKGxpbmVGaWVsZE5hbWUsIGxpbmUsICdzb3VyY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuUkVGRVJFTkNFX1RBRzpcbiAgICAgICAgaWYgKGxpbmVGaWVsZE5hbWUgPT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5LlJFRkVSRU5DRV9UQUcpIHtcbiAgICAgICAgICBjb25zdCByZWYgPSByZXN1bHQucmVmZXJlbmNlcyB8fCBbXTtcbiAgICAgICAgICByZXN1bHQucmVmZXJlbmNlcyA9IHJlZjtcbiAgICAgICAgICByZWYucHVzaCh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VSZWZlcmVuY2UobGluZSwgc3ViRmllbGRUeXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LkVORF9TRVFVRU5DRV9UQUc6XG4gICAgICAgIGVuZFNlcSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFVuaGFuZGxlZCB0YWdcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2F0Y2ggdGhlIGNhc2Ugd2hlcmUgd2UndmUgc3VjY2Vzc2Z1bGx5IHN0YXJ0ZWQgYSBzZXF1ZW5jZSBhbmQgcGFyc2VkIGl0LCBidXQgZW5kU2VxIGlzbid0IGNhbGxlZCBjb3JyZWN0bHlcbiAgaWYgKHJlc3VsdHNBcnJheVtyZXN1bHRzQXJyYXkubGVuZ3RoIC0gMV0gIT09IHJlc3VsdCkge1xuICAgIC8vIGN1cnJlbnQgcmVzdWx0IGlzbid0IGluIHJlc3VsdHNBcnJheSB5ZXRcbiAgICAvLyBzbyB3ZSBjYWxsIGVuZFNlcSBoZXJlXG4gICAgZW5kU2VxKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHNBcnJheTtcblxuICBmdW5jdGlvbiBlbmRTZXEoKSB7XG4gICAgLy8gZG8gc29tZSBwb3N0IHByb2Nlc3NpbmcgY2xlYW4tdXBcbiAgICBwb3N0UHJvY2Vzc0N1clNlcSgpO1xuICAgIC8vIHB1c2ggdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHRzQXJyYXlcbiAgICByZXN1bHRzQXJyYXkucHVzaChyZXN1bHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudEZlYXR1cmUoKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5mZWF0dXJlc1tyZXN1bHQuZmVhdHVyZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0UHJvY2Vzc0N1clNlcSgpIHtcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5mZWF0dXJlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LmZlYXR1cmVzW2ldID0gcG9zdFByb2Nlc3NHZW5iYW5rRmVhdHVyZShyZXN1bHQuZmVhdHVyZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT3JpZ2luKGxpbmUsIGtleSkge1xuICAgIGlmIChrZXkgIT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5Lk9SSUdJTl9UQUcpIHtcbiAgICAgIGxldCBuZXdMaW5lID0gbGluZS5yZXBsYWNlKC9bXFxzXSpbMC05XSovZywgJycpO1xuICAgICAgcmVzdWx0LnNlcXVlbmNlICs9IG5ld0xpbmU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2N1cyhsaW5lKSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgbmFtZTogJ1VudGl0bGVkIHNlcXVlbmNlJyxcbiAgICAgIHNlcXVlbmNlOiAnJyxcbiAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgIH07XG4gICAgbGluZSA9IHJlbW92ZUZpZWxkTmFtZShnZW5iYW5rQW5ub3RhdGlvbktleS5MT0NVU19UQUcsIGxpbmUpO1xuICAgIGNvbnN0IG0gPSBsaW5lLm1hdGNoKFxuICAgICAgL14oW15cXHNdKylcXHMrKFxcZCspXFxzK2JwXFxzKyhbXlxcc10rKVxccysoW15cXHNdKylcXHMrKFteXFxzXSspXFxzKihbXlxcc10rKT8kLyxcbiAgICApO1xuICAgIGxldCBsb2N1c05hbWUgPSBtWzFdO1xuICAgIGxldCBzaXplID0gK21bMl07XG4gICAgbGV0IG1vbGVjdWxlVHlwZSA9IG1bM107XG4gICAgbGV0IGNpcmN1bGFyID0gbVs0XSA9PT0gJ2NpcmN1bGFyJztcbiAgICBjb25zdCBzZXEgPSByZXN1bHQ7XG4gICAgbGV0IGRhdGVTdHIgPSAnJztcbiAgICBpZiAoIW1bNl0pIHtcbiAgICAgIGRhdGVTdHIgPSBtWzVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXEuZ2VuYmFua0RpdmlzaW9uID0gbVs1XTtcbiAgICAgIGRhdGVTdHIgPSBtWzZdO1xuICAgIH1cbiAgICBzZXEuY2lyY3VsYXIgPSBjaXJjdWxhcjtcbiAgICBzZXEubW9sZWN1bGVUeXBlID0gbW9sZWN1bGVUeXBlO1xuICAgIGNvbnN0IGRhdGVNYXRjaCA9IGRhdGVTdHIubWF0Y2goL14oXFxkezJ9KS0oLnszfSktKFxcZHs0fSkkLyk7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcigrZGF0ZU1hdGNoWzNdKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKE1PTlRIUy5pbmRleE9mKGRhdGVNYXRjaFsyXS50b1VwcGVyQ2FzZSgpKSk7XG4gICAgZGF0ZS5zZXREYXRlKCtkYXRlTWF0Y2hbMV0pO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMTIpO1xuICAgIGRhdGUuc2V0TWludXRlcygwKTtcbiAgICBkYXRlLnNldFNlY29uZHMoMCk7XG4gICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgc2VxLmRhdGUgPSBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgc2VxLm5hbWUgPSBsb2N1c05hbWU7XG4gICAgc2VxLnNpemUgPSBzaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRmllbGROYW1lKGZOYW1lLCBsaW5lKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXlxccyovLCAnJyk7XG4gICAgaWYgKGxpbmUuaW5kZXhPZihmTmFtZSkgPT09IDApIHtcbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoZk5hbWUsICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2UobGluZSwgc3ViVHlwZSkge1xuICAgIGNvbnN0IHJlZnMgPSByZXN1bHQucmVmZXJlbmNlcztcbiAgICBsZXQgbGFzdFJlZiA9IHJlZnNbcmVmcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIXN1YlR5cGUpIHtcbiAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQoXG4gICAgICAgIGdlbmJhbmtBbm5vdGF0aW9uS2V5LlJFRkVSRU5DRV9UQUcsXG4gICAgICAgIGxpbmUsXG4gICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgIGxhc3RSZWYsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZU11bHRpTGluZUZpZWxkKHN1YlR5cGUsIGxpbmUsIHN1YlR5cGUudG9Mb3dlckNhc2UoKSwgbGFzdFJlZik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGZWF0dXJlcyhsaW5lLCBrZXksIHZhbCkge1xuICAgIGxldCBzdHJhbmQ7XG4gICAgLy8gRk9SIFRIRSBNQUlOIEZFQVRVUkVTIExPQ0FUSU9OL1FVQUxJRklFUiBMSU5FXG4gICAgaWYgKGtleSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuRkVBVFVSRVNfVEFHKSB7XG4gICAgICBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGFzdExpbmVXYXNGZWF0dXJlc1RhZykge1xuICAgICAgLy8gd2UgbmVlZCB0byBnZXQgdGhlIGluZGVudGF0aW9uIG9mIGZlYXR1cmUgbG9jYXRpb25zXG4gICAgICBmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbiA9IGdldExlbmd0aE9mV2hpdGVTcGFjZUJlZm9yZVN0YXJ0T2ZMZXR0ZXJzKFxuICAgICAgICBsaW5lLFxuICAgICAgKTtcbiAgICAgIC8vIHNldCBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnIHRvIGZhbHNlXG4gICAgICBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRk9SIExPQ0FUSU9OICYmIFFVQUxJRklFUiBMSU5FU1xuICAgIGlmIChpc0ZlYXR1cmVMaW5lUnVub24obGluZSwgZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb24pKSB7XG4gICAgICAvLyB0aGUgbGluZSBpcyBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgYWJvdmUgbGluZVxuICAgICAgaWYgKGxhc3RMaW5lV2FzTG9jYXRpb24pIHtcbiAgICAgICAgLy8gdGhlIGxhc3QgbGluZSB3YXMgYSBsb2NhdGlvbiwgc28gdGhlIHJ1bi1vbiBsaW5lIGlzIGV4cGVjdGVkIHRvIGJlIGEgZmVhdHVyZSBsb2NhdGlvbiBhcyB3ZWxsXG4gICAgICAgIHBhcnNlRmVhdHVyZUxvY2F0aW9uKGxpbmUudHJpbSgpKTtcbiAgICAgICAgbGFzdExpbmVXYXNMb2NhdGlvbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgbGFzdCBsaW5lIHdhcyBhIG5vdGVcbiAgICAgICAgaWYgKGN1cnJlbnRGZWF0dXJlTm90ZSkge1xuICAgICAgICAgIC8vIGFwcGVuZCB0byB0aGUgY3VycmVudEZlYXR1cmVOb3RlXG4gICAgICAgICAgY3VycmVudEZlYXR1cmVOb3RlW1xuICAgICAgICAgICAgY3VycmVudEZlYXR1cmVOb3RlLmxlbmd0aCAtIDFcbiAgICAgICAgICBdICs9IGxpbmUudHJpbSgpLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGluZVdhc0xvY2F0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyBFbGVtZW50L1F1YWxpZmllciBsaW5lcy4gTm90IHJ1bm9uIGxpbmVzLlxuICAgICAgaWYgKGlzTm90ZShsaW5lKSkge1xuICAgICAgICAvLyBpcyBhIG5ldyBGZWF0dXJlIEVsZW1lbnQgKGUuZy4gc291cmNlLCBDRFMpIGluIHRoZSBmb3JtIG9mICBcIltcXHNdIEtFWSAgU0VRTE9DQVRJT05cIlxuICAgICAgICAvLyBpcyBhIEZlYXR1cmVRdWFsaWZpZXIgaW4gdGhlIC9LRVk9XCJCTEFIXCIgZm9ybWF0OyBjb3VsZCBiZSBtdWx0aXBsZSBwZXIgRWxlbWVudFxuICAgICAgICAvLyBDaGVjayB0aGF0IGZlYXR1cmUgZGlkIG5vdCBnZXQgc2tpcHBlZCBmb3IgbWlzc2luZyBsb2NhdGlvblxuICAgICAgICBpZiAoZ2V0Q3VycmVudEZlYXR1cmUoKSkge1xuICAgICAgICAgIHBhcnNlRmVhdHVyZU5vdGUobGluZSk7XG4gICAgICAgICAgbGFzdExpbmVXYXNMb2NhdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgbGluZSBpcyBhIGxvY2F0aW9uLCBzbyB3ZSBtYWtlIGEgbmV3IGZlYXR1cmUgZnJvbSBpdFxuICAgICAgICBpZiAodmFsLm1hdGNoKC9jb21wbGVtZW50L2cpKSB7XG4gICAgICAgICAgc3RyYW5kID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyYW5kID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0ZlYXR1cmUoKTtcbiAgICAgICAgbGV0IGZlYXQgPSBnZXRDdXJyZW50RmVhdHVyZSgpO1xuICAgICAgICBmZWF0LnR5cGUgPSBrZXk7XG4gICAgICAgIGZlYXQuc3RyYW5kID0gc3RyYW5kO1xuXG4gICAgICAgIHBhcnNlRmVhdHVyZUxvY2F0aW9uKHZhbCk7XG4gICAgICAgIGxhc3RMaW5lV2FzTG9jYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld0ZlYXR1cmUoKSB7XG4gICAgcmVzdWx0LmZlYXR1cmVzLnB1c2goe1xuICAgICAgbm90ZXM6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb3RlKGxpbmUpIHtcbiAgICBsZXQgcXVhbCA9IGZhbHNlO1xuICAgIC8qIGlmIChsaW5lLmNoYXJBdCgyMSkgPT09IFwiL1wiKSB7Ly9ULkguIEhhcmQgY29kZWQgbWV0aG9kXG4gICAgICAgICAgIHF1YWwgPSB0cnVlO1xuICAgICAgICAgfSovXG4gICAgaWYgKGxpbmUudHJpbSgpLmNoYXJBdCgwKS5tYXRjaCgvXFwvLykpIHtcbiAgICAgIC8vIHNlYXJjaGVzIGJhc2VkIG9uIGxvb2tpbmcgZm9yIC8gaW4gYmVnaW5uaW5nIG9mIGxpbmVcbiAgICAgIHF1YWwgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaCgvXltcXHNdKlxcL1tcXHddKz1bXFxTXSsvKSkge1xuICAgICAgLy8gc2VhcmNoZXMgYmFzZWQgb24gXCIgICAva2V5PUJMQUhcIiByZWdleFxuICAgICAgcXVhbCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBxdWFsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGZWF0dXJlTG9jYXRpb24obG9jU3RyKSB7XG4gICAgbG9jU3RyID0gbG9jU3RyLnRyaW0oKTtcbiAgICBsZXQgbG9jQXJyID0gW107XG4gICAgbG9jU3RyLnJlcGxhY2UoLyhcXGQrKS9nLCBmdW5jdGlvbiAoc3RyaW5nLCBtYXRjaCkge1xuICAgICAgbG9jQXJyLnB1c2gobWF0Y2gpO1xuICAgIH0pO1xuICAgIGxldCBmZWF0ID0gZ2V0Q3VycmVudEZlYXR1cmUoKTtcbiAgICBmZWF0LnN0YXJ0ID0gK2xvY0FyclswXTtcbiAgICBmZWF0LmVuZCA9IGxvY0FyclsxXSA9PT0gdW5kZWZpbmVkID8gK2xvY0FyclswXSA6ICtsb2NBcnJbMV07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZlYXR1cmVOb3RlKGxpbmUpIHtcbiAgICBsZXQgbmV3TGluZSwgbGluZUFycjtcblxuICAgIG5ld0xpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICBuZXdMaW5lID0gbmV3TGluZS5yZXBsYWNlKC9eXFwvfFwiJC9nLCAnJyk7XG4gICAgbGluZUFyciA9IG5ld0xpbmUuc3BsaXQoLz1cInw9Lyk7XG5cbiAgICBsZXQgdmFsID0gbGluZUFyclsxXTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXFxcL2csICcgJyk7XG5cbiAgICAgIGlmIChsaW5lLm1hdGNoKC89XCIvZykpIHtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1wiLiovZywgJycpO1xuICAgICAgfSBlbHNlIGlmICh2YWwubWF0Y2goL15cXGQrJC9nKSkge1xuICAgICAgICB2YWwgPSArdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2V5ID0gbGluZUFyclswXTtcbiAgICBsZXQgY3VycmVudE5vdGVzID0gZ2V0Q3VycmVudEZlYXR1cmUoKS5ub3RlcztcbiAgICBpZiAoY3VycmVudE5vdGVzW2tleV0pIHtcbiAgICAgIC8vIGFycmF5IGFscmVhZHkgZXhpc3RzLCBzbyBwdXNoIHZhbHVlIGludG8gaXRcbiAgICAgIGN1cnJlbnROb3Rlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXJyYXkgZG9lc24ndCBleGlzdCB5ZXQsIHNvIGNyZWF0ZSBpdCBhbmQgcG9wdWxhdGUgaXQgd2l0aCB0aGUgdmFsdWVcbiAgICAgIGN1cnJlbnROb3Rlc1trZXldID0gW3ZhbF07XG4gICAgfVxuICAgIGN1cnJlbnRGZWF0dXJlTm90ZSA9IGN1cnJlbnROb3Rlc1trZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZUZpZWxkTmFtZShsaW5lKSB7XG4gICAgbGV0IGFycjtcbiAgICBsaW5lID0gbGluZS50cmltKCk7XG5cbiAgICBhcnIgPSBsaW5lLnNwbGl0KC9bXFxzXSsvKTtcblxuICAgIHJldHVybiBhcnJbMF07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU11bHRpTGluZUZpZWxkKGZOYW1lLCBsaW5lLCByZXN1bHRLZXksIHIpIHtcbiAgICByID0gciB8fCByZXN1bHQ7XG4gICAgbGV0IGZpZWxkVmFsdWUgPSByZW1vdmVGaWVsZE5hbWUoZk5hbWUsIGxpbmUpO1xuICAgIHJbcmVzdWx0S2V5XSA9IHJbcmVzdWx0S2V5XSA/IGAke3JbcmVzdWx0S2V5XX0gYCA6ICcnO1xuICAgIHJbcmVzdWx0S2V5XSArPSBmaWVsZFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZVZhbChsaW5lKSB7XG4gICAgbGV0IGFycjtcblxuICAgIGlmIChsaW5lLmluZGV4T2YoJz0nKSA8IDApIHtcbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL15bXFxzXSpbXFxTXStbXFxzXSt8W1xcc10rJC8sICcnKTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnIgPSBsaW5lLnNwbGl0KC89Lyk7XG4gICAgICByZXR1cm4gYXJyWzFdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzS2V5d29yZChsaW5lKSB7XG4gICAgbGV0IGlzS2V5ID0gZmFsc2U7XG4gICAgaWYgKGxpbmUuc3Vic3RyKDAsIDEwKS5tYXRjaCgvXltcXFNdKy8pKSB7XG4gICAgICBpc0tleSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc0tleTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ViS2V5d29yZChsaW5lKSB7XG4gICAgbGV0IGlzU3ViS2V5ID0gZmFsc2U7XG4gICAgaWYgKGxpbmUuc3Vic3RyKDAsIDEwKS5tYXRjaCgvXltcXHNdK1tcXFNdKy8pKSB7XG4gICAgICBpc1N1YktleSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1N1YktleTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RQcm9jZXNzR2VuYmFua0ZlYXR1cmUoZmVhdCkge1xuICAgIGlmIChmZWF0Lm5vdGVzLmxhYmVsKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLmxhYmVsWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5nZW5lKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLmdlbmVbMF07XG4gICAgfSBlbHNlIGlmIChmZWF0Lm5vdGVzLkFwRWluZm9fbGFiZWwpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMuQXBFaW5mb19sYWJlbFswXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMubmFtZSkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5uYW1lWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5vcmdhbmlzbSkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5vcmdhbmlzbVswXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMubG9jdXNfdGFnKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLmxvY3VzX3RhZ1swXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMubm90ZSkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5ub3RlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0Lm5hbWUgPSAnVW50aXRsZWQgRmVhdHVyZSc7XG4gICAgfVxuICAgIGZlYXQubmFtZSA9IHR5cGVvZiBmZWF0Lm5hbWUgPT09ICdzdHJpbmcnID8gZmVhdC5uYW1lIDogU3RyaW5nKGZlYXQubmFtZSk7XG4gICAgcmV0dXJuIGZlYXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGZWF0dXJlTGluZVJ1bm9uKGxpbmUsIGZlYXR1cmVMb2NhdGlvbkluZGVudGF0aW9uKSB7XG4gIGxldCBpbmRlbnRhdGlvbk9mTGluZSA9IGdldExlbmd0aE9mV2hpdGVTcGFjZUJlZm9yZVN0YXJ0T2ZMZXR0ZXJzKGxpbmUpO1xuICBpZiAoZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb24gPT09IGluZGVudGF0aW9uT2ZMaW5lKSB7XG4gICAgLy8gdGhlIGZlYXR1cmUgbG9jYXRpb24gaW5kZW50YXRpb24gY2FsY3VsYXRlZCByaWdodCBhZnRlciB0aGUgZmVhdHVyZSB0YWdcbiAgICAvLyBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBsaW5lXG4gICAgLy9cbiAgICAvLyBGRUFUVVJFUyAgICAgICAgICAgICBMb2NhdGlvbi9RdWFsaWZpZXJzXG4gICAgLy8gICAgIHJlcF9vcmlnaW4gICAgICBjb21wbGVtZW50KDEwNzQuLjMzMDIpXG4gICAgLy8gMDEyMzQgIDwtLSB0aGlzIGlzIHRoZSBpbmRlbnRhdGlvbiB3ZSdyZSB0YWxraW5nIGFib3V0XG4gICAgcmV0dXJuIGZhbHNlOyAvLyB0aGUgbGluZSBpcyBOT1QgYSBydW4gb25cbiAgfVxuXG4gIGxldCB0cmltbWVkID0gbGluZS50cmltKCk7XG4gIGlmICh0cmltbWVkLmNoYXJBdCgwKS5tYXRjaCgvXFwvLykpIHtcbiAgICAvLyB0aGUgZmlyc3QgY2hhciBpbiB0aGUgdHJpbW1lZCBsaW5lIGNhbm5vdCBiZSBhIC9cbiAgICByZXR1cm4gZmFsc2U7IC8vIHRoZSBsaW5lIGlzIE5PVCBhIHJ1biBvblxuICB9XG4gIC8vIHRoZSBsaW5lIGlzIGEgcnVuIG9uXG4gIHJldHVybiB0cnVlO1xuICAvLyBydW4tb24gbGluZSBleGFtcGxlOlxuICAvLyBGRUFUVVJFUyAgICAgICAgICAgICBMb2NhdGlvbi9RdWFsaWZpZXJzXG4gIC8vICAgICByZXBfb3JpZ2luICAgICAgY29tcGxlbWVudCgxMDc0Li4zMzAyKVxuICAvLyAgICAgICAgICAgICAgICAgL2xhYmVsPXBTQzEwMSoqXG4gIC8vICAgICAgICAgICAgICAgICAvbm90ZT1cIlJFUF9PUklHSU4gUkVQX09SSUdJTiBwU0MxMDEqIGFrYSBwTVBQNiwgZ2l2ZXMgcGxhc21cbiAgLy8gICAgICAgICAgICAgICAgIGlkIG51bWJlciAzIC00IGNvcGllcyBwZXIgY2VsbCwgQmdsSUkgc2l0ZSBpbiBwU0MxMDEqIG9yaSBoIDwtLXJ1bi1vbiBsaW5lIVxuICAvLyAgICAgICAgICAgICAgICAgYXMgYmVlbiBkZWxlIHRlZCBieSBxdWljayBjaGFuZ2UgYWdhdGNUIGNoYW5nZWQgdG8gYWdhdGNBIGcgPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICBpdmluZyBwU0MxMDEqICogcFNDMTAxKiBha2EgcE1QUDYsIGdpdmVzIHBsYXNtaWQgbnVtYmVyIDMtNCA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgIGNvcGllcyBwIGVyIGNlbGwsIEJnbElJIHNpdGUgaW4gcFNDMTAxKiBvcmkgaGFzIGJlZW4gZGVsZXQgIDwtLXJ1bi1vbiBsaW5lIVxuICAvLyAgICAgICAgICAgICAgICAgZWQgYnkgcXVpYyBrIGNoYW5nZSBhZ2F0Y1QgY2hhbmdlZCB0byBhZ2F0Y0EgZ2l2aW5nIHBTQzEwMSogPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICAqIFtwQmJTMGEtUkZQXVwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICAvZ2VuZT1cIlNDMTAxKiogT3JpXCJcbiAgLy8gICAgICAgICAgICAgICAgIC9ub3RlPVwicFNDMTAxKiBha2EgcE1QUDYsIGdpdmVzIHBsYXNtaWQgbnVtYmVyIDMtNCBjb3BpZXMgcFxuICAvLyAgICAgICAgICAgICAgICAgZXIgY2VsbCwgQmdsSUkgc2l0ZSBpbiBwU0MxMDEqIG9yaSBoYXMgYmVlbiBkZWxldGVkIGJ5IHF1aVxuICAvLyAgICAgICAgICAgICAgICAgYyBrIGNoYW5nZSBhZ2F0Y1QgY2hhbmdlZCB0byBhZ2F0Y0EgZ2l2aW5nIHBTQzEwMSoqXCJcbiAgLy8gICAgICAgICAgICAgICAgIC92bnRpZmtleT1cIjMzXCJcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoT2ZXaGl0ZVNwYWNlQmVmb3JlU3RhcnRPZkxldHRlcnMoc3RyaW5nKSB7XG4gIGxldCBtYXRjaCA9IC9eXFxzKi8uZXhlYyhzdHJpbmcpO1xuICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuYmFua1RvSnNvbjtcbiIsInZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgdXRpbC5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIC5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XG5jb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm5hblwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJ1bmRlZmluZWRcIixcbiAgICBcIm51bGxcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJtYXBcIixcbiAgICBcInNldFwiLFxuXSk7XG5jb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuXG5jb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5jb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcblxuY29uc3QgZXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5cbmxldCBvdmVycmlkZUVycm9yTWFwID0gZXJyb3JNYXA7XG5mdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG5cbmNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uKGlzc3VlRGF0YS5wYXRoIHx8IFtdKV07XG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIH07XG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5jb25zdCBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBlcnJvck1hcCA/IHVuZGVmaW5lZCA6IGVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5jb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5jb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5jb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5jb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxudmFyIF9ab2RFbnVtX2NhY2hlLCBfWm9kTmF0aXZlRW51bV9jYWNoZTtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IHJlcXVpcmVkX2Vycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2IgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBpbnZhbGlkX3R5cGVfZXJyb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5jbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hc3luYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgXCJ+dmFsaWRhdGVcIihkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6ICEhdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcbi8vIGNvbnN0IHV1aWRSZWdleCA9XG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaTtcbmNvbnN0IG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbmNvbnN0IGp3dFJlZ2V4ID0gL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLztcbmNvbnN0IGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuLy8gZmFzdGVyLCBzaW1wbGVyLCBzYWZlclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbmNvbnN0IGlwdjRDaWRyUmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLztcbi8vIGNvbnN0IGlwdjZSZWdleCA9XG4vLyAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKSQvO1xuY29uc3QgaXB2NkNpZHJSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC87XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcbmNvbnN0IGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuLy8gaHR0cHM6Ly9iYXNlNjQuZ3VydS9zdGFuZGFyZHMvYmFzZTY0dXJsXG5jb25zdCBiYXNlNjR1cmxSZWdleCA9IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLztcbi8vIHNpbXBsZVxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9YDtcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tKCgwWzEzNTc4XXwxMHwxMiktMzF8KDBbMTMtOV18MVswLTJdKS0zMHwoMFsxLTldfDFbMC0yXSktKDBbMS05XXwxXFxcXGR8MlxcXFxkKSlgO1xuLy8gd2l0aCBsZWFwIHllYXIgdmFsaWRhdGlvblxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGBeJHtkYXRlUmVnZXhTb3VyY2V9JGApO1xuZnVuY3Rpb24gdGltZVJlZ2V4U291cmNlKGFyZ3MpIHtcbiAgICAvLyBsZXQgcmVnZXggPSBgXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn1gO1xuICAgIGxldCByZWdleCA9IGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZDpbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH0oXFxcXC5cXFxcZCspP2A7XG4gICAgfVxuICAgIHJldHVybiByZWdleDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcbiAgICBjb25zdCBvcHRzID0gW107XG4gICAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgICBpZiAoYXJncy5vZmZzZXQpXG4gICAgICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gICAgcmVnZXggPSBgJHtyZWdleH0oJHtvcHRzLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSldUKGp3dCwgYWxnKSB7XG4gICAgaWYgKCFqd3RSZWdleC50ZXN0KGp3dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0dXJsIHRvIGJhc2U2NFxuICAgICAgICBjb25zdCBiYXNlNjQgPSBoZWFkZXJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL18vZywgXCIvXCIpXG4gICAgICAgICAgICAucGFkRW5kKGhlYWRlci5sZW5ndGggKyAoKDQgLSAoaGVhZGVyLmxlbmd0aCAlIDQpKSAlIDQpLCBcIj1cIik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVjb2RlZCAhPT0gXCJvYmplY3RcIiB8fCBkZWNvZGVkID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQudHlwIHx8ICFkZWNvZGVkLmFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFsZyAmJiBkZWNvZGVkLmFsZyAhPT0gYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibmFub2lkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkMlJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpbmNsdWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZHVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJqd3RcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiand0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDaWRyKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjR1cmxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgZW1vamkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIG5hbm9pZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkMlwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVsaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NHVybChtZXNzYWdlKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgand0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBpcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBjaWRyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgIGxvY2FsOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcbiAgICB9XG4gICAgdGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgICAqL1xuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvd2VyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1VwcGVyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzTkFOT0lEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ0lEUigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xufVxuY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgIChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbCwgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgICAgICBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdGaWVsZCBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICAgIH1cbn1cblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbn1cblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3R5cGUudmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbCkge1xuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEJyYW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5jbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGRpc2NyaW1pbmF0b3IpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zTWFwLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gICAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xuICAgIGNvbnN0IGJUeXBlID0gZ2V0UGFyc2VkVHlwZShiKTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gdXRpbFxuICAgICAgICAgICAgLm9iamVjdEtleXMoYSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXG4gICAgICAgIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5jbGFzcyBab2RJbnRlcnNlY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlVmFsdWVzKHBhcnNlZExlZnQudmFsdWUsIHBhcnNlZFJpZ2h0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXG4gICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RNYXAgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZSwgbWVzc2FnZSkubWF4KHNpemUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIG1pblNpemU6IG51bGwsXG4gICAgICAgIG1heFNpemU6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJnc1xuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgICB9XG4gICAgcmV0dXJuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICAgIH1cbiAgICBhcmdzKC4uLml0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGFyZ3MsIHJldHVybnMsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IChhcmdzXG4gICAgICAgICAgICAgICAgPyBhcmdzXG4gICAgICAgICAgICAgICAgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5jbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9ab2RFbnVtX2NhY2hlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4Y2x1ZGUodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5fWm9kRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5jbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9ab2ROYXRpdmVFbnVtX2NhY2hlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiZcbiAgICAgICAgICAgIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuX1pvZE5hdGl2ZUVudW1fY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmXG4gICAgICAgICAgICBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlXG4gICAgICAgICAgICA/IGN0eC5kYXRhXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIHNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc2VkKS50aGVuKGFzeW5jIChwcm9jZXNzZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW5uZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gICAgfVxufVxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICBlZmZlY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RPcHRpb25hbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGxhYmxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kTnVsbGFibGUuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHBhcmFtcy5kZWZhdWx0XG4gICAgICAgICAgICA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxuICAgICAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IG5ld0N0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNvbnN0IEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxufVxuY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQaXBlbGluZSh7XG4gICAgICAgICAgICBpbjogYSxcbiAgICAgICAgICAgIG91dDogYixcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IE9iamVjdC5mcmVlemUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KVxuICAgICAgICAgICAgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKVxuICAgICAgICAgICAgOiBmcmVlemUocmVzdWx0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RSZWFkb25seS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICB6LmN1c3RvbSAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGNsZWFuUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBwYXJhbXMoZGF0YSlcbiAgICAgICAgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHsgbWVzc2FnZTogcGFyYW1zIH1cbiAgICAgICAgICAgIDogcGFyYW1zO1xuICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgcmV0dXJuIHAyO1xufVxuZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBfcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gKF9iID0gKF9hID0gcGFyYW1zLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gKF9iID0gKF9hID0gcGFyYW1zLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG5jb25zdCBsYXRlID0ge1xuICAgIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcbi8vIGNvbnN0IGluc3RhbmNlT2ZUeXBlID0gPFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuY2xzLCBwYXJhbXMgPSB7XG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IGNvZXJjZSA9IHtcbiAgICBzdHJpbmc6ICgoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAgICAgLi4uYXJnLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgfSkpLFxuICAgIGJpZ2ludDogKChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxufTtcbmNvbnN0IE5FVkVSID0gSU5WQUxJRDtcblxudmFyIHogPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHRFcnJvck1hcDogZXJyb3JNYXAsXG4gICAgc2V0RXJyb3JNYXA6IHNldEVycm9yTWFwLFxuICAgIGdldEVycm9yTWFwOiBnZXRFcnJvck1hcCxcbiAgICBtYWtlSXNzdWU6IG1ha2VJc3N1ZSxcbiAgICBFTVBUWV9QQVRIOiBFTVBUWV9QQVRILFxuICAgIGFkZElzc3VlVG9Db250ZXh0OiBhZGRJc3N1ZVRvQ29udGV4dCxcbiAgICBQYXJzZVN0YXR1czogUGFyc2VTdGF0dXMsXG4gICAgSU5WQUxJRDogSU5WQUxJRCxcbiAgICBESVJUWTogRElSVFksXG4gICAgT0s6IE9LLFxuICAgIGlzQWJvcnRlZDogaXNBYm9ydGVkLFxuICAgIGlzRGlydHk6IGlzRGlydHksXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBpc0FzeW5jOiBpc0FzeW5jLFxuICAgIGdldCB1dGlsICgpIHsgcmV0dXJuIHV0aWw7IH0sXG4gICAgZ2V0IG9iamVjdFV0aWwgKCkgeyByZXR1cm4gb2JqZWN0VXRpbDsgfSxcbiAgICBab2RQYXJzZWRUeXBlOiBab2RQYXJzZWRUeXBlLFxuICAgIGdldFBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUsXG4gICAgWm9kVHlwZTogWm9kVHlwZSxcbiAgICBkYXRldGltZVJlZ2V4OiBkYXRldGltZVJlZ2V4LFxuICAgIFpvZFN0cmluZzogWm9kU3RyaW5nLFxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxuICAgIFpvZEJpZ0ludDogWm9kQmlnSW50LFxuICAgIFpvZEJvb2xlYW46IFpvZEJvb2xlYW4sXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcbiAgICBab2RTeW1ib2w6IFpvZFN5bWJvbCxcbiAgICBab2RVbmRlZmluZWQ6IFpvZFVuZGVmaW5lZCxcbiAgICBab2ROdWxsOiBab2ROdWxsLFxuICAgIFpvZEFueTogWm9kQW55LFxuICAgIFpvZFVua25vd246IFpvZFVua25vd24sXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxuICAgIFpvZFZvaWQ6IFpvZFZvaWQsXG4gICAgWm9kQXJyYXk6IFpvZEFycmF5LFxuICAgIFpvZE9iamVjdDogWm9kT2JqZWN0LFxuICAgIFpvZFVuaW9uOiBab2RVbmlvbixcbiAgICBab2REaXNjcmltaW5hdGVkVW5pb246IFpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICBab2RJbnRlcnNlY3Rpb246IFpvZEludGVyc2VjdGlvbixcbiAgICBab2RUdXBsZTogWm9kVHVwbGUsXG4gICAgWm9kUmVjb3JkOiBab2RSZWNvcmQsXG4gICAgWm9kTWFwOiBab2RNYXAsXG4gICAgWm9kU2V0OiBab2RTZXQsXG4gICAgWm9kRnVuY3Rpb246IFpvZEZ1bmN0aW9uLFxuICAgIFpvZExhenk6IFpvZExhenksXG4gICAgWm9kTGl0ZXJhbDogWm9kTGl0ZXJhbCxcbiAgICBab2RFbnVtOiBab2RFbnVtLFxuICAgIFpvZE5hdGl2ZUVudW06IFpvZE5hdGl2ZUVudW0sXG4gICAgWm9kUHJvbWlzZTogWm9kUHJvbWlzZSxcbiAgICBab2RFZmZlY3RzOiBab2RFZmZlY3RzLFxuICAgIFpvZFRyYW5zZm9ybWVyOiBab2RFZmZlY3RzLFxuICAgIFpvZE9wdGlvbmFsOiBab2RPcHRpb25hbCxcbiAgICBab2ROdWxsYWJsZTogWm9kTnVsbGFibGUsXG4gICAgWm9kRGVmYXVsdDogWm9kRGVmYXVsdCxcbiAgICBab2RDYXRjaDogWm9kQ2F0Y2gsXG4gICAgWm9kTmFOOiBab2ROYU4sXG4gICAgQlJBTkQ6IEJSQU5ELFxuICAgIFpvZEJyYW5kZWQ6IFpvZEJyYW5kZWQsXG4gICAgWm9kUGlwZWxpbmU6IFpvZFBpcGVsaW5lLFxuICAgIFpvZFJlYWRvbmx5OiBab2RSZWFkb25seSxcbiAgICBjdXN0b206IGN1c3RvbSxcbiAgICBTY2hlbWE6IFpvZFR5cGUsXG4gICAgWm9kU2NoZW1hOiBab2RUeXBlLFxuICAgIGxhdGU6IGxhdGUsXG4gICAgZ2V0IFpvZEZpcnN0UGFydHlUeXBlS2luZCAoKSB7IHJldHVybiBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7IH0sXG4gICAgY29lcmNlOiBjb2VyY2UsXG4gICAgYW55OiBhbnlUeXBlLFxuICAgIGFycmF5OiBhcnJheVR5cGUsXG4gICAgYmlnaW50OiBiaWdJbnRUeXBlLFxuICAgIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxuICAgIGRhdGU6IGRhdGVUeXBlLFxuICAgIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcbiAgICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxuICAgICdlbnVtJzogZW51bVR5cGUsXG4gICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb25UeXBlLFxuICAgICdpbnN0YW5jZW9mJzogaW5zdGFuY2VPZlR5cGUsXG4gICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb25UeXBlLFxuICAgIGxhenk6IGxhenlUeXBlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxuICAgIG1hcDogbWFwVHlwZSxcbiAgICBuYW46IG5hblR5cGUsXG4gICAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXG4gICAgbmV2ZXI6IG5ldmVyVHlwZSxcbiAgICAnbnVsbCc6IG51bGxUeXBlLFxuICAgIG51bGxhYmxlOiBudWxsYWJsZVR5cGUsXG4gICAgbnVtYmVyOiBudW1iZXJUeXBlLFxuICAgIG9iamVjdDogb2JqZWN0VHlwZSxcbiAgICBvYm9vbGVhbjogb2Jvb2xlYW4sXG4gICAgb251bWJlcjogb251bWJlcixcbiAgICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxuICAgIG9zdHJpbmc6IG9zdHJpbmcsXG4gICAgcGlwZWxpbmU6IHBpcGVsaW5lVHlwZSxcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgICBwcm9taXNlOiBwcm9taXNlVHlwZSxcbiAgICByZWNvcmQ6IHJlY29yZFR5cGUsXG4gICAgc2V0OiBzZXRUeXBlLFxuICAgIHN0cmljdE9iamVjdDogc3RyaWN0T2JqZWN0VHlwZSxcbiAgICBzdHJpbmc6IHN0cmluZ1R5cGUsXG4gICAgc3ltYm9sOiBzeW1ib2xUeXBlLFxuICAgIHRyYW5zZm9ybWVyOiBlZmZlY3RzVHlwZSxcbiAgICB0dXBsZTogdHVwbGVUeXBlLFxuICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWRUeXBlLFxuICAgIHVuaW9uOiB1bmlvblR5cGUsXG4gICAgdW5rbm93bjogdW5rbm93blR5cGUsXG4gICAgJ3ZvaWQnOiB2b2lkVHlwZSxcbiAgICBORVZFUjogTkVWRVIsXG4gICAgWm9kSXNzdWVDb2RlOiBab2RJc3N1ZUNvZGUsXG4gICAgcXVvdGVsZXNzSnNvbjogcXVvdGVsZXNzSnNvbixcbiAgICBab2RFcnJvcjogWm9kRXJyb3Jcbn0pO1xuXG5leHBvcnQgeyBCUkFORCwgRElSVFksIEVNUFRZX1BBVEgsIElOVkFMSUQsIE5FVkVSLCBPSywgUGFyc2VTdGF0dXMsIFpvZFR5cGUgYXMgU2NoZW1hLCBab2RBbnksIFpvZEFycmF5LCBab2RCaWdJbnQsIFpvZEJvb2xlYW4sIFpvZEJyYW5kZWQsIFpvZENhdGNoLCBab2REYXRlLCBab2REZWZhdWx0LCBab2REaXNjcmltaW5hdGVkVW5pb24sIFpvZEVmZmVjdHMsIFpvZEVudW0sIFpvZEVycm9yLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQsIFpvZEZ1bmN0aW9uLCBab2RJbnRlcnNlY3Rpb24sIFpvZElzc3VlQ29kZSwgWm9kTGF6eSwgWm9kTGl0ZXJhbCwgWm9kTWFwLCBab2ROYU4sIFpvZE5hdGl2ZUVudW0sIFpvZE5ldmVyLCBab2ROdWxsLCBab2ROdWxsYWJsZSwgWm9kTnVtYmVyLCBab2RPYmplY3QsIFpvZE9wdGlvbmFsLCBab2RQYXJzZWRUeXBlLCBab2RQaXBlbGluZSwgWm9kUHJvbWlzZSwgWm9kUmVhZG9ubHksIFpvZFJlY29yZCwgWm9kVHlwZSBhcyBab2RTY2hlbWEsIFpvZFNldCwgWm9kU3RyaW5nLCBab2RTeW1ib2wsIFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIsIFpvZFR1cGxlLCBab2RUeXBlLCBab2RVbmRlZmluZWQsIFpvZFVuaW9uLCBab2RVbmtub3duLCBab2RWb2lkLCBhZGRJc3N1ZVRvQ29udGV4dCwgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGNvZXJjZSwgY3VzdG9tLCBkYXRlVHlwZSBhcyBkYXRlLCBkYXRldGltZVJlZ2V4LCB6IGFzIGRlZmF1bHQsIGVycm9yTWFwIGFzIGRlZmF1bHRFcnJvck1hcCwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBnZXRFcnJvck1hcCwgZ2V0UGFyc2VkVHlwZSwgaW5zdGFuY2VPZlR5cGUgYXMgaW5zdGFuY2VvZiwgaW50ZXJzZWN0aW9uVHlwZSBhcyBpbnRlcnNlY3Rpb24sIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbGF0ZSwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFrZUlzc3VlLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9iamVjdFV0aWwsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIHBpcGVsaW5lVHlwZSBhcyBwaXBlbGluZSwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcXVvdGVsZXNzSnNvbiwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzZXRFcnJvck1hcCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdXRpbCwgdm9pZFR5cGUgYXMgdm9pZCwgeiB9O1xuIiwiaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcblxuZXhwb3J0IGNvbnN0IGNvb3JTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHg6IHoubnVtYmVyKCksXG4gIHk6IHoubnVtYmVyKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IGFuZ2xlU2NoZW1hID0gei5vYmplY3Qoe1xuICBkZWdyZWVzOiB6Lm51bWJlcigpLFxuICBjZW50ZXI6IGNvb3JTY2hlbWEsXG59KTtcblxuZXhwb3J0IGNvbnN0IGFubm90YXRpb25UeXBlU2NoZW1hID0gei51bmlvbihbXG4gIHoubGl0ZXJhbChcIkNEU1wiKSxcbiAgei5saXRlcmFsKFwiZW5oYW5jZXJcIiksXG4gIHoubGl0ZXJhbChcImludHJvblwiKSxcbiAgei5saXRlcmFsKFwibWlzY19mZWF0dXJlXCIpLFxuICB6LmxpdGVyYWwoXCJwb2x5QV9zaWduYWxcIiksXG4gIHoubGl0ZXJhbChcInByb21vdGVyXCIpLFxuICB6LmxpdGVyYWwoXCJwcm90ZWluX2JpbmRcIiksXG4gIHoubGl0ZXJhbChcInJlcF9vcmlnaW5cIiksXG4gIHoubGl0ZXJhbChcIkxUUlwiKSxcbiAgei5zdHJpbmcoKSxcbl0pO1xuXG5leHBvcnQgY29uc3QgYW5ub3RhdGlvblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgdHlwZTogYW5ub3RhdGlvblR5cGVTY2hlbWEsXG4gIGRpcmVjdGlvbjogei51bmlvbihbei5saXRlcmFsKFwiZm9yd2FyZFwiKSwgei5saXRlcmFsKFwicmV2ZXJzZVwiKV0pLFxuICBzdGFydDogei5udW1iZXIoKSxcbiAgZW5kOiB6Lm51bWJlcigpLFxuICBjbGFzc05hbWU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdGV4dDogei5zdHJpbmcoKSxcbiAgb25DbGljazogei5mdW5jdGlvbigpLmFyZ3Moei5hbnkoKSkub3B0aW9uYWwoKSwgLy8gY2lyY3VsYXIgcmVmZXJlbmNlXG59KTtcblxuZXhwb3J0IGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9uU2NoZW1hID0gYW5ub3RhdGlvblNjaGVtYS5leHRlbmQoe1xuICBzdGFjazogei5udW1iZXIoKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgbnVjbFNjaGVtYSA9IHoudW5pb24oW1xuICB6LmxpdGVyYWwoXCJBXCIpLFxuICB6LmxpdGVyYWwoXCJDXCIpLFxuICB6LmxpdGVyYWwoXCJHXCIpLFxuICB6LmxpdGVyYWwoXCJUXCIpLFxuXSk7XG5cbmV4cG9ydCBjb25zdCBhYVNjaGVtYSA9IHoudW5pb24oW1xuICAvLyBBZGQgYWxsIHlvdXIgYW1pbm8gYWNpZHMgbGl0ZXJhbHMgaGVyZVxuICB6LmxpdGVyYWwoXCJBXCIpLFxuICB6LmxpdGVyYWwoXCJDXCIpLFxuICB6LmxpdGVyYWwoXCJEXCIpLFxuICB6LmxpdGVyYWwoXCJFXCIpLFxuICB6LmxpdGVyYWwoXCJGXCIpLFxuICB6LmxpdGVyYWwoXCJHXCIpLFxuICB6LmxpdGVyYWwoXCJIXCIpLFxuICB6LmxpdGVyYWwoXCJJXCIpLFxuICB6LmxpdGVyYWwoXCJLXCIpLFxuICB6LmxpdGVyYWwoXCJMXCIpLFxuICB6LmxpdGVyYWwoXCJNXCIpLFxuICB6LmxpdGVyYWwoXCJOXCIpLFxuICB6LmxpdGVyYWwoXCJQXCIpLFxuICB6LmxpdGVyYWwoXCJRXCIpLFxuICB6LmxpdGVyYWwoXCJSXCIpLFxuICB6LmxpdGVyYWwoXCJTXCIpLFxuICB6LmxpdGVyYWwoXCJUXCIpLFxuICB6LmxpdGVyYWwoXCJWXCIpLFxuICB6LmxpdGVyYWwoXCJXXCIpLFxuICB6LmxpdGVyYWwoXCJZXCIpLFxuXSk7XG5leHBvcnQgY29uc3QgR2FwU2NoZW1hID0gei5saXRlcmFsKFwiLVwiKTtcbmV4cG9ydCBjb25zdCBTdG9wU2NoZW1hID0gei5saXRlcmFsKFwiKlwiKTtcbmV4cG9ydCBjb25zdCBTcGFjZVNjaGVtYSA9IHoubGl0ZXJhbChcIiBcIik7XG5leHBvcnQgY29uc3QgVW5rbm93blNjaGVtYSA9IHoubGl0ZXJhbChcIj9cIik7XG5leHBvcnQgY29uc3QgYW5ub3RhdGVkQmFzZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgYmFzZTogei5zdHJpbmcoKS5sZW5ndGgoMSksXG4gIGFubm90YXRpb25zOiB6LmFycmF5KHN0YWNrZWRBbm5vdGF0aW9uU2NoZW1hKSxcbiAgaW5kZXg6IHoubnVtYmVyKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hID0gei5hcnJheShhbm5vdGF0ZWRCYXNlU2NoZW1hKTtcblxuZXhwb3J0IGNvbnN0IGFyaWFkbmVTZWxlY3Rpb25TY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHN0YXJ0OiB6Lm51bWJlcigpLFxuICBlbmQ6IHoubnVtYmVyKCksXG4gIGRpcmVjdGlvbjogei51bmlvbihbei5saXRlcmFsKFwiZm9yd2FyZFwiKSwgei5saXRlcmFsKFwicmV2ZXJzZVwiKV0pLFxufSk7XG4iLCJpbXBvcnQgZ2VuYmFua1BhcnNlciwgeyBQYXJzZWRHZW5iYW5rIH0gZnJvbSBcImdlbmJhbmstcGFyc2VyXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgYW5ub3RhdGVkU2VxdWVuY2VTY2hlbWEsIGFubm90YXRpb25UeXBlU2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hc1wiO1xuaW1wb3J0IHsgQW5ub3RhdGlvbiwgQW5ub3RhdGlvblR5cGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMsIHN0YWNrQW5uc0J5VHlwZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBHZW5iYW5rRmVhdHVyZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgbmFtZTogei5zdHJpbmcoKS5taW4oMSksXG4gIHN0YXJ0OiB6Lm51bWJlcigpLFxuICBlbmQ6IHoubnVtYmVyKCksXG4gIHN0cmFuZDogei51bmlvbihbei5saXRlcmFsKDEpLCB6LmxpdGVyYWwoLTEpXSksXG4gIHR5cGU6IGFubm90YXRpb25UeXBlU2NoZW1hLFxuICBub3Rlczogei5yZWNvcmQoei5hcnJheSh6LnN0cmluZygpKSkub3B0aW9uYWwoKSxcbn0pO1xuZXhwb3J0IHR5cGUgR2VuYmFua0ZlYXR1cmUgPSB6LmluZmVyPHR5cGVvZiBHZW5iYW5rRmVhdHVyZVNjaGVtYT47XG5cbmV4cG9ydCBjb25zdCBnZW5iYW5rVG9Bbm5vdGF0ZWRTZXF1ZW5jZSA9ICh7XG4gIGdlbmJhbmssXG4gIGFubm90YXRpb25PbkNsaWNrLFxufToge1xuICBnZW5iYW5rOiBQYXJzZWRHZW5iYW5rO1xuICBhbm5vdGF0aW9uT25DbGljaz86IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uKSA9PiB2b2lkO1xufSkgPT4ge1xuICBjb25zdCBmZWF0dXJlcyA9IGdlbmJhbmsuZmVhdHVyZXMubWFwKChmZWF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIEdlbmJhbmtGZWF0dXJlU2NoZW1hLnBhcnNlKGZlYXR1cmUpO1xuICB9KTtcbiAgY29uc3QgYW5ub3RhdGlvbnMgPSBnZW5iYW5rRmVhdHVyZXNUb0Fubm90YXRpb25zKHtcbiAgICBmZWF0dXJlcyxcbiAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgfSk7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrQW5uc0J5VHlwZShhbm5vdGF0aW9ucyk7XG4gIGNvbnN0IHsgc3VjY2Vzc2VzLCBmYWlsdXJlcyB9ID0gc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMoe1xuICAgIHBheWxvYWQ6IGdlbmJhbmsuc2VxdWVuY2UsXG4gICAgcGF5bG9hZFR5cGU6IFwicmF3XCIsXG4gICAgYW5ub3RhdGlvbnM6IHN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgfSk7XG4gIGlmIChmYWlsdXJlcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgZ2VuYmFuazogJHtmYWlsdXJlc1swXX1gKTtcbiAgfVxuICBpZiAoc3VjY2Vzc2VzLmxlbmd0aCAhPT0gMSB8fCBzdWNjZXNzZXNbMF0uc2VxdWVuY2VzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXhhY3RseSBvbmUgYW5ub3RhdGVkIHNlcXVlbmNlYCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFubm90YXRlZFNlcXVlbmNlOiBhbm5vdGF0ZWRTZXF1ZW5jZVNjaGVtYS5wYXJzZShzdWNjZXNzZXNbMF0uc2VxdWVuY2VzWzBdKSxcbiAgICBhbm5vdGF0aW9ucyxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5iYW5rRmVhdHVyZXNUb0Fubm90YXRpb25zID0gKHtcbiAgZmVhdHVyZXMsXG4gIGFubm90YXRpb25PbkNsaWNrLFxufToge1xuICBmZWF0dXJlczogR2VuYmFua0ZlYXR1cmVbXTtcbiAgYW5ub3RhdGlvbk9uQ2xpY2s/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4gdm9pZDtcbn0pOiBBbm5vdGF0aW9uW10gPT4ge1xuICByZXR1cm4gZmVhdHVyZXMubWFwKChmZWF0dXJlKSA9PiB7XG4gICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gW2ZlYXR1cmUuc3RhcnQsIGZlYXR1cmUuZW5kXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZmVhdHVyZS50eXBlLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBsYWJlbDogZmVhdHVyZS50eXBlLFxuICAgICAgdGV4dDogZmVhdHVyZS5uYW1lLFxuICAgICAgZGlyZWN0aW9uOiBmZWF0dXJlLnN0cmFuZCA9PT0gMSA/IFwiZm9yd2FyZFwiIDogXCJyZXZlcnNlXCIsXG4gICAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZUZyb21GZWF0dXJlVHlwZShmZWF0dXJlLnR5cGUpLFxuICAgICAgb25DbGljazogYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgfTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lRnJvbUZlYXR1cmVUeXBlKGFublR5cGU6IEFubm90YXRpb25UeXBlKTogc3RyaW5nIHtcbiAgY29uc3QgY29tbW9uID1cbiAgICBcImN1cnNvci1wb2ludGVyIG9wYWNpdHktNjAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgIXRleHQteHMgaG92ZXI6b3BhY2l0eS0xMDAgcG9pbnRlci1ldmVudHMtYWxsIHRleHQtd2hpdGUgdGV4dC1jbGlwIG92ZXJmbG93LWhpZGRlbiB3aGl0ZXNwYWNlLW5vd3JhcFwiO1xuICBjb25zdCBjbGFzc05hbWVNYXA6IHsgW2tleTogQW5ub3RhdGlvblR5cGVdOiBzdHJpbmcgfSA9IHppcEFycmF5cyhcbiAgICBbXG4gICAgICBcIkNEU1wiLFxuICAgICAgXCJlbmhhbmNlclwiLFxuICAgICAgXCJpbnRyb25cIixcbiAgICAgIFwibWlzY19mZWF0dXJlXCIsXG4gICAgICBcInBvbHlBX3NpZ25hbFwiLFxuICAgICAgXCJwcm9tb3RlclwiLFxuICAgICAgXCJwcm90ZWluX2JpbmRcIixcbiAgICAgIFwicmVwX29yaWdpblwiLFxuICAgICAgXCJMVFJcIixcbiAgICAgIFwic291cmNlXCIsXG4gICAgICBcImluc2VydGlvblwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgXCJiZy1yZWQtNjAwIGZpbGwtcmVkLTYwMCBzdHJva2UtcmVkLTYwMFwiLFxuICAgICAgXCJiZy1ibHVlLTYwMCBmaWxsLWJsdWUtNjAwIHN0cm9rZS1ibHVlLTYwMFwiLFxuICAgICAgXCJiZy1ncmVlbi02MDAgZmlsbC1ncmVlbi02MDAgc3Ryb2tlLWdyZWVuLTYwMFwiLFxuICAgICAgXCJiZy15ZWxsb3ctNjAwIGZpbGwteWVsbG93LTYwMCBzdHJva2UteWVsbG93LTYwMFwiLFxuICAgICAgXCJiZy1vcmFuZ2UtNjAwIGZpbGwtb3JhbmdlLTYwMCBzdHJva2Utb3JhbmdlLTYwMFwiLFxuICAgICAgXCJiZy1wdXJwbGUtNjAwIGZpbGwtcHVycGxlLTYwMCBzdHJva2UtcHVycGxlLTYwMFwiLFxuICAgICAgXCJiZy1za3ktNjAwIGZpbGwtc2t5LTYwMCBzdHJva2Utc2t5LTYwMFwiLFxuICAgICAgXCJiZy10ZWFsLTYwMCBmaWxsLXRlYWwtNjAwIHN0cm9rZS10ZWFsLTYwMFwiLFxuICAgICAgXCJiZy1ncmF5LTYwMCBmaWxsLWdyYXktNjAwIHN0cm9rZS1ncmF5LTYwMFwiLFxuICAgICAgXCJiZy1waW5rLTYwMCBmaWxsLXBpbmstNjAwIHN0cm9rZS1waW5rLTYwMFwiLFxuICAgIF0sXG4gICk7XG4gIGlmIChhbm5UeXBlIGluIGNsYXNzTmFtZU1hcCkge1xuICAgIHJldHVybiBgJHtjb21tb259ICR7Y2xhc3NOYW1lTWFwW2FublR5cGVdIX1gO1xuICB9XG4gIHJldHVybiBjb21tb247XG59XG5cbmV4cG9ydCBjb25zdCB6aXBBcnJheXMgPSA8VDEsIFQyPihrZXlzOiBUMVtdLCB2YWx1ZXM6IFQyW10pID0+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBrZXlzLm1hcCgoa2V5OiBUMSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCB2YWw6IFQyIHwgdW5kZWZpbmVkID0gdmFsdWVzW2ldO1xuICAgICAgcmV0dXJuIFtrZXksIHZhbF07XG4gICAgfSksXG4gICkgYXMgeyBUMTogVDIgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdlbmJhbmsgPSAoZ2VuYmFua1N0cmluZzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGdlbmJhbmtQYXJzZXIoZ2VuYmFua1N0cmluZyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiaW1wb3J0IGdlbmJhbmtQYXJzZXIsIHsgUGFyc2VkR2VuYmFuayB9IGZyb20gXCJnZW5iYW5rLXBhcnNlclwiO1xuaW1wb3J0IHsgZ2VuYmFua1RvQW5ub3RhdGVkU2VxdWVuY2UgfSBmcm9tIFwiLi9nZW5iYW5rVXRpbHNcIjtcbmltcG9ydCB7IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hc1wiO1xuaW1wb3J0IHR5cGUge1xuICBBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgQW5ub3RhdGlvbixcbiAgQW5ub3RhdGlvblR5cGUsXG4gIEFyaWFkbmVTZWxlY3Rpb24sXG4gIFN0YWNrZWRBbm5vdGF0aW9uLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0Q29tcGxlbWVudCA9IChzZXF1ZW5jZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNvbXBsZW1lbnQ6IHtcbiAgICBba2V5OiBzdHJpbmddOiBcIkFcIiB8IFwiVFwiIHwgXCJDXCIgfCBcIkdcIiB8IFwiTlwiO1xuICB9ID0ge1xuICAgIEE6IFwiVFwiLFxuICAgIFQ6IFwiQVwiLFxuICAgIEM6IFwiR1wiLFxuICAgIEc6IFwiQ1wiLFxuICAgIE46IFwiTlwiLFxuICB9O1xuICByZXR1cm4gc2VxdWVuY2VcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKChiYXNlKSA9PiB7XG4gICAgICBpZiAoYmFzZSBpbiBjb21wbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBjb21wbGVtZW50W2Jhc2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmpvaW4oXCJcIik7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QW5ub3RhdGVkU2VxdWVuY2UgPSAoe1xuICBzZXF1ZW5jZSxcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBub1ZhbGlkYXRlLFxufToge1xuICBzZXF1ZW5jZTogc3RyaW5nO1xuICBzdGFja2VkQW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgbm9WYWxpZGF0ZT86IGJvb2xlYW47XG59KTogQW5ub3RhdGVkU2VxdWVuY2UgPT4ge1xuICAvKiBsb29wIHRocm91Z2ggc2VxdWVuY2UgZmluZGluZyBhbGwgYW5ub2F0YXRpb25zIHRoYXQgYXBwbHkgdG8gZWFjaCBiYXNlICovXG4gIGNvbnN0IG1hcEZuID0gKGJhc2U6IHN0cmluZywgaWR4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBhbm5vdGF0aW9uc0ZvckJhc2UgPSBzdGFja2VkQW5ub3RhdGlvbnMuZmlsdGVyKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAvLyBpZiB0aGUgYW5ub3RhdGlvbiBzcGFucyB0aGUgc2VhbSBvZiB0aGUgcGxhc21pZFxuICAgICAgaWYgKGFubm90YXRpb24uc3RhcnQgPiBhbm5vdGF0aW9uLmVuZCkge1xuICAgICAgICBjb25zdCBpc0JldHdlZW5Bbm5vdGF0aW9uU3RhcnRBbmRFbmRvZlNlcXVlbmNlID1cbiAgICAgICAgICBpZHggPj0gYW5ub3RhdGlvbi5zdGFydCAmJiBpZHggPD0gc2VxdWVuY2UubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc0JldHdlZW5TdGFydE9mU2VxdWVuY2VBbmRBbm5vdGF0aW9uRW5kID1cbiAgICAgICAgICBpZHggPj0gMCAmJiBpZHggPD0gYW5ub3RhdGlvbi5lbmQ7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaXNCZXR3ZWVuQW5ub3RhdGlvblN0YXJ0QW5kRW5kb2ZTZXF1ZW5jZSB8fFxuICAgICAgICAgIGlzQmV0d2VlblN0YXJ0T2ZTZXF1ZW5jZUFuZEFubm90YXRpb25FbmRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlZ3VsYXIgY2FzZVxuICAgICAgICByZXR1cm4gaWR4ID49IGFubm90YXRpb24uc3RhcnQgJiYgaWR4IDw9IGFubm90YXRpb24uZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlLFxuICAgICAgaW5kZXg6IGlkeCxcbiAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9uc0ZvckJhc2UsXG4gICAgICBjb21wbGVtZW50OiBnZXRDb21wbGVtZW50KGJhc2UpLFxuICAgIH07XG4gIH07XG4gIGNvbnN0IHJhdyA9IHNlcXVlbmNlXG4gICAgLnNwbGl0KFwiXCIpXG4gICAgLm1hcChtYXBGbilcbiAgICAuZmlsdGVyKCh4KSA9PiB4LmJhc2UgIT09IFwiIFwiKTsgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2UgPSBhbm5vdGF0ZWRTZXF1ZW5jZVNjaGVtYS5zYWZlUGFyc2UocmF3KTtcbiAgaWYgKG5vVmFsaWRhdGUpIHtcbiAgICBpZiAoYW5ub3RhdGVkU2VxdWVuY2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUud2Fybihhbm5vdGF0ZWRTZXF1ZW5jZS5lcnJvcik7XG4gICAgfVxuICAgIHJldHVybiByYXcgYXMgdW5rbm93biBhcyBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgfVxuICBpZiAoYW5ub3RhdGVkU2VxdWVuY2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYW5ub3RhdGVkU2VxdWVuY2UuZXJyb3IubWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIGFubm90YXRlZFNlcXVlbmNlLmRhdGE7XG59O1xuXG5pbnRlcmZhY2UgU3RhY2thYmxlIHtcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG59XG4vLyBtb2RpZmllZCBmcm9tIHNlcXZpelxuZXhwb3J0IGNvbnN0IHN0YWNrRWxlbWVudHMgPSA8VCBleHRlbmRzIFN0YWNrYWJsZT4oZWxlbWVudHM6IFRbXSkgPT4ge1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIHV0aWxpdHkgZnVuY3MgZm9yIHN0YWNrRWxlbWVudHNcbiAgY29uc3QgbGFzdCA9IChhcnI6IFRbXSk6IFQgPT4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgY29uc3QgZmlyc3QgPSAoYXJyOiBUW10pOiBUID0+IGFyclswXTtcbiAgY29uc3QgbWF4SW5kZXggPSBlbGVtZW50cy5tYXAoKGUpID0+IGUuZW5kKS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKTtcblxuICBjb25zdCBzdGFjazogVFtdW10gPSBbXTtcbiAgZWxlbWVudHMuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGNvbnN0IGluc2VydEluZGV4ID0gc3RhY2suZmluZEluZGV4KChlbGVtcykgPT4ge1xuICAgICAgaWYgKGEuZW5kID09PSBhLnN0YXJ0KSB7XG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIGluZGV4IGFuZCB0aGVyZWZvcmUgc3BhbnMgdGhlIHdob2xlIGFuZCBnZXRzIGl0cyBvd24gcm93XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0KGVsZW1zKS5lbmQgPD0gbGFzdChlbGVtcykuc3RhcnQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGlzIHJvdyBjcm9zc2VzIHplcm8gaW5kZXggaXQgZ2V0cyBpdHMgb3duIHJvd1xuICAgICAgICByZXR1cm4gbGFzdChlbGVtcykuZW5kICsgbWF4SW5kZXggPD0gYS5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChhLmVuZCA+IGEuc3RhcnQpIHtcbiAgICAgICAgLy8gdGhpcyBlbGVtZW50IGRvZXNuJ3QgY3Jvc3MgdGhlIHplcm8gaW5kZXggYW5kIHRoZSBsYXN0IGluIHJvdyBkb2Vzbid0XG4gICAgICAgIHJldHVybiBsYXN0KGVsZW1zKS5lbmQgPD0gYS5zdGFydDtcbiAgICAgIH1cbiAgICAgIC8vIGJvdGggdGhpcyBjdXJyIGVsZW1lbnQgYW5kIHRoZSBsYXN0IGluIHRoZSByb3cgY3Jvc3MgdGhlIHplcm8gaW5kZXhcbiAgICAgIHJldHVybiBsYXN0KGVsZW1zKS5lbmQgPCBhLnN0YXJ0ICYmIGEuZW5kIDwgZmlyc3QoZWxlbXMpLnN0YXJ0O1xuICAgIH0pO1xuXG4gICAgaWYgKGluc2VydEluZGV4ID4gLTEpIHtcbiAgICAgIC8vIGluc2VydCBpbiB0aGUgcm93IHdoZXJlIGl0J3MgdGhlIG5ldyBoaWdoZXN0XG4gICAgICBzdGFja1tpbnNlcnRJbmRleF0ucHVzaChhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IHJvdyBmb3IgdGhpcyBlbnRyeVxuICAgICAgc3RhY2sucHVzaChbYV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdGFjay5tYXAoKHJvdykgPT4gcm93LnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KSk7XG59O1xuXG4vLyByZXR1cm5zIGFubm90YXRpb25zIHdpdGggdGhlaXIgc3RhY2sgaW5kZXggYW5kIG1heCBzdGFjayBpbmRleFxuZXhwb3J0IGNvbnN0IGdldFN0YWNrZWRBbm5vdGF0aW9ucyA9IChcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSxcbik6IFN0YWNrZWRBbm5vdGF0aW9uW10gPT4ge1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSBzdGFja0VsZW1lbnRzKGFubm90YXRpb25zKTtcbiAgcmV0dXJuIHN0YWNrZWRBbm5vdGF0aW9uc1xuICAgIC5tYXAoKHJvdywgaWR4KSA9PiByb3cubWFwKChhbm5vdGF0aW9uKSA9PiAoeyAuLi5hbm5vdGF0aW9uLCBzdGFjazogaWR4IH0pKSlcbiAgICAuZmxhdCgpO1xufTtcbmV4cG9ydCBjb25zdCBiYXNlSW5TZWxlY3Rpb24gPSAoe1xuICBiYXNlSW5kZXgsXG4gIHNlbGVjdGlvbixcbiAgc2VxdWVuY2VMZW5ndGgsXG59OiB7XG4gIGJhc2VJbmRleDogbnVtYmVyO1xuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xufSkgPT4ge1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gYmFzZUluZGV4ID09PSBzdGFydDtcbiAgfVxuICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICByZXR1cm4gaW5SYW5nZShiYXNlSW5kZXgsIHN0YXJ0LCBlbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNwYW5zIHNlYW1cbiAgICByZXR1cm4gKFxuICAgICAgaW5SYW5nZShiYXNlSW5kZXgsIHN0YXJ0LCBzZXF1ZW5jZUxlbmd0aCkgfHwgaW5SYW5nZShiYXNlSW5kZXgsIDAsIGVuZClcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5SYW5nZSA9ICh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpID0+IHtcbiAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXg7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U3Vic2VxdWVuY2VMZW5ndGggPSAoXG4gIHsgc3RhcnQsIGVuZCB9OiBBcmlhZG5lU2VsZWN0aW9uLFxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuKSA9PiB7XG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIHJldHVybiBlbmQgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VxdWVuY2VMZW5ndGggLSBzdGFydCArIGVuZDtcbiAgfVxufTtcblxuaW50ZXJmYWNlIFN0cmluZ1NvdXJjZSB7XG4gIHBheWxvYWRUeXBlOiBcImdlbmJhbmtcIiB8IFwiZmFzdGFcIiB8IFwicmF3XCI7XG4gIHBheWxvYWQ6IHN0cmluZztcbiAgYW5ub3RhdGlvbnM/OiBBbm5vdGF0aW9uW107XG4gIGFubm90YXRpb25PbkNsaWNrPzogKGFubm90YXRpb246IEFubm90YXRpb24pID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBHZW5iYW5rU291cmNlIHtcbiAgcGF5bG9hZFR5cGU6IFwicGFyc2VkLWdlbmJhbmtcIjtcbiAgcGF5bG9hZDogUGFyc2VkR2VuYmFuaztcbiAgYW5ub3RhdGlvbnM/OiB1bmRlZmluZWQ7XG4gIGFubm90YXRpb25PbkNsaWNrPzogKGFubm90YXRpb246IEFubm90YXRpb24pID0+IHZvaWQ7XG59XG50eXBlIEFueXRoaW5nU291cmNlID0gU3RyaW5nU291cmNlIHwgR2VuYmFua1NvdXJjZTtcblxudHlwZSBQYXJzZUVycm9yID0ge1xuICBzb3VyY2U6IEFueXRoaW5nU291cmNlO1xuICBlcnJvcjogc3RyaW5nO1xufTtcbnR5cGUgUGFyc2VTdWNjZXNzID0ge1xuICBzb3VyY2U6IEFueXRoaW5nU291cmNlO1xuICBzZXF1ZW5jZXM6IEFubm90YXRlZFNlcXVlbmNlW107XG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW107XG59O1xuZXhwb3J0IGNvbnN0IGFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMgPSAoe1xuICBwYXlsb2FkLFxuICBwYXlsb2FkVHlwZSxcbiAgYW5ub3RhdGlvbnMsXG4gIGFubm90YXRpb25PbkNsaWNrLFxufTogQW55dGhpbmdTb3VyY2UpOiB7XG4gIHNlcXVlbmNlczogQW5ub3RhdGVkU2VxdWVuY2VbXTtcbiAgc3RhY2tlZEFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xufSA9PiB7XG4gIGNvbnN0IHsgc3VjY2Vzc2VzLCBmYWlsdXJlcyB9ID0gc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMoe1xuICAgIHBheWxvYWQsXG4gICAgcGF5bG9hZFR5cGUsXG4gICAgYW5ub3RhdGlvbnMsXG4gICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gIH0gYXMgQW55dGhpbmdTb3VyY2UpO1xuICBpZiAoZmFpbHVyZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZhaWxTdHJpbmcgPSBmYWlsdXJlcy5tYXAoKGYpID0+IGYuZXJyb3IpLmpvaW4oXCJcXG5cIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQYXJzZSBmYWlsdXJlczogJHtmYWlsU3RyaW5nfWApO1xuICB9XG4gIGNvbnN0IHNlcXVlbmNlcyA9IHN1Y2Nlc3Nlcy5tYXAoKHMpID0+IHMuc2VxdWVuY2VzKS5mbGF0KCk7XG4gIGNvbnN0IG5ld0Fubm90YXRpb25zOiBBbm5vdGF0aW9uW10gPSBzdWNjZXNzZXNcbiAgICAubWFwKChzKSA9PiBzLmFubm90YXRpb25zKVxuICAgIC5mbGF0KCk7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IGdldFN0YWNrZWRBbm5vdGF0aW9ucyhuZXdBbm5vdGF0aW9ucyk7XG4gIHJldHVybiB7IHNlcXVlbmNlcywgc3RhY2tlZEFubm90YXRpb25zIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMgPSAoe1xuICBwYXlsb2FkLFxuICBwYXlsb2FkVHlwZSxcbiAgYW5ub3RhdGlvbnMsXG4gIGFubm90YXRpb25PbkNsaWNrLFxufTogQW55dGhpbmdTb3VyY2UpOiB7IHN1Y2Nlc3NlczogUGFyc2VTdWNjZXNzW107IGZhaWx1cmVzOiBQYXJzZUVycm9yW10gfSA9PiB7XG4gIGNvbnN0IHN1Y2Nlc3NlczogUGFyc2VTdWNjZXNzW10gPSBbXTtcbiAgY29uc3QgZmFpbHVyZXM6IFBhcnNlRXJyb3JbXSA9IFtdO1xuICBzd2l0Y2ggKHBheWxvYWRUeXBlKSB7XG4gICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZXMgPSBbXG4gICAgICAgICAgc3RyaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZSh7XG4gICAgICAgICAgICBzZXF1ZW5jZTogcGF5bG9hZCxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9ucyA/PyBbXSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICAgICAgc3VjY2Vzc2VzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlcXVlbmNlczogc2VxdWVuY2VzLFxuICAgICAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9ucyA/PyBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWx1cmVzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHBhcnNlIHJhdyBzZXF1ZW5jZTogJHtlfWAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJwYXJzZWQtZ2VuYmFua1wiOlxuICAgIGNhc2UgXCJnZW5iYW5rXCI6IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9XG4gICAgICAgIHBheWxvYWRUeXBlID09PSBcInBhcnNlZC1nZW5iYW5rXCIgPyBbcGF5bG9hZF0gOiBnZW5iYW5rUGFyc2VyKHBheWxvYWQpO1xuXG4gICAgICBwYXJzZWQuZm9yRWFjaCgoZ2VuYmFuaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNlcXVlbmNlID0gZ2VuYmFua1RvQW5ub3RhdGVkU2VxdWVuY2Uoe1xuICAgICAgICAgICAgZ2VuYmFuayxcbiAgICAgICAgICAgIGFubm90YXRpb25PbkNsaWNrLFxuICAgICAgICAgIH0pLmFubm90YXRlZFNlcXVlbmNlO1xuICAgICAgICAgIHN1Y2Nlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgfSBhcyBBbnl0aGluZ1NvdXJjZSxcbiAgICAgICAgICAgIHNlcXVlbmNlczogW3NlcXVlbmNlXSxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBbXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWx1cmVzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICB9IGFzIEFueXRoaW5nU291cmNlLFxuICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gcGFyc2UgZ2VuYmFuazogJHtlfWAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmYXN0YVwiOiB7XG4gICAgICBsZXQgcmVjb3JkczogKEZhc3RhUmVjb3JkIHwgRmFzdHFSZWNvcmQpW107XG4gICAgICBpZiAocGF5bG9hZFR5cGUgPT09IFwiZmFzdGFcIikge1xuICAgICAgICByZWNvcmRzID0gcGFyc2VGYXN0YShwYXlsb2FkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhc3RxXG4gICAgICAgIHJlY29yZHMgPSBwYXJzZUZhc3RxKHBheWxvYWQpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXMgPSBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyh7XG4gICAgICAgICAgICBwYXlsb2FkOiByZWNvcmQuc2VxdWVuY2UsXG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogXCJyYXdcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKC4uLnJlcy5mYWlsdXJlcyk7XG4gICAgICAgICAgc3VjY2Vzc2VzLnB1c2goLi4ucmVzLnN1Y2Nlc3Nlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHBhcnNlICR7cGF5bG9hZFR5cGV9OiAke2V9YCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgIHNvdXJjZToge1xuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBgVW5rbm93biBwYXlsb2FkIHR5cGU6ICR7cGF5bG9hZFR5cGV9YCxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzZXMsXG4gICAgZmFpbHVyZXMsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZSA9ICh7XG4gIHNlcXVlbmNlLFxuICBhbm5vdGF0aW9ucyxcbn06IHtcbiAgc2VxdWVuY2U6IHN0cmluZztcbiAgYW5ub3RhdGlvbnM/OiBBbm5vdGF0aW9uW107XG59KTogQW5ub3RhdGVkU2VxdWVuY2UgPT4ge1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSBnZXRTdGFja2VkQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMgPz8gW10pO1xuICBjb25zdCBhbm5vdGF0ZWRTZXF1ZW5jZSA9IGdldEFubm90YXRlZFNlcXVlbmNlKHtcbiAgICBzZXF1ZW5jZSxcbiAgICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIH0pO1xuICByZXR1cm4gYW5ub3RhdGVkU2VxdWVuY2U7XG59O1xuXG4vLyBEZXRlcm1pbmUgaWYgdHdvIGFubm90YXRpb25zIGZyb20gdGhlIHNhbWUgc2VxdWVuY2Ugb3ZlcmxhcC5cbmV4cG9ydCBjb25zdCBhbm5vdGF0aW9uc0hhdmVPdmVybGFwID0gKFxuICBhMTogQW5ub3RhdGlvbixcbiAgYTI6IEFubm90YXRpb24sXG4gIG1heExlbjogbnVtYmVyLFxuKTogYm9vbGVhbiA9PiB7XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMS5zdGFydCxcbiAgICAgIHNlbGVjdGlvbjogYTIsXG4gICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4TGVuLFxuICAgIH0pXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMS5lbmQsXG4gICAgICBzZWxlY3Rpb246IGEyLFxuICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heExlbixcbiAgICB9KVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgIGJhc2VJbmRleDogYTIuc3RhcnQsXG4gICAgICBzZWxlY3Rpb246IGExLFxuICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heExlbixcbiAgICB9KVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgIGJhc2VJbmRleDogYTIuZW5kLFxuICAgICAgc2VsZWN0aW9uOiBhMSxcbiAgICAgIHNlcXVlbmNlTGVuZ3RoOiBtYXhMZW4sXG4gICAgfSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQ3JlYXRlIFN0YWNrZWRBbm5vdGF0aW9ucyBzdWNoIHRoYXQgbm8gXCJzdGFja1wiIG9yIGxpbmUgb2YgYW5ub3RhdGlvbnMgaGF2ZVxuLy8gYW55IG92ZXJsYXBwaW5nIGFubm90YXRpb25zLlxuZXhwb3J0IGNvbnN0IHN0YWNrQW5ub3RhdGlvbnNOb092ZXJsYXAgPSAoXG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW10sXG4gIG1heExlbjogbnVtYmVyLFxuKTogU3RhY2tlZEFubm90YXRpb25bXSA9PiB7XG4gIGNvbnN0IGFubm90YXRpb25zQnlTdGFjayA9IFtdIGFzIEFubm90YXRpb25bXVtdO1xuXG4gIGFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgIGxldCBjdXJTdGFjayA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHN0YWNrQW5ucyA9IGFubm90YXRpb25zQnlTdGFja1tjdXJTdGFja107XG4gICAgICBpZiAoIXN0YWNrQW5ucykge1xuICAgICAgICBhbm5vdGF0aW9uc0J5U3RhY2tbY3VyU3RhY2tdID0gW2Fubm90YXRpb25dO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBvdmVybGFwID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IHN0YWNrZWRBbm4gb2Ygc3RhY2tBbm5zKSB7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uc0hhdmVPdmVybGFwKGFubm90YXRpb24sIHN0YWNrZWRBbm4sIG1heExlbikpIHtcbiAgICAgICAgICBvdmVybGFwID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxhcCkge1xuICAgICAgICAvLyBBIG92ZXJsYXAgd2FzIGRldGVjdGVkIHNvIHRyeSB0aGUgbmV4dCBsaW5lLlxuICAgICAgICBjdXJTdGFjayArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm8gb3ZlcmxhcHMgZGV0ZWN0ZWQgb24gdGhpcyBzdGFjayB0aGVuIGFkZCB0aGVcbiAgICAgICAgLy8gYW5ub3RhdGlvbiB0byB0aGlzIGxpbmUuXG4gICAgICAgIGFubm90YXRpb25zQnlTdGFja1tjdXJTdGFja10ucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29udmVydCBhbm5vdGF0aW9ucyB0byBzdGFja2VkIGFubm90YXRpb25zXG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IFtdIGFzIFN0YWNrZWRBbm5vdGF0aW9uW107XG4gIGFubm90YXRpb25zQnlTdGFjay5mb3JFYWNoKChzdGFja2VkQW5ucywgaW5kZXgpID0+IHtcbiAgICBzdGFja2VkQW5ucy5mb3JFYWNoKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICBzdGFja2VkQW5ub3RhdGlvbnMucHVzaCh7XG4gICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgIHN0YWNrOiBpbmRleCxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gc3RhY2tlZEFubm90YXRpb25zO1xufTtcblxuZXhwb3J0IGNvbnN0IHN0YWNrQW5uc0J5VHlwZSA9IChcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSxcbik6IFN0YWNrZWRBbm5vdGF0aW9uW10gPT4ge1xuICAvLyBjcmVhdGUgYSBtYXAgb2YgYW5ub3RhdGlvbiB0eXBlIHRvIGxpc3RcbiAgY29uc3QgYW5ub3RhdGlvbk1hcCA9IGFubm90YXRpb25zLnJlZHVjZShcbiAgICAoYWNjOiB7IFtrZXk6IEFubm90YXRpb25UeXBlXTogQW5ub3RhdGlvbltdIH0sIGFubm90YXRpb246IEFubm90YXRpb24pID0+IHtcbiAgICAgIGlmIChhY2NbYW5ub3RhdGlvbi50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY1thbm5vdGF0aW9uLnR5cGVdID0gW107XG4gICAgICB9XG4gICAgICBhY2NbYW5ub3RhdGlvbi50eXBlXSEucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fSBhcyB7IFtrZXk6IEFubm90YXRpb25UeXBlXTogQW5ub3RhdGlvbltdIH0sXG4gICk7XG5cbiAgY29uc3Qgc3RhY2tzID0gT2JqZWN0LnZhbHVlcyhhbm5vdGF0aW9uTWFwKVxuICAgIC5tYXAoKHN0YWNrLCBzdGFja0lkeCkgPT4ge1xuICAgICAgcmV0dXJuIHN0YWNrLm1hcCgoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4ge1xuICAgICAgICBjb25zdCByZXM6IFN0YWNrZWRBbm5vdGF0aW9uID0ge1xuICAgICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgICAgc3RhY2s6IHN0YWNrSWR4LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSlcbiAgICAuZmxhdCgpO1xuXG4gIHJldHVybiBzdGFja3M7XG59O1xuXG5pbnRlcmZhY2UgRmFzdHFSZWNvcmQge1xuICBpZDogc3RyaW5nO1xuICBzZXF1ZW5jZTogc3RyaW5nO1xuICBvcHRpb25hbElkOiBzdHJpbmc7XG4gIHF1YWxpdHk6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmFzdHEoZGF0YTogc3RyaW5nKTogRmFzdHFSZWNvcmRbXSB7XG4gIGNvbnN0IGxpbmVzID0gZGF0YS50cmltKCkuc3BsaXQoXCJcXG5cIik7XG4gIGNvbnN0IHJlY29yZHM6IEZhc3RxUmVjb3JkW10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgcmVjb3JkOiBGYXN0cVJlY29yZCA9IHtcbiAgICAgIGlkOiBsaW5lc1tpXS5zdWJzdHJpbmcoMSksXG4gICAgICBzZXF1ZW5jZTogbGluZXNbaSArIDFdLFxuICAgICAgb3B0aW9uYWxJZDogbGluZXNbaSArIDJdLnN1YnN0cmluZygxKSxcbiAgICAgIHF1YWxpdHk6IGxpbmVzW2kgKyAzXSxcbiAgICB9O1xuXG4gICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cblxuICByZXR1cm4gcmVjb3Jkcztcbn1cblxuaW50ZXJmYWNlIEZhc3RhUmVjb3JkIHtcbiAgaWQ6IHN0cmluZztcbiAgc2VxdWVuY2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmFzdGEoZGF0YTogc3RyaW5nKTogRmFzdGFSZWNvcmRbXSB7XG4gIGNvbnN0IGxpbmVzID0gZGF0YS50cmltKCkuc3BsaXQoXCJcXG5cIik7XG4gIGNvbnN0IHJlY29yZHM6IEZhc3RhUmVjb3JkW10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgcmVjb3JkOiBGYXN0YVJlY29yZCA9IHtcbiAgICAgIGlkOiBsaW5lc1tpXS5zdWJzdHJpbmcoMSksXG4gICAgICBzZXF1ZW5jZTogbGluZXNbaSArIDFdLFxuICAgIH07XG5cbiAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvcmRzO1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IHVzZVN0YXRlUmVmID0gPFQ+KGluaXRpYWxWYWx1ZTogVCkgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWY8VD4oaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgW3N0YXRlLCBpbnRlcm5hbFNldFN0YXRlXSA9IHVzZVN0YXRlPFQ+KGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2soKHZhbHVlOiBUKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICBpbnRlcm5hbFNldFN0YXRlKHZhbHVlKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCByZWZdIGFzIGNvbnN0O1xufTtcbiIsImltcG9ydCB7IGZpbmRBbmdsZUZyb21Db29yIH0gZnJvbSBcIkBBcmlhZG5lL0NpcmN1bGFyVmlld2VyL2NpcmN1bGFyVXRpbHNcIjtcbmltcG9ydCB7IEFuZ2xlLCBDb29yIH0gZnJvbSBcIkBBcmlhZG5lL3R5cGVzXCI7XG5pbXBvcnQgeyBpblJhbmdlIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBSZWZPYmplY3QsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGVSZWYgfSBmcm9tIFwiLi91c2VTdGF0ZVJlZlwiO1xuXG4vKiB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0IG1hbmFnZXMgdGhlIHNlbGVjdGlvbiBvZiBhIExpbmVhclNlbGVjdGlvbiB3aXRoaW5cbiAqIHRoZSBMaW5lYXJWaWV3ZXIuXG4gKlxuICogcmVmIChSZWZPYmplY3QpIEEgcmVmZXJlbmNlIHRvIHRoZSBzdmcgY29udGFpbmluZyB0aGUgTGluZWFyU2VsZWN0aW9uLlxuICogb25Nb3VzZVVwOiBPcHRpb25hbCBoYW5kbGVyIHdoZW4gdXNlciByZWxlYXNlcyB0aGUgbW91c2VcbiAqIG9uTW91c2VEb3duOiBPcHRpb25hbCBoYW5kbGVyIHdoZW4gdXNlciBwcmVzc2VzIHRoZSBtb3VzZSBvbiB0aGUgTGluZWFyU2VsZWN0aW9uLlxuICogb25Nb3VzZU1vdmU6IE9wdGlvbmFsIGhhbmRsZXIgd2hlbiB1c2VyIGRyYWdzLlxuICovXG5leHBvcnQgY29uc3QgdXNlTGluZWFyU2VsZWN0aW9uUmVjdCA9IDxcbiAgVCBleHRlbmRzIHtcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKTogRE9NUmVjdDtcbiAgICBhZGRFdmVudExpc3RlbmVyOiAodHlwZTogc3RyaW5nLCBsaXN0ZW5lcjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQpID0+IHZvaWQ7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogKFxuICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAgbGlzdGVuZXI6IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuICAgICkgPT4gdm9pZDtcbiAgfSxcbj4oe1xuICByZWYsXG4gIG9uTW91c2VVcCxcbiAgb25Nb3VzZURvd24sXG4gIG9uTW91c2VNb3ZlLFxufToge1xuICByZWY6IFJlZk9iamVjdDxUIHwgbnVsbD47XG4gIG9uTW91c2VVcD86IChwYXlsb2FkOiB7IHN0YXJ0OiBDb29yOyBlbmQ6IENvb3IgfSkgPT4gdm9pZDtcbiAgb25Nb3VzZURvd24/OiAocGF5bG9hZDogeyBzdGFydDogQ29vciB9KSA9PiB2b2lkO1xuICBvbk1vdXNlTW92ZT86IChwYXlsb2FkOiB7IHN0YXJ0OiBDb29yOyBlbmQ6IENvb3IgfSkgPT4gdm9pZDtcbn0pID0+IHtcbiAgY29uc3QgW3N0YXJ0LCBzZXRTdGFydCwgc3RhcnRSZWZdID0gdXNlU3RhdGVSZWY8Q29vciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZW5kLCBzZXRFbmQsIGVuZFJlZl0gPSB1c2VTdGF0ZVJlZjxDb29yIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgW2RpcmVjdGlvbiwgc2V0RGlyZWN0aW9uXSA9IHVzZVN0YXRlPFwiZm9yd2FyZFwiIHwgXCJyZXZlcnNlXCI+KFwiZm9yd2FyZFwiKTtcblxuICBjb25zdCBhY3RpdmUgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIGNvbnN0IF9vbk1vdXNlRG93biA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xuICAgIGNvbnN0IHsgbGVmdCwgdG9wIH0gPSByZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICB9O1xuICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICBjb25zdCB5ID0gY2xpZW50WSAtIHRvcDtcbiAgICBhY3RpdmUuY3VycmVudCA9IHRydWU7XG4gICAgc2V0U3RhcnQoeyB4LCB5IH0pO1xuICAgIHNldEVuZCh7IHgsIHkgfSk7XG4gICAgb25Nb3VzZURvd24/Lih7IHN0YXJ0OiB7IHgsIHkgfSB9KTtcbiAgfTtcbiAgY29uc3QgX29uTW91c2VVcCA9ICgpID0+IHtcbiAgICBhY3RpdmUuY3VycmVudCA9IGZhbHNlO1xuICAgIGlmIChzdGFydFJlZi5jdXJyZW50ICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICBvbk1vdXNlVXA/Lih7IHN0YXJ0OiBzdGFydFJlZi5jdXJyZW50LCBlbmQ6IGVuZFJlZi5jdXJyZW50IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwic3RhcnQgb3IgZW5kIGlzIG51bGwgd2hlbiBtb3VzZXVwXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBtdXN0IHVzZSByZWZzIGluIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBtb3N0IHVwIHRvIGRhdGUgdmFsdWVzXG4gIGNvbnN0IF9vbk1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKGFjdGl2ZS5jdXJyZW50KSB7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gcmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgY29uc3QgeyBzdGFydFggfSA9IHtcbiAgICAgICAgc3RhcnRYOiBzdGFydFJlZi5jdXJyZW50Py54LFxuICAgICAgfTtcbiAgICAgIGlmIChzdGFydFggJiYgc3RhcnRYID4geCkge1xuICAgICAgICBzZXREaXJlY3Rpb24oXCJyZXZlcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RGlyZWN0aW9uKFwiZm9yd2FyZFwiKTtcbiAgICAgIH1cbiAgICAgIHNldEVuZCh7IHgsIHkgfSk7XG4gICAgICBpZiAoc3RhcnRSZWYuY3VycmVudCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICBvbk1vdXNlTW92ZT8uKHsgc3RhcnQ6IHN0YXJ0UmVmLmN1cnJlbnQsIGVuZDogZW5kUmVmLmN1cnJlbnQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwic3RhcnQgaXMgbnVsbCB3aGVuIG1vdXNlbW92ZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZj8uY3VycmVudDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF9vbk1vdXNlRG93bik7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX29uTW91c2VNb3ZlKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgLy8gc3RpbGwgd2FudCB0byBjYWxsIG1vdXNldXAgaWYgbW91c2UgbGVhdmVzIHBhcmVudFxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF9vbk1vdXNlVXApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfb25Nb3VzZURvd24pO1xuICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfb25Nb3VzZU1vdmUpO1xuICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfb25Nb3VzZVVwKTtcbiAgICB9O1xuICB9LCBbcmVmXSk7XG4gIHJldHVybiB7IHN0YXJ0LCBlbmQsIGRpcmVjdGlvbiB9O1xufTtcblxuLy8gZm9yIGNpcmN1bGFyIGNvb3JkaW5hdGVzXG5leHBvcnQgY29uc3QgdXNlQ2lyY3VsYXJTZWxlY3Rpb25SZWN0ID0gKFxuICByZWY6IFJlZk9iamVjdDxTVkdTVkdFbGVtZW50IHwgbnVsbD4sXG4pID0+IHtcbiAgY29uc3QgW3N0YXJ0LCBzZXRTdGFydCwgc3RhcnRSZWZdID0gdXNlU3RhdGVSZWY8QW5nbGUgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2VuZCwgc2V0RW5kXSA9IHVzZVN0YXRlUmVmPEFuZ2xlIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgW2RpcmVjdGlvbiwgc2V0RGlyZWN0aW9uXSA9IHVzZVN0YXRlPFxuICAgIFwiY2xvY2t3aXNlXCIgfCBcImNvdW50ZXJjbG9ja3dpc2VcIiB8IG51bGxcbiAgPihudWxsKTtcbiAgY29uc3QgQU5HTEVfREVMVEFfVEhSRVNIT0xEX0lOX0RFR1JFRVMgPSAyO1xuXG4gIGNvbnN0IGFjdGl2ZSA9IHVzZVJlZihmYWxzZSk7XG5cbiAgY29uc3Qgb25Nb3VzZURvd24gPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcInJlc2V0dGluZyBzdGFydCBhbmQgZW5kXCIpO1xuICAgICAgc2V0U3RhcnQobnVsbCk7XG4gICAgICBzZXRFbmQobnVsbCk7XG4gICAgICBzZXREaXJlY3Rpb24obnVsbCk7XG4gICAgICBhY3RpdmUuY3VycmVudCA9IHRydWU7XG5cbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSByZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgY29uc3QgY2VudGVyID0geyB4OiB3aWR0aCAvIDIsIHk6IGhlaWdodCAvIDIgfTtcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBmaW5kQW5nbGVGcm9tQ29vcih7IGNvb3I6IHsgeCwgeSB9LCBjZW50ZXIgfSk7XG4gICAgICBzZXRTdGFydCh7XG4gICAgICAgIGRlZ3JlZXM6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGNlbnRlcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgYWN0aXZlLmN1cnJlbnQgPSBmYWxzZTtcblxuICAgIHNldERpcmVjdGlvbihudWxsKTtcbiAgfTtcblxuICBjb25zdCBvbk1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKGFjdGl2ZS5jdXJyZW50ICYmIHJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICBjb25zdCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gcmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB4ID0gY2xpZW50WCAtIGxlZnQ7XG4gICAgICBjb25zdCB5ID0gY2xpZW50WSAtIHRvcDtcbiAgICAgIGNvbnN0IGNlbnRlciA9IHsgeDogd2lkdGggLyAyLCB5OiBoZWlnaHQgLyAyIH07XG4gICAgICAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgY2VudGVyLCBkb24ndCB1cGRhdGUgc2VsZWN0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIE1hdGguc3FydChNYXRoLnBvdyh4IC0gY2VudGVyLngsIDIpICsgTWF0aC5wb3coeSAtIGNlbnRlci55LCAyKSkgPFxuICAgICAgICAwLjQgKiAod2lkdGggLyAyKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJ3aXRoaW4gMC41IHJhZGl1cyBvZiBjZW50ZXIsIG5vdCB1cGRhdGluZyBzZWxlY3Rpb25cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW5kQW5nbGUgPSBmaW5kQW5nbGVGcm9tQ29vcih7IGNvb3I6IHsgeCwgeSB9LCBjZW50ZXIgfSk7XG4gICAgICBpZiAoc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnRSZWYuY3VycmVudC5kZWdyZWVzO1xuICAgICAgICBjb25zdCBlbmRBbmdsZUlzTmVhclN0YXJ0QW5nbGUgPSBpblJhbmdlKFxuICAgICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICAgIHN0YXJ0QW5nbGUgLSBBTkdMRV9ERUxUQV9USFJFU0hPTERfSU5fREVHUkVFUyxcbiAgICAgICAgICBzdGFydEFuZ2xlICsgQU5HTEVfREVMVEFfVEhSRVNIT0xEX0lOX0RFR1JFRVMsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbmRBbmdsZUlzTmVhclN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICBzZXREaXJlY3Rpb24obnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEVuZCh7XG4gICAgICAgIGRlZ3JlZXM6IGVuZEFuZ2xlLFxuICAgICAgICBjZW50ZXIsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIGRldGVybWluZURpcmVjdGlvbigpIHtcbiAgICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZGlyZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydC5kZWdyZWVzO1xuICAgICAgICBjb25zdCBlbmRBbmdsZSA9IGVuZC5kZWdyZWVzO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICAgICAgY29uc3QgZ3Vlc3NlZERpcmVjdGlvbiA9IGRlbHRhID4gMCA/IFwiY2xvY2t3aXNlXCIgOiBcImNvdW50ZXJjbG9ja3dpc2VcIjtcbiAgICAgICAgc2V0RGlyZWN0aW9uKGd1ZXNzZWREaXJlY3Rpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3N0YXJ0LCBlbmRdLFxuICApO1xuXG4gIHVzZUVmZmVjdChcbiAgICBmdW5jdGlvbiBoYW5kbGVFdmVudExpc3RlbmVycygpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG5vZGU/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24pO1xuICAgICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgfTtcbiAgICB9LFxuICAgIFtyZWYuY3VycmVudCwgc3RhcnQsIGRpcmVjdGlvbl0sXG4gICk7XG4gIHJldHVybiB7IHN0YXJ0LCBlbmQsIGRpcmVjdGlvbiB9O1xufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWVzKFxuICAuLi5jbGFzc2VzOiAoc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCB8IGJvb2xlYW4pW11cbikge1xuICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG59XG5leHBvcnQgY29uc3QgY24gPSBjbGFzc05hbWVzO1xuIiwiaW1wb3J0IHsgZ2VuQXJjIH0gZnJvbSBcIi4uL2NpcmN1bGFyVXRpbHNcIjtcbmltcG9ydCB0eXBlIHsgQW5ub3RhdGVkU2VxdWVuY2UsIEFubm90YXRpb24sIENvb3IgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyBnZXRTdWJzZXF1ZW5jZUxlbmd0aCB9IGZyb20gXCJAQXJpYWRuZS91dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgQ2lyY3VsYXJBbm5vdGF0aW9uID0gKHtcbiAgc2VxdWVuY2UsXG4gIGFubm90YXRpb24sXG4gIHJhZGl1cyxcbiAgY2VudGVyLFxufToge1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIHJhZGl1czogbnVtYmVyO1xuICBhbm5vdGF0aW9uOiBBbm5vdGF0aW9uO1xuXG4gIGNlbnRlcjogQ29vcjtcbn0pID0+IHtcbiAgY29uc3QgeyB4OiBjeCwgeTogY3kgfSA9IGNlbnRlcjtcbiAgY29uc3QgYW5ub3RhdGlvbkxlbmd0aCA9IGdldFN1YnNlcXVlbmNlTGVuZ3RoKGFubm90YXRpb24sIHNlcXVlbmNlLmxlbmd0aCk7XG4gIGlmIChhbm5vdGF0aW9uTGVuZ3RoID4gc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBBbm5vdGF0aW9uICR7YW5ub3RhdGlvbi50ZXh0fSdzIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gc2VxdWVuY2UgbGVuZ3RoOiAke2Fubm90YXRpb25MZW5ndGh9ID4gJHtzZXF1ZW5jZS5sZW5ndGh9YCxcbiAgICApO1xuICB9XG4gIGNvbnN0IGFyY1BhdGggPSBnZW5BcmMoe1xuICAgIGlubmVyUmFkaXVzOiByYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXM6IHJhZGl1cyArIDUsXG4gICAgbGFyZ2VBcmM6IGFubm90YXRpb25MZW5ndGggPiBzZXF1ZW5jZS5sZW5ndGggLyAyLFxuICAgIGxlbmd0aDogYW5ub3RhdGlvbkxlbmd0aCxcbiAgICBzZXFMZW5ndGg6IHNlcXVlbmNlLmxlbmd0aCxcbiAgICBvZmZzZXQ6IGFubm90YXRpb24uc3RhcnQsXG4gICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhhbm5vdGF0aW9uLmNsYXNzTmFtZSl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGFubm90YXRpb24ub25DbGljaz8uKGFubm90YXRpb24pO1xuICAgICAgfX1cbiAgICA+XG4gICAgICA8cGF0aCBkPXthcmNQYXRofT5cbiAgICAgICAgPHRpdGxlPnthbm5vdGF0aW9uLnRleHR9PC90aXRsZT5cbiAgICAgICAgPHRleHQ+QW5ub3RhdGlvbjwvdGV4dD5cbiAgICAgIDwvcGF0aD5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgdHlwZSB7IEFubm90YXRlZFNlcXVlbmNlLCBTdGFja2VkQW5ub3RhdGlvbiB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgQ2lyY3VsYXJBbm5vdGF0aW9uIH0gZnJvbSBcIi4vQ2lyY3VsYXJBbm5vdGF0aW9uXCI7XG5pbXBvcnQgeyBjbGFtcFNsaWNlIH0gZnJvbSBcIi4uL2NpcmN1bGFyVXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IENpcmN1bGFyQW5ub3RhdGlvbkd1dHRlciA9ICh7XG4gIHN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgY3gsXG4gIGN5LFxuICByYWRpdXMsXG4gIGFubm90YXRlZFNlcXVlbmNlLFxufToge1xuICBzdGFja2VkQW5ub3RhdGlvbnM6IFN0YWNrZWRBbm5vdGF0aW9uW107XG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG59KSA9PiB7XG4gIGNvbnN0IGd1dHRlclJhZGl1cyA9IHJhZGl1cyAqIDAuMztcbiAgY29uc3QgZmlyc3RJZHggPVxuICAgIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDAgPyBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgwKSEuaW5kZXggOiAwO1xuICBjb25zdCBsYXN0SWR4ID1cbiAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggPiAwID8gYW5ub3RhdGVkU2VxdWVuY2UuYXQoLTEpIS5pbmRleCA6IDA7XG4gIHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrZWRBbm5vdGF0aW9uc1xuICAgIC5tYXAoKGFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IGNsYW1wZWRCb3VuZHMgPSBjbGFtcFNsaWNlKHtcbiAgICAgICAgc2xpY2U6IGFubm90YXRpb24sXG4gICAgICAgIGZpcnN0SWR4LFxuICAgICAgICBsYXN0SWR4LFxuICAgICAgfSk7XG4gICAgICBpZiAoIWNsYW1wZWRCb3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICBzdGFydDogY2xhbXBlZEJvdW5kcy5zdGFydCxcbiAgICAgICAgZW5kOiBjbGFtcGVkQm91bmRzLmVuZCxcbiAgICAgIH07XG4gICAgfSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIFN0YWNrZWRBbm5vdGF0aW9uW107IC8vIGZpbHRlciBlbnN1cmVzIHRoYXQgdGhlIGFycmF5IGlzIG9mIHR5cGUgU3RhY2tlZEFubm90YXRpb25bXVxuICBjb25zdCBzdGFja3M6IFN0YWNrZWRBbm5vdGF0aW9uW11bXSA9IFtdO1xuICBzdGFja2VkQW5ub3RhdGlvbnMuZm9yRWFjaCgoYW5uKSA9PiB7XG4gICAgc3RhY2tzW2Fubi5zdGFja10gPSBzdGFja3NbYW5uLnN0YWNrXSB8fCBbXTtcbiAgICBzdGFja3NbYW5uLnN0YWNrXS5wdXNoKGFubik7XG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGc+XG4gICAgICA8Y2lyY2xlIGN4PXtjeH0gY3k9e2N5fSByPXtndXR0ZXJSYWRpdXN9IGZpbGw9XCJub25lXCIgc3Ryb2tlV2lkdGg9ezAuOH0gLz47XG4gICAgICB7c3RhY2tzLm1hcCgoYW5ub3RhdGlvbnMsIHN0YWNrSWR4KSA9PiAoXG4gICAgICAgIDxGcmFnbWVudCBrZXk9e2Bhbm5vdGF0aW9uLXN0YWNrLSR7c3RhY2tJZHh9YH0+XG4gICAgICAgICAge2Fubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKFxuICAgICAgICAgICAgPENpcmN1bGFyQW5ub3RhdGlvblxuICAgICAgICAgICAgICBrZXk9e2BzdGFjay0ke3N0YWNrSWR4fS0ke2Fubm90YXRpb24uc3RhcnR9LSR7YW5ub3RhdGlvbi5lbmR9LSR7YW5ub3RhdGlvbi50ZXh0fWB9XG4gICAgICAgICAgICAgIGFubm90YXRpb249e2Fubm90YXRpb259XG4gICAgICAgICAgICAgIHJhZGl1cz17Z3V0dGVyUmFkaXVzICsgc3RhY2tJZHggKiA2fVxuICAgICAgICAgICAgICBjZW50ZXI9e3sgeDogY3gsIHk6IGN5IH19XG4gICAgICAgICAgICAgIHNlcXVlbmNlPXthbm5vdGF0ZWRTZXF1ZW5jZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICApKX1cbiAgICA8L2c+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgQW5ub3RhdGVkU2VxdWVuY2UgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmaW5kQ29vciB9IGZyb20gXCIuLi9jaXJjdWxhclV0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBDaXJjdWxhckluZGV4ID0gKHtcbiAgYW5ub3RhdGVkU2VxdWVuY2UsXG4gIGN4LFxuICBjeSxcbiAgcmFkaXVzLFxuICB0aWNrcyxcbn06IHtcbiAgYW5ub3RhdGVkU2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBjeDogbnVtYmVyO1xuICBjeTogbnVtYmVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgdGlja3M6IG51bWJlcjtcbn0pID0+IHtcbiAgY29uc3QgYmFzZXNQZXJUaWNrID0gTWF0aC5mbG9vcihhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggLyB0aWNrcyk7XG5cbiAgaWYgKGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDUwKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxzdmcgY2xhc3NOYW1lPXtgZmlsbC1jdXJyZW50YH0+XG4gICAgICAgIDxnPlxuICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgIGN4PXtjeH1cbiAgICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICAgIHI9e3JhZGl1cyAqIDAuNzV9XG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8VGlja3NcbiAgICAgICAgICAgIGN4PXtjeH1cbiAgICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICAgIHJhZGl1cz17cmFkaXVzICogMC43NX1cbiAgICAgICAgICAgIGJhc2VzUGVyVGljaz17YmFzZXNQZXJUaWNrfVxuICAgICAgICAgICAgdG90YWxCYXNlcz17YW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RofVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIChcbiAgICA8dGV4dD5cbiAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZS5tYXAoKHsgYmFzZTogbGV0dGVyIH0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZmluZENvb3Ioe1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHJhZGl1czogcmFkaXVzICogMC43LFxuICAgICAgICAgIGNlbnRlcjogeyB4OiBjeCwgeTogY3kgfSxcbiAgICAgICAgICBzZXFMZW5ndGg6IGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZURlZ3JlZXMgPSAoaW5kZXggLyBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgpICogMzYwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDx0c3BhblxuICAgICAgICAgICAga2V5PXtgYmFzZS0ke2luZGV4fWB9XG4gICAgICAgICAgICB4PXt4fVxuICAgICAgICAgICAgeT17eX1cbiAgICAgICAgICAgIHRyYW5zZm9ybT17YHJvdGF0ZSgke3JvdGF0ZURlZ3JlZXN9ICR7eH0gJHt5fSlgfVxuICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4gICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGNvbG9yPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgZm9udFNpemU9XCIwLjVyZW1cIlxuICAgICAgICAgICAgZm9udFdlaWdodD1cInRoaW5cIlxuICAgICAgICAgICAgZm9udEZhbWlseT1cImluaGVyaXRcIlxuICAgICAgICAgICAgZGF0YS1zZXEtaW5kZXg9e2luZGV4fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtsZXR0ZXJ9XG4gICAgICAgICAgPC90c3Bhbj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvdGV4dD5cbiAgKTtcbn07XG5cbmNvbnN0IFRpY2tzID0gKHtcbiAgcmFkaXVzLFxuICBjeCxcbiAgY3ksXG4gIGJhc2VzUGVyVGljayxcbiAgdG90YWxCYXNlcyxcbn06IHtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIGJhc2VzUGVyVGljazogbnVtYmVyO1xuICB0b3RhbEJhc2VzOiBudW1iZXI7XG59KSA9PiB7XG4gIGNvbnN0IG51bWJlck9mVGlja3MgPSBNYXRoLmZsb29yKHRvdGFsQmFzZXMgLyBiYXNlc1BlclRpY2spO1xuICByZXR1cm4gKFxuICAgIDxzdmc+XG4gICAgICB7Wy4uLkFycmF5KG51bWJlck9mVGlja3MpLmtleXMoKV0ubWFwKChpKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSBmaW5kQ29vcih7XG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgIGNlbnRlcjogeyB4OiBjeCwgeTogY3kgfSxcbiAgICAgICAgICBzZXFMZW5ndGg6IHRvdGFsQmFzZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gZmluZENvb3Ioe1xuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHJhZGl1czogcmFkaXVzICogMS4xLFxuICAgICAgICAgIGNlbnRlcjogeyB4OiBjeCwgeTogY3kgfSxcbiAgICAgICAgICBzZXFMZW5ndGg6IHRvdGFsQmFzZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByb3RhdGVEZWdyZWVzID0gKGkgLyBudW1iZXJPZlRpY2tzKSAqIDM2MDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8RnJhZ21lbnQga2V5PXtgdGljay0ke2l9YH0+XG4gICAgICAgICAgICA8bGluZVxuICAgICAgICAgICAgICBpZD17YHRpY2stJHtpfWB9XG4gICAgICAgICAgICAgIHgxPXt4MX1cbiAgICAgICAgICAgICAgeTE9e3kxfVxuICAgICAgICAgICAgICB4Mj17eDJ9XG4gICAgICAgICAgICAgIHkyPXt5Mn1cbiAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgIG9wYWNpdHk9ezAuNX1cbiAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgcm90YXRlKCR7cm90YXRlRGVncmVlc30gJHtjeH0gJHtjeX0pYH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICB4PXt4Mn1cbiAgICAgICAgICAgICAgeT17eTIgLSA0fVxuICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgZm9udFNpemU9XCIuOHJlbVwiXG4gICAgICAgICAgICAgIHRyYW5zZm9ybT17YHJvdGF0ZSgke3JvdGF0ZURlZ3JlZXN9ICR7Y3h9ICR7Y3l9KWB9XG4gICAgICAgICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICBvcGFjaXR5PXswLjc1fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7aSAqIGJhc2VzUGVyVGlja31cbiAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgdXNlQ2lyY3VsYXJTZWxlY3Rpb25SZWN0IH0gZnJvbSBcIkBBcmlhZG5lL2hvb2tzL3VzZVNlbGVjdGlvblwiO1xuaW1wb3J0IHtcbiAgQW5ub3RhdGVkU2VxdWVuY2UsXG4gIEFubm90YXRpb24sXG4gIEFyaWFkbmVTZWxlY3Rpb24sXG59IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHtcbiAgZ2V0QW5ub3RhdGVkU2VxdWVuY2UsXG4gIGdldFN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgZ2V0U3Vic2VxdWVuY2VMZW5ndGgsXG59IGZyb20gXCJAQXJpYWRuZS91dGlsc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdGFja0FubnNCeVR5cGUgfSBmcm9tIFwiLi5cIjtcbmltcG9ydCB7IENpcmN1bGFyQW5ub3RhdGlvbkd1dHRlciB9IGZyb20gXCIuL0NpcmN1bGFyQW5ub3RhdGlvbnNcIjtcbmltcG9ydCB7IENpcmN1bGFySW5kZXggfSBmcm9tIFwiLi9DaXJjdWxhckluZGV4XCI7XG5pbXBvcnQgeyBjbGFtcFNsaWNlLCBmaW5kSW5kZXhGcm9tQW5nbGUsIGdlbkFyYyB9IGZyb20gXCIuL2NpcmN1bGFyVXRpbHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHNlcXVlbmNlOiBzdHJpbmc7XG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW107XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbikgPT4gdm9pZDtcbiAgY29udGFpbmVyQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBzdmdTaXplUFg/OiBudW1iZXI7XG4gIHN2Z1BhZGRpbmc/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBDaXJjdWxhclZpZXdlciA9ICh7XG4gIHNlcXVlbmNlLFxuICBhbm5vdGF0aW9ucyxcbiAgc2VsZWN0aW9uLFxuICBzZXRTZWxlY3Rpb24sXG4gIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgc3ZnU2l6ZVBYID0gMzAwLFxuICBzdmdQYWRkaW5nID0gMjAsXG59OiBQcm9wcykgPT4ge1xuICBjb25zdCB7IGN4LCBjeSwgc2l6ZVgsIHNpemVZLCByYWRpdXMgfSA9IHtcbiAgICBjeDogc3ZnU2l6ZVBYIC8gMixcbiAgICBjeTogc3ZnU2l6ZVBYIC8gMixcbiAgICBzaXplWDogc3ZnU2l6ZVBYLFxuICAgIHNpemVZOiBzdmdTaXplUFgsXG4gICAgcmFkaXVzOiAoc3ZnU2l6ZVBYIC0gc3ZnUGFkZGluZykgLyAyLFxuICB9O1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSBzdGFja0FubnNCeVR5cGUoYW5ub3RhdGlvbnMpO1xuICBjb25zdCBhbm5vdGF0ZWRTZXF1ZW5jZSA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSh7XG4gICAgICAgIHNlcXVlbmNlLFxuICAgICAgICBzdGFja2VkQW5ub3RhdGlvbnM6IGdldFN0YWNrZWRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucyksXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtzZXF1ZW5jZSwgYW5ub3RhdGlvbnNdLFxuICApO1xuXG4gIGlmIChhbm5vdGF0ZWRTZXF1ZW5jZSAmJiBzZWxlY3Rpb24gJiYgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpcnN0SWR4ID1cbiAgICAgIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDAgPyBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgwKSEuaW5kZXggOiAwO1xuICAgIGNvbnN0IGxhc3RJZHggPVxuICAgICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCA/IGFubm90YXRlZFNlcXVlbmNlLmF0KC0xKSEuaW5kZXggOiAwO1xuICAgIHNlbGVjdGlvbiA9IGNsYW1wU2xpY2UoeyBzbGljZTogc2VsZWN0aW9uLCBmaXJzdElkeCwgbGFzdElkeCB9KTtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb25SZWYgPSB1c2VSZWY8U1ZHU1ZHRWxlbWVudD4obnVsbCk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgIFwiZmxleCBzZWxlY3Qtbm9uZSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZm9udC10aGluXCIsXG4gICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgPlxuICAgICAgPHN2Z1xuICAgICAgICByZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgdmlld0JveD17YDAgMCAke3NpemVYfSAke3NpemVZfWB9XG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICBmb250RmFtaWx5PVwiaW5oZXJpdFwiXG4gICAgICAgIGZvbnRTaXplPVwiaW5oZXJpdFwiXG4gICAgICAgIGZvbnRXZWlnaHQ9XCJpbmhlcml0XCJcbiAgICAgICAgY2xhc3NOYW1lPXtgc3Ryb2tlLWN1cnJlbnRgfVxuICAgICAgICB3aWR0aD17c2l6ZVh9XG4gICAgICAgIGhlaWdodD17c2l6ZVl9XG4gICAgICA+XG4gICAgICAgIDxDaXJjdWxhckluZGV4XG4gICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICByYWRpdXM9e3JhZGl1c31cbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZT17YW5ub3RhdGVkU2VxdWVuY2V9XG4gICAgICAgICAgdGlja3M9ezR9XG4gICAgICAgIC8+XG4gICAgICAgIDxDaXJjdWxhckFubm90YXRpb25HdXR0ZXJcbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZT17YW5ub3RhdGVkU2VxdWVuY2V9XG4gICAgICAgICAgc3RhY2tlZEFubm90YXRpb25zPXtzdGFja2VkQW5ub3RhdGlvbnN9XG4gICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICByYWRpdXM9e3JhZGl1c31cbiAgICAgICAgLz5cbiAgICAgICAgPENpcmN1bGFyU2VsZWN0aW9uXG4gICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2U9e2Fubm90YXRlZFNlcXVlbmNlfVxuICAgICAgICAgIHNlbGVjdGlvbj17c2VsZWN0aW9ufVxuICAgICAgICAgIGN4PXtjeH1cbiAgICAgICAgICBjeT17Y3l9XG4gICAgICAgICAgcmFkaXVzPXtyYWRpdXN9XG4gICAgICAgICAgc2VsZWN0aW9uUmVmPXtzZWxlY3Rpb25SZWZ9XG4gICAgICAgICAgc2V0U2VsZWN0aW9uPXtzZXRTZWxlY3Rpb259XG4gICAgICAgIC8+XG5cbiAgICAgICAgPHRleHRcbiAgICAgICAgICB4PXtjeH1cbiAgICAgICAgICB5PXtjeX1cbiAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgIGFsaWdubWVudEJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICBmb250U2l6ZT17XCIxcmVtXCJ9XG4gICAgICAgID5cbiAgICAgICAgICB7YW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RofSBicFxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmNvbnN0IENpcmN1bGFyU2VsZWN0aW9uID0gKHtcbiAgcmFkaXVzLFxuICBjeCxcbiAgY3ksXG4gIHNlbGVjdGlvbixcbiAgc2VsZWN0aW9uUmVmLFxuICBzZXRTZWxlY3Rpb24sXG4gIGFubm90YXRlZFNlcXVlbmNlLFxufToge1xuICByYWRpdXM6IG51bWJlcjtcblxuICBjeDogbnVtYmVyO1xuICBjeTogbnVtYmVyO1xuICBzZWxlY3Rpb25SZWY6IFJlYWN0LlJlZk9iamVjdDxTVkdTVkdFbGVtZW50PjtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiB2b2lkO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG59KSA9PiB7XG4gIC8qIENvbGxlY3QgaW50ZXJuYWwgc2VsZWN0aW9uIGRhdGEgYW5kIHByb3BvZ2F0ZSB1cCAqL1xuICBjb25zdCB7XG4gICAgc3RhcnQ6IGludGVybmFsU2VsZWN0aW9uU3RhcnQsXG4gICAgZW5kOiBpbnRlcm5hbFNlbGVjdGlvbkVuZCxcbiAgICBkaXJlY3Rpb246IGludGVybmFsRGlyZWN0aW9uLFxuICB9ID0gdXNlQ2lyY3VsYXJTZWxlY3Rpb25SZWN0KHNlbGVjdGlvblJlZik7XG4gIHVzZUVmZmVjdChcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVTZWxlY3Rpb25VcCgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgc2VsZWN0aW9uUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgaW50ZXJuYWxTZWxlY3Rpb25TdGFydCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvbkVuZCAmJlxuICAgICAgICBpbnRlcm5hbERpcmVjdGlvblxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gZmluZEluZGV4RnJvbUFuZ2xlKHtcbiAgICAgICAgICBhbmdsZTogaW50ZXJuYWxTZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBzZXFMZW5ndGg6IGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGZpbmRJbmRleEZyb21BbmdsZSh7XG4gICAgICAgICAgYW5nbGU6IGludGVybmFsU2VsZWN0aW9uRW5kLFxuICAgICAgICAgIHNlcUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID1cbiAgICAgICAgICBpbnRlcm5hbERpcmVjdGlvbiA9PT0gXCJjbG9ja3dpc2VcIiA/IFwiZm9yd2FyZFwiIDogXCJyZXZlcnNlXCI7XG5cbiAgICAgICAgY29uc3QgcHJldkxlbmd0aCA9IHNlbGVjdGlvblxuICAgICAgICAgID8gTWF0aC5hYnMoc2VsZWN0aW9uLmVuZCAtIHNlbGVjdGlvbi5zdGFydClcbiAgICAgICAgICA6IDA7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGdldFN1YnNlcXVlbmNlTGVuZ3RoKFxuICAgICAgICAgIHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uIH0sXG4gICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkZWx0YUxlbmd0aCA9IE1hdGguYWJzKHByZXZMZW5ndGggLSBuZXdMZW5ndGgpO1xuICAgICAgICBjb25zdCBkZWx0YVRocmVzaG9sZCA9IE1hdGgubWF4KDAuNyAqIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCwgMTApO1xuICAgICAgICBpZiAoZGVsdGFMZW5ndGggPiBkZWx0YVRocmVzaG9sZCAmJiBzZWxlY3Rpb24pIHtcbiAgICAgICAgICAvLyBwcmVzZXJ2ZSBpbml0aWFsIGRpcmVjdGlvblxuICAgICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogc2VsZWN0aW9uPy5kaXJlY3Rpb24sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LCBpbnRlcm5hbFNlbGVjdGlvbkVuZF0sXG4gICk7XG5cbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyogRGlzcGxheSBzZWxlY3Rpb24gZGF0YSB0aGF0IGhhcyB0cmlja2xlZCBkb3duICovXG4gIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uO1xuICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2VudGVyID0geyB4OiBjeCwgeTogY3kgfTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXM7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gcmFkaXVzICsgMTA7XG4gIGNvbnN0IGxlbmd0aCA9IGdldFN1YnNlcXVlbmNlTGVuZ3RoKHNlbGVjdGlvbiwgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoKTtcblxuICBjb25zdCBbc3RhcnRJZHgsIGVuZElkeF0gPSBbXG4gICAgYW5ub3RhdGVkU2VxdWVuY2UuYXQoMCk/LmluZGV4LFxuICAgIGFubm90YXRlZFNlcXVlbmNlLmF0KC0xKT8uaW5kZXgsXG4gIF07XG4gIGlmIChzdGFydElkeCA9PT0gdW5kZWZpbmVkIHx8IGVuZElkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNpcmN1bGFyVmlld2VyOiBzZXF1ZW5jZSBoYXMgbm8gaW5kaWNlc1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSBzdGFydCAtIHN0YXJ0SWR4O1xuICBjb25zdCBzZXFMZW5ndGggPSBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGg7XG5cbiAgY29uc3QgYXJjID0gZ2VuQXJjKHtcbiAgICBjZW50ZXIsXG4gICAgaW5uZXJSYWRpdXMsXG4gICAgbGFyZ2VBcmM6IGxlbmd0aCA+IHNlcUxlbmd0aCAvIDIsXG4gICAgbGVuZ3RoLFxuICAgIG9mZnNldCxcbiAgICBvdXRlclJhZGl1cyxcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICByZXR1cm4gKFxuICAgIDxnPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD17YXJjfVxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgIC8+XG4gICAgPC9nPlxuICApO1xufTtcbiIsImltcG9ydCB7IGdldFN1YnNlcXVlbmNlTGVuZ3RoIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEFubm90YXRlZFNlcXVlbmNlLCBBbm5vdGF0aW9uLCBTdGFja2VkQW5ub3RhdGlvbiB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVhckFubm90YXRpb25HdXR0ZXJQcm9wcyB7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogU3RhY2tlZEFubm90YXRpb25bXTtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBjb250YWluZXJDbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBMaW5lYXJBbm5vdGF0aW9uR3V0dGVyID0gKHtcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBzZXF1ZW5jZSxcbiAgY29udGFpbmVyQ2xhc3NOYW1lLFxufTogTGluZWFyQW5ub3RhdGlvbkd1dHRlclByb3BzKSA9PiB7XG4gIGNvbnN0IHN0YWNrczogU3RhY2tlZEFubm90YXRpb25bXVtdID0gW107XG4gIHN0YWNrZWRBbm5vdGF0aW9ucy5mb3JFYWNoKChhbm4pID0+IHtcbiAgICBzdGFja3NbYW5uLnN0YWNrXSA9IHN0YWNrc1thbm4uc3RhY2tdIHx8IFtdO1xuICAgIHN0YWNrc1thbm4uc3RhY2tdLnB1c2goYW5uKTtcbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICBcImdyaWQtcm93cy1hdXRvIGJsb2NrIGdyaWQgZ3JpZC1jb2xzLTEgZ2FwLTFcIixcbiAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICA+XG4gICAgICB7c3RhY2tzLm1hcCgoYW5ub3RhdGlvbnMsIHN0YWNrSWR4KSA9PiAoXG4gICAgICAgIDxkaXYga2V5PXtgYW5ub3RhdGlvbi1zdGFjay0ke3N0YWNrSWR4fWB9IGNsYXNzTmFtZT1cInJlbGF0aXZlIGgtOFwiPlxuICAgICAgICAgIHthbm5vdGF0aW9ucy5tYXAoKGFubm90YXRpb24pID0+IChcbiAgICAgICAgICAgIDxMaW5lYXJBbm5vdGF0aW9uXG4gICAgICAgICAgICAgIGtleT17YGFubm90YXRpb24tJHthbm5vdGF0aW9uLnRleHR9LSR7YW5ub3RhdGlvbi5zdGFydH0tJHthbm5vdGF0aW9uLmVuZH0tJHthbm5vdGF0aW9uLmRpcmVjdGlvbn1gfVxuICAgICAgICAgICAgICBhbm5vdGF0aW9uPXthbm5vdGF0aW9ufVxuICAgICAgICAgICAgICBzZXF1ZW5jZT17c2VxdWVuY2V9XG4gICAgICAgICAgICAgIHN0YWNrSWR4PXtzdGFja0lkeH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuY29uc3QgTGluZWFyQW5ub3RhdGlvbiA9ICh7XG4gIGFubm90YXRpb24sXG4gIHNlcXVlbmNlLFxuICBzdGFja0lkeCxcbn06IHtcbiAgYW5ub3RhdGlvbjogQW5ub3RhdGlvbjtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBzdGFja0lkeDogbnVtYmVyO1xufSkgPT4ge1xuICAvKiBpZiB0aGUgYW5ub3RhdGlvbiBzcGFucyB0aGUgc2VhbSwgd2UgZHJhdyB0d28gbGluZXMgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGVuZCwgYW5kIGZyb20gc3RhcnQgdG8gZW5kICovXG5cbiAgY29uc3QgYW5ub3RhdGlvblNwYW5zU2VhbSA9IGFubm90YXRpb24uc3RhcnQgPiBhbm5vdGF0aW9uLmVuZDtcbiAgaWYgKGFubm90YXRpb25TcGFuc1NlYW0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEZyYWdtZW50PlxuICAgICAgICA8TGluZWFyQW5ub3RhdGlvblxuICAgICAgICAgIGFubm90YXRpb249e3tcbiAgICAgICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgICAgICBlbmQ6IHNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbi5vbkNsaWNrPy4oeyAuLi5hbm5vdGF0aW9uIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHNlcXVlbmNlPXtzZXF1ZW5jZX1cbiAgICAgICAgICBzdGFja0lkeD17c3RhY2tJZHh9XG4gICAgICAgIC8+XG4gICAgICAgIDxMaW5lYXJBbm5vdGF0aW9uXG4gICAgICAgICAgYW5ub3RhdGlvbj17e1xuICAgICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICBhbm5vdGF0aW9uLm9uQ2xpY2s/Lih7IC4uLmFubm90YXRpb24gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgICAgc2VxdWVuY2U9e3NlcXVlbmNlfVxuICAgICAgICAgIHN0YWNrSWR4PXtzdGFja0lkeH1cbiAgICAgICAgLz5cbiAgICAgIDwvRnJhZ21lbnQ+XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGFubm90YXRpb25SZWN0YW5nbGVXaWR0aFBlcmMgPVxuICAgIChnZXRTdWJzZXF1ZW5jZUxlbmd0aChhbm5vdGF0aW9uLCBzZXF1ZW5jZS5sZW5ndGgpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcblxuICBjb25zdCB4UGVyYyA9XG4gICAgKE1hdGgubWluKGFubm90YXRpb24uc3RhcnQsIGFubm90YXRpb24uZW5kKSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIC8vIGNsaXAgcGF0aCB0byBjcmVhdGUgcmVjdGFuZ2xlIHdpdGggYSBwb2ludCBhdCBvbmUgZW5kXG4gIGNvbnN0IGZvcndhcmRDbGlwUGF0aCA9IFwicG9seWdvbigwIDAsIDkwJSAwLCAxMDAlIDUwJSwgOTAlIDEwMCUsIDAgMTAwJSlcIjtcbiAgY29uc3QgcmV2ZXJzZUNsaXBQYXRoID0gXCJwb2x5Z29uKDAgNTAlLCAxMCUgMCwgMTAwJSAwLCAxMDAlIDEwMCUsIDEwJSAxMDAlKVwiO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cImdyb3VwIGFic29sdXRlXCJcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIG1hcmdpbkxlZnQ6IGAke3hQZXJjfSVgLFxuICAgICAgICB3aWR0aDogYCR7YW5ub3RhdGlvblJlY3RhbmdsZVdpZHRoUGVyY30lYCxcbiAgICAgIH19XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGFubm90YXRpb24ub25DbGljaz8uKGFubm90YXRpb24pO1xuICAgICAgfX1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICBcInB4LTJcIixcbiAgICAgICAgICBhbm5vdGF0aW9uLmRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCIgPyBcInRleHQtbGVmdFwiIDogXCJ0ZXh0LXJpZ2h0XCIsXG4gICAgICAgICAgYW5ub3RhdGlvbi5jbGFzc05hbWUsXG4gICAgICAgICl9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgY2xpcFBhdGg6XG4gICAgICAgICAgICBhbm5vdGF0aW9uLmRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCJcbiAgICAgICAgICAgICAgPyBmb3J3YXJkQ2xpcFBhdGhcbiAgICAgICAgICAgICAgOiByZXZlcnNlQ2xpcFBhdGgsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHthbm5vdGF0aW9uLnRleHR9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwiYWJzb2x1dGUgbGVmdC0xLzIgei0xMCBoaWRkZW4gLXRyYW5zbGF0ZS14LTEvMiB0cmFuc2xhdGUteS00IGZsZXgtY29sIHJvdW5kZWQtbWQgcHgtMiBweS0xIHRleHQtc20gZ3JvdXAtaG92ZXI6ZmxleFwiLFxuICAgICAgICAgIGFubm90YXRpb24uY2xhc3NOYW1lLFxuICAgICAgICApfVxuICAgICAgPlxuICAgICAgICA8c3Bhbj57YW5ub3RhdGlvbi50ZXh0fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4+e2Fubm90YXRpb24udHlwZX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0IH0gZnJvbSBcIkBBcmlhZG5lL2hvb2tzL3VzZVNlbGVjdGlvblwiO1xuaW1wb3J0IHsgZ2V0QW5ub3RhdGVkU2VxdWVuY2UsIGdldFN1YnNlcXVlbmNlTGVuZ3RoIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEFubm90YXRlZFNlcXVlbmNlLFxuICBBcmlhZG5lU2VsZWN0aW9uLFxuICBBbm5vdGF0aW9uLFxuICBBbm5vdGF0ZWRCYXNlLFxuICBTdGFja2VkQW5ub3RhdGlvbixcbn0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBzdGFja0Fubm90YXRpb25zTm9PdmVybGFwIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBMaW5lYXJBbm5vdGF0aW9uR3V0dGVyIH0gZnJvbSBcIi4vTGluZWFyQW5ub3RhdGlvbkd1dHRlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgc2VxdWVuY2VzOiBzdHJpbmdbXTtcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgb25Eb3VibGVDbGljaz86ICgpID0+IHZvaWQ7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24pID0+IHN0cmluZztcbiAgY29udGFpbmVyQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBzZXF1ZW5jZUNsYXNzTmFtZTogKHsgc2VxdWVuY2VJZHggfTogeyBzZXF1ZW5jZUlkeDogbnVtYmVyIH0pID0+IHN0cmluZztcbiAgbWlzbWF0Y2hDbGFzc05hbWU/OiAobWlzbWF0Y2hlZEJhc2U6IEFubm90YXRlZEJhc2UpID0+IHN0cmluZztcbiAgc3RhY2tpbmdGbj86IChhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdKSA9PiBTdGFja2VkQW5ub3RhdGlvbltdO1xufVxuXG5jb25zdCBNSVNNQVRDSF9ESVNUX1BFUkNfVEhSRVNIT0xEID0gMC4wMTtcblxuZXhwb3J0IGNvbnN0IExpbmVhclZpZXdlciA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIHNlcXVlbmNlcyxcbiAgICBzZWxlY3Rpb24sXG4gICAgYW5ub3RhdGlvbnMsXG4gICAgc2V0U2VsZWN0aW9uLFxuICAgIG9uRG91YmxlQ2xpY2ssXG4gICAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxuICAgIG1pc21hdGNoQ2xhc3NOYW1lLFxuICAgIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICBzZXF1ZW5jZUNsYXNzTmFtZSxcbiAgICBzdGFja2luZ0ZuLFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgLy8gaWYgYSBzdGFja2luZyBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIGl0LCBvdGhlcndpc2UgdXNlIHRoZSBkZWZhdWx0IHdoaWNoXG4gICAgICAvLyBzdGFja3MgYW5ub3RhdGlvbnMgdG8gcHJldmVudCBvdmVybGFwLlxuICAgICAgcmV0dXJuIHN0YWNraW5nRm5cbiAgICAgICAgPyBzdGFja2luZ0ZuKGFubm90YXRpb25zKVxuICAgICAgICA6IHN0YWNrQW5ub3RhdGlvbnNOb092ZXJsYXAoXG4gICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgIE1hdGgubWF4KC4uLnNlcXVlbmNlcy5tYXAoKHNlcSkgPT4gc2VxLmxlbmd0aCkpLFxuICAgICAgICAgICk7XG4gICAgfSxcbiAgICBbYW5ub3RhdGlvbnNdLFxuICApO1xuXG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlcyA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZXMubWFwKChzZXF1ZW5jZSkgPT5cbiAgICAgICAgZ2V0QW5ub3RhdGVkU2VxdWVuY2UoeyBzZXF1ZW5jZSwgc3RhY2tlZEFubm90YXRpb25zIH0pLFxuICAgICAgKTtcbiAgICB9LFxuICAgIFtzZXF1ZW5jZXMsIHN0YWNrZWRBbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgYmFzZVNlcXVlbmNlID0gYW5ub3RhdGVkU2VxdWVuY2VzWzBdO1xuICBjb25zdCBzZWxlY3Rpb25SZWYgPSB1c2VSZWY8U1ZHU1ZHRWxlbWVudD4obnVsbCk7XG5cbiAgLy8gY29uc3QgbnVtYmVyT2ZUaWNrcyA9IDU7XG4gIC8vIGNvbnN0IGJhc2VzUGVyVGljayA9IE1hdGguZmxvb3Ioc2VxdWVuY2UubGVuZ3RoIC8gbnVtYmVyT2ZUaWNrcyk7XG5cbiAgY29uc3QgU1ZHX1dJRFRIID0gNTAwO1xuICBjb25zdCBTVkdfSEVJR0hUID0gc2VxdWVuY2VzLmxlbmd0aCAqIDEwICsgMTA7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y29udGFpbmVyQ2xhc3NOYW1lIHx8IFwiXCJ9PlxuICAgICAgPHN2Z1xuICAgICAgICByZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwic2VsZWN0LW5vbmUgZm9udC10aGluXCIpfVxuICAgICAgICBvbkRvdWJsZUNsaWNrPXtvbkRvdWJsZUNsaWNrfVxuICAgICAgICB2aWV3Qm94PXtgMCAwICR7U1ZHX1dJRFRIfSAke1NWR19IRUlHSFR9YH1cbiAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgPlxuICAgICAgICA8Zz5cbiAgICAgICAgICB7YW5ub3RhdGVkU2VxdWVuY2VzLm1hcCgoc2VxdWVuY2UsIGkpID0+IChcbiAgICAgICAgICAgIDxnIGtleT17YFNlcXVlbmNlLSR7aX1gfT5cbiAgICAgICAgICAgICAgPFNlcXVlbmNlTGluZVxuICAgICAgICAgICAgICAgIHNlcXVlbmNlQ2xhc3NOYW1lPXtzZXF1ZW5jZUNsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICBiYXNlU2VxdWVuY2U9e3NlcXVlbmNlfVxuICAgICAgICAgICAgICAgIGFsaWduZWRTZXF1ZW5jZXM9e2Fubm90YXRlZFNlcXVlbmNlcy5maWx0ZXIoKF8sIGopID0+IGogIT09IGkpfVxuICAgICAgICAgICAgICAgIHNlcXVlbmNlSWR4PXtpfVxuICAgICAgICAgICAgICAgIG1pc21hdGNoQ2xhc3NOYW1lPXttaXNtYXRjaENsYXNzTmFtZX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9nPlxuICAgICAgICA8TGluZWFyU2VsZWN0aW9uXG4gICAgICAgICAgc2VsZWN0aW9uQ2xhc3NOYW1lPXtzZWxlY3Rpb25DbGFzc05hbWV9XG4gICAgICAgICAgc2VsZWN0aW9uUmVmPXtzZWxlY3Rpb25SZWZ9XG4gICAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgc2V0U2VsZWN0aW9uPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgc2VxdWVuY2U9e2Jhc2VTZXF1ZW5jZX1cbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAge3N0YWNrZWRBbm5vdGF0aW9ucy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPExpbmVhckFubm90YXRpb25HdXR0ZXJcbiAgICAgICAgICBjb250YWluZXJDbGFzc05hbWU9XCJcIlxuICAgICAgICAgIHN0YWNrZWRBbm5vdGF0aW9ucz17c3RhY2tlZEFubm90YXRpb25zfVxuICAgICAgICAgIHNlcXVlbmNlPXtiYXNlU2VxdWVuY2V9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuaW50ZXJmYWNlIFNlcXVlbmNlTGluZVByb3BzIHtcbiAgYmFzZVNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgc2VxdWVuY2VJZHg6IG51bWJlcjtcbiAgYWxpZ25lZFNlcXVlbmNlczogQW5ub3RhdGVkU2VxdWVuY2VbXTtcbiAgc2VxdWVuY2VDbGFzc05hbWU6ICh7IHNlcXVlbmNlSWR4IH06IHsgc2VxdWVuY2VJZHg6IG51bWJlciB9KSA9PiBzdHJpbmc7XG4gIG1pc21hdGNoQ2xhc3NOYW1lPzogKG1pc21hdGNoZWRCYXNlOiBBbm5vdGF0ZWRCYXNlKSA9PiBzdHJpbmc7XG59XG5cbmNvbnN0IFNlcXVlbmNlTGluZSA9ICh7XG4gIGJhc2VTZXF1ZW5jZSxcbiAgc2VxdWVuY2VJZHgsXG4gIGFsaWduZWRTZXF1ZW5jZXMsXG4gIHNlcXVlbmNlQ2xhc3NOYW1lLFxuICBtaXNtYXRjaENsYXNzTmFtZSxcbn06IFNlcXVlbmNlTGluZVByb3BzKSA9PiB7XG4gIGNvbnN0IHN0YXJ0ID0gYmFzZVNlcXVlbmNlWzBdPy5pbmRleDtcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcXVlbmNlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYmFzZSAke2Jhc2VTZXF1ZW5jZX1gKTtcbiAgfVxuICBjb25zdCBlbmQgPSBiYXNlU2VxdWVuY2VbYmFzZVNlcXVlbmNlLmxlbmd0aCAtIDFdPy5pbmRleDtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTZXF1ZW5jZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGJhc2UgJHtiYXNlU2VxdWVuY2V9YCk7XG4gIH1cblxuICBsZXQgbWF4RW5kID0gZW5kO1xuICBhbGlnbmVkU2VxdWVuY2VzLmZvckVhY2goKGFsaWduZWRTZXF1ZW5jZSkgPT4ge1xuICAgIGNvbnN0IG90aGVyRW5kID0gYWxpZ25lZFNlcXVlbmNlLmF0KGFsaWduZWRTZXF1ZW5jZS5sZW5ndGggLSAxKT8uaW5kZXg7XG4gICAgaWYgKG90aGVyRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYG90aGVyU2VxdWVuY2UgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBiYXNlICR7YWxpZ25lZFNlcXVlbmNlfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvdGhlckVuZCA+IG1heEVuZCkge1xuICAgICAgbWF4RW5kID0gb3RoZXJFbmQ7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RhcnRQZXJjID0gc3RhcnQgLyBtYXhFbmQ7XG4gIGNvbnN0IGVuZFBlcmMgPSBlbmQgLyBtYXhFbmQ7XG5cbiAgLy8gbWlzbWF0Y2hlc1xuICBjb25zdCBtaXNtYXRjaGVzID0gYmFzZVNlcXVlbmNlLmZpbHRlcigoYmFzZSkgPT4ge1xuICAgIGNvbnN0IHJvb3RCYXNlID0gYmFzZVNlcXVlbmNlLmF0KGJhc2UuaW5kZXgpO1xuICAgIHJldHVybiByb290QmFzZSAmJiByb290QmFzZS5iYXNlICE9PSBiYXNlLmJhc2U7XG4gIH0pO1xuICBtaXNtYXRjaENsYXNzTmFtZSA9XG4gICAgbWlzbWF0Y2hDbGFzc05hbWUgPz9cbiAgICBmdW5jdGlvbiBtaXNtYXRjaENsYXNzTmFtZShtaXNtYXRjaDogQW5ub3RhdGVkQmFzZSkge1xuICAgICAgaWYgKG1pc21hdGNoLmJhc2UgPT09IFwiLVwiKSB7XG4gICAgICAgIHJldHVybiBcImZpbGwtYmxhY2sgc3Ryb2tlLWJsYWNrIG9wYWNpdHktODBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcImRhcms6ZmlsbC1yZWQtNjAwIGRhcms6c3Ryb2tlLXJlZC02MDAgZmlsbC1yZWQtNzAwIHN0cm9rZS1yZWQtNzAwXCI7XG4gICAgICB9XG4gICAgfTtcblxuICBsZXQgbGFzdFhQZXJjID0gLTE7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxsaW5lXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcIlwiLCBzZXF1ZW5jZUNsYXNzTmFtZSh7IHNlcXVlbmNlSWR4IH0pKX1cbiAgICAgICAgeDE9e2Ake3N0YXJ0UGVyYyAqIDEwMH0lYH1cbiAgICAgICAgeTE9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICB4Mj17YCR7ZW5kUGVyYyAqIDEwMH0lYH1cbiAgICAgICAgeTI9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICBzdHJva2VXaWR0aD17NX1cbiAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgICB7bWlzbWF0Y2hlcy5tYXAoKGJhc2UpID0+IHtcbiAgICAgICAgY29uc3QgeFBlcmMgPSAoYmFzZS5pbmRleCAvIG1heEVuZCkgKiAxMDA7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoKDEgLyBiYXNlU2VxdWVuY2UubGVuZ3RoKSAqIDEwMCwgMC4wMSk7XG4gICAgICAgIGNvbnN0IGRpZmYgPSB4UGVyYyAtIGxhc3RYUGVyYztcbiAgICAgICAgaWYgKGRpZmYgPCBNSVNNQVRDSF9ESVNUX1BFUkNfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgLy8gRGlzcGxheWluZyBldmVyeSBtaXNtYXRjaCBpcyBub3QgcGFydGljdWxhcmx5IGhlbHBmdWwgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZW0uIEhlcmUgd2UgY2hvb3NlIGEgcmVhc29uYWJsZVxuICAgICAgICAgIC8vIHRocmVzaG9sZCBhbmQgb25seSBkaXNwbGF5IGVsZW1lbnRzIHRoYXQgYXJlIHN1ZmZpY2llbnRseSBmYXIgYXBhcnQuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFhQZXJjID0geFBlcmM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGdcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhtaXNtYXRjaENsYXNzTmFtZT8uKGJhc2UpIHx8IFwiYmctcmVkLTQwMFwiKX1cbiAgICAgICAgICAgIGtleT17YHNlcXVlbmNlLSR7c2VxdWVuY2VJZHh9LW1pc21hdGNoLSR7YmFzZS5pbmRleH1gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgIHgxPXtgJHt4UGVyYyAtIHdpZHRoIC8gMn0lYH1cbiAgICAgICAgICAgICAgeTE9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICAgICAgICB4Mj17YCR7eFBlcmMgKyB3aWR0aCAvIDJ9JWB9XG4gICAgICAgICAgICAgIHkyPXtgJHtzZXF1ZW5jZUlkeCAqIDEwICsgMTB9YH1cbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufTtcblxuY29uc3QgTGluZWFyU2VsZWN0aW9uID0gKHtcbiAgc2VsZWN0aW9uLFxuICBzZWxlY3Rpb25SZWYsXG4gIHNldFNlbGVjdGlvbixcbiAgc2VxdWVuY2UsXG4gIHNlbGVjdGlvbkNsYXNzTmFtZSxcbn06IHtcbiAgc2VsZWN0aW9uUmVmOiBSZWFjdC5SZWZPYmplY3Q8U1ZHU1ZHRWxlbWVudD47XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbikgPT4gdm9pZDtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBzZWxlY3Rpb25DbGFzc05hbWU/OiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiBzdHJpbmc7XG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdGFydDogaW50ZXJuYWxTZWxlY3Rpb25TdGFydCxcbiAgICBlbmQ6IGludGVybmFsU2VsZWN0aW9uRW5kLFxuICAgIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24sXG4gIH0gPSB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0KHsgcmVmOiBzZWxlY3Rpb25SZWYgfSk7XG4gIHVzZUVmZmVjdChcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVTZWxlY3Rpb25VcCgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgc2VsZWN0aW9uUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgaW50ZXJuYWxTZWxlY3Rpb25TdGFydCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvbkVuZFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHN2Z1dpZHRoID0gc2VsZWN0aW9uUmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgKGludGVybmFsU2VsZWN0aW9uU3RhcnQueCAvIHN2Z1dpZHRoKSAqIHNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAoaW50ZXJuYWxTZWxlY3Rpb25FbmQueCAvIHN2Z1dpZHRoKSAqIHNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzaG93IGEgdmVyeSBzbWFsbCBmaXJzdCBzZWxlY3Rpb24gcmVzdWx0IGFzIHN0YXJ0ID09PSBlbmQgYmVjYXVzZSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IHdhbnQgdGhlIGVudGlyZSBzZXF1ZW5jZSB0byBiZSBoaWdobGlnaHRlZCBldmVyeSB0aW1lIHRoZXkgY2xpY2tcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsIHx8IHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0ICsgMSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFNlbGVjdGlvbih7IHN0YXJ0LCBlbmQsIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LCBpbnRlcm5hbFNlbGVjdGlvbkVuZF0sXG4gICk7XG5cbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qIERpc3BsYXkgc2VsZWN0aW9uIGRhdGEgdGhhdCBoYXMgdHJpY2tsZWQgZG93biAqL1xuICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlbGVjdGlvbjtcblxuICAvLyBiYXNpYyBjYXNlXG4gIGxldCBmaXJzdFJlY3RTdGFydCA9IChNYXRoLm1pbihzdGFydCwgZW5kKSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIGxldCBmaXJzdFJlY3RXaWR0aCA9XG4gICAgKGdldFN1YnNlcXVlbmNlTGVuZ3RoKHNlbGVjdGlvbiwgc2VxdWVuY2UubGVuZ3RoKSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIGxldCBzZWNvbmRSZWN0U3RhcnQgPSBudWxsO1xuICBsZXQgc2Vjb25kUmVjdFdpZHRoID0gbnVsbDtcblxuICAvLyBUT0RPOiBhYnN0cmFjdCB0aGlzIGFuZCBsb2dpYyBpbiBMaW5lYXJBbm5vdGF0aW9uIGludG8gaGVscGVyIGZ1bmN0aW9uc1xuICBjb25zdCBzZWxlY3Rpb25TcGFuc1NlYW0gPSBzZWxlY3Rpb24uc3RhcnQgPiBzZWxlY3Rpb24uZW5kO1xuXG4gIC8qIGlmIGRpcmVjdGlvbiBpcyBiYWNrd2FyZCBhbmQgZW5kID4gc3RhcnQgd2UgbmVlZCB0byByZW5kZXIgdHdvIHJlY3RhbmdsZXMgKi9cbiAgaWYgKHNlbGVjdGlvblNwYW5zU2VhbSkge1xuICAgIGZpcnN0UmVjdFN0YXJ0ID0gMDtcbiAgICBmaXJzdFJlY3RXaWR0aCA9IChlbmQgLyBzZXF1ZW5jZS5sZW5ndGgpICogMTAwO1xuICAgIHNlY29uZFJlY3RTdGFydCA9IChzdGFydCAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gICAgc2Vjb25kUmVjdFdpZHRoID0gKChzZXF1ZW5jZS5sZW5ndGggLSBzdGFydCkgLyBzZXF1ZW5jZS5sZW5ndGgpICogMTAwO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8Z1xuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICBcImZpbGwtY3VycmVudCBzdHJva2UtY3VycmVudFwiLFxuICAgICAgICBzZWxlY3Rpb25DbGFzc05hbWU/LihzZWxlY3Rpb24pLFxuICAgICAgKX1cbiAgICA+XG4gICAgICA8cmVjdFxuICAgICAgICB4PXtgJHtmaXJzdFJlY3RTdGFydH0lYH1cbiAgICAgICAgd2lkdGg9e2Ake2ZpcnN0UmVjdFdpZHRofSVgfVxuICAgICAgICB5PXtgMCVgfVxuICAgICAgICBoZWlnaHQ9e2AxMDAlYH1cbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIGZpbGxPcGFjaXR5PXswLjJ9XG4gICAgICAgIHN0cm9rZVdpZHRoPXsxLjV9XG4gICAgICAvPlxuICAgICAge3NlY29uZFJlY3RTdGFydCAmJiBzZWNvbmRSZWN0V2lkdGggJiYgKFxuICAgICAgICA8cmVjdFxuICAgICAgICAgIHg9e2Ake3NlY29uZFJlY3RTdGFydH0lYH1cbiAgICAgICAgICB3aWR0aD17YCR7c2Vjb25kUmVjdFdpZHRofSVgfVxuICAgICAgICAgIHk9e2AwJWB9XG4gICAgICAgICAgaGVpZ2h0PXtgMTAwJWB9XG4gICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgZmlsbE9wYWNpdHk9ezAuMn1cbiAgICAgICAgICBzdHJva2VXaWR0aD17MS41fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICA8L2c+XG4gICk7XG59O1xuIiwiLy8gcGFja2FnZXMvY29yZS9udW1iZXIvc3JjL251bWJlci50c1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIFttaW4sIG1heF0pIHtcbiAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xufVxuZXhwb3J0IHtcbiAgY2xhbXBcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9jb3JlL3ByaW1pdGl2ZS9zcmMvcHJpbWl0aXZlLnRzeFxuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnMob3JpZ2luYWxFdmVudEhhbmRsZXIsIG91ckV2ZW50SGFuZGxlciwgeyBjaGVja0ZvckRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlIH0gPSB7fSkge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBvcmlnaW5hbEV2ZW50SGFuZGxlcj8uKGV2ZW50KTtcbiAgICBpZiAoY2hlY2tGb3JEZWZhdWx0UHJldmVudGVkID09PSBmYWxzZSB8fCAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuIG91ckV2ZW50SGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBjb21wb3NlRXZlbnRIYW5kbGVyc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L2NvbnRleHQvc3JjL2NyZWF0ZUNvbnRleHQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dDIocm9vdENvbXBvbmVudE5hbWUsIGRlZmF1bHRDb250ZXh0KSB7XG4gIGNvbnN0IENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRDb250ZXh0KTtcbiAgY29uc3QgUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5jb250ZXh0IH0gPSBwcm9wcztcbiAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29udGV4dCwgT2JqZWN0LnZhbHVlcyhjb250ZXh0KSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZSwgY2hpbGRyZW4gfSk7XG4gIH07XG4gIFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gcm9vdENvbXBvbmVudE5hbWUgKyBcIlByb3ZpZGVyXCI7XG4gIGZ1bmN0aW9uIHVzZUNvbnRleHQyKGNvbnN1bWVyTmFtZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpO1xuICAgIGlmIChjb250ZXh0KSByZXR1cm4gY29udGV4dDtcbiAgICBpZiAoZGVmYXVsdENvbnRleHQgIT09IHZvaWQgMCkgcmV0dXJuIGRlZmF1bHRDb250ZXh0O1xuICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtjb25zdW1lck5hbWV9XFxgIG11c3QgYmUgdXNlZCB3aXRoaW4gXFxgJHtyb290Q29tcG9uZW50TmFtZX1cXGBgKTtcbiAgfVxuICByZXR1cm4gW1Byb3ZpZGVyLCB1c2VDb250ZXh0Ml07XG59XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0U2NvcGUoc2NvcGVOYW1lLCBjcmVhdGVDb250ZXh0U2NvcGVEZXBzID0gW10pIHtcbiAgbGV0IGRlZmF1bHRDb250ZXh0cyA9IFtdO1xuICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0Myhyb290Q29tcG9uZW50TmFtZSwgZGVmYXVsdENvbnRleHQpIHtcbiAgICBjb25zdCBCYXNlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbnRleHQpO1xuICAgIGNvbnN0IGluZGV4ID0gZGVmYXVsdENvbnRleHRzLmxlbmd0aDtcbiAgICBkZWZhdWx0Q29udGV4dHMgPSBbLi4uZGVmYXVsdENvbnRleHRzLCBkZWZhdWx0Q29udGV4dF07XG4gICAgY29uc3QgUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuLCAuLi5jb250ZXh0IH0gPSBwcm9wcztcbiAgICAgIGNvbnN0IENvbnRleHQgPSBzY29wZT8uW3Njb3BlTmFtZV0/LltpbmRleF0gfHwgQmFzZUNvbnRleHQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29udGV4dCwgT2JqZWN0LnZhbHVlcyhjb250ZXh0KSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlLCBjaGlsZHJlbiB9KTtcbiAgICB9O1xuICAgIFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gcm9vdENvbXBvbmVudE5hbWUgKyBcIlByb3ZpZGVyXCI7XG4gICAgZnVuY3Rpb24gdXNlQ29udGV4dDIoY29uc3VtZXJOYW1lLCBzY29wZSkge1xuICAgICAgY29uc3QgQ29udGV4dCA9IHNjb3BlPy5bc2NvcGVOYW1lXT8uW2luZGV4XSB8fCBCYXNlQ29udGV4dDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpO1xuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0O1xuICAgICAgaWYgKGRlZmF1bHRDb250ZXh0ICE9PSB2b2lkIDApIHJldHVybiBkZWZhdWx0Q29udGV4dDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtjb25zdW1lck5hbWV9XFxgIG11c3QgYmUgdXNlZCB3aXRoaW4gXFxgJHtyb290Q29tcG9uZW50TmFtZX1cXGBgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtQcm92aWRlciwgdXNlQ29udGV4dDJdO1xuICB9XG4gIGNvbnN0IGNyZWF0ZVNjb3BlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlQ29udGV4dHMgPSBkZWZhdWx0Q29udGV4dHMubWFwKChkZWZhdWx0Q29udGV4dCkgPT4ge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbnRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VTY29wZShzY29wZSkge1xuICAgICAgY29uc3QgY29udGV4dHMgPSBzY29wZT8uW3Njb3BlTmFtZV0gfHwgc2NvcGVDb250ZXh0cztcbiAgICAgIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICAgICAoKSA9PiAoeyBbYF9fc2NvcGUke3Njb3BlTmFtZX1gXTogeyAuLi5zY29wZSwgW3Njb3BlTmFtZV06IGNvbnRleHRzIH0gfSksXG4gICAgICAgIFtzY29wZSwgY29udGV4dHNdXG4gICAgICApO1xuICAgIH07XG4gIH07XG4gIGNyZWF0ZVNjb3BlLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgcmV0dXJuIFtjcmVhdGVDb250ZXh0MywgY29tcG9zZUNvbnRleHRTY29wZXMoY3JlYXRlU2NvcGUsIC4uLmNyZWF0ZUNvbnRleHRTY29wZURlcHMpXTtcbn1cbmZ1bmN0aW9uIGNvbXBvc2VDb250ZXh0U2NvcGVzKC4uLnNjb3Blcykge1xuICBjb25zdCBiYXNlU2NvcGUgPSBzY29wZXNbMF07XG4gIGlmIChzY29wZXMubGVuZ3RoID09PSAxKSByZXR1cm4gYmFzZVNjb3BlO1xuICBjb25zdCBjcmVhdGVTY29wZSA9ICgpID0+IHtcbiAgICBjb25zdCBzY29wZUhvb2tzID0gc2NvcGVzLm1hcCgoY3JlYXRlU2NvcGUyKSA9PiAoe1xuICAgICAgdXNlU2NvcGU6IGNyZWF0ZVNjb3BlMigpLFxuICAgICAgc2NvcGVOYW1lOiBjcmVhdGVTY29wZTIuc2NvcGVOYW1lXG4gICAgfSkpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VDb21wb3NlZFNjb3BlcyhvdmVycmlkZVNjb3Blcykge1xuICAgICAgY29uc3QgbmV4dFNjb3BlcyA9IHNjb3BlSG9va3MucmVkdWNlKChuZXh0U2NvcGVzMiwgeyB1c2VTY29wZSwgc2NvcGVOYW1lIH0pID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcGVQcm9wcyA9IHVzZVNjb3BlKG92ZXJyaWRlU2NvcGVzKTtcbiAgICAgICAgY29uc3QgY3VycmVudFNjb3BlID0gc2NvcGVQcm9wc1tgX19zY29wZSR7c2NvcGVOYW1lfWBdO1xuICAgICAgICByZXR1cm4geyAuLi5uZXh0U2NvcGVzMiwgLi4uY3VycmVudFNjb3BlIH07XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoeyBbYF9fc2NvcGUke2Jhc2VTY29wZS5zY29wZU5hbWV9YF06IG5leHRTY29wZXMgfSksIFtuZXh0U2NvcGVzXSk7XG4gICAgfTtcbiAgfTtcbiAgY3JlYXRlU2NvcGUuc2NvcGVOYW1lID0gYmFzZVNjb3BlLnNjb3BlTmFtZTtcbiAgcmV0dXJuIGNyZWF0ZVNjb3BlO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlQ29udGV4dDIgYXMgY3JlYXRlQ29udGV4dCxcbiAgY3JlYXRlQ29udGV4dFNjb3BlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvY29tcG9zZS1yZWZzL3NyYy9jb21wb3NlUmVmcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gc2V0UmVmKHJlZiwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiByZWYodmFsdWUpO1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHZvaWQgMCkge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgbGV0IGhhc0NsZWFudXAgPSBmYWxzZTtcbiAgICBjb25zdCBjbGVhbnVwcyA9IHJlZnMubWFwKChyZWYpID0+IHtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSBzZXRSZWYocmVmLCBub2RlKTtcbiAgICAgIGlmICghaGFzQ2xlYW51cCAmJiB0eXBlb2YgY2xlYW51cCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaGFzQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9KTtcbiAgICBpZiAoaGFzQ2xlYW51cCkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGVhbnVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBjbGVhbnVwc1tpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNsZWFudXAgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFJlZihyZWZzW2ldLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlQ29tcG9zZWRSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGNvbXBvc2VSZWZzKC4uLnJlZnMpLCByZWZzKTtcbn1cbmV4cG9ydCB7XG4gIGNvbXBvc2VSZWZzLFxuICB1c2VDb21wb3NlZFJlZnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9zbG90L3NyYy9zbG90LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjb21wb3NlUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDIsIGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNsb3QgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnNsb3RQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcbiAgY29uc3Qgc2xvdHRhYmxlID0gY2hpbGRyZW5BcnJheS5maW5kKGlzU2xvdHRhYmxlKTtcbiAgaWYgKHNsb3R0YWJsZSkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBzbG90dGFibGUucHJvcHMuY2hpbGRyZW47XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBjaGlsZHJlbkFycmF5Lm1hcCgoY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZCA9PT0gc2xvdHRhYmxlKSB7XG4gICAgICAgIGlmIChSZWFjdC5DaGlsZHJlbi5jb3VudChuZXdFbGVtZW50KSA+IDEpIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KG51bGwpO1xuICAgICAgICByZXR1cm4gUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV3RWxlbWVudCkgPyBuZXdFbGVtZW50LnByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90Q2xvbmUsIHsgLi4uc2xvdFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiwgY2hpbGRyZW46IFJlYWN0LmlzVmFsaWRFbGVtZW50KG5ld0VsZW1lbnQpID8gUmVhY3QuY2xvbmVFbGVtZW50KG5ld0VsZW1lbnQsIHZvaWQgMCwgbmV3Q2hpbGRyZW4pIDogbnVsbCB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90Q2xvbmUsIHsgLi4uc2xvdFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiwgY2hpbGRyZW4gfSk7XG59KTtcblNsb3QuZGlzcGxheU5hbWUgPSBcIlNsb3RcIjtcbnZhciBTbG90Q2xvbmUgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnNsb3RQcm9wcyB9ID0gcHJvcHM7XG4gIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjb25zdCBjaGlsZHJlblJlZiA9IGdldEVsZW1lbnRSZWYoY2hpbGRyZW4pO1xuICAgIGNvbnN0IHByb3BzMiA9IG1lcmdlUHJvcHMoc2xvdFByb3BzLCBjaGlsZHJlbi5wcm9wcyk7XG4gICAgaWYgKGNoaWxkcmVuLnR5cGUgIT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICBwcm9wczIucmVmID0gZm9yd2FyZGVkUmVmID8gY29tcG9zZVJlZnMoZm9yd2FyZGVkUmVmLCBjaGlsZHJlblJlZikgOiBjaGlsZHJlblJlZjtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgcHJvcHMyKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID4gMSA/IFJlYWN0LkNoaWxkcmVuLm9ubHkobnVsbCkgOiBudWxsO1xufSk7XG5TbG90Q2xvbmUuZGlzcGxheU5hbWUgPSBcIlNsb3RDbG9uZVwiO1xudmFyIFNsb3R0YWJsZSA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQyLCB7IGNoaWxkcmVuIH0pO1xufTtcbmZ1bmN0aW9uIGlzU2xvdHRhYmxlKGNoaWxkKSB7XG4gIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgY2hpbGQudHlwZSA9PT0gU2xvdHRhYmxlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhzbG90UHJvcHMsIGNoaWxkUHJvcHMpIHtcbiAgY29uc3Qgb3ZlcnJpZGVQcm9wcyA9IHsgLi4uY2hpbGRQcm9wcyB9O1xuICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIGNoaWxkUHJvcHMpIHtcbiAgICBjb25zdCBzbG90UHJvcFZhbHVlID0gc2xvdFByb3BzW3Byb3BOYW1lXTtcbiAgICBjb25zdCBjaGlsZFByb3BWYWx1ZSA9IGNoaWxkUHJvcHNbcHJvcE5hbWVdO1xuICAgIGNvbnN0IGlzSGFuZGxlciA9IC9eb25bQS1aXS8udGVzdChwcm9wTmFtZSk7XG4gICAgaWYgKGlzSGFuZGxlcikge1xuICAgICAgaWYgKHNsb3RQcm9wVmFsdWUgJiYgY2hpbGRQcm9wVmFsdWUpIHtcbiAgICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGNoaWxkUHJvcFZhbHVlKC4uLmFyZ3MpO1xuICAgICAgICAgIHNsb3RQcm9wVmFsdWUoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHNsb3RQcm9wVmFsdWUpIHtcbiAgICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSBzbG90UHJvcFZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSB7IC4uLnNsb3RQcm9wVmFsdWUsIC4uLmNoaWxkUHJvcFZhbHVlIH07XG4gICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCJjbGFzc05hbWVcIikge1xuICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSBbc2xvdFByb3BWYWx1ZSwgY2hpbGRQcm9wVmFsdWVdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgLi4uc2xvdFByb3BzLCAuLi5vdmVycmlkZVByb3BzIH07XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UmVmKGVsZW1lbnQpIHtcbiAgbGV0IGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWxlbWVudC5wcm9wcywgXCJyZWZcIik/LmdldDtcbiAgbGV0IG1heVdhcm4gPSBnZXR0ZXIgJiYgXCJpc1JlYWN0V2FybmluZ1wiIGluIGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmc7XG4gIGlmIChtYXlXYXJuKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQucmVmO1xuICB9XG4gIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWxlbWVudCwgXCJyZWZcIik/LmdldDtcbiAgbWF5V2FybiA9IGdldHRlciAmJiBcImlzUmVhY3RXYXJuaW5nXCIgaW4gZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZztcbiAgaWYgKG1heVdhcm4pIHtcbiAgICByZXR1cm4gZWxlbWVudC5wcm9wcy5yZWY7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucHJvcHMucmVmIHx8IGVsZW1lbnQucmVmO1xufVxudmFyIFJvb3QgPSBTbG90O1xuZXhwb3J0IHtcbiAgUm9vdCxcbiAgU2xvdCxcbiAgU2xvdHRhYmxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L2NvbGxlY3Rpb24vc3JjL2NvbGxlY3Rpb24udHN4XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0U2NvcGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb24obmFtZSkge1xuICBjb25zdCBQUk9WSURFUl9OQU1FID0gbmFtZSArIFwiQ29sbGVjdGlvblByb3ZpZGVyXCI7XG4gIGNvbnN0IFtjcmVhdGVDb2xsZWN0aW9uQ29udGV4dCwgY3JlYXRlQ29sbGVjdGlvblNjb3BlXSA9IGNyZWF0ZUNvbnRleHRTY29wZShQUk9WSURFUl9OQU1FKTtcbiAgY29uc3QgW0NvbGxlY3Rpb25Qcm92aWRlckltcGwsIHVzZUNvbGxlY3Rpb25Db250ZXh0XSA9IGNyZWF0ZUNvbGxlY3Rpb25Db250ZXh0KFxuICAgIFBST1ZJREVSX05BTUUsXG4gICAgeyBjb2xsZWN0aW9uUmVmOiB7IGN1cnJlbnQ6IG51bGwgfSwgaXRlbU1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9XG4gICk7XG4gIGNvbnN0IENvbGxlY3Rpb25Qcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaXRlbU1hcCA9IFJlYWN0LnVzZVJlZigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKS5jdXJyZW50O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb25Qcm92aWRlckltcGwsIHsgc2NvcGUsIGl0ZW1NYXAsIGNvbGxlY3Rpb25SZWY6IHJlZiwgY2hpbGRyZW4gfSk7XG4gIH07XG4gIENvbGxlY3Rpb25Qcm92aWRlci5kaXNwbGF5TmFtZSA9IFBST1ZJREVSX05BTUU7XG4gIGNvbnN0IENPTExFQ1RJT05fU0xPVF9OQU1FID0gbmFtZSArIFwiQ29sbGVjdGlvblNsb3RcIjtcbiAgY29uc3QgQ29sbGVjdGlvblNsb3QgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAgIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgICBjb25zdCB7IHNjb3BlLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29sbGVjdGlvbkNvbnRleHQoQ09MTEVDVElPTl9TTE9UX05BTUUsIHNjb3BlKTtcbiAgICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRleHQuY29sbGVjdGlvblJlZik7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90LCB7IHJlZjogY29tcG9zZWRSZWZzLCBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICk7XG4gIENvbGxlY3Rpb25TbG90LmRpc3BsYXlOYW1lID0gQ09MTEVDVElPTl9TTE9UX05BTUU7XG4gIGNvbnN0IElURU1fU0xPVF9OQU1FID0gbmFtZSArIFwiQ29sbGVjdGlvbkl0ZW1TbG90XCI7XG4gIGNvbnN0IElURU1fREFUQV9BVFRSID0gXCJkYXRhLXJhZGl4LWNvbGxlY3Rpb24taXRlbVwiO1xuICBjb25zdCBDb2xsZWN0aW9uSXRlbVNsb3QgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAgIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgICBjb25zdCB7IHNjb3BlLCBjaGlsZHJlbiwgLi4uaXRlbURhdGEgfSA9IHByb3BzO1xuICAgICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb2xsZWN0aW9uQ29udGV4dChJVEVNX1NMT1RfTkFNRSwgc2NvcGUpO1xuICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udGV4dC5pdGVtTWFwLnNldChyZWYsIHsgcmVmLCAuLi5pdGVtRGF0YSB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHZvaWQgY29udGV4dC5pdGVtTWFwLmRlbGV0ZShyZWYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90LCB7IC4uLnsgW0lURU1fREFUQV9BVFRSXTogXCJcIiB9LCByZWY6IGNvbXBvc2VkUmVmcywgY2hpbGRyZW4gfSk7XG4gICAgfVxuICApO1xuICBDb2xsZWN0aW9uSXRlbVNsb3QuZGlzcGxheU5hbWUgPSBJVEVNX1NMT1RfTkFNRTtcbiAgZnVuY3Rpb24gdXNlQ29sbGVjdGlvbihzY29wZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb2xsZWN0aW9uQ29udGV4dChuYW1lICsgXCJDb2xsZWN0aW9uQ29uc3VtZXJcIiwgc2NvcGUpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdGlvbk5vZGUgPSBjb250ZXh0LmNvbGxlY3Rpb25SZWYuY3VycmVudDtcbiAgICAgIGlmICghY29sbGVjdGlvbk5vZGUpIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IG9yZGVyZWROb2RlcyA9IEFycmF5LmZyb20oY29sbGVjdGlvbk5vZGUucXVlcnlTZWxlY3RvckFsbChgWyR7SVRFTV9EQVRBX0FUVFJ9XWApKTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShjb250ZXh0Lml0ZW1NYXAudmFsdWVzKCkpO1xuICAgICAgY29uc3Qgb3JkZXJlZEl0ZW1zID0gaXRlbXMuc29ydChcbiAgICAgICAgKGEsIGIpID0+IG9yZGVyZWROb2Rlcy5pbmRleE9mKGEucmVmLmN1cnJlbnQpIC0gb3JkZXJlZE5vZGVzLmluZGV4T2YoYi5yZWYuY3VycmVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4gb3JkZXJlZEl0ZW1zO1xuICAgIH0sIFtjb250ZXh0LmNvbGxlY3Rpb25SZWYsIGNvbnRleHQuaXRlbU1hcF0pO1xuICAgIHJldHVybiBnZXRJdGVtcztcbiAgfVxuICByZXR1cm4gW1xuICAgIHsgUHJvdmlkZXI6IENvbGxlY3Rpb25Qcm92aWRlciwgU2xvdDogQ29sbGVjdGlvblNsb3QsIEl0ZW1TbG90OiBDb2xsZWN0aW9uSXRlbVNsb3QgfSxcbiAgICB1c2VDb2xsZWN0aW9uLFxuICAgIGNyZWF0ZUNvbGxlY3Rpb25TY29wZVxuICBdO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlQ29sbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L2RpcmVjdGlvbi9zcmMvRGlyZWN0aW9uLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBEaXJlY3Rpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xudmFyIERpcmVjdGlvblByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgZGlyLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KERpcmVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRpciwgY2hpbGRyZW4gfSk7XG59O1xuZnVuY3Rpb24gdXNlRGlyZWN0aW9uKGxvY2FsRGlyKSB7XG4gIGNvbnN0IGdsb2JhbERpciA9IFJlYWN0LnVzZUNvbnRleHQoRGlyZWN0aW9uQ29udGV4dCk7XG4gIHJldHVybiBsb2NhbERpciB8fCBnbG9iYWxEaXIgfHwgXCJsdHJcIjtcbn1cbnZhciBQcm92aWRlciA9IERpcmVjdGlvblByb3ZpZGVyO1xuZXhwb3J0IHtcbiAgRGlyZWN0aW9uUHJvdmlkZXIsXG4gIFByb3ZpZGVyLFxuICB1c2VEaXJlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9wcmltaXRpdmUvc3JjL3ByaW1pdGl2ZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgU2xvdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3Qtc2xvdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTk9ERVMgPSBbXG4gIFwiYVwiLFxuICBcImJ1dHRvblwiLFxuICBcImRpdlwiLFxuICBcImZvcm1cIixcbiAgXCJoMlwiLFxuICBcImgzXCIsXG4gIFwiaW1nXCIsXG4gIFwiaW5wdXRcIixcbiAgXCJsYWJlbFwiLFxuICBcImxpXCIsXG4gIFwibmF2XCIsXG4gIFwib2xcIixcbiAgXCJwXCIsXG4gIFwic3BhblwiLFxuICBcInN2Z1wiLFxuICBcInVsXCJcbl07XG52YXIgUHJpbWl0aXZlID0gTk9ERVMucmVkdWNlKChwcmltaXRpdmUsIG5vZGUpID0+IHtcbiAgY29uc3QgTm9kZSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IGFzQ2hpbGQsIC4uLnByaW1pdGl2ZVByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBDb21wID0gYXNDaGlsZCA/IFNsb3QgOiBub2RlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3dbU3ltYm9sLmZvcihcInJhZGl4LXVpXCIpXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENvbXAsIHsgLi4ucHJpbWl0aXZlUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pO1xuICB9KTtcbiAgTm9kZS5kaXNwbGF5TmFtZSA9IGBQcmltaXRpdmUuJHtub2RlfWA7XG4gIHJldHVybiB7IC4uLnByaW1pdGl2ZSwgW25vZGVdOiBOb2RlIH07XG59LCB7fSk7XG5mdW5jdGlvbiBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnQodGFyZ2V0LCBldmVudCkge1xuICBpZiAodGFyZ2V0KSBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpKTtcbn1cbnZhciBSb290ID0gUHJpbWl0aXZlO1xuZXhwb3J0IHtcbiAgUHJpbWl0aXZlLFxuICBSb290LFxuICBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtY2FsbGJhY2stcmVmL3NyYy91c2VDYWxsYmFja1JlZi50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoY2FsbGJhY2spIHtcbiAgY29uc3QgY2FsbGJhY2tSZWYgPSBSZWFjdC51c2VSZWYoY2FsbGJhY2spO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICguLi5hcmdzKSA9PiBjYWxsYmFja1JlZi5jdXJyZW50Py4oLi4uYXJncyksIFtdKTtcbn1cbmV4cG9ydCB7XG4gIHVzZUNhbGxiYWNrUmVmXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLWVzY2FwZS1rZXlkb3duL3NyYy91c2VFc2NhcGVLZXlkb3duLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuZnVuY3Rpb24gdXNlRXNjYXBlS2V5ZG93bihvbkVzY2FwZUtleURvd25Qcm9wLCBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcz8uZG9jdW1lbnQpIHtcbiAgY29uc3Qgb25Fc2NhcGVLZXlEb3duID0gdXNlQ2FsbGJhY2tSZWYob25Fc2NhcGVLZXlEb3duUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICBvbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IG93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93biwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICB9LCBbb25Fc2NhcGVLZXlEb3duLCBvd25lckRvY3VtZW50XSk7XG59XG5leHBvcnQge1xuICB1c2VFc2NhcGVLZXlkb3duXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L2Rpc21pc3NhYmxlLWxheWVyL3NyYy9kaXNtaXNzYWJsZS1sYXllci50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY29tcG9zZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiQHJhZGl4LXVpL3ByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlLCBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnQgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5pbXBvcnQgeyB1c2VFc2NhcGVLZXlkb3duIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtZXNjYXBlLWtleWRvd25cIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIERJU01JU1NBQkxFX0xBWUVSX05BTUUgPSBcIkRpc21pc3NhYmxlTGF5ZXJcIjtcbnZhciBDT05URVhUX1VQREFURSA9IFwiZGlzbWlzc2FibGVMYXllci51cGRhdGVcIjtcbnZhciBQT0lOVEVSX0RPV05fT1VUU0lERSA9IFwiZGlzbWlzc2FibGVMYXllci5wb2ludGVyRG93bk91dHNpZGVcIjtcbnZhciBGT0NVU19PVVRTSURFID0gXCJkaXNtaXNzYWJsZUxheWVyLmZvY3VzT3V0c2lkZVwiO1xudmFyIG9yaWdpbmFsQm9keVBvaW50ZXJFdmVudHM7XG52YXIgRGlzbWlzc2FibGVMYXllckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgbGF5ZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBsYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgYnJhbmNoZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbn0pO1xudmFyIERpc21pc3NhYmxlTGF5ZXIgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cyA9IGZhbHNlLFxuICAgICAgb25Fc2NhcGVLZXlEb3duLFxuICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUsXG4gICAgICBvbkZvY3VzT3V0c2lkZSxcbiAgICAgIG9uSW50ZXJhY3RPdXRzaWRlLFxuICAgICAgb25EaXNtaXNzLFxuICAgICAgLi4ubGF5ZXJQcm9wc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEaXNtaXNzYWJsZUxheWVyQ29udGV4dCk7XG4gICAgY29uc3QgW25vZGUsIHNldE5vZGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IG5vZGU/Lm93bmVyRG9jdW1lbnQgPz8gZ2xvYmFsVGhpcz8uZG9jdW1lbnQ7XG4gICAgY29uc3QgWywgZm9yY2VdID0gUmVhY3QudXNlU3RhdGUoe30pO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlMikgPT4gc2V0Tm9kZShub2RlMikpO1xuICAgIGNvbnN0IGxheWVycyA9IEFycmF5LmZyb20oY29udGV4dC5sYXllcnMpO1xuICAgIGNvbnN0IFtoaWdoZXN0TGF5ZXJXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZF0gPSBbLi4uY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZF0uc2xpY2UoLTEpO1xuICAgIGNvbnN0IGhpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkSW5kZXggPSBsYXllcnMuaW5kZXhPZihoaWdoZXN0TGF5ZXJXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZCk7XG4gICAgY29uc3QgaW5kZXggPSBub2RlID8gbGF5ZXJzLmluZGV4T2Yobm9kZSkgOiAtMTtcbiAgICBjb25zdCBpc0JvZHlQb2ludGVyRXZlbnRzRGlzYWJsZWQgPSBjb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkLnNpemUgPiAwO1xuICAgIGNvbnN0IGlzUG9pbnRlckV2ZW50c0VuYWJsZWQgPSBpbmRleCA+PSBoaWdoZXN0TGF5ZXJXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZEluZGV4O1xuICAgIGNvbnN0IHBvaW50ZXJEb3duT3V0c2lkZSA9IHVzZVBvaW50ZXJEb3duT3V0c2lkZSgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGNvbnN0IGlzUG9pbnRlckRvd25PbkJyYW5jaCA9IFsuLi5jb250ZXh0LmJyYW5jaGVzXS5zb21lKChicmFuY2gpID0+IGJyYW5jaC5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgIGlmICghaXNQb2ludGVyRXZlbnRzRW5hYmxlZCB8fCBpc1BvaW50ZXJEb3duT25CcmFuY2gpIHJldHVybjtcbiAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlPy4oZXZlbnQpO1xuICAgICAgb25JbnRlcmFjdE91dHNpZGU/LihldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIG9uRGlzbWlzcz8uKCk7XG4gICAgfSwgb3duZXJEb2N1bWVudCk7XG4gICAgY29uc3QgZm9jdXNPdXRzaWRlID0gdXNlRm9jdXNPdXRzaWRlKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgaXNGb2N1c0luQnJhbmNoID0gWy4uLmNvbnRleHQuYnJhbmNoZXNdLnNvbWUoKGJyYW5jaCkgPT4gYnJhbmNoLmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgaWYgKGlzRm9jdXNJbkJyYW5jaCkgcmV0dXJuO1xuICAgICAgb25Gb2N1c091dHNpZGU/LihldmVudCk7XG4gICAgICBvbkludGVyYWN0T3V0c2lkZT8uKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgb25EaXNtaXNzPy4oKTtcbiAgICB9LCBvd25lckRvY3VtZW50KTtcbiAgICB1c2VFc2NhcGVLZXlkb3duKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgaXNIaWdoZXN0TGF5ZXIgPSBpbmRleCA9PT0gY29udGV4dC5sYXllcnMuc2l6ZSAtIDE7XG4gICAgICBpZiAoIWlzSGlnaGVzdExheWVyKSByZXR1cm47XG4gICAgICBvbkVzY2FwZUtleURvd24/LihldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgb25EaXNtaXNzKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uRGlzbWlzcygpO1xuICAgICAgfVxuICAgIH0sIG93bmVyRG9jdW1lbnQpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgIGlmIChkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHQubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIG9yaWdpbmFsQm9keVBvaW50ZXJFdmVudHMgPSBvd25lckRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cztcbiAgICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuYWRkKG5vZGUpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5sYXllcnMuYWRkKG5vZGUpO1xuICAgICAgZGlzcGF0Y2hVcGRhdGUoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHMgJiYgY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5zaXplID09PSAxKSB7XG4gICAgICAgICAgb3duZXJEb2N1bWVudC5ib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBvcmlnaW5hbEJvZHlQb2ludGVyRXZlbnRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtub2RlLCBvd25lckRvY3VtZW50LCBkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHMsIGNvbnRleHRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgIGNvbnRleHQubGF5ZXJzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5kZWxldGUobm9kZSk7XG4gICAgICAgIGRpc3BhdGNoVXBkYXRlKCk7XG4gICAgICB9O1xuICAgIH0sIFtub2RlLCBjb250ZXh0XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IGZvcmNlKHt9KTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoQ09OVEVYVF9VUERBVEUsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05URVhUX1VQREFURSwgaGFuZGxlVXBkYXRlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuZGl2LFxuICAgICAge1xuICAgICAgICAuLi5sYXllclByb3BzLFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBpc0JvZHlQb2ludGVyRXZlbnRzRGlzYWJsZWQgPyBpc1BvaW50ZXJFdmVudHNFbmFibGVkID8gXCJhdXRvXCIgOiBcIm5vbmVcIiA6IHZvaWQgMCxcbiAgICAgICAgICAuLi5wcm9wcy5zdHlsZVxuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzQ2FwdHVyZTogY29tcG9zZUV2ZW50SGFuZGxlcnMocHJvcHMub25Gb2N1c0NhcHR1cmUsIGZvY3VzT3V0c2lkZS5vbkZvY3VzQ2FwdHVyZSksXG4gICAgICAgIG9uQmx1ckNhcHR1cmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKHByb3BzLm9uQmx1ckNhcHR1cmUsIGZvY3VzT3V0c2lkZS5vbkJsdXJDYXB0dXJlKSxcbiAgICAgICAgb25Qb2ludGVyRG93bkNhcHR1cmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKFxuICAgICAgICAgIHByb3BzLm9uUG9pbnRlckRvd25DYXB0dXJlLFxuICAgICAgICAgIHBvaW50ZXJEb3duT3V0c2lkZS5vblBvaW50ZXJEb3duQ2FwdHVyZVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcbkRpc21pc3NhYmxlTGF5ZXIuZGlzcGxheU5hbWUgPSBESVNNSVNTQUJMRV9MQVlFUl9OQU1FO1xudmFyIEJSQU5DSF9OQU1FID0gXCJEaXNtaXNzYWJsZUxheWVyQnJhbmNoXCI7XG52YXIgRGlzbWlzc2FibGVMYXllckJyYW5jaCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGlzbWlzc2FibGVMYXllckNvbnRleHQpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHJlZik7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICBjb250ZXh0LmJyYW5jaGVzLmFkZChub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRleHQuYnJhbmNoZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtjb250ZXh0LmJyYW5jaGVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgLi4ucHJvcHMsIHJlZjogY29tcG9zZWRSZWZzIH0pO1xufSk7XG5EaXNtaXNzYWJsZUxheWVyQnJhbmNoLmRpc3BsYXlOYW1lID0gQlJBTkNIX05BTUU7XG5mdW5jdGlvbiB1c2VQb2ludGVyRG93bk91dHNpZGUob25Qb2ludGVyRG93bk91dHNpZGUsIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzPy5kb2N1bWVudCkge1xuICBjb25zdCBoYW5kbGVQb2ludGVyRG93bk91dHNpZGUgPSB1c2VDYWxsYmFja1JlZihvblBvaW50ZXJEb3duT3V0c2lkZSk7XG4gIGNvbnN0IGlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGhhbmRsZUNsaWNrUmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgJiYgIWlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxldCBoYW5kbGVBbmREaXNwYXRjaFBvaW50ZXJEb3duT3V0c2lkZUV2ZW50MiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGhhbmRsZUFuZERpc3BhdGNoQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICBQT0lOVEVSX0RPV05fT1VUU0lERSxcbiAgICAgICAgICAgIGhhbmRsZVBvaW50ZXJEb3duT3V0c2lkZSxcbiAgICAgICAgICAgIGV2ZW50RGV0YWlsLFxuICAgICAgICAgICAgeyBkaXNjcmV0ZTogdHJ1ZSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQgPSBoYW5kbGVBbmREaXNwYXRjaFBvaW50ZXJEb3duT3V0c2lkZUV2ZW50MjtcbiAgICAgICAgY29uc3QgZXZlbnREZXRhaWwgPSB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50IH07XG4gICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCk7XG4gICAgICAgICAgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCA9IGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyO1xuICAgICAgICAgIG93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrUmVmLmN1cnJlbnQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVBbmREaXNwYXRjaFBvaW50ZXJEb3duT3V0c2lkZUV2ZW50MigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGlja1JlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lcklkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgIH0sIDApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW293bmVyRG9jdW1lbnQsIGhhbmRsZVBvaW50ZXJEb3duT3V0c2lkZV0pO1xuICByZXR1cm4ge1xuICAgIC8vIGVuc3VyZXMgd2UgY2hlY2sgUmVhY3QgY29tcG9uZW50IHRyZWUgKG5vdCBqdXN0IERPTSB0cmVlKVxuICAgIG9uUG9pbnRlckRvd25DYXB0dXJlOiAoKSA9PiBpc1BvaW50ZXJJbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUZvY3VzT3V0c2lkZShvbkZvY3VzT3V0c2lkZSwgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXM/LmRvY3VtZW50KSB7XG4gIGNvbnN0IGhhbmRsZUZvY3VzT3V0c2lkZSA9IHVzZUNhbGxiYWNrUmVmKG9uRm9jdXNPdXRzaWRlKTtcbiAgY29uc3QgaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgJiYgIWlzRm9jdXNJbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBldmVudERldGFpbCA9IHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfTtcbiAgICAgICAgaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudChGT0NVU19PVVRTSURFLCBoYW5kbGVGb2N1c091dHNpZGUsIGV2ZW50RGV0YWlsLCB7XG4gICAgICAgICAgZGlzY3JldGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBoYW5kbGVGb2N1cyk7XG4gICAgcmV0dXJuICgpID0+IG93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgaGFuZGxlRm9jdXMpO1xuICB9LCBbb3duZXJEb2N1bWVudCwgaGFuZGxlRm9jdXNPdXRzaWRlXSk7XG4gIHJldHVybiB7XG4gICAgb25Gb2N1c0NhcHR1cmU6ICgpID0+IGlzRm9jdXNJbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IHRydWUsXG4gICAgb25CbHVyQ2FwdHVyZTogKCkgPT4gaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoVXBkYXRlKCkge1xuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChDT05URVhUX1VQREFURSk7XG4gIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudChuYW1lLCBoYW5kbGVyLCBkZXRhaWwsIHsgZGlzY3JldGUgfSkge1xuICBjb25zdCB0YXJnZXQgPSBkZXRhaWwub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbCB9KTtcbiAgaWYgKGhhbmRsZXIpIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgaWYgKGRpc2NyZXRlKSB7XG4gICAgZGlzcGF0Y2hEaXNjcmV0ZUN1c3RvbUV2ZW50KHRhcmdldCwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxudmFyIFJvb3QgPSBEaXNtaXNzYWJsZUxheWVyO1xudmFyIEJyYW5jaCA9IERpc21pc3NhYmxlTGF5ZXJCcmFuY2g7XG5leHBvcnQge1xuICBCcmFuY2gsXG4gIERpc21pc3NhYmxlTGF5ZXIsXG4gIERpc21pc3NhYmxlTGF5ZXJCcmFuY2gsXG4gIFJvb3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvZm9jdXMtZ3VhcmRzL3NyYy9Gb2N1c0d1YXJkcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIGNvdW50ID0gMDtcbmZ1bmN0aW9uIEZvY3VzR3VhcmRzKHByb3BzKSB7XG4gIHVzZUZvY3VzR3VhcmRzKCk7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHVzZUZvY3VzR3VhcmRzKCkge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVkZ2VHdWFyZHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtcmFkaXgtZm9jdXMtZ3VhcmRdXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlZGdlR3VhcmRzWzBdID8/IGNyZWF0ZUZvY3VzR3VhcmQoKSk7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgZWRnZUd1YXJkc1sxXSA/PyBjcmVhdGVGb2N1c0d1YXJkKCkpO1xuICAgIGNvdW50Kys7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtcmFkaXgtZm9jdXMtZ3VhcmRdXCIpLmZvckVhY2goKG5vZGUpID0+IG5vZGUucmVtb3ZlKCkpO1xuICAgICAgfVxuICAgICAgY291bnQtLTtcbiAgICB9O1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb2N1c0d1YXJkKCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1yYWRpeC1mb2N1cy1ndWFyZFwiLCBcIlwiKTtcbiAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gIGVsZW1lbnQuc3R5bGUub3V0bGluZSA9IFwibm9uZVwiO1xuICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIFJvb3QgPSBGb2N1c0d1YXJkcztcbmV4cG9ydCB7XG4gIEZvY3VzR3VhcmRzLFxuICBSb290LFxuICB1c2VGb2N1c0d1YXJkc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9mb2N1cy1zY29wZS9zcmMvZm9jdXMtc2NvcGUudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2tSZWYgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1jYWxsYmFjay1yZWZcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEFVVE9GT0NVU19PTl9NT1VOVCA9IFwiZm9jdXNTY29wZS5hdXRvRm9jdXNPbk1vdW50XCI7XG52YXIgQVVUT0ZPQ1VTX09OX1VOTU9VTlQgPSBcImZvY3VzU2NvcGUuYXV0b0ZvY3VzT25Vbm1vdW50XCI7XG52YXIgRVZFTlRfT1BUSU9OUyA9IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IHRydWUgfTtcbnZhciBGT0NVU19TQ09QRV9OQU1FID0gXCJGb2N1c1Njb3BlXCI7XG52YXIgRm9jdXNTY29wZSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIGxvb3AgPSBmYWxzZSxcbiAgICB0cmFwcGVkID0gZmFsc2UsXG4gICAgb25Nb3VudEF1dG9Gb2N1czogb25Nb3VudEF1dG9Gb2N1c1Byb3AsXG4gICAgb25Vbm1vdW50QXV0b0ZvY3VzOiBvblVubW91bnRBdXRvRm9jdXNQcm9wLFxuICAgIC4uLnNjb3BlUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbY29udGFpbmVyLCBzZXRDb250YWluZXJdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IG9uTW91bnRBdXRvRm9jdXMgPSB1c2VDYWxsYmFja1JlZihvbk1vdW50QXV0b0ZvY3VzUHJvcCk7XG4gIGNvbnN0IG9uVW5tb3VudEF1dG9Gb2N1cyA9IHVzZUNhbGxiYWNrUmVmKG9uVW5tb3VudEF1dG9Gb2N1c1Byb3ApO1xuICBjb25zdCBsYXN0Rm9jdXNlZEVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlKSA9PiBzZXRDb250YWluZXIobm9kZSkpO1xuICBjb25zdCBmb2N1c1Njb3BlID0gUmVhY3QudXNlUmVmKHtcbiAgICBwYXVzZWQ6IGZhbHNlLFxuICAgIHBhdXNlKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgcmVzdW1lKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0pLmN1cnJlbnQ7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYXBwZWQpIHtcbiAgICAgIGxldCBoYW5kbGVGb2N1c0luMiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChmb2N1c1Njb3BlLnBhdXNlZCB8fCAhY29udGFpbmVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgbGFzdEZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9jdXMobGFzdEZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQsIHsgc2VsZWN0OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBoYW5kbGVGb2N1c091dDIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZm9jdXNTY29wZS5wYXVzZWQgfHwgIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKCFjb250YWluZXIuY29udGFpbnMocmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICBmb2N1cyhsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGhhbmRsZU11dGF0aW9uczIgPSBmdW5jdGlvbihtdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aCA+IDApIGZvY3VzKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlRm9jdXNJbiA9IGhhbmRsZUZvY3VzSW4yLCBoYW5kbGVGb2N1c091dCA9IGhhbmRsZUZvY3VzT3V0MiwgaGFuZGxlTXV0YXRpb25zID0gaGFuZGxlTXV0YXRpb25zMjtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGhhbmRsZUZvY3VzSW4yKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBoYW5kbGVGb2N1c091dDIpO1xuICAgICAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZU11dGF0aW9uczIpO1xuICAgICAgaWYgKGNvbnRhaW5lcikgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lciwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBoYW5kbGVGb2N1c0luMik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBoYW5kbGVGb2N1c091dDIpO1xuICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbdHJhcHBlZCwgY29udGFpbmVyLCBmb2N1c1Njb3BlLnBhdXNlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGZvY3VzU2NvcGVzU3RhY2suYWRkKGZvY3VzU2NvcGUpO1xuICAgICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGNvbnN0IGhhc0ZvY3VzZWRDYW5kaWRhdGUgPSBjb250YWluZXIuY29udGFpbnMocHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIGlmICghaGFzRm9jdXNlZENhbmRpZGF0ZSkge1xuICAgICAgICBjb25zdCBtb3VudEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEFVVE9GT0NVU19PTl9NT1VOVCwgRVZFTlRfT1BUSU9OUyk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKEFVVE9GT0NVU19PTl9NT1VOVCwgb25Nb3VudEF1dG9Gb2N1cyk7XG4gICAgICAgIGNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG1vdW50RXZlbnQpO1xuICAgICAgICBpZiAoIW1vdW50RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGZvY3VzRmlyc3QocmVtb3ZlTGlua3MoZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcikpLCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBmb2N1cyhjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoQVVUT0ZPQ1VTX09OX01PVU5ULCBvbk1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdW5tb3VudEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEFVVE9GT0NVU19PTl9VTk1PVU5ULCBFVkVOVF9PUFRJT05TKTtcbiAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihBVVRPRk9DVVNfT05fVU5NT1VOVCwgb25Vbm1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgICBjb250YWluZXIuZGlzcGF0Y2hFdmVudCh1bm1vdW50RXZlbnQpO1xuICAgICAgICAgIGlmICghdW5tb3VudEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGZvY3VzKHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA/PyBkb2N1bWVudC5ib2R5LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoQVVUT0ZPQ1VTX09OX1VOTU9VTlQsIG9uVW5tb3VudEF1dG9Gb2N1cyk7XG4gICAgICAgICAgZm9jdXNTY29wZXNTdGFjay5yZW1vdmUoZm9jdXNTY29wZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtjb250YWluZXIsIG9uTW91bnRBdXRvRm9jdXMsIG9uVW5tb3VudEF1dG9Gb2N1cywgZm9jdXNTY29wZV0pO1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWxvb3AgJiYgIXRyYXBwZWQpIHJldHVybjtcbiAgICAgIGlmIChmb2N1c1Njb3BlLnBhdXNlZCkgcmV0dXJuO1xuICAgICAgY29uc3QgaXNUYWJLZXkgPSBldmVudC5rZXkgPT09IFwiVGFiXCIgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleTtcbiAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChpc1RhYktleSAmJiBmb2N1c2VkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIyID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBsYXN0XSA9IGdldFRhYmJhYmxlRWRnZXMoY29udGFpbmVyMik7XG4gICAgICAgIGNvbnN0IGhhc1RhYmJhYmxlRWxlbWVudHNJbnNpZGUgPSBmaXJzdCAmJiBsYXN0O1xuICAgICAgICBpZiAoIWhhc1RhYmJhYmxlRWxlbWVudHNJbnNpZGUpIHtcbiAgICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnQgPT09IGNvbnRhaW5lcjIpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkRWxlbWVudCA9PT0gbGFzdCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChsb29wKSBmb2N1cyhmaXJzdCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkRWxlbWVudCA9PT0gZmlyc3QpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAobG9vcCkgZm9jdXMobGFzdCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbbG9vcCwgdHJhcHBlZCwgZm9jdXNTY29wZS5wYXVzZWRdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgdGFiSW5kZXg6IC0xLCAuLi5zY29wZVByb3BzLCByZWY6IGNvbXBvc2VkUmVmcywgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duIH0pO1xufSk7XG5Gb2N1c1Njb3BlLmRpc3BsYXlOYW1lID0gRk9DVVNfU0NPUEVfTkFNRTtcbmZ1bmN0aW9uIGZvY3VzRmlyc3QoY2FuZGlkYXRlcywgeyBzZWxlY3QgPSBmYWxzZSB9ID0ge30pIHtcbiAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgIGZvY3VzKGNhbmRpZGF0ZSwgeyBzZWxlY3QgfSk7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCkgcmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUVkZ2VzKGNvbnRhaW5lcikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcik7XG4gIGNvbnN0IGZpcnN0ID0gZmluZFZpc2libGUoY2FuZGlkYXRlcywgY29udGFpbmVyKTtcbiAgY29uc3QgbGFzdCA9IGZpbmRWaXNpYmxlKGNhbmRpZGF0ZXMucmV2ZXJzZSgpLCBjb250YWluZXIpO1xuICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcbn1cbmZ1bmN0aW9uIGdldFRhYmJhYmxlQ2FuZGlkYXRlcyhjb250YWluZXIpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihjb250YWluZXIsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgYWNjZXB0Tm9kZTogKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGlzSGlkZGVuSW5wdXQgPSBub2RlLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBub2RlLnR5cGUgPT09IFwiaGlkZGVuXCI7XG4gICAgICBpZiAobm9kZS5kaXNhYmxlZCB8fCBub2RlLmhpZGRlbiB8fCBpc0hpZGRlbklucHV0KSByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgIHJldHVybiBub2RlLnRhYkluZGV4ID49IDAgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIH1cbiAgfSk7XG4gIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkgbm9kZXMucHVzaCh3YWxrZXIuY3VycmVudE5vZGUpO1xuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBmaW5kVmlzaWJsZShlbGVtZW50cywgY29udGFpbmVyKSB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgIGlmICghaXNIaWRkZW4oZWxlbWVudCwgeyB1cFRvOiBjb250YWluZXIgfSkpIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5mdW5jdGlvbiBpc0hpZGRlbihub2RlLCB7IHVwVG8gfSkge1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSByZXR1cm4gdHJ1ZTtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAodXBUbyAhPT0gdm9pZCAwICYmIG5vZGUgPT09IHVwVG8pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5ID09PSBcIm5vbmVcIikgcmV0dXJuIHRydWU7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NlbGVjdGFibGVJbnB1dChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBcInNlbGVjdFwiIGluIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBmb2N1cyhlbGVtZW50LCB7IHNlbGVjdCA9IGZhbHNlIH0gPSB7fSkge1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmZvY3VzKSB7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBlbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICBpZiAoZWxlbWVudCAhPT0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ICYmIGlzU2VsZWN0YWJsZUlucHV0KGVsZW1lbnQpICYmIHNlbGVjdClcbiAgICAgIGVsZW1lbnQuc2VsZWN0KCk7XG4gIH1cbn1cbnZhciBmb2N1c1Njb3Blc1N0YWNrID0gY3JlYXRlRm9jdXNTY29wZXNTdGFjaygpO1xuZnVuY3Rpb24gY3JlYXRlRm9jdXNTY29wZXNTdGFjaygpIHtcbiAgbGV0IHN0YWNrID0gW107XG4gIHJldHVybiB7XG4gICAgYWRkKGZvY3VzU2NvcGUpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUZvY3VzU2NvcGUgPSBzdGFja1swXTtcbiAgICAgIGlmIChmb2N1c1Njb3BlICE9PSBhY3RpdmVGb2N1c1Njb3BlKSB7XG4gICAgICAgIGFjdGl2ZUZvY3VzU2NvcGU/LnBhdXNlKCk7XG4gICAgICB9XG4gICAgICBzdGFjayA9IGFycmF5UmVtb3ZlKHN0YWNrLCBmb2N1c1Njb3BlKTtcbiAgICAgIHN0YWNrLnVuc2hpZnQoZm9jdXNTY29wZSk7XG4gICAgfSxcbiAgICByZW1vdmUoZm9jdXNTY29wZSkge1xuICAgICAgc3RhY2sgPSBhcnJheVJlbW92ZShzdGFjaywgZm9jdXNTY29wZSk7XG4gICAgICBzdGFja1swXT8ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYXJyYXlSZW1vdmUoYXJyYXksIGl0ZW0pIHtcbiAgY29uc3QgdXBkYXRlZEFycmF5ID0gWy4uLmFycmF5XTtcbiAgY29uc3QgaW5kZXggPSB1cGRhdGVkQXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHVwZGF0ZWRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB1cGRhdGVkQXJyYXk7XG59XG5mdW5jdGlvbiByZW1vdmVMaW5rcyhpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRhZ05hbWUgIT09IFwiQVwiKTtcbn1cbnZhciBSb290ID0gRm9jdXNTY29wZTtcbmV4cG9ydCB7XG4gIEZvY3VzU2NvcGUsXG4gIFJvb3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtbGF5b3V0LWVmZmVjdC9zcmMvdXNlTGF5b3V0RWZmZWN0LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTGF5b3V0RWZmZWN0MiA9IEJvb2xlYW4oZ2xvYmFsVGhpcz8uZG9jdW1lbnQpID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogKCkgPT4ge1xufTtcbmV4cG9ydCB7XG4gIHVzZUxheW91dEVmZmVjdDIgYXMgdXNlTGF5b3V0RWZmZWN0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvaWQvc3JjL2lkLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0XCI7XG52YXIgdXNlUmVhY3RJZCA9IFJlYWN0W1widXNlSWRcIi50b1N0cmluZygpXSB8fCAoKCkgPT4gdm9pZCAwKTtcbnZhciBjb3VudCA9IDA7XG5mdW5jdGlvbiB1c2VJZChkZXRlcm1pbmlzdGljSWQpIHtcbiAgY29uc3QgW2lkLCBzZXRJZF0gPSBSZWFjdC51c2VTdGF0ZSh1c2VSZWFjdElkKCkpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZGV0ZXJtaW5pc3RpY0lkKSBzZXRJZCgocmVhY3RJZCkgPT4gcmVhY3RJZCA/PyBTdHJpbmcoY291bnQrKykpO1xuICB9LCBbZGV0ZXJtaW5pc3RpY0lkXSk7XG4gIHJldHVybiBkZXRlcm1pbmlzdGljSWQgfHwgKGlkID8gYHJhZGl4LSR7aWR9YCA6IFwiXCIpO1xufVxuZXhwb3J0IHtcbiAgdXNlSWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICBsZWZ0OiB4LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5leHBvcnQgeyBhbGlnbm1lbnRzLCBjbGFtcCwgY3JlYXRlQ29vcmRzLCBldmFsdWF0ZSwgZXhwYW5kUGFkZGluZ09iamVjdCwgZmxvb3IsIGdldEFsaWdubWVudCwgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldEF4aXNMZW5ndGgsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlQXhpcywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldFBhZGRpbmdPYmplY3QsIGdldFNpZGUsIGdldFNpZGVBeGlzLCBtYXgsIG1pbiwgcGxhY2VtZW50cywgcmVjdFRvQ2xpZW50UmVjdCwgcm91bmQsIHNpZGVzIH07XG4iLCJpbXBvcnQgeyBnZXRTaWRlQXhpcywgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QXhpc0xlbmd0aCwgZ2V0U2lkZSwgZ2V0QWxpZ25tZW50LCBldmFsdWF0ZSwgZ2V0UGFkZGluZ09iamVjdCwgcmVjdFRvQ2xpZW50UmVjdCwgbWluLCBjbGFtcCwgcGxhY2VtZW50cywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBzaWRlcywgbWF4LCBnZXRPcHBvc2l0ZUF4aXMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuZXhwb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KF9yZWYsIHBsYWNlbWVudCwgcnRsKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzaWRlQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWduTGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IHNpZGVBeGlzID09PSAneSc7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3RzLmZsb2F0aW5nLmhlaWdodFxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaW5pdGlhbFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoaW5pdGlhbFBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZSc7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0LCBmaW5kIHRoZSBjYW5kaWRhdGVzIHRoYXQgZml0IG9uIHRoZSBtYWluQXhpcyBzaWRlIG9mIG92ZXJmbG93LFxuICAgICAgICAvLyB0aGVuIGZpbmQgdGhlIHBsYWNlbWVudCB0aGF0IGZpdHMgdGhlIGJlc3Qgb24gdGhlIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IGQub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGEsIGIpID0+IGEub3ZlcmZsb3dzWzFdIC0gYi5vdmVyZmxvd3NbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyLnBsYWNlbWVudDtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZmFsbGJhY2suXG4gICAgICAgIGlmICghcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbGxiYWNrU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlc3RGaXQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjI7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlcjIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaWRlQXhpcyA9IGdldFNpZGVBeGlzKGQucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTaWRlQXhpcyA9PT0gaW5pdGlhbFNpZGVBeGlzIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGJpYXMgdG8gdGhlIGB5YCBzaWRlIGF4aXMgZHVlIHRvIGhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGluZyBkaXJlY3Rpb25zIGZhdm9yaW5nIGdyZWF0ZXIgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaWRlQXhpcyA9PT0gJ3knO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSkubWFwKGQgPT4gW2QucGxhY2VtZW50LCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlcjJbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdoaWRlJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW5PZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzKSB7XG4gIGNvbnN0IG1pblggPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gIGNvbnN0IG1pblkgPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC50b3ApKTtcbiAgY29uc3QgbWF4WCA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gIGNvbnN0IG1heFkgPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RzQnlMaW5lKHJlY3RzKSB7XG4gIGNvbnN0IHNvcnRlZFJlY3RzID0gcmVjdHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IHByZXZSZWN0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRSZWN0c1tpXTtcbiAgICBpZiAoIXByZXZSZWN0IHx8IHJlY3QueSAtIHByZXZSZWN0LnkgPiBwcmV2UmVjdC5oZWlnaHQgLyAyKSB7XG4gICAgICBncm91cHMucHVzaChbcmVjdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdLnB1c2gocmVjdCk7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gcmVjdDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLm1hcChyZWN0ID0+IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KHJlY3QpKSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2lubGluZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBuYXRpdmVDbGllbnRSZWN0cyA9IEFycmF5LmZyb20oKGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpIHx8IFtdKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gZ2V0UmVjdHNCeUxpbmUobmF0aXZlQ2xpZW50UmVjdHMpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChuYXRpdmVDbGllbnRSZWN0cykpO1xuICAgICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZC5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQgJiYgeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHJlY3QgaW4gd2hpY2ggdGhlIHBvaW50IGlzIGZ1bGx5IGluc2lkZS5cbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSB8fCBmYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUubWFpbkF4aXMgfHwgMCxcbiAgICBjcm9zc0F4aXM6IHJhd1ZhbHVlLmNyb3NzQXhpcyB8fCAwLFxuICAgIGFsaWdubWVudEF4aXM6IHJhd1ZhbHVlLmFsaWdubWVudEF4aXNcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJGFycm93O1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxhY2VtZW50IGlzIHRoZSBzYW1lIGFuZCB0aGUgYXJyb3cgY2F1c2VkIGFuIGFsaWdubWVudCBvZmZzZXRcbiAgICAgIC8vIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uaW5nIGNvb3JkaW5hdGVzLlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGlmZkNvb3JkcyxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geSxcbiAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBbbWFpbkF4aXNdOiBjaGVja01haW5BeGlzLFxuICAgICAgICAgICAgW2Nyb3NzQXhpc106IGNoZWNrQ3Jvc3NBeGlzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFsndG9wJywgJ2xlZnQnXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLCBfc3RhdGUkbWlkZGxld2FyZURhdGEyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IG1pbihoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXSwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSBtaW4od2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCk7XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmICgoX3N0YXRlJG1pZGRsZXdhcmVEYXRhID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLmVuYWJsZWQueCkge1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEyID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMi5lbmFibGVkLnkpIHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIiwiZnVuY3Rpb24gaGFzV2luZG93KCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLy8gTW9ja2VkIG5vZGVzIGluIHRlc3RpbmcgZW52aXJvbm1lbnRzIG1heSBub3QgYmUgaW5zdGFuY2VzIG9mIE5vZGUuIEJ5XG4gIC8vIHJldHVybmluZyBgI2RvY3VtZW50YCBhbiBpbmZpbml0ZSBsb29wIHdvbid0IG9jY3VyLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIzMTdcbiAgcmV0dXJuICcjZG9jdW1lbnQnO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsIHx8IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpIHx8IHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTaGFkb3dSb290IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5TaGFkb3dSb290O1xufVxuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFbJ2lubGluZScsICdjb250ZW50cyddLmluY2x1ZGVzKGRpc3BsYXkpO1xufVxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzVG9wTGF5ZXIoZWxlbWVudCkge1xuICByZXR1cm4gWyc6cG9wb3Zlci1vcGVuJywgJzptb2RhbCddLnNvbWUoc2VsZWN0b3IgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnRPckNzcykge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBpc0VsZW1lbnQoZWxlbWVudE9yQ3NzKSA/IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudE9yQ3NzKSA6IGVsZW1lbnRPckNzcztcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXRyYW5zZm9ybXMtMi8jaW5kaXZpZHVhbC10cmFuc2Zvcm1zXG4gIHJldHVybiBbJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3BlcnNwZWN0aXZlJ10uc29tZSh2YWx1ZSA9PiBjc3NbdmFsdWVdID8gY3NzW3ZhbHVlXSAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IChjc3MuY29udGFpbmVyVHlwZSA/IGNzcy5jb250YWluZXJUeXBlICE9PSAnbm9ybWFsJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IFsndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ10uc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXS5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzVG9wTGF5ZXIoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxYLFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QsIHRyYXZlcnNlSWZyYW1lcykge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDI7XG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cbiAgaWYgKHRyYXZlcnNlSWZyYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhdmVyc2VJZnJhbWVzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgY29uc3QgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KHdpbik7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIGZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhmcmFtZUVsZW1lbnQpIDogW10pO1xuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChzY3JvbGxhYmxlQW5jZXN0b3IsIGdldE92ZXJmbG93QW5jZXN0b3JzKHNjcm9sbGFibGVBbmNlc3RvciwgW10sIHRyYXZlcnNlSWZyYW1lcykpO1xufVxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KHdpbikge1xuICByZXR1cm4gd2luLnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yod2luLnBhcmVudCkgPyB3aW4uZnJhbWVFbGVtZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldEZyYW1lRWxlbWVudCwgZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IsIGdldE5vZGVOYW1lLCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgZ2V0V2luZG93LCBpc0NvbnRhaW5pbmdCbG9jaywgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzTm9kZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGlzU2hhZG93Um9vdCwgaXNUYWJsZUVsZW1lbnQsIGlzVG9wTGF5ZXIsIGlzV2ViS2l0IH07XG4iLCJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBkZXRlY3RPdmVyZmxvdyBhcyBkZXRlY3RPdmVyZmxvdyQxLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBzaGlmdCBhcyBzaGlmdCQxLCBmbGlwIGFzIGZsaXAkMSwgc2l6ZSBhcyBzaXplJDEsIGhpZGUgYXMgaGlkZSQxLCBhcnJvdyBhcyBhcnJvdyQxLCBpbmxpbmUgYXMgaW5saW5lJDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5pbXBvcnQgeyByb3VuZCwgY3JlYXRlQ29vcmRzLCBtYXgsIG1pbiwgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNIVE1MRWxlbWVudCwgaXNFbGVtZW50LCBnZXRXaW5kb3csIGlzV2ViS2l0LCBnZXRGcmFtZUVsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldERvY3VtZW50RWxlbWVudCwgaXNUb3BMYXllciwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRXaW4gPSB3aW47XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRXaW4gPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSk7XG4gICAgICBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbn1cblxuLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuLy8gaW5jb3JyZWN0IGZvciBSVEwuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQsIHJlY3QpIHtcbiAgY29uc3QgbGVmdFNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBsZWZ0U2Nyb2xsO1xuICB9XG4gIHJldHVybiByZWN0LmxlZnQgKyBsZWZ0U2Nyb2xsO1xufVxuXG5mdW5jdGlvbiBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCBpZ25vcmVTY3JvbGxiYXJYKSB7XG4gIGlmIChpZ25vcmVTY3JvbGxiYXJYID09PSB2b2lkIDApIHtcbiAgICBpZ25vcmVTY3JvbGxiYXJYID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHRtbFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHggPSBodG1sUmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSAoaWdub3JlU2Nyb2xsYmFyWCA/IDAgOlxuICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhci5cbiAgZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQsIGh0bWxSZWN0KSk7XG4gIGNvbnN0IHkgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHRvcExheWVyID0gZWxlbWVudHMgPyBpc1RvcExheWVyKGVsZW1lbnRzLmZsb2F0aW5nKSA6IGZhbHNlO1xuICBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQgfHwgdG9wTGF5ZXIgJiYgaXNGaXhlZCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgdHJ1ZSkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZS54LFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZS55LFxuICAgIHg6IHJlY3QueCAqIHNjYWxlLnggLSBzY3JvbGwuc2Nyb2xsTGVmdCAqIHNjYWxlLnggKyBvZmZzZXRzLnggKyBodG1sT2Zmc2V0LngsXG4gICAgeTogcmVjdC55ICogc2NhbGUueSAtIHNjcm9sbC5zY3JvbGxUb3AgKiBzY2FsZS55ICsgb2Zmc2V0cy55ICsgaHRtbE9mZnNldC55XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5nZXRDbGllbnRSZWN0cygpKTtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIHRoZSBpbm5lciBjbGllbnQgcmVjdCwgc3VidHJhY3Rpbmcgc2Nyb2xsYmFycyBpZiBwcmVzZW50LlxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJlY3QgPSBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpO1xuICB9IGVsc2UgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgeDogY2xpcHBpbmdBbmNlc3Rvci54IC0gdmlzdWFsT2Zmc2V0cy54LFxuICAgICAgeTogY2xpcHBpbmdBbmNlc3Rvci55IC0gdmlzdWFsT2Zmc2V0cy55LFxuICAgICAgd2lkdGg6IGNsaXBwaW5nQW5jZXN0b3Iud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaXBwaW5nQW5jZXN0b3IuaGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChyZWN0KTtcbn1cbmZ1bmN0aW9uIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBzdG9wTm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKHBhcmVudE5vZGUgPT09IHN0b3BOb2RlIHx8ICFpc0VsZW1lbnQocGFyZW50Tm9kZSkgfHwgaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpLnBvc2l0aW9uID09PSAnZml4ZWQnIHx8IGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihwYXJlbnROb2RlLCBzdG9wTm9kZSk7XG59XG5cbi8vIEEgXCJjbGlwcGluZyBhbmNlc3RvclwiIGlzIGFuIGBvdmVyZmxvd2AgZWxlbWVudCB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgY2hpbGQgZWxlbWVudHMuIFRoaXMgcmV0dXJucyBhbGwgY2xpcHBpbmcgYW5jZXN0b3JzXG4vLyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCB1cCB0aGUgdHJlZS5cbmZ1bmN0aW9uIGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCBjYWNoZSkge1xuICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQoZWxlbWVudCk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG4gIGxldCByZXN1bHQgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50LCBbXSwgZmFsc2UpLmZpbHRlcihlbCA9PiBpc0VsZW1lbnQoZWwpICYmIGdldE5vZGVOYW1lKGVsKSAhPT0gJ2JvZHknKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnO1xuICBsZXQgY3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/IGdldFBhcmVudE5vZGUoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHdoaWxlIChpc0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSXNDb250YWluaW5nID0gaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpO1xuICAgIGlmICghY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGREcm9wQ3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiAhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgOiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgISFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSAmJiBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5jbHVkZXMoY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUucG9zaXRpb24pIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIGN1cnJlbnROb2RlKTtcbiAgICBpZiAoc2hvdWxkRHJvcEN1cnJlbnROb2RlKSB7XG4gICAgICAvLyBEcm9wIG5vbi1jb250YWluaW5nIGJsb2Nrcy5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoYW5jZXN0b3IgPT4gYW5jZXN0b3IgIT09IGN1cnJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVjb3JkIGxhc3QgY29udGFpbmluZyBibG9jayBmb3IgbmV4dCBpdGVyYXRpb24uXG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgY2FjaGUuc2V0KGVsZW1lbnQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIGFuY2VzdG9ycy5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudCxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdBbmNlc3RvcnMnID8gaXNUb3BMYXllcihlbGVtZW50KSA/IFtdIDogZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIHRoaXMuX2MpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBbLi4uZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nQW5jZXN0b3IgPSBjbGlwcGluZ0FuY2VzdG9yc1swXTtcbiAgY29uc3QgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdBbmNlc3RvcnMucmVkdWNlKChhY2NSZWN0LCBjbGlwcGluZ0FuY2VzdG9yKSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcCxcbiAgICB4OiBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICB5OiBjbGlwcGluZ1JlY3QudG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAvLyBJZiB0aGUgPGJvZHk+IHNjcm9sbGJhciBhcHBlYXJzIG9uIHRoZSBsZWZ0IChlLmcuIFJUTCBzeXN0ZW1zKS4gVXNlXG4gICAgICAvLyBGaXJlZm94IHdpdGggbGF5b3V0LnNjcm9sbGJhci5zaWRlID0gMyBpbiBhYm91dDpjb25maWcgdG8gdGVzdCB0aGlzLlxuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLnggLSBodG1sT2Zmc2V0Lng7XG4gIGNvbnN0IHkgPSByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnkgLSBodG1sT2Zmc2V0Lnk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAvLyBGaXJlZm94IHJldHVybnMgdGhlIDxodG1sPiBlbGVtZW50IGFzIHRoZSBvZmZzZXRQYXJlbnQgaWYgaXQncyBub24tc3RhdGljLFxuICAvLyB3aGlsZSBDaHJvbWUgYW5kIFNhZmFyaSByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LiBUaGUgPGJvZHk+IGVsZW1lbnQgbXVzdFxuICAvLyBiZSB1c2VkIHRvIHBlcmZvcm0gdGhlIGNvcnJlY3QgY2FsY3VsYXRpb25zIGV2ZW4gaWYgdGhlIDxodG1sPiBlbGVtZW50IGlzXG4gIC8vIG5vbi1zdGF0aWMuXG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZmxvYXRpbmdEaW1lbnNpb25zLmhlaWdodFxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuZnVuY3Rpb24gcmVjdHNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLndpZHRoID09PSBiLndpZHRoICYmIGEuaGVpZ2h0ID09PSBiLmhlaWdodDtcbn1cblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgKF9pbyA9IGlvKSA9PSBudWxsIHx8IF9pby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW47XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBjbGlwcGVkLCB0aGUgcmF0aW8gaXMgMC4gVGhyb3R0bGUgdGhlIHJlZnJlc2hcbiAgICAgICAgICAvLyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgdXBkYXRlcy5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZnJlc2goZmFsc2UsIDFlLTcpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhdGlvID09PSAxICYmICFyZWN0c0FyZUVxdWFsKGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpIHtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gdGhvdWdoIHRoZSByYXRpbyBpcyByZXBvcnRlZCBhcyAxLCB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBpcyBub3QgYWN0dWFsbHkgZnVsbHkgd2l0aGluIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlcidzIHJvb3RcbiAgICAgICAgLy8gYXJlYSBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gdW5kZXIgcGVyZm9ybWFuY2UgY29uc3RyYWludHMuIFRoaXMgbWF5XG4gICAgICAgIC8vIGJlIGEgYnVnIGluIHRoZSBicm93c2VyJ3MgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24uIFRvXG4gICAgICAgIC8vIHdvcmsgYXJvdW5kIHRoaXMsIHdlIGNvbXBhcmUgdGhlIGVsZW1lbnQncyBib3VuZGluZyByZWN0IG5vdyB3aXRoXG4gICAgICAgIC8vIHdoYXQgaXQgd2FzIGF0IHRoZSB0aW1lIHdlIGNyZWF0ZWQgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLiBJZiB0aGV5XG4gICAgICAgIC8vIGFyZSBub3QgZXF1YWwgdGhlbiB0aGUgZWxlbWVudCBtb3ZlZCwgc28gd2UgcmVmcmVzaC5cbiAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBtb3VudGVkIG9uIHRoZSBET00gb3JcbiAqIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTSBvciBoaWRkZW4gZnJvbSB0aGUgc2NyZWVuLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gdW53cmFwRWxlbWVudChyZWZlcmVuY2UpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4ocmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSksIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQgW2ZpcnN0RW50cnldID0gX3JlZjtcbiAgICAgIGlmIChmaXJzdEVudHJ5ICYmIGZpcnN0RW50cnkudGFyZ2V0ID09PSByZWZlcmVuY2VFbCAmJiByZXNpemVPYnNlcnZlcikge1xuICAgICAgICAvLyBQcmV2ZW50IHVwZGF0ZSBsb29wcyB3aGVuIHVzaW5nIHRoZSBgc2l6ZWAgbWlkZGxld2FyZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzQwXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgICAgKF9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgIXJlY3RzQXJlRXF1YWwocHJldlJlZlJlY3QsIG5leHRSZWZSZWN0KSkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICAgIHByZXZSZWZSZWN0ID0gbmV4dFJlZlJlY3Q7XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZUxvb3ApO1xuICB9XG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfcmVzaXplT2JzZXJ2ZXIyO1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSk7XG4gICAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICAgIH0pO1xuICAgIGNsZWFudXBJbyA9PSBudWxsIHx8IGNsZWFudXBJbygpO1xuICAgIChfcmVzaXplT2JzZXJ2ZXIyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyMi5kaXNjb25uZWN0KCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuY29uc3QgZGV0ZWN0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyQxO1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBvZmZzZXQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBhdXRvUGxhY2VtZW50JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IHNoaWZ0JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZmxpcCQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBzaXplJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gaGlkZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IGFycm93JDE7XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGlubGluZSQxO1xuXG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gbGltaXRTaGlmdCQxO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpID0+IHtcbiAgLy8gVGhpcyBjYWNoZXMgdGhlIGV4cGVuc2l2ZSBgZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzYCBmdW5jdGlvbiBzbyB0aGF0XG4gIC8vIG11bHRpcGxlIGxpZmVjeWNsZSByZXNldHMgcmUtdXNlIHRoZSBzYW1lIHJlc3VsdC4gSXQgb25seSBsaXZlcyBmb3IgYVxuICAvLyBzaW5nbGUgY2FsbC4gSWYgb3RoZXIgZnVuY3Rpb25zIGJlY29tZSBleHBlbnNpdmUsIHdlIGNhbiBhZGQgdGhlbSBhcyB3ZWxsLlxuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICBwbGF0Zm9ybSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHBsYXRmb3JtV2l0aENhY2hlID0ge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMucGxhdGZvcm0sXG4gICAgX2M6IGNhY2hlXG4gIH07XG4gIHJldHVybiBjb21wdXRlUG9zaXRpb24kMShyZWZlcmVuY2UsIGZsb2F0aW5nLCB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucyxcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm1XaXRoQ2FjaGVcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9O1xuIiwiaW1wb3J0IHsgY29tcHV0ZVBvc2l0aW9uLCBhcnJvdyBhcyBhcnJvdyQyLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBmbGlwIGFzIGZsaXAkMSwgc2l6ZSBhcyBzaXplJDEsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBoaWRlIGFzIGhpZGUkMSwgaW5saW5lIGFzIGlubGluZSQxIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5leHBvcnQgeyBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgcGxhdGZvcm0gfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLy8gRm9yayBvZiBgZmFzdC1kZWVwLWVxdWFsYCB0aGF0IG9ubHkgZG9lcyB0aGUgY29tcGFyaXNvbnMgd2UgbmVlZCBhbmQgY29tcGFyZXNcbi8vIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCBsZW5ndGg7XG4gIGxldCBpO1xuICBsZXQga2V5cztcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG5mdW5jdGlvbiBnZXREUFIoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCB3aW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeURQUihlbGVtZW50LCB2YWx1ZSkge1xuICBjb25zdCBkcHIgPSBnZXREUFIoZWxlbWVudCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZHByKSAvIGRwcjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogZXh0ZXJuYWxSZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZzogZXh0ZXJuYWxGbG9hdGluZ1xuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm0gPSB0cnVlLFxuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkLFxuICAgIG9wZW5cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RyYXRlZ3ksXG4gICAgcGxhY2VtZW50LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fSxcbiAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBbbGF0ZXN0TWlkZGxld2FyZSwgc2V0TGF0ZXN0TWlkZGxld2FyZV0gPSBSZWFjdC51c2VTdGF0ZShtaWRkbGV3YXJlKTtcbiAgaWYgKCFkZWVwRXF1YWwobGF0ZXN0TWlkZGxld2FyZSwgbWlkZGxld2FyZSkpIHtcbiAgICBzZXRMYXRlc3RNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICB9XG4gIGNvbnN0IFtfcmVmZXJlbmNlLCBfc2V0UmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbX2Zsb2F0aW5nLCBfc2V0RmxvYXRpbmddID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSByZWZlcmVuY2VSZWYuY3VycmVudCkge1xuICAgICAgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0RmxvYXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgZmxvYXRpbmdSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0RmxvYXRpbmcobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gZXh0ZXJuYWxSZWZlcmVuY2UgfHwgX3JlZmVyZW5jZTtcbiAgY29uc3QgZmxvYXRpbmdFbCA9IGV4dGVybmFsRmxvYXRpbmcgfHwgX2Zsb2F0aW5nO1xuICBjb25zdCByZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZsb2F0aW5nUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKGRhdGEpO1xuICBjb25zdCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCA9IHdoaWxlRWxlbWVudHNNb3VudGVkICE9IG51bGw7XG4gIGNvbnN0IHdoaWxlRWxlbWVudHNNb3VudGVkUmVmID0gdXNlTGF0ZXN0UmVmKHdoaWxlRWxlbWVudHNNb3VudGVkKTtcbiAgY29uc3QgcGxhdGZvcm1SZWYgPSB1c2VMYXRlc3RSZWYocGxhdGZvcm0pO1xuICBjb25zdCBvcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCB1cGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWZlcmVuY2VSZWYuY3VycmVudCB8fCAhZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhdGVzdE1pZGRsZXdhcmVcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybVJlZi5jdXJyZW50KSB7XG4gICAgICBjb25maWcucGxhdGZvcm0gPSBwbGF0Zm9ybVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBjb21wdXRlUG9zaXRpb24ocmVmZXJlbmNlUmVmLmN1cnJlbnQsIGZsb2F0aW5nUmVmLmN1cnJlbnQsIGNvbmZpZykudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZ1bGxEYXRhID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICAvLyBUaGUgZmxvYXRpbmcgZWxlbWVudCdzIHBvc2l0aW9uIG1heSBiZSByZWNvbXB1dGVkIHdoaWxlIGl0J3MgY2xvc2VkXG4gICAgICAgIC8vIGJ1dCBzdGlsbCBtb3VudGVkIChzdWNoIGFzIHdoZW4gdHJhbnNpdGlvbmluZyBvdXQpLiBUbyBlbnN1cmVcbiAgICAgICAgLy8gYGlzUG9zaXRpb25lZGAgd2lsbCBiZSBgZmFsc2VgIGluaXRpYWxseSBvbiB0aGUgbmV4dCBvcGVuLCBhdm9pZFxuICAgICAgICAvLyBzZXR0aW5nIGl0IHRvIGB0cnVlYCB3aGVuIGBvcGVuID09PSBmYWxzZWAgKG11c3QgYmUgc3BlY2lmaWVkKS5cbiAgICAgICAgaXNQb3NpdGlvbmVkOiBvcGVuUmVmLmN1cnJlbnQgIT09IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50ICYmICFkZWVwRXF1YWwoZGF0YVJlZi5jdXJyZW50LCBmdWxsRGF0YSkpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50ID0gZnVsbERhdGE7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgc2V0RGF0YShmdWxsRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbbGF0ZXN0TWlkZGxld2FyZSwgcGxhY2VtZW50LCBzdHJhdGVneSwgcGxhdGZvcm1SZWYsIG9wZW5SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuID09PSBmYWxzZSAmJiBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkKSB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgICBzZXREYXRhKGRhdGEgPT4gKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocmVmZXJlbmNlRWwpIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gcmVmZXJlbmNlRWw7XG4gICAgaWYgKGZsb2F0aW5nRWwpIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBmbG9hdGluZ0VsO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gd2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudChyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZF0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlUmVmLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ1JlZixcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0RmxvYXRpbmdcbiAgfSksIFtzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlRWwsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nRWxcbiAgfSksIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbF0pO1xuICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgY29uc3QgeCA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCk7XG4gICAgY29uc3QgeSA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiLFxuICAgICAgICAuLi4oZ2V0RFBSKGVsZW1lbnRzLmZsb2F0aW5nKSA+PSAxLjUgJiYge1xuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeVxuICAgIH07XG4gIH0sIFtzdHJhdGVneSwgdHJhbnNmb3JtLCBlbGVtZW50cy5mbG9hdGluZywgZGF0YS54LCBkYXRhLnldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5kYXRhLFxuICAgIHVwZGF0ZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nU3R5bGVzXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgZmxvYXRpbmdTdHlsZXNdKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93JDEgPSBvcHRpb25zID0+IHtcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYWRkaW5nXG4gICAgICB9ID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zKHN0YXRlKSA6IG9wdGlvbnM7XG4gICAgICBpZiAoZWxlbWVudCAmJiBpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMih7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5vZmZzZXQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4ubGltaXRTaGlmdCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5mbGlwJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaXplJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmF1dG9QbGFjZW1lbnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaGlkZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaW5saW5lJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5hcnJvdyQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplLCB1c2VGbG9hdGluZyB9O1xuIiwiLy8gcGFja2FnZXMvcmVhY3QvYXJyb3cvc3JjL2Fycm93LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTkFNRSA9IFwiQXJyb3dcIjtcbnZhciBBcnJvdyA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gNSwgLi4uYXJyb3dQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFByaW1pdGl2ZS5zdmcsXG4gICAge1xuICAgICAgLi4uYXJyb3dQcm9wcyxcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB2aWV3Qm94OiBcIjAgMCAzMCAxMFwiLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsXG4gICAgICBjaGlsZHJlbjogcHJvcHMuYXNDaGlsZCA/IGNoaWxkcmVuIDogLyogQF9fUFVSRV9fICovIGpzeChcInBvbHlnb25cIiwgeyBwb2ludHM6IFwiMCwwIDMwLDAgMTUsMTBcIiB9KVxuICAgIH1cbiAgKTtcbn0pO1xuQXJyb3cuZGlzcGxheU5hbWUgPSBOQU1FO1xudmFyIFJvb3QgPSBBcnJvdztcbmV4cG9ydCB7XG4gIEFycm93LFxuICBSb290XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLXNpemUvc3JjL3VzZVNpemUudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbmZ1bmN0aW9uIHVzZVNpemUoZWxlbWVudCkge1xuICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSBSZWFjdC51c2VTdGF0ZSh2b2lkIDApO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBzZXRTaXplKHsgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgfSk7XG4gICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgbGV0IGhlaWdodDtcbiAgICAgICAgaWYgKFwiYm9yZGVyQm94U2l6ZVwiIGluIGVudHJ5KSB7XG4gICAgICAgICAgY29uc3QgYm9yZGVyU2l6ZUVudHJ5ID0gZW50cnlbXCJib3JkZXJCb3hTaXplXCJdO1xuICAgICAgICAgIGNvbnN0IGJvcmRlclNpemUgPSBBcnJheS5pc0FycmF5KGJvcmRlclNpemVFbnRyeSkgPyBib3JkZXJTaXplRW50cnlbMF0gOiBib3JkZXJTaXplRW50cnk7XG4gICAgICAgICAgd2lkdGggPSBib3JkZXJTaXplW1wiaW5saW5lU2l6ZVwiXTtcbiAgICAgICAgICBoZWlnaHQgPSBib3JkZXJTaXplW1wiYmxvY2tTaXplXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzZXRTaXplKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgIH0pO1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTaXplKHZvaWQgMCk7XG4gICAgfVxuICB9LCBbZWxlbWVudF0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydCB7XG4gIHVzZVNpemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvcG9wcGVyL3NyYy9wb3BwZXIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIHVzZUZsb2F0aW5nLFxuICBhdXRvVXBkYXRlLFxuICBvZmZzZXQsXG4gIHNoaWZ0LFxuICBsaW1pdFNoaWZ0LFxuICBoaWRlLFxuICBhcnJvdyBhcyBmbG9hdGluZ1VJYXJyb3csXG4gIGZsaXAsXG4gIHNpemVcbn0gZnJvbSBcIkBmbG9hdGluZy11aS9yZWFjdC1kb21cIjtcbmltcG9ydCAqIGFzIEFycm93UHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtYXJyb3dcIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0U2NvcGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlU2l6ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLXNpemVcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNJREVfT1BUSU9OUyA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbnZhciBBTElHTl9PUFRJT05TID0gW1wic3RhcnRcIiwgXCJjZW50ZXJcIiwgXCJlbmRcIl07XG52YXIgUE9QUEVSX05BTUUgPSBcIlBvcHBlclwiO1xudmFyIFtjcmVhdGVQb3BwZXJDb250ZXh0LCBjcmVhdGVQb3BwZXJTY29wZV0gPSBjcmVhdGVDb250ZXh0U2NvcGUoUE9QUEVSX05BTUUpO1xudmFyIFtQb3BwZXJQcm92aWRlciwgdXNlUG9wcGVyQ29udGV4dF0gPSBjcmVhdGVQb3BwZXJDb250ZXh0KFBPUFBFUl9OQU1FKTtcbnZhciBQb3BwZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlUG9wcGVyLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIGNvbnN0IFthbmNob3IsIHNldEFuY2hvcl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUG9wcGVyUHJvdmlkZXIsIHsgc2NvcGU6IF9fc2NvcGVQb3BwZXIsIGFuY2hvciwgb25BbmNob3JDaGFuZ2U6IHNldEFuY2hvciwgY2hpbGRyZW4gfSk7XG59O1xuUG9wcGVyLmRpc3BsYXlOYW1lID0gUE9QUEVSX05BTUU7XG52YXIgQU5DSE9SX05BTUUgPSBcIlBvcHBlckFuY2hvclwiO1xudmFyIFBvcHBlckFuY2hvciA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlUG9wcGVyLCB2aXJ0dWFsUmVmLCAuLi5hbmNob3JQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVBvcHBlckNvbnRleHQoQU5DSE9SX05BTUUsIF9fc2NvcGVQb3BwZXIpO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCByZWYpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb250ZXh0Lm9uQW5jaG9yQ2hhbmdlKHZpcnR1YWxSZWY/LmN1cnJlbnQgfHwgcmVmLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgIHJldHVybiB2aXJ0dWFsUmVmID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyAuLi5hbmNob3JQcm9wcywgcmVmOiBjb21wb3NlZFJlZnMgfSk7XG4gIH1cbik7XG5Qb3BwZXJBbmNob3IuZGlzcGxheU5hbWUgPSBBTkNIT1JfTkFNRTtcbnZhciBDT05URU5UX05BTUUgPSBcIlBvcHBlckNvbnRlbnRcIjtcbnZhciBbUG9wcGVyQ29udGVudFByb3ZpZGVyLCB1c2VDb250ZW50Q29udGV4dF0gPSBjcmVhdGVQb3BwZXJDb250ZXh0KENPTlRFTlRfTkFNRSk7XG52YXIgUG9wcGVyQ29udGVudCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX19zY29wZVBvcHBlcixcbiAgICAgIHNpZGUgPSBcImJvdHRvbVwiLFxuICAgICAgc2lkZU9mZnNldCA9IDAsXG4gICAgICBhbGlnbiA9IFwiY2VudGVyXCIsXG4gICAgICBhbGlnbk9mZnNldCA9IDAsXG4gICAgICBhcnJvd1BhZGRpbmcgPSAwLFxuICAgICAgYXZvaWRDb2xsaXNpb25zID0gdHJ1ZSxcbiAgICAgIGNvbGxpc2lvbkJvdW5kYXJ5ID0gW10sXG4gICAgICBjb2xsaXNpb25QYWRkaW5nOiBjb2xsaXNpb25QYWRkaW5nUHJvcCA9IDAsXG4gICAgICBzdGlja3kgPSBcInBhcnRpYWxcIixcbiAgICAgIGhpZGVXaGVuRGV0YWNoZWQgPSBmYWxzZSxcbiAgICAgIHVwZGF0ZVBvc2l0aW9uU3RyYXRlZ3kgPSBcIm9wdGltaXplZFwiLFxuICAgICAgb25QbGFjZWQsXG4gICAgICAuLi5jb250ZW50UHJvcHNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVBvcHBlckNvbnRleHQoQ09OVEVOVF9OQU1FLCBfX3Njb3BlUG9wcGVyKTtcbiAgICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCAobm9kZSkgPT4gc2V0Q29udGVudChub2RlKSk7XG4gICAgY29uc3QgW2Fycm93LCBzZXRBcnJvd10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBhcnJvd1NpemUgPSB1c2VTaXplKGFycm93KTtcbiAgICBjb25zdCBhcnJvd1dpZHRoID0gYXJyb3dTaXplPy53aWR0aCA/PyAwO1xuICAgIGNvbnN0IGFycm93SGVpZ2h0ID0gYXJyb3dTaXplPy5oZWlnaHQgPz8gMDtcbiAgICBjb25zdCBkZXNpcmVkUGxhY2VtZW50ID0gc2lkZSArIChhbGlnbiAhPT0gXCJjZW50ZXJcIiA/IFwiLVwiICsgYWxpZ24gOiBcIlwiKTtcbiAgICBjb25zdCBjb2xsaXNpb25QYWRkaW5nID0gdHlwZW9mIGNvbGxpc2lvblBhZGRpbmdQcm9wID09PSBcIm51bWJlclwiID8gY29sbGlzaW9uUGFkZGluZ1Byb3AgOiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgLi4uY29sbGlzaW9uUGFkZGluZ1Byb3AgfTtcbiAgICBjb25zdCBib3VuZGFyeSA9IEFycmF5LmlzQXJyYXkoY29sbGlzaW9uQm91bmRhcnkpID8gY29sbGlzaW9uQm91bmRhcnkgOiBbY29sbGlzaW9uQm91bmRhcnldO1xuICAgIGNvbnN0IGhhc0V4cGxpY2l0Qm91bmRhcmllcyA9IGJvdW5kYXJ5Lmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zID0ge1xuICAgICAgcGFkZGluZzogY29sbGlzaW9uUGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeS5maWx0ZXIoaXNOb3ROdWxsKSxcbiAgICAgIC8vIHdpdGggYHN0cmF0ZWd5OiAnZml4ZWQnYCwgdGhpcyBpcyB0aGUgb25seSB3YXkgdG8gZ2V0IGl0IHRvIHJlc3BlY3QgYm91bmRhcmllc1xuICAgICAgYWx0Qm91bmRhcnk6IGhhc0V4cGxpY2l0Qm91bmRhcmllc1xuICAgIH07XG4gICAgY29uc3QgeyByZWZzLCBmbG9hdGluZ1N0eWxlcywgcGxhY2VtZW50LCBpc1Bvc2l0aW9uZWQsIG1pZGRsZXdhcmVEYXRhIH0gPSB1c2VGbG9hdGluZyh7XG4gICAgICAvLyBkZWZhdWx0IHRvIGBmaXhlZGAgc3RyYXRlZ3kgc28gdXNlcnMgZG9uJ3QgaGF2ZSB0byBwaWNrIGFuZCB3ZSBhbHNvIGF2b2lkIGZvY3VzIHNjcm9sbCBpc3N1ZXNcbiAgICAgIHN0cmF0ZWd5OiBcImZpeGVkXCIsXG4gICAgICBwbGFjZW1lbnQ6IGRlc2lyZWRQbGFjZW1lbnQsXG4gICAgICB3aGlsZUVsZW1lbnRzTW91bnRlZDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGF1dG9VcGRhdGUoLi4uYXJncywge1xuICAgICAgICAgIGFuaW1hdGlvbkZyYW1lOiB1cGRhdGVQb3NpdGlvblN0cmF0ZWd5ID09PSBcImFsd2F5c1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICAgIH0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IGNvbnRleHQuYW5jaG9yXG4gICAgICB9LFxuICAgICAgbWlkZGxld2FyZTogW1xuICAgICAgICBvZmZzZXQoeyBtYWluQXhpczogc2lkZU9mZnNldCArIGFycm93SGVpZ2h0LCBhbGlnbm1lbnRBeGlzOiBhbGlnbk9mZnNldCB9KSxcbiAgICAgICAgYXZvaWRDb2xsaXNpb25zICYmIHNoaWZ0KHtcbiAgICAgICAgICBtYWluQXhpczogdHJ1ZSxcbiAgICAgICAgICBjcm9zc0F4aXM6IGZhbHNlLFxuICAgICAgICAgIGxpbWl0ZXI6IHN0aWNreSA9PT0gXCJwYXJ0aWFsXCIgPyBsaW1pdFNoaWZ0KCkgOiB2b2lkIDAsXG4gICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICAgIH0pLFxuICAgICAgICBhdm9pZENvbGxpc2lvbnMgJiYgZmxpcCh7IC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyB9KSxcbiAgICAgICAgc2l6ZSh7XG4gICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgIGFwcGx5OiAoeyBlbGVtZW50cywgcmVjdHMsIGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aDogYW5jaG9yV2lkdGgsIGhlaWdodDogYW5jaG9ySGVpZ2h0IH0gPSByZWN0cy5yZWZlcmVuY2U7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50U3R5bGUgPSBlbGVtZW50cy5mbG9hdGluZy5zdHlsZTtcbiAgICAgICAgICAgIGNvbnRlbnRTdHlsZS5zZXRQcm9wZXJ0eShcIi0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS13aWR0aFwiLCBgJHthdmFpbGFibGVXaWR0aH1weGApO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLWhlaWdodFwiLCBgJHthdmFpbGFibGVIZWlnaHR9cHhgKTtcbiAgICAgICAgICAgIGNvbnRlbnRTdHlsZS5zZXRQcm9wZXJ0eShcIi0tcmFkaXgtcG9wcGVyLWFuY2hvci13aWR0aFwiLCBgJHthbmNob3JXaWR0aH1weGApO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYW5jaG9yLWhlaWdodFwiLCBgJHthbmNob3JIZWlnaHR9cHhgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBhcnJvdyAmJiBmbG9hdGluZ1VJYXJyb3coeyBlbGVtZW50OiBhcnJvdywgcGFkZGluZzogYXJyb3dQYWRkaW5nIH0pLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4oeyBhcnJvd1dpZHRoLCBhcnJvd0hlaWdodCB9KSxcbiAgICAgICAgaGlkZVdoZW5EZXRhY2hlZCAmJiBoaWRlKHsgc3RyYXRlZ3k6IFwicmVmZXJlbmNlSGlkZGVuXCIsIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyB9KVxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IFtwbGFjZWRTaWRlLCBwbGFjZWRBbGlnbl0gPSBnZXRTaWRlQW5kQWxpZ25Gcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgaGFuZGxlUGxhY2VkID0gdXNlQ2FsbGJhY2tSZWYob25QbGFjZWQpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaXNQb3NpdGlvbmVkKSB7XG4gICAgICAgIGhhbmRsZVBsYWNlZD8uKCk7XG4gICAgICB9XG4gICAgfSwgW2lzUG9zaXRpb25lZCwgaGFuZGxlUGxhY2VkXSk7XG4gICAgY29uc3QgYXJyb3dYID0gbWlkZGxld2FyZURhdGEuYXJyb3c/Lng7XG4gICAgY29uc3QgYXJyb3dZID0gbWlkZGxld2FyZURhdGEuYXJyb3c/Lnk7XG4gICAgY29uc3QgY2Fubm90Q2VudGVyQXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8uY2VudGVyT2Zmc2V0ICE9PSAwO1xuICAgIGNvbnN0IFtjb250ZW50WkluZGV4LCBzZXRDb250ZW50WkluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZW50KSBzZXRDb250ZW50WkluZGV4KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRlbnQpLnpJbmRleCk7XG4gICAgfSwgW2NvbnRlbnRdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogcmVmcy5zZXRGbG9hdGluZyxcbiAgICAgICAgXCJkYXRhLXJhZGl4LXBvcHBlci1jb250ZW50LXdyYXBwZXJcIjogXCJcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAuLi5mbG9hdGluZ1N0eWxlcyxcbiAgICAgICAgICB0cmFuc2Zvcm06IGlzUG9zaXRpb25lZCA/IGZsb2F0aW5nU3R5bGVzLnRyYW5zZm9ybSA6IFwidHJhbnNsYXRlKDAsIC0yMDAlKVwiLFxuICAgICAgICAgIC8vIGtlZXAgb2ZmIHRoZSBwYWdlIHdoZW4gbWVhc3VyaW5nXG4gICAgICAgICAgbWluV2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgICB6SW5kZXg6IGNvbnRlbnRaSW5kZXgsXG4gICAgICAgICAgW1wiLS1yYWRpeC1wb3BwZXItdHJhbnNmb3JtLW9yaWdpblwiXTogW1xuICAgICAgICAgICAgbWlkZGxld2FyZURhdGEudHJhbnNmb3JtT3JpZ2luPy54LFxuICAgICAgICAgICAgbWlkZGxld2FyZURhdGEudHJhbnNmb3JtT3JpZ2luPy55XG4gICAgICAgICAgXS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAvLyBoaWRlIHRoZSBjb250ZW50IGlmIHVzaW5nIHRoZSBoaWRlIG1pZGRsZXdhcmUgYW5kIHNob3VsZCBiZSBoaWRkZW5cbiAgICAgICAgICAvLyBzZXQgdmlzaWJpbGl0eSB0byBoaWRkZW4gYW5kIGRpc2FibGUgcG9pbnRlciBldmVudHMgc28gdGhlIFVJIGJlaGF2ZXNcbiAgICAgICAgICAvLyBhcyBpZiB0aGUgUG9wcGVyQ29udGVudCBpc24ndCB0aGVyZSBhdCBhbGxcbiAgICAgICAgICAuLi5taWRkbGV3YXJlRGF0YS5oaWRlPy5yZWZlcmVuY2VIaWRkZW4gJiYge1xuICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkaXI6IHByb3BzLmRpcixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgUG9wcGVyQ29udGVudFByb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNjb3BlOiBfX3Njb3BlUG9wcGVyLFxuICAgICAgICAgICAgcGxhY2VkU2lkZSxcbiAgICAgICAgICAgIG9uQXJyb3dDaGFuZ2U6IHNldEFycm93LFxuICAgICAgICAgICAgYXJyb3dYLFxuICAgICAgICAgICAgYXJyb3dZLFxuICAgICAgICAgICAgc2hvdWxkSGlkZUFycm93OiBjYW5ub3RDZW50ZXJBcnJvdyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICBQcmltaXRpdmUuZGl2LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJkYXRhLXNpZGVcIjogcGxhY2VkU2lkZSxcbiAgICAgICAgICAgICAgICBcImRhdGEtYWxpZ25cIjogcGxhY2VkQWxpZ24sXG4gICAgICAgICAgICAgICAgLi4uY29udGVudFByb3BzLFxuICAgICAgICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgUG9wcGVyQ29udGVudCBoYXNuJ3QgYmVlbiBwbGFjZWQgeWV0IChub3QgYWxsIG1lYXN1cmVtZW50cyBkb25lKVxuICAgICAgICAgICAgICAgICAgLy8gd2UgcHJldmVudCBhbmltYXRpb25zIHNvIHRoYXQgdXNlcnMncyBhbmltYXRpb24gZG9uJ3Qga2ljayBpbiB0b28gZWFybHkgcmVmZXJyaW5nIHdyb25nIHNpZGVzXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb246ICFpc1Bvc2l0aW9uZWQgPyBcIm5vbmVcIiA6IHZvaWQgMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5Qb3BwZXJDb250ZW50LmRpc3BsYXlOYW1lID0gQ09OVEVOVF9OQU1FO1xudmFyIEFSUk9XX05BTUUgPSBcIlBvcHBlckFycm93XCI7XG52YXIgT1BQT1NJVEVfU0lERSA9IHtcbiAgdG9wOiBcImJvdHRvbVwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgbGVmdDogXCJyaWdodFwiXG59O1xudmFyIFBvcHBlckFycm93ID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBQb3BwZXJBcnJvdzIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7IF9fc2NvcGVQb3BwZXIsIC4uLmFycm93UHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZUNvbnRlbnRDb250ZXh0KEFSUk9XX05BTUUsIF9fc2NvcGVQb3BwZXIpO1xuICBjb25zdCBiYXNlU2lkZSA9IE9QUE9TSVRFX1NJREVbY29udGVudENvbnRleHQucGxhY2VkU2lkZV07XG4gIHJldHVybiAoXG4gICAgLy8gd2UgaGF2ZSB0byB1c2UgYW4gZXh0cmEgd3JhcHBlciBiZWNhdXNlIGBSZXNpemVPYnNlcnZlcmAgKHVzZWQgYnkgYHVzZVNpemVgKVxuICAgIC8vIGRvZXNuJ3QgcmVwb3J0IHNpemUgYXMgd2UnZCBleHBlY3Qgb24gU1ZHIGVsZW1lbnRzLlxuICAgIC8vIGl0IHJlcG9ydHMgdGhlaXIgYm91bmRpbmcgYm94IHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBsYXJnZXN0IHBhdGggaW5zaWRlIHRoZSBTVkcuXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFwic3BhblwiLFxuICAgICAge1xuICAgICAgICByZWY6IGNvbnRlbnRDb250ZXh0Lm9uQXJyb3dDaGFuZ2UsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICBsZWZ0OiBjb250ZW50Q29udGV4dC5hcnJvd1gsXG4gICAgICAgICAgdG9wOiBjb250ZW50Q29udGV4dC5hcnJvd1ksXG4gICAgICAgICAgW2Jhc2VTaWRlXTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IHtcbiAgICAgICAgICAgIHRvcDogXCJcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjAgMFwiLFxuICAgICAgICAgICAgYm90dG9tOiBcImNlbnRlciAwXCIsXG4gICAgICAgICAgICBsZWZ0OiBcIjEwMCUgMFwiXG4gICAgICAgICAgfVtjb250ZW50Q29udGV4dC5wbGFjZWRTaWRlXSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgICAgIHRvcDogXCJ0cmFuc2xhdGVZKDEwMCUpXCIsXG4gICAgICAgICAgICByaWdodDogXCJ0cmFuc2xhdGVZKDUwJSkgcm90YXRlKDkwZGVnKSB0cmFuc2xhdGVYKC01MCUpXCIsXG4gICAgICAgICAgICBib3R0b206IGByb3RhdGUoMTgwZGVnKWAsXG4gICAgICAgICAgICBsZWZ0OiBcInRyYW5zbGF0ZVkoNTAlKSByb3RhdGUoLTkwZGVnKSB0cmFuc2xhdGVYKDUwJSlcIlxuICAgICAgICAgIH1bY29udGVudENvbnRleHQucGxhY2VkU2lkZV0sXG4gICAgICAgICAgdmlzaWJpbGl0eTogY29udGVudENvbnRleHQuc2hvdWxkSGlkZUFycm93ID8gXCJoaWRkZW5cIiA6IHZvaWQgMFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICBBcnJvd1ByaW1pdGl2ZS5Sb290LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmFycm93UHJvcHMsXG4gICAgICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIC4uLmFycm93UHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgIC8vIGVuc3VyZXMgdGhlIGVsZW1lbnQgY2FuIGJlIG1lYXN1cmVkIGNvcnJlY3RseSAobW9zdGx5IGZvciBpZiBTVkcpXG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIClcbiAgKTtcbn0pO1xuUG9wcGVyQXJyb3cuZGlzcGxheU5hbWUgPSBBUlJPV19OQU1FO1xuZnVuY3Rpb24gaXNOb3ROdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbDtcbn1cbnZhciB0cmFuc2Zvcm1PcmlnaW4gPSAob3B0aW9ucykgPT4gKHtcbiAgbmFtZTogXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgb3B0aW9ucyxcbiAgZm4oZGF0YSkge1xuICAgIGNvbnN0IHsgcGxhY2VtZW50LCByZWN0cywgbWlkZGxld2FyZURhdGEgfSA9IGRhdGE7XG4gICAgY29uc3QgY2Fubm90Q2VudGVyQXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8uY2VudGVyT2Zmc2V0ICE9PSAwO1xuICAgIGNvbnN0IGlzQXJyb3dIaWRkZW4gPSBjYW5ub3RDZW50ZXJBcnJvdztcbiAgICBjb25zdCBhcnJvd1dpZHRoID0gaXNBcnJvd0hpZGRlbiA/IDAgOiBvcHRpb25zLmFycm93V2lkdGg7XG4gICAgY29uc3QgYXJyb3dIZWlnaHQgPSBpc0Fycm93SGlkZGVuID8gMCA6IG9wdGlvbnMuYXJyb3dIZWlnaHQ7XG4gICAgY29uc3QgW3BsYWNlZFNpZGUsIHBsYWNlZEFsaWduXSA9IGdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBub0Fycm93QWxpZ24gPSB7IHN0YXJ0OiBcIjAlXCIsIGNlbnRlcjogXCI1MCVcIiwgZW5kOiBcIjEwMCVcIiB9W3BsYWNlZEFsaWduXTtcbiAgICBjb25zdCBhcnJvd1hDZW50ZXIgPSAobWlkZGxld2FyZURhdGEuYXJyb3c/LnggPz8gMCkgKyBhcnJvd1dpZHRoIC8gMjtcbiAgICBjb25zdCBhcnJvd1lDZW50ZXIgPSAobWlkZGxld2FyZURhdGEuYXJyb3c/LnkgPz8gMCkgKyBhcnJvd0hlaWdodCAvIDI7XG4gICAgbGV0IHggPSBcIlwiO1xuICAgIGxldCB5ID0gXCJcIjtcbiAgICBpZiAocGxhY2VkU2lkZSA9PT0gXCJib3R0b21cIikge1xuICAgICAgeCA9IGlzQXJyb3dIaWRkZW4gPyBub0Fycm93QWxpZ24gOiBgJHthcnJvd1hDZW50ZXJ9cHhgO1xuICAgICAgeSA9IGAkey1hcnJvd0hlaWdodH1weGA7XG4gICAgfSBlbHNlIGlmIChwbGFjZWRTaWRlID09PSBcInRvcFwiKSB7XG4gICAgICB4ID0gaXNBcnJvd0hpZGRlbiA/IG5vQXJyb3dBbGlnbiA6IGAke2Fycm93WENlbnRlcn1weGA7XG4gICAgICB5ID0gYCR7cmVjdHMuZmxvYXRpbmcuaGVpZ2h0ICsgYXJyb3dIZWlnaHR9cHhgO1xuICAgIH0gZWxzZSBpZiAocGxhY2VkU2lkZSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICB4ID0gYCR7LWFycm93SGVpZ2h0fXB4YDtcbiAgICAgIHkgPSBpc0Fycm93SGlkZGVuID8gbm9BcnJvd0FsaWduIDogYCR7YXJyb3dZQ2VudGVyfXB4YDtcbiAgICB9IGVsc2UgaWYgKHBsYWNlZFNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICB4ID0gYCR7cmVjdHMuZmxvYXRpbmcud2lkdGggKyBhcnJvd0hlaWdodH1weGA7XG4gICAgICB5ID0gaXNBcnJvd0hpZGRlbiA/IG5vQXJyb3dBbGlnbiA6IGAke2Fycm93WUNlbnRlcn1weGA7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IHsgeCwgeSB9IH07XG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0U2lkZUFuZEFsaWduRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgY29uc3QgW3NpZGUsIGFsaWduID0gXCJjZW50ZXJcIl0gPSBwbGFjZW1lbnQuc3BsaXQoXCItXCIpO1xuICByZXR1cm4gW3NpZGUsIGFsaWduXTtcbn1cbnZhciBSb290MiA9IFBvcHBlcjtcbnZhciBBbmNob3IgPSBQb3BwZXJBbmNob3I7XG52YXIgQ29udGVudCA9IFBvcHBlckNvbnRlbnQ7XG52YXIgQXJyb3cgPSBQb3BwZXJBcnJvdztcbmV4cG9ydCB7XG4gIEFMSUdOX09QVElPTlMsXG4gIEFuY2hvcixcbiAgQXJyb3csXG4gIENvbnRlbnQsXG4gIFBvcHBlcixcbiAgUG9wcGVyQW5jaG9yLFxuICBQb3BwZXJBcnJvdyxcbiAgUG9wcGVyQ29udGVudCxcbiAgUm9vdDIgYXMgUm9vdCxcbiAgU0lERV9PUFRJT05TLFxuICBjcmVhdGVQb3BwZXJTY29wZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9wb3J0YWwvc3JjL3BvcnRhbC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBQT1JUQUxfTkFNRSA9IFwiUG9ydGFsXCI7XG52YXIgUG9ydGFsID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7IGNvbnRhaW5lcjogY29udGFpbmVyUHJvcCwgLi4ucG9ydGFsUHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiBzZXRNb3VudGVkKHRydWUpLCBbXSk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclByb3AgfHwgbW91bnRlZCAmJiBnbG9iYWxUaGlzPy5kb2N1bWVudD8uYm9keTtcbiAgcmV0dXJuIGNvbnRhaW5lciA/IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCgvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgLi4ucG9ydGFsUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pLCBjb250YWluZXIpIDogbnVsbDtcbn0pO1xuUG9ydGFsLmRpc3BsYXlOYW1lID0gUE9SVEFMX05BTUU7XG52YXIgUm9vdCA9IFBvcnRhbDtcbmV4cG9ydCB7XG4gIFBvcnRhbCxcbiAgUm9vdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3VzZS1jb250cm9sbGFibGUtc3RhdGUvc3JjL3VzZUNvbnRyb2xsYWJsZVN0YXRlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuZnVuY3Rpb24gdXNlQ29udHJvbGxhYmxlU3RhdGUoe1xuICBwcm9wLFxuICBkZWZhdWx0UHJvcCxcbiAgb25DaGFuZ2UgPSAoKSA9PiB7XG4gIH1cbn0pIHtcbiAgY29uc3QgW3VuY29udHJvbGxlZFByb3AsIHNldFVuY29udHJvbGxlZFByb3BdID0gdXNlVW5jb250cm9sbGVkU3RhdGUoeyBkZWZhdWx0UHJvcCwgb25DaGFuZ2UgfSk7XG4gIGNvbnN0IGlzQ29udHJvbGxlZCA9IHByb3AgIT09IHZvaWQgMDtcbiAgY29uc3QgdmFsdWUgPSBpc0NvbnRyb2xsZWQgPyBwcm9wIDogdW5jb250cm9sbGVkUHJvcDtcbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2tSZWYob25DaGFuZ2UpO1xuICBjb25zdCBzZXRWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChuZXh0VmFsdWUpID0+IHtcbiAgICAgIGlmIChpc0NvbnRyb2xsZWQpIHtcbiAgICAgICAgY29uc3Qgc2V0dGVyID0gbmV4dFZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSB0eXBlb2YgbmV4dFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBzZXR0ZXIocHJvcCkgOiBuZXh0VmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZTIgIT09IHByb3ApIGhhbmRsZUNoYW5nZSh2YWx1ZTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VW5jb250cm9sbGVkUHJvcChuZXh0VmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2lzQ29udHJvbGxlZCwgcHJvcCwgc2V0VW5jb250cm9sbGVkUHJvcCwgaGFuZGxlQ2hhbmdlXVxuICApO1xuICByZXR1cm4gW3ZhbHVlLCBzZXRWYWx1ZV07XG59XG5mdW5jdGlvbiB1c2VVbmNvbnRyb2xsZWRTdGF0ZSh7XG4gIGRlZmF1bHRQcm9wLFxuICBvbkNoYW5nZVxufSkge1xuICBjb25zdCB1bmNvbnRyb2xsZWRTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGRlZmF1bHRQcm9wKTtcbiAgY29uc3QgW3ZhbHVlXSA9IHVuY29udHJvbGxlZFN0YXRlO1xuICBjb25zdCBwcmV2VmFsdWVSZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFja1JlZihvbkNoYW5nZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZXZWYWx1ZVJlZi5jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgaGFuZGxlQ2hhbmdlKHZhbHVlKTtcbiAgICAgIHByZXZWYWx1ZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICB9LCBbdmFsdWUsIHByZXZWYWx1ZVJlZiwgaGFuZGxlQ2hhbmdlXSk7XG4gIHJldHVybiB1bmNvbnRyb2xsZWRTdGF0ZTtcbn1cbmV4cG9ydCB7XG4gIHVzZUNvbnRyb2xsYWJsZVN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLXByZXZpb3VzL3NyYy91c2VQcmV2aW91cy50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHsgdmFsdWUsIHByZXZpb3VzOiB2YWx1ZSB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudC52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHJlZi5jdXJyZW50LnByZXZpb3VzID0gcmVmLmN1cnJlbnQudmFsdWU7XG4gICAgICByZWYuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQucHJldmlvdXM7XG4gIH0sIFt2YWx1ZV0pO1xufVxuZXhwb3J0IHtcbiAgdXNlUHJldmlvdXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC92aXN1YWxseS1oaWRkZW4vc3JjL3Zpc3VhbGx5LWhpZGRlbi50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE5BTUUgPSBcIlZpc3VhbGx5SGlkZGVuXCI7XG52YXIgVmlzdWFsbHlIaWRkZW4gPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgUHJpbWl0aXZlLnNwYW4sXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vc2Nzcy9taXhpbnMvX3Zpc3VhbGx5LWhpZGRlbi5zY3NzXG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgbWFyZ2luOiAtMSxcbiAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICBjbGlwOiBcInJlY3QoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuVmlzdWFsbHlIaWRkZW4uZGlzcGxheU5hbWUgPSBOQU1FO1xudmFyIFJvb3QgPSBWaXN1YWxseUhpZGRlbjtcbmV4cG9ydCB7XG4gIFJvb3QsXG4gIFZpc3VhbGx5SGlkZGVuXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGdldERlZmF1bHRQYXJlbnQgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNhbXBsZVRhcmdldCA9IEFycmF5LmlzQXJyYXkob3JpZ2luYWxUYXJnZXQpID8gb3JpZ2luYWxUYXJnZXRbMF0gOiBvcmlnaW5hbFRhcmdldDtcbiAgICByZXR1cm4gc2FtcGxlVGFyZ2V0Lm93bmVyRG9jdW1lbnQuYm9keTtcbn07XG52YXIgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgdW5jb250cm9sbGVkTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xudmFyIG1hcmtlck1hcCA9IHt9O1xudmFyIGxvY2tDb3VudCA9IDA7XG52YXIgdW53cmFwSG9zdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUuaG9zdCB8fCB1bndyYXBIb3N0KG5vZGUucGFyZW50Tm9kZSkpO1xufTtcbnZhciBjb3JyZWN0VGFyZ2V0cyA9IGZ1bmN0aW9uIChwYXJlbnQsIHRhcmdldHMpIHtcbiAgICByZXR1cm4gdGFyZ2V0c1xuICAgICAgICAubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JyZWN0ZWRUYXJnZXQgPSB1bndyYXBIb3N0KHRhcmdldCk7XG4gICAgICAgIGlmIChjb3JyZWN0ZWRUYXJnZXQgJiYgcGFyZW50LmNvbnRhaW5zKGNvcnJlY3RlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3JyZWN0ZWRUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcignYXJpYS1oaWRkZW4nLCB0YXJnZXQsICdpbiBub3QgY29udGFpbmVkIGluc2lkZScsIHBhcmVudCwgJy4gRG9pbmcgbm90aGluZycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBCb29sZWFuKHgpOyB9KTtcbn07XG4vKipcbiAqIE1hcmtzIGV2ZXJ5dGhpbmcgZXhjZXB0IGdpdmVuIG5vZGUob3Igbm9kZXMpIGFzIGFyaWEtaGlkZGVuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBFbGVtZW50W119IG9yaWdpbmFsVGFyZ2V0IC0gZWxlbWVudHMgdG8ga2VlcCBvbiB0aGUgcGFnZVxuICogQHBhcmFtIFtwYXJlbnROb2RlXSAtIHRvcCBlbGVtZW50LCBkZWZhdWx0cyB0byBkb2N1bWVudC5ib2R5XG4gKiBAcGFyYW0ge1N0cmluZ30gW21hcmtlck5hbWVdIC0gYSBzcGVjaWFsIGF0dHJpYnV0ZSB0byBtYXJrIGV2ZXJ5IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29udHJvbEF0dHJpYnV0ZV0gLSBodG1sIEF0dHJpYnV0ZSB0byBjb250cm9sXG4gKiBAcmV0dXJuIHtVbmRvfSB1bmRvIGNvbW1hbmRcbiAqL1xudmFyIGFwcGx5QXR0cmlidXRlVG9PdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUsIGNvbnRyb2xBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IGNvcnJlY3RUYXJnZXRzKHBhcmVudE5vZGUsIEFycmF5LmlzQXJyYXkob3JpZ2luYWxUYXJnZXQpID8gb3JpZ2luYWxUYXJnZXQgOiBbb3JpZ2luYWxUYXJnZXRdKTtcbiAgICBpZiAoIW1hcmtlck1hcFttYXJrZXJOYW1lXSkge1xuICAgICAgICBtYXJrZXJNYXBbbWFya2VyTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICB2YXIgbWFya2VyQ291bnRlciA9IG1hcmtlck1hcFttYXJrZXJOYW1lXTtcbiAgICB2YXIgaGlkZGVuTm9kZXMgPSBbXTtcbiAgICB2YXIgZWxlbWVudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGVsZW1lbnRzVG9TdG9wID0gbmV3IFNldCh0YXJnZXRzKTtcbiAgICB2YXIga2VlcCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoIWVsIHx8IGVsZW1lbnRzVG9LZWVwLmhhcyhlbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50c1RvS2VlcC5hZGQoZWwpO1xuICAgICAgICBrZWVwKGVsLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgdGFyZ2V0cy5mb3JFYWNoKGtlZXApO1xuICAgIHZhciBkZWVwID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBlbGVtZW50c1RvU3RvcC5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzVG9LZWVwLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGRlZXAobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeUhpZGRlbiA9IGF0dHIgIT09IG51bGwgJiYgYXR0ciAhPT0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyTWFwLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJNYXAuc2V0KG5vZGUsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJWYWx1ZSA9PT0gMSAmJiBhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmNvbnRyb2xsZWROb2Rlcy5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlclZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShtYXJrZXJOYW1lLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeUhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSwgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhcmlhLWhpZGRlbjogY2Fubm90IG9wZXJhdGUgb24gJywgbm9kZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGRlZXAocGFyZW50Tm9kZSk7XG4gICAgZWxlbWVudHNUb0tlZXAuY2xlYXIoKTtcbiAgICBsb2NrQ291bnQrKztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRkZW5Ob2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgY291bnRlclZhbHVlID0gY291bnRlck1hcC5nZXQobm9kZSkgLSAxO1xuICAgICAgICAgICAgdmFyIG1hcmtlclZhbHVlID0gbWFya2VyQ291bnRlci5nZXQobm9kZSkgLSAxO1xuICAgICAgICAgICAgY291bnRlck1hcC5zZXQobm9kZSwgY291bnRlclZhbHVlKTtcbiAgICAgICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgICAgIGlmICghY291bnRlclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmNvbnRyb2xsZWROb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuY29udHJvbGxlZE5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWFya2VyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShtYXJrZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxvY2tDb3VudC0tO1xuICAgICAgICBpZiAoIWxvY2tDb3VudCkge1xuICAgICAgICAgICAgLy8gY2xlYXJcbiAgICAgICAgICAgIGNvdW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICB1bmNvbnRyb2xsZWROb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBtYXJrZXJNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBNYXJrcyBldmVyeXRoaW5nIGV4Y2VwdCBnaXZlbiBub2RlKG9yIG5vZGVzKSBhcyBhcmlhLWhpZGRlblxuICogQHBhcmFtIHtFbGVtZW50IHwgRWxlbWVudFtdfSBvcmlnaW5hbFRhcmdldCAtIGVsZW1lbnRzIHRvIGtlZXAgb24gdGhlIHBhZ2VcbiAqIEBwYXJhbSBbcGFyZW50Tm9kZV0gLSB0b3AgZWxlbWVudCwgZGVmYXVsdHMgdG8gZG9jdW1lbnQuYm9keVxuICogQHBhcmFtIHtTdHJpbmd9IFttYXJrZXJOYW1lXSAtIGEgc3BlY2lhbCBhdHRyaWJ1dGUgdG8gbWFyayBldmVyeSBub2RlXG4gKiBAcmV0dXJuIHtVbmRvfSB1bmRvIGNvbW1hbmRcbiAqL1xuZXhwb3J0IHZhciBoaWRlT3RoZXJzID0gZnVuY3Rpb24gKG9yaWdpbmFsVGFyZ2V0LCBwYXJlbnROb2RlLCBtYXJrZXJOYW1lKSB7XG4gICAgaWYgKG1hcmtlck5hbWUgPT09IHZvaWQgMCkgeyBtYXJrZXJOYW1lID0gJ2RhdGEtYXJpYS1oaWRkZW4nOyB9XG4gICAgdmFyIHRhcmdldHMgPSBBcnJheS5mcm9tKEFycmF5LmlzQXJyYXkob3JpZ2luYWxUYXJnZXQpID8gb3JpZ2luYWxUYXJnZXQgOiBbb3JpZ2luYWxUYXJnZXRdKTtcbiAgICB2YXIgYWN0aXZlUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgZ2V0RGVmYXVsdFBhcmVudChvcmlnaW5hbFRhcmdldCk7XG4gICAgaWYgKCFhY3RpdmVQYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIH1cbiAgICAvLyB3ZSBzaG91bGQgbm90IGhpZGUgYXJpYUxpdmUgZWxlbWVudHMgLSBodHRwczovL2dpdGh1Yi5jb20vdGhlS2FzaGV5L2FyaWEtaGlkZGVuL2lzc3Vlcy8xMFxuICAgIHRhcmdldHMucHVzaC5hcHBseSh0YXJnZXRzLCBBcnJheS5mcm9tKGFjdGl2ZVBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2FyaWEtbGl2ZV0nKSkpO1xuICAgIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKHRhcmdldHMsIGFjdGl2ZVBhcmVudE5vZGUsIG1hcmtlck5hbWUsICdhcmlhLWhpZGRlbicpO1xufTtcbi8qKlxuICogTWFya3MgZXZlcnl0aGluZyBleGNlcHQgZ2l2ZW4gbm9kZShvciBub2RlcykgYXMgaW5lcnRcbiAqIEBwYXJhbSB7RWxlbWVudCB8IEVsZW1lbnRbXX0gb3JpZ2luYWxUYXJnZXQgLSBlbGVtZW50cyB0byBrZWVwIG9uIHRoZSBwYWdlXG4gKiBAcGFyYW0gW3BhcmVudE5vZGVdIC0gdG9wIGVsZW1lbnQsIGRlZmF1bHRzIHRvIGRvY3VtZW50LmJvZHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWFya2VyTmFtZV0gLSBhIHNwZWNpYWwgYXR0cmlidXRlIHRvIG1hcmsgZXZlcnkgbm9kZVxuICogQHJldHVybiB7VW5kb30gdW5kbyBjb21tYW5kXG4gKi9cbmV4cG9ydCB2YXIgaW5lcnRPdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpIHtcbiAgICBpZiAobWFya2VyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcmtlck5hbWUgPSAnZGF0YS1pbmVydC1lZCc7IH1cbiAgICB2YXIgYWN0aXZlUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgZ2V0RGVmYXVsdFBhcmVudChvcmlnaW5hbFRhcmdldCk7XG4gICAgaWYgKCFhY3RpdmVQYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHlBdHRyaWJ1dGVUb090aGVycyhvcmlnaW5hbFRhcmdldCwgYWN0aXZlUGFyZW50Tm9kZSwgbWFya2VyTmFtZSwgJ2luZXJ0Jyk7XG59O1xuLyoqXG4gKiBAcmV0dXJucyBpZiBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgaW5lcnRcbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0luZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIEhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKTtcbn07XG4vKipcbiAqIEF1dG9tYXRpYyBmdW5jdGlvbiB0byBcInN1cHByZXNzXCIgRE9NIGVsZW1lbnRzIC0gX2hpZGVfIG9yIF9pbmVydF8gaW4gdGhlIGJlc3QgcG9zc2libGUgd2F5XG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBFbGVtZW50W119IG9yaWdpbmFsVGFyZ2V0IC0gZWxlbWVudHMgdG8ga2VlcCBvbiB0aGUgcGFnZVxuICogQHBhcmFtIFtwYXJlbnROb2RlXSAtIHRvcCBlbGVtZW50LCBkZWZhdWx0cyB0byBkb2N1bWVudC5ib2R5XG4gKiBAcGFyYW0ge1N0cmluZ30gW21hcmtlck5hbWVdIC0gYSBzcGVjaWFsIGF0dHJpYnV0ZSB0byBtYXJrIGV2ZXJ5IG5vZGVcbiAqIEByZXR1cm4ge1VuZG99IHVuZG8gY29tbWFuZFxuICovXG5leHBvcnQgdmFyIHN1cHByZXNzT3RoZXJzID0gZnVuY3Rpb24gKG9yaWdpbmFsVGFyZ2V0LCBwYXJlbnROb2RlLCBtYXJrZXJOYW1lKSB7XG4gICAgaWYgKG1hcmtlck5hbWUgPT09IHZvaWQgMCkgeyBtYXJrZXJOYW1lID0gJ2RhdGEtc3VwcHJlc3NlZCc7IH1cbiAgICByZXR1cm4gKHN1cHBvcnRzSW5lcnQoKSA/IGluZXJ0T3RoZXJzIDogaGlkZU90aGVycykob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpO1xufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcbiAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG52YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGFyID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICByZXR1cm4gYXI7XG4gIH07XG4gIHJldHVybiBvd25LZXlzKG8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICBpZiAoYXN5bmMpIGlubmVyID0gZGlzcG9zZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkgeyB0cnkgeyBpbm5lci5jYWxsKHRoaXMpOyB9IGNhdGNoIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSB9O1xuICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gIH1cbiAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xuICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgfVxuICB2YXIgciwgcyA9IDA7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKHIgPSBlbnYuc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghci5hc3luYyAmJiBzID09PSAxKSByZXR1cm4gcyA9IDAsIGVudi5zdGFjay5wdXNoKHIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xuICAgICAgICBpZiAoci5kaXNwb3NlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHIuZGlzcG9zZS5jYWxsKHIudmFsdWUpO1xuICAgICAgICAgIGlmIChyLmFzeW5jKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzIHw9IDE7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA9PT0gMSkgcmV0dXJuIGVudi5oYXNFcnJvciA/IFByb21pc2UucmVqZWN0KGVudi5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uKHBhdGgsIHByZXNlcnZlSnN4KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLlxcLj9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLih0c3gpJHwoKD86XFwuZCk/KSgoPzpcXC5bXi4vXSs/KT8pXFwuKFtjbV0/KXRzJC9pLCBmdW5jdGlvbiAobSwgdHN4LCBkLCBleHQsIGNtKSB7XG4gICAgICAgICAgcmV0dXJuIHRzeCA/IHByZXNlcnZlSnN4ID8gXCIuanN4XCIgOiBcIi5qc1wiIDogZCAmJiAoIWV4dCB8fCAhY20pID8gbSA6IChkICsgZXh0ICsgXCIuXCIgKyBjbS50b0xvd2VyQ2FzZSgpICsgXCJqc1wiKTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19lc0RlY29yYXRlLFxuICBfX3J1bkluaXRpYWxpemVycyxcbiAgX19wcm9wS2V5LFxuICBfX3NldEZ1bmN0aW9uTmFtZSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG4gIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uLFxufTtcbiIsImV4cG9ydCB2YXIgemVyb1JpZ2h0Q2xhc3NOYW1lID0gJ3JpZ2h0LXNjcm9sbC1iYXItcG9zaXRpb24nO1xuZXhwb3J0IHZhciBmdWxsV2lkdGhDbGFzc05hbWUgPSAnd2lkdGgtYmVmb3JlLXNjcm9sbC1iYXInO1xuZXhwb3J0IHZhciBub1Njcm9sbGJhcnNDbGFzc05hbWUgPSAnd2l0aC1zY3JvbGwtYmFycy1oaWRkZW4nO1xuLyoqXG4gKiBOYW1lIG9mIGEgQ1NTIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlIGFtb3VudCBvZiBcImhpZGRlblwiIHNjcm9sbGJhclxuICogISBtaWdodCBiZSB1bmRlZmluZWQgISB1c2Ugd2lsbCBmYWxsYmFjayFcbiAqL1xuZXhwb3J0IHZhciByZW1vdmVkQmFyU2l6ZVZhcmlhYmxlID0gJy0tcmVtb3ZlZC1ib2R5LXNjcm9sbC1iYXItc2l6ZSc7XG4iLCIvKipcbiAqIEFzc2lnbnMgYSB2YWx1ZSBmb3IgYSBnaXZlbiByZWYsIG5vIG1hdHRlciBvZiB0aGUgcmVmIGZvcm1hdFxuICogQHBhcmFtIHtSZWZPYmplY3R9IHJlZiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gb3IgcmVmIG9iamVjdFxuICogQHBhcmFtIHZhbHVlIC0gYSBuZXcgdmFsdWVcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvdXNlLWNhbGxiYWNrLXJlZiNhc3NpZ25yZWZcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZWZPYmplY3QgPSB1c2VSZWYoKTtcbiAqIGNvbnN0IHJlZkZuID0gKHJlZikgPT4gey4uLi59XG4gKlxuICogYXNzaWduUmVmKHJlZk9iamVjdCwgXCJyZWZWYWx1ZVwiKTtcbiAqIGFzc2lnblJlZihyZWZGbiwgXCJyZWZWYWx1ZVwiKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnblJlZihyZWYsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG4iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogY3JlYXRlcyBhIE11dGFibGVSZWYgd2l0aCByZWYgY2hhbmdlIGNhbGxiYWNrXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIC0gaW5pdGlhbCByZWYgdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gYSBjYWxsYmFjayB0byBydW4gd2hlbiB2YWx1ZSBjaGFuZ2VzXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlZiA9IHVzZUNhbGxiYWNrUmVmKDAsIChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IGNvbnNvbGUubG9nKG9sZFZhbHVlLCAnLT4nLCBuZXdWYWx1ZSk7XG4gKiByZWYuY3VycmVudCA9IDE7XG4gKiAvLyBwcmludHMgMCAtPiAxXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlcmVmXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvdXNlLWNhbGxiYWNrLXJlZiN1c2VjYWxsYmFja3JlZi0tLXRvLXJlcGxhY2UtcmVhY3R1c2VyZWZcbiAqIEByZXR1cm5zIHtNdXRhYmxlUmVmT2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoaW5pdGlhbFZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZWYgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAvLyB2YWx1ZVxuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlLFxuICAgICAgICAvLyBsYXN0IGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgLy8gXCJtZW1vaXplZFwiIHB1YmxpYyBpbnRlcmZhY2VcbiAgICAgICAgZmFjYWRlOiB7XG4gICAgICAgICAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmLnZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBjdXJyZW50KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZWYuY2FsbGJhY2sodmFsdWUsIGxhc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7IH0pWzBdO1xuICAgIC8vIHVwZGF0ZSBjYWxsYmFja1xuICAgIHJlZi5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiByZWYuZmFjYWRlO1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduUmVmIH0gZnJvbSAnLi9hc3NpZ25SZWYnO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2tSZWYgfSBmcm9tICcuL3VzZVJlZic7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIGN1cnJlbnRWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBNZXJnZXMgdHdvIG9yIG1vcmUgcmVmcyB0b2dldGhlciBwcm92aWRpbmcgYSBzaW5nbGUgaW50ZXJmYWNlIHRvIHNldCB0aGVpciB2YWx1ZVxuICogQHBhcmFtIHtSZWZPYmplY3R8UmVmfSByZWZzXG4gKiBAcmV0dXJucyB7TXV0YWJsZVJlZk9iamVjdH0gLSBhIG5ldyByZWYsIHdoaWNoIHRyYW5zbGF0ZXMgYWxsIGNoYW5nZXMgdG8ge3JlZnN9XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VSZWZzfSBhIHZlcnNpb24gd2l0aG91dCBidWl0LWluIG1lbW9pemF0aW9uXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvdXNlLWNhbGxiYWNrLXJlZiN1c2VtZXJnZXJlZnNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gKiAgIGNvbnN0IG93blJlZiA9IHVzZVJlZigpO1xuICogICBjb25zdCBkb21SZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgb3duUmVmXSk7IC8vIPCfkYggbWVyZ2UgdG9nZXRoZXJcbiAqICAgcmV0dXJuIDxkaXYgcmVmPXtkb21SZWZ9Pi4uLjwvZGl2PlxuICogfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VSZWZzKHJlZnMsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciBjYWxsYmFja1JlZiA9IHVzZUNhbGxiYWNrUmVmKGRlZmF1bHRWYWx1ZSB8fCBudWxsLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBhc3NpZ25SZWYocmVmLCBuZXdWYWx1ZSk7IH0pO1xuICAgIH0pO1xuICAgIC8vIGhhbmRsZSByZWZzIGNoYW5nZXMgLSBhZGRlZCBvciByZW1vdmVkXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZXMuZ2V0KGNhbGxiYWNrUmVmKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJldlJlZnNfMSA9IG5ldyBTZXQob2xkVmFsdWUpO1xuICAgICAgICAgICAgdmFyIG5leHRSZWZzXzEgPSBuZXcgU2V0KHJlZnMpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfMSA9IGNhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBwcmV2UmVmc18xLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFJlZnNfMS5oYXMocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25SZWYocmVmLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRSZWZzXzEuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2UmVmc18xLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnblJlZihyZWYsIGN1cnJlbnRfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFZhbHVlcy5zZXQoY2FsbGJhY2tSZWYsIHJlZnMpO1xuICAgIH0sIFtyZWZzXSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrUmVmO1xufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmZ1bmN0aW9uIEl0b0koYSkge1xuICAgIHJldHVybiBhO1xufVxuZnVuY3Rpb24gaW5uZXJDcmVhdGVNZWRpdW0oZGVmYXVsdHMsIG1pZGRsZXdhcmUpIHtcbiAgICBpZiAobWlkZGxld2FyZSA9PT0gdm9pZCAwKSB7IG1pZGRsZXdhcmUgPSBJdG9JOyB9XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciBhc3NpZ25lZCA9IGZhbHNlO1xuICAgIHZhciBtZWRpdW0gPSB7XG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhc3NpZ25lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lkZWNhcjogY291bGQgbm90IGByZWFkYCBmcm9tIGFuIGBhc3NpZ25lZGAgbWVkaXVtLiBgcmVhZGAgY291bGQgYmUgdXNlZCBvbmx5IHdpdGggYHVzZU1lZGl1bWAuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZWRpdW06IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1pZGRsZXdhcmUoZGF0YSwgYXNzaWduZWQpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IGl0ZW07IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXNzaWduU3luY01lZGl1bTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBhc3NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjYnMgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgY2JzLmZvckVhY2goY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0ge1xuICAgICAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBjYih4KTsgfSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1ZmZlcjsgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFzc2lnbk1lZGl1bTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBhc3NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ1F1ZXVlID0gW107XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjYnMgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgY2JzLmZvckVhY2goY2IpO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleGVjdXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNicyA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBjYnMuZm9yRWFjaChjYik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGN5Y2xlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihleGVjdXRlUXVldWUpOyB9O1xuICAgICAgICAgICAgY3ljbGUoKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHtcbiAgICAgICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUXVldWUucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgY3ljbGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUXVldWUgPSBwZW5kaW5nUXVldWUuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gbWVkaXVtO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lZGl1bShkZWZhdWx0cywgbWlkZGxld2FyZSkge1xuICAgIGlmIChtaWRkbGV3YXJlID09PSB2b2lkIDApIHsgbWlkZGxld2FyZSA9IEl0b0k7IH1cbiAgICByZXR1cm4gaW5uZXJDcmVhdGVNZWRpdW0oZGVmYXVsdHMsIG1pZGRsZXdhcmUpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaWRlY2FyTWVkaXVtKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBtZWRpdW0gPSBpbm5lckNyZWF0ZU1lZGl1bShudWxsKTtcbiAgICBtZWRpdW0ub3B0aW9ucyA9IF9fYXNzaWduKHsgYXN5bmM6IHRydWUsIHNzcjogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG1lZGl1bTtcbn1cbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbnZhciBTaWRlQ2FyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNpZGVDYXIgPSBfYS5zaWRlQ2FyLCByZXN0ID0gX19yZXN0KF9hLCBbXCJzaWRlQ2FyXCJdKTtcbiAgICBpZiAoIXNpZGVDYXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWRlY2FyOiBwbGVhc2UgcHJvdmlkZSBgc2lkZUNhcmAgcHJvcGVydHkgdG8gaW1wb3J0IHRoZSByaWdodCBjYXInKTtcbiAgICB9XG4gICAgdmFyIFRhcmdldCA9IHNpZGVDYXIucmVhZCgpO1xuICAgIGlmICghVGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2lkZWNhciBtZWRpdW0gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRhcmdldCwgX19hc3NpZ24oe30sIHJlc3QpKTtcbn07XG5TaWRlQ2FyLmlzU2lkZUNhckV4cG9ydCA9IHRydWU7XG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0U2lkZWNhcihtZWRpdW0sIGV4cG9ydGVkKSB7XG4gICAgbWVkaXVtLnVzZU1lZGl1bShleHBvcnRlZCk7XG4gICAgcmV0dXJuIFNpZGVDYXI7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVTaWRlY2FyTWVkaXVtIH0gZnJvbSAndXNlLXNpZGVjYXInO1xuZXhwb3J0IHZhciBlZmZlY3RDYXIgPSBjcmVhdGVTaWRlY2FyTWVkaXVtKCk7XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmdWxsV2lkdGhDbGFzc05hbWUsIHplcm9SaWdodENsYXNzTmFtZSB9IGZyb20gJ3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyL2NvbnN0YW50cyc7XG5pbXBvcnQgeyB1c2VNZXJnZVJlZnMgfSBmcm9tICd1c2UtY2FsbGJhY2stcmVmJztcbmltcG9ydCB7IGVmZmVjdENhciB9IGZyb20gJy4vbWVkaXVtJztcbnZhciBub3RoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbn07XG4vKipcbiAqIFJlbW92ZXMgc2Nyb2xsYmFyIGZyb20gdGhlIHBhZ2UgYW5kIGNvbnRhaW4gdGhlIHNjcm9sbCB3aXRoaW4gdGhlIExvY2tcbiAqL1xudmFyIFJlbW92ZVNjcm9sbCA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCBwYXJlbnRSZWYpIHtcbiAgICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgb25TY3JvbGxDYXB0dXJlOiBub3RoaW5nLFxuICAgICAgICBvbldoZWVsQ2FwdHVyZTogbm90aGluZyxcbiAgICAgICAgb25Ub3VjaE1vdmVDYXB0dXJlOiBub3RoaW5nLFxuICAgIH0pLCBjYWxsYmFja3MgPSBfYVswXSwgc2V0Q2FsbGJhY2tzID0gX2FbMV07XG4gICAgdmFyIGZvcndhcmRQcm9wcyA9IHByb3BzLmZvcndhcmRQcm9wcywgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCByZW1vdmVTY3JvbGxCYXIgPSBwcm9wcy5yZW1vdmVTY3JvbGxCYXIsIGVuYWJsZWQgPSBwcm9wcy5lbmFibGVkLCBzaGFyZHMgPSBwcm9wcy5zaGFyZHMsIHNpZGVDYXIgPSBwcm9wcy5zaWRlQ2FyLCBub0lzb2xhdGlvbiA9IHByb3BzLm5vSXNvbGF0aW9uLCBpbmVydCA9IHByb3BzLmluZXJ0LCBhbGxvd1BpbmNoWm9vbSA9IHByb3BzLmFsbG93UGluY2hab29tLCBfYiA9IHByb3BzLmFzLCBDb250YWluZXIgPSBfYiA9PT0gdm9pZCAwID8gJ2RpdicgOiBfYiwgZ2FwTW9kZSA9IHByb3BzLmdhcE1vZGUsIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcImZvcndhcmRQcm9wc1wiLCBcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwicmVtb3ZlU2Nyb2xsQmFyXCIsIFwiZW5hYmxlZFwiLCBcInNoYXJkc1wiLCBcInNpZGVDYXJcIiwgXCJub0lzb2xhdGlvblwiLCBcImluZXJ0XCIsIFwiYWxsb3dQaW5jaFpvb21cIiwgXCJhc1wiLCBcImdhcE1vZGVcIl0pO1xuICAgIHZhciBTaWRlQ2FyID0gc2lkZUNhcjtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gdXNlTWVyZ2VSZWZzKFtyZWYsIHBhcmVudFJlZl0pO1xuICAgIHZhciBjb250YWluZXJQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN0KSwgY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGVuYWJsZWQgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lkZUNhciwgeyBzaWRlQ2FyOiBlZmZlY3RDYXIsIHJlbW92ZVNjcm9sbEJhcjogcmVtb3ZlU2Nyb2xsQmFyLCBzaGFyZHM6IHNoYXJkcywgbm9Jc29sYXRpb246IG5vSXNvbGF0aW9uLCBpbmVydDogaW5lcnQsIHNldENhbGxiYWNrczogc2V0Q2FsbGJhY2tzLCBhbGxvd1BpbmNoWm9vbTogISFhbGxvd1BpbmNoWm9vbSwgbG9ja1JlZjogcmVmLCBnYXBNb2RlOiBnYXBNb2RlIH0pKSxcbiAgICAgICAgZm9yd2FyZFByb3BzID8gKFJlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbnRhaW5lclByb3BzKSwgeyByZWY6IGNvbnRhaW5lclJlZiB9KSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCBfX2Fzc2lnbih7fSwgY29udGFpbmVyUHJvcHMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHJlZjogY29udGFpbmVyUmVmIH0pLCBjaGlsZHJlbikpKSk7XG59KTtcblJlbW92ZVNjcm9sbC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICByZW1vdmVTY3JvbGxCYXI6IHRydWUsXG4gICAgaW5lcnQ6IGZhbHNlLFxufTtcblJlbW92ZVNjcm9sbC5jbGFzc05hbWVzID0ge1xuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoQ2xhc3NOYW1lLFxuICAgIHplcm9SaWdodDogemVyb1JpZ2h0Q2xhc3NOYW1lLFxufTtcbmV4cG9ydCB7IFJlbW92ZVNjcm9sbCB9O1xuIiwidmFyIGN1cnJlbnROb25jZTtcbmV4cG9ydCB2YXIgc2V0Tm9uY2UgPSBmdW5jdGlvbiAobm9uY2UpIHtcbiAgICBjdXJyZW50Tm9uY2UgPSBub25jZTtcbn07XG5leHBvcnQgdmFyIGdldE5vbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50Tm9uY2UpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb25jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbiIsImltcG9ydCB7IGdldE5vbmNlIH0gZnJvbSAnZ2V0LW5vbmNlJztcbmZ1bmN0aW9uIG1ha2VTdHlsZVRhZygpIHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICB0YWcudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5mdW5jdGlvbiBpbmplY3RTdHlsZXModGFnLCBjc3MpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHRhZy5zdHlsZVNoZWV0KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZVRhZyh0YWcpIHtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG59XG5leHBvcnQgdmFyIHN0eWxlc2hlZXRTaW5nbGV0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBzdHlsZXNoZWV0ID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgoc3R5bGVzaGVldCA9IG1ha2VTdHlsZVRhZygpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmplY3RTdHlsZXMoc3R5bGVzaGVldCwgc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTdHlsZVRhZyhzdHlsZXNoZWV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgaWYgKCFjb3VudGVyICYmIHN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LnBhcmVudE5vZGUgJiYgc3R5bGVzaGVldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59O1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3R5bGVzaGVldFNpbmdsZXRvbiB9IGZyb20gJy4vc2luZ2xldG9uJztcbi8qKlxuICogY3JlYXRlcyBhIGhvb2sgdG8gY29udHJvbCBzdHlsZSBzaW5nbGV0b25cbiAqIEBzZWUge0BsaW5rIHN0eWxlU2luZ2xldG9ufSBmb3IgYSBzYWZlciBjb21wb25lbnQgdmVyc2lvblxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgdXNlU3R5bGUgPSBzdHlsZUhvb2tTaW5nbGV0b24oKTtcbiAqIC8vL1xuICogdXNlU3R5bGUoJ2JvZHkgeyBvdmVyZmxvdzogaGlkZGVufScpO1xuICovXG5leHBvcnQgdmFyIHN0eWxlSG9va1NpbmdsZXRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2hlZXQgPSBzdHlsZXNoZWV0U2luZ2xldG9uKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHlsZXMsIGlzRHluYW1pYykge1xuICAgICAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2hlZXQuYWRkKHN0eWxlcyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNoZWV0LnJlbW92ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW3N0eWxlcyAmJiBpc0R5bmFtaWNdKTtcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IHN0eWxlSG9va1NpbmdsZXRvbiB9IGZyb20gJy4vaG9vayc7XG4vKipcbiAqIGNyZWF0ZSBhIENvbXBvbmVudCB0byBhZGQgc3R5bGVzIG9uIGRlbWFuZFxuICogLSBzdHlsZXMgYXJlIGFkZGVkIHdoZW4gZmlyc3QgaW5zdGFuY2UgaXMgbW91bnRlZFxuICogLSBzdHlsZXMgYXJlIHJlbW92ZWQgd2hlbiB0aGUgbGFzdCBpbnN0YW5jZSBpcyB1bm1vdW50ZWRcbiAqIC0gY2hhbmdpbmcgc3R5bGVzIGluIHJ1bnRpbWUgZG9lcyBub3RoaW5nIHVubGVzcyBkeW5hbWljIGlzIHNldC4gQnV0IHdpdGggbXVsdGlwbGUgY29tcG9uZW50cyB0aGF0IGNhbiBsZWFkIHRvIHRoZSB1bmRlZmluZWQgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHZhciBzdHlsZVNpbmdsZXRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlU3R5bGUgPSBzdHlsZUhvb2tTaW5nbGV0b24oKTtcbiAgICB2YXIgU2hlZXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IF9hLnN0eWxlcywgZHluYW1pYyA9IF9hLmR5bmFtaWM7XG4gICAgICAgIHVzZVN0eWxlKHN0eWxlcywgZHluYW1pYyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFNoZWV0O1xufTtcbiIsImV4cG9ydCB2YXIgemVyb0dhcCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBnYXA6IDAsXG59O1xudmFyIHBhcnNlID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHBhcnNlSW50KHggfHwgJycsIDEwKSB8fCAwOyB9O1xudmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uIChnYXBNb2RlKSB7XG4gICAgdmFyIGNzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gICAgdmFyIGxlZnQgPSBjc1tnYXBNb2RlID09PSAncGFkZGluZycgPyAncGFkZGluZ0xlZnQnIDogJ21hcmdpbkxlZnQnXTtcbiAgICB2YXIgdG9wID0gY3NbZ2FwTW9kZSA9PT0gJ3BhZGRpbmcnID8gJ3BhZGRpbmdUb3AnIDogJ21hcmdpblRvcCddO1xuICAgIHZhciByaWdodCA9IGNzW2dhcE1vZGUgPT09ICdwYWRkaW5nJyA/ICdwYWRkaW5nUmlnaHQnIDogJ21hcmdpblJpZ2h0J107XG4gICAgcmV0dXJuIFtwYXJzZShsZWZ0KSwgcGFyc2UodG9wKSwgcGFyc2UocmlnaHQpXTtcbn07XG5leHBvcnQgdmFyIGdldEdhcFdpZHRoID0gZnVuY3Rpb24gKGdhcE1vZGUpIHtcbiAgICBpZiAoZ2FwTW9kZSA9PT0gdm9pZCAwKSB7IGdhcE1vZGUgPSAnbWFyZ2luJzsgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gemVyb0dhcDtcbiAgICB9XG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXQoZ2FwTW9kZSk7XG4gICAgdmFyIGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogb2Zmc2V0c1swXSxcbiAgICAgICAgdG9wOiBvZmZzZXRzWzFdLFxuICAgICAgICByaWdodDogb2Zmc2V0c1syXSxcbiAgICAgICAgZ2FwOiBNYXRoLm1heCgwLCB3aW5kb3dXaWR0aCAtIGRvY3VtZW50V2lkdGggKyBvZmZzZXRzWzJdIC0gb2Zmc2V0c1swXSksXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdHlsZVNpbmdsZXRvbiB9IGZyb20gJ3JlYWN0LXN0eWxlLXNpbmdsZXRvbic7XG5pbXBvcnQgeyBmdWxsV2lkdGhDbGFzc05hbWUsIHplcm9SaWdodENsYXNzTmFtZSwgbm9TY3JvbGxiYXJzQ2xhc3NOYW1lLCByZW1vdmVkQmFyU2l6ZVZhcmlhYmxlIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0R2FwV2lkdGggfSBmcm9tICcuL3V0aWxzJztcbnZhciBTdHlsZSA9IHN0eWxlU2luZ2xldG9uKCk7XG5leHBvcnQgdmFyIGxvY2tBdHRyaWJ1dGUgPSAnZGF0YS1zY3JvbGwtbG9ja2VkJztcbi8vIGltcG9ydGFudCB0aXAgLSBvbmNlIHdlIG1lYXN1cmUgc2Nyb2xsQmFyIHdpZHRoIGFuZCByZW1vdmUgdGhlbVxuLy8gd2UgY291bGQgbm90IHJlcGVhdCB0aGlzIG9wZXJhdGlvblxuLy8gdGh1cyB3ZSBhcmUgdXNpbmcgc3R5bGUtc2luZ2xldG9uIC0gb25seSB0aGUgZmlyc3QgXCJ5ZXQgY29ycmVjdFwiIHN0eWxlIHdpbGwgYmUgYXBwbGllZC5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiAoX2EsIGFsbG93UmVsYXRpdmUsIGdhcE1vZGUsIGltcG9ydGFudCkge1xuICAgIHZhciBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBnYXAgPSBfYS5nYXA7XG4gICAgaWYgKGdhcE1vZGUgPT09IHZvaWQgMCkgeyBnYXBNb2RlID0gJ21hcmdpbic7IH1cbiAgICByZXR1cm4gXCJcXG4gIC5cIi5jb25jYXQobm9TY3JvbGxiYXJzQ2xhc3NOYW1lLCBcIiB7XFxuICAgb3ZlcmZsb3c6IGhpZGRlbiBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICAgcGFkZGluZy1yaWdodDogXCIpLmNvbmNhdChnYXAsIFwicHggXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgYm9keVtcIikuY29uY2F0KGxvY2tBdHRyaWJ1dGUsIFwiXSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW4gXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgICBvdmVyc2Nyb2xsLWJlaGF2aW9yOiBjb250YWluO1xcbiAgICBcIikuY29uY2F0KFtcbiAgICAgICAgYWxsb3dSZWxhdGl2ZSAmJiBcInBvc2l0aW9uOiByZWxhdGl2ZSBcIi5jb25jYXQoaW1wb3J0YW50LCBcIjtcIiksXG4gICAgICAgIGdhcE1vZGUgPT09ICdtYXJnaW4nICYmXG4gICAgICAgICAgICBcIlxcbiAgICBwYWRkaW5nLWxlZnQ6IFwiLmNvbmNhdChsZWZ0LCBcInB4O1xcbiAgICBwYWRkaW5nLXRvcDogXCIpLmNvbmNhdCh0b3AsIFwicHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IFwiKS5jb25jYXQocmlnaHQsIFwicHg7XFxuICAgIG1hcmdpbi1sZWZ0OjA7XFxuICAgIG1hcmdpbi10b3A6MDtcXG4gICAgbWFyZ2luLXJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICAgIFwiKSxcbiAgICAgICAgZ2FwTW9kZSA9PT0gJ3BhZGRpbmcnICYmIFwicGFkZGluZy1yaWdodDogXCIuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XCIpLFxuICAgIF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbignJyksIFwiXFxuICB9XFxuICBcXG4gIC5cIikuY29uY2F0KHplcm9SaWdodENsYXNzTmFtZSwgXCIge1xcbiAgICByaWdodDogXCIpLmNvbmNhdChnYXAsIFwicHggXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgXFxuICAuXCIpLmNvbmNhdChmdWxsV2lkdGhDbGFzc05hbWUsIFwiIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICB9XFxuICBcXG4gIC5cIikuY29uY2F0KHplcm9SaWdodENsYXNzTmFtZSwgXCIgLlwiKS5jb25jYXQoemVyb1JpZ2h0Q2xhc3NOYW1lLCBcIiB7XFxuICAgIHJpZ2h0OiAwIFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gIH1cXG4gIFxcbiAgLlwiKS5jb25jYXQoZnVsbFdpZHRoQ2xhc3NOYW1lLCBcIiAuXCIpLmNvbmNhdChmdWxsV2lkdGhDbGFzc05hbWUsIFwiIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwIFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gIH1cXG4gIFxcbiAgYm9keVtcIikuY29uY2F0KGxvY2tBdHRyaWJ1dGUsIFwiXSB7XFxuICAgIFwiKS5jb25jYXQocmVtb3ZlZEJhclNpemVWYXJpYWJsZSwgXCI6IFwiKS5jb25jYXQoZ2FwLCBcInB4O1xcbiAgfVxcblwiKTtcbn07XG52YXIgZ2V0Q3VycmVudFVzZUNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBwYXJzZUludChkb2N1bWVudC5ib2R5LmdldEF0dHJpYnV0ZShsb2NrQXR0cmlidXRlKSB8fCAnMCcsIDEwKTtcbiAgICByZXR1cm4gaXNGaW5pdGUoY291bnRlcikgPyBjb3VudGVyIDogMDtcbn07XG5leHBvcnQgdmFyIHVzZUxvY2tBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUobG9ja0F0dHJpYnV0ZSwgKGdldEN1cnJlbnRVc2VDb3VudGVyKCkgKyAxKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdDb3VudGVyID0gZ2V0Q3VycmVudFVzZUNvdW50ZXIoKSAtIDE7XG4gICAgICAgICAgICBpZiAobmV3Q291bnRlciA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUobG9ja0F0dHJpYnV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShsb2NrQXR0cmlidXRlLCBuZXdDb3VudGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG4vKipcbiAqIFJlbW92ZXMgcGFnZSBzY3JvbGxiYXIgYW5kIGJsb2NrcyBwYWdlIHNjcm9sbCB3aGVuIG1vdW50ZWRcbiAqL1xuZXhwb3J0IHZhciBSZW1vdmVTY3JvbGxCYXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbm9SZWxhdGl2ZSA9IF9hLm5vUmVsYXRpdmUsIG5vSW1wb3J0YW50ID0gX2Eubm9JbXBvcnRhbnQsIF9iID0gX2EuZ2FwTW9kZSwgZ2FwTW9kZSA9IF9iID09PSB2b2lkIDAgPyAnbWFyZ2luJyA6IF9iO1xuICAgIHVzZUxvY2tBdHRyaWJ1dGUoKTtcbiAgICAvKlxuICAgICBnYXAgd2lsbCBiZSBtZWFzdXJlZCBvbiBldmVyeSBjb21wb25lbnQgbW91bnRcbiAgICAgaG93ZXZlciBpdCB3aWxsIGJlIHVzZWQgb25seSBieSB0aGUgXCJmaXJzdFwiIGludm9jYXRpb25cbiAgICAgZHVlIHRvIHNpbmdsZXRvbiBuYXR1cmUgb2YgPFN0eWxlXG4gICAgICovXG4gICAgdmFyIGdhcCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0R2FwV2lkdGgoZ2FwTW9kZSk7IH0sIFtnYXBNb2RlXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3R5bGUsIHsgc3R5bGVzOiBnZXRTdHlsZXMoZ2FwLCAhbm9SZWxhdGl2ZSwgZ2FwTW9kZSwgIW5vSW1wb3J0YW50ID8gJyFpbXBvcnRhbnQnIDogJycpIH0pO1xufTtcbiIsInZhciBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IHZhciBub25QYXNzaXZlID0gcGFzc2l2ZVN1cHBvcnRlZCA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IGZhbHNlO1xuIiwidmFyIGFsd2F5c0NvbnRhaW5zU2Nyb2xsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyB0ZXh0YXJlYSB3aWxsIGFsd2F5cyBfY29udGFpbl8gc2Nyb2xsIGluc2lkZSBzZWxmLiBJdCBvbmx5IGNhbiBiZSBoaWRkZW5cbiAgICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnO1xufTtcbnZhciBlbGVtZW50Q2FuQmVTY3JvbGxlZCA9IGZ1bmN0aW9uIChub2RlLCBvdmVyZmxvdykge1xuICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICByZXR1cm4gKFxuICAgIC8vIG5vdC1ub3Qtc2Nyb2xsYWJsZVxuICAgIHN0eWxlc1tvdmVyZmxvd10gIT09ICdoaWRkZW4nICYmXG4gICAgICAgIC8vIGNvbnRhaW5zIHNjcm9sbCBpbnNpZGUgc2VsZlxuICAgICAgICAhKHN0eWxlcy5vdmVyZmxvd1kgPT09IHN0eWxlcy5vdmVyZmxvd1ggJiYgIWFsd2F5c0NvbnRhaW5zU2Nyb2xsKG5vZGUpICYmIHN0eWxlc1tvdmVyZmxvd10gPT09ICd2aXNpYmxlJykpO1xufTtcbnZhciBlbGVtZW50Q291bGRCZVZTY3JvbGxlZCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBlbGVtZW50Q2FuQmVTY3JvbGxlZChub2RlLCAnb3ZlcmZsb3dZJyk7IH07XG52YXIgZWxlbWVudENvdWxkQmVIU2Nyb2xsZWQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZWxlbWVudENhbkJlU2Nyb2xsZWQobm9kZSwgJ292ZXJmbG93WCcpOyB9O1xuZXhwb3J0IHZhciBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZCA9IGZ1bmN0aW9uIChheGlzLCBub2RlKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIGRvIHtcbiAgICAgICAgLy8gU2tpcCBvdmVyIHNoYWRvdyByb290XG4gICAgICAgIGlmICh0eXBlb2YgU2hhZG93Um9vdCAhPT0gJ3VuZGVmaW5lZCcgJiYgY3VycmVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzU2Nyb2xsYWJsZSA9IGVsZW1lbnRDb3VsZEJlU2Nyb2xsZWQoYXhpcywgY3VycmVudCk7XG4gICAgICAgIGlmIChpc1Njcm9sbGFibGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFNjcm9sbFZhcmlhYmxlcyhheGlzLCBjdXJyZW50KSwgc2Nyb2xsSGVpZ2h0ID0gX2FbMV0sIGNsaWVudEhlaWdodCA9IF9hWzJdO1xuICAgICAgICAgICAgaWYgKHNjcm9sbEhlaWdodCA+IGNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfSB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBvd25lckRvY3VtZW50LmJvZHkpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG52YXIgZ2V0VlNjcm9sbFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzY3JvbGxUb3AgPSBfYS5zY3JvbGxUb3AsIHNjcm9sbEhlaWdodCA9IF9hLnNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0ID0gX2EuY2xpZW50SGVpZ2h0O1xuICAgIHJldHVybiBbXG4gICAgICAgIHNjcm9sbFRvcCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBjbGllbnRIZWlnaHQsXG4gICAgXTtcbn07XG52YXIgZ2V0SFNjcm9sbFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gX2Euc2Nyb2xsTGVmdCwgc2Nyb2xsV2lkdGggPSBfYS5zY3JvbGxXaWR0aCwgY2xpZW50V2lkdGggPSBfYS5jbGllbnRXaWR0aDtcbiAgICByZXR1cm4gW1xuICAgICAgICBzY3JvbGxMZWZ0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgY2xpZW50V2lkdGgsXG4gICAgXTtcbn07XG52YXIgZWxlbWVudENvdWxkQmVTY3JvbGxlZCA9IGZ1bmN0aW9uIChheGlzLCBub2RlKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd2JyA/IGVsZW1lbnRDb3VsZEJlVlNjcm9sbGVkKG5vZGUpIDogZWxlbWVudENvdWxkQmVIU2Nyb2xsZWQobm9kZSk7XG59O1xudmFyIGdldFNjcm9sbFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChheGlzLCBub2RlKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd2JyA/IGdldFZTY3JvbGxWYXJpYWJsZXMobm9kZSkgOiBnZXRIU2Nyb2xsVmFyaWFibGVzKG5vZGUpO1xufTtcbnZhciBnZXREaXJlY3Rpb25GYWN0b3IgPSBmdW5jdGlvbiAoYXhpcywgZGlyZWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQncyBkaXJlY3Rpb24gaXMgcnRsIChyaWdodC10by1sZWZ0KSwgdGhlbiBzY3JvbGxMZWZ0IGlzIDAgd2hlbiB0aGUgc2Nyb2xsYmFyIGlzIGF0IGl0cyByaWdodG1vc3QgcG9zaXRpb24sXG4gICAgICogYW5kIHRoZW4gaW5jcmVhc2luZ2x5IG5lZ2F0aXZlIGFzIHlvdSBzY3JvbGwgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2Nyb2xsTGVmdFxuICAgICAqL1xuICAgIHJldHVybiBheGlzID09PSAnaCcgJiYgZGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcbn07XG5leHBvcnQgdmFyIGhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uIChheGlzLCBlbmRUYXJnZXQsIGV2ZW50LCBzb3VyY2VEZWx0YSwgbm9PdmVyc2Nyb2xsKSB7XG4gICAgdmFyIGRpcmVjdGlvbkZhY3RvciA9IGdldERpcmVjdGlvbkZhY3RvcihheGlzLCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbmRUYXJnZXQpLmRpcmVjdGlvbik7XG4gICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uRmFjdG9yICogc291cmNlRGVsdGE7XG4gICAgLy8gZmluZCBzY3JvbGxhYmxlIHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIHRhcmdldEluTG9jayA9IGVuZFRhcmdldC5jb250YWlucyh0YXJnZXQpO1xuICAgIHZhciBzaG91bGRDYW5jZWxTY3JvbGwgPSBmYWxzZTtcbiAgICB2YXIgaXNEZWx0YVBvc2l0aXZlID0gZGVsdGEgPiAwO1xuICAgIHZhciBhdmFpbGFibGVTY3JvbGwgPSAwO1xuICAgIHZhciBhdmFpbGFibGVTY3JvbGxUb3AgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0U2Nyb2xsVmFyaWFibGVzKGF4aXMsIHRhcmdldCksIHBvc2l0aW9uID0gX2FbMF0sIHNjcm9sbF8xID0gX2FbMV0sIGNhcGFjaXR5ID0gX2FbMl07XG4gICAgICAgIHZhciBlbGVtZW50U2Nyb2xsID0gc2Nyb2xsXzEgLSBjYXBhY2l0eSAtIGRpcmVjdGlvbkZhY3RvciAqIHBvc2l0aW9uO1xuICAgICAgICBpZiAocG9zaXRpb24gfHwgZWxlbWVudFNjcm9sbCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDb3VsZEJlU2Nyb2xsZWQoYXhpcywgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVNjcm9sbCArPSBlbGVtZW50U2Nyb2xsO1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVNjcm9sbFRvcCArPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKFxuICAgIC8vIHBvcnRhbGVkIGNvbnRlbnRcbiAgICAoIXRhcmdldEluTG9jayAmJiB0YXJnZXQgIT09IGRvY3VtZW50LmJvZHkpIHx8XG4gICAgICAgIC8vIHNlbGYgY29udGVudFxuICAgICAgICAodGFyZ2V0SW5Mb2NrICYmIChlbmRUYXJnZXQuY29udGFpbnModGFyZ2V0KSB8fCBlbmRUYXJnZXQgPT09IHRhcmdldCkpKTtcbiAgICAvLyBoYW5kbGUgZXBzaWxvbiBhcm91bmQgMCAobm9uIHN0YW5kYXJkIHpvb20gbGV2ZWxzKVxuICAgIGlmIChpc0RlbHRhUG9zaXRpdmUgJiZcbiAgICAgICAgKChub092ZXJzY3JvbGwgJiYgTWF0aC5hYnMoYXZhaWxhYmxlU2Nyb2xsKSA8IDEpIHx8ICghbm9PdmVyc2Nyb2xsICYmIGRlbHRhID4gYXZhaWxhYmxlU2Nyb2xsKSkpIHtcbiAgICAgICAgc2hvdWxkQ2FuY2VsU2Nyb2xsID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRGVsdGFQb3NpdGl2ZSAmJlxuICAgICAgICAoKG5vT3ZlcnNjcm9sbCAmJiBNYXRoLmFicyhhdmFpbGFibGVTY3JvbGxUb3ApIDwgMSkgfHwgKCFub092ZXJzY3JvbGwgJiYgLWRlbHRhID4gYXZhaWxhYmxlU2Nyb2xsVG9wKSkpIHtcbiAgICAgICAgc2hvdWxkQ2FuY2VsU2Nyb2xsID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZENhbmNlbFNjcm9sbDtcbn07XG4iLCJpbXBvcnQgeyBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSZW1vdmVTY3JvbGxCYXIgfSBmcm9tICdyZWFjdC1yZW1vdmUtc2Nyb2xsLWJhcic7XG5pbXBvcnQgeyBzdHlsZVNpbmdsZXRvbiB9IGZyb20gJ3JlYWN0LXN0eWxlLXNpbmdsZXRvbic7XG5pbXBvcnQgeyBub25QYXNzaXZlIH0gZnJvbSAnLi9hZ2dyZXNpdmVDYXB0dXJlJztcbmltcG9ydCB7IGhhbmRsZVNjcm9sbCwgbG9jYXRpb25Db3VsZEJlU2Nyb2xsZWQgfSBmcm9tICcuL2hhbmRsZVNjcm9sbCc7XG5leHBvcnQgdmFyIGdldFRvdWNoWFkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NoYW5nZWRUb3VjaGVzJyBpbiBldmVudCA/IFtldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXSA6IFswLCAwXTtcbn07XG5leHBvcnQgdmFyIGdldERlbHRhWFkgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIFtldmVudC5kZWx0YVgsIGV2ZW50LmRlbHRhWV07IH07XG52YXIgZXh0cmFjdFJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gcmVmICYmICdjdXJyZW50JyBpbiByZWYgPyByZWYuY3VycmVudCA6IHJlZjtcbn07XG52YXIgZGVsdGFDb21wYXJlID0gZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHhbMF0gPT09IHlbMF0gJiYgeFsxXSA9PT0geVsxXTsgfTtcbnZhciBnZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiBcIlxcbiAgLmJsb2NrLWludGVyYWN0aXZpdHktXCIuY29uY2F0KGlkLCBcIiB7cG9pbnRlci1ldmVudHM6IG5vbmU7fVxcbiAgLmFsbG93LWludGVyYWN0aXZpdHktXCIpLmNvbmNhdChpZCwgXCIge3BvaW50ZXItZXZlbnRzOiBhbGw7fVxcblwiKTsgfTtcbnZhciBpZENvdW50ZXIgPSAwO1xudmFyIGxvY2tTdGFjayA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIFJlbW92ZVNjcm9sbFNpZGVDYXIocHJvcHMpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudFF1ZXVlID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgICB2YXIgdG91Y2hTdGFydFJlZiA9IFJlYWN0LnVzZVJlZihbMCwgMF0pO1xuICAgIHZhciBhY3RpdmVBeGlzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgdmFyIGlkID0gUmVhY3QudXNlU3RhdGUoaWRDb3VudGVyKyspWzBdO1xuICAgIHZhciBTdHlsZSA9IFJlYWN0LnVzZVN0YXRlKHN0eWxlU2luZ2xldG9uKVswXTtcbiAgICB2YXIgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmKHByb3BzKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHByb3BzO1xuICAgIH0sIFtwcm9wc10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9wcy5pbmVydCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgIHZhciBhbGxvd18xID0gX19zcHJlYWRBcnJheShbcHJvcHMubG9ja1JlZi5jdXJyZW50XSwgKHByb3BzLnNoYXJkcyB8fCBbXSkubWFwKGV4dHJhY3RSZWYpLCB0cnVlKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICBhbGxvd18xLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKFwiYWxsb3ctaW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImJsb2NrLWludGVyYWN0aXZpdHktXCIuY29uY2F0KGlkKSk7XG4gICAgICAgICAgICAgICAgYWxsb3dfMS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShcImFsbG93LWludGVyYWN0aXZpdHktXCIuY29uY2F0KGlkKSk7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfSwgW3Byb3BzLmluZXJ0LCBwcm9wcy5sb2NrUmVmLmN1cnJlbnQsIHByb3BzLnNoYXJkc10pO1xuICAgIHZhciBzaG91bGRDYW5jZWxFdmVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgcGFyZW50KSB7XG4gICAgICAgIGlmICgoJ3RvdWNoZXMnIGluIGV2ZW50ICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAyKSB8fCAoZXZlbnQudHlwZSA9PT0gJ3doZWVsJyAmJiBldmVudC5jdHJsS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuICFsYXN0UHJvcHMuY3VycmVudC5hbGxvd1BpbmNoWm9vbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG91Y2ggPSBnZXRUb3VjaFhZKGV2ZW50KTtcbiAgICAgICAgdmFyIHRvdWNoU3RhcnQgPSB0b3VjaFN0YXJ0UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBkZWx0YVggPSAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IHRvdWNoU3RhcnRbMF0gLSB0b3VjaFswXTtcbiAgICAgICAgdmFyIGRlbHRhWSA9ICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogdG91Y2hTdGFydFsxXSAtIHRvdWNoWzFdO1xuICAgICAgICB2YXIgY3VycmVudEF4aXM7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciBtb3ZlRGlyZWN0aW9uID0gTWF0aC5hYnMoZGVsdGFYKSA+IE1hdGguYWJzKGRlbHRhWSkgPyAnaCcgOiAndic7XG4gICAgICAgIC8vIGFsbG93IGhvcml6b250YWwgdG91Y2ggbW92ZSBvbiBSYW5nZSBpbnB1dHMuIFRoZXkgd2lsbCBub3QgY2F1c2UgYW55IHNjcm9sbFxuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGV2ZW50ICYmIG1vdmVEaXJlY3Rpb24gPT09ICdoJyAmJiB0YXJnZXQudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uID0gbG9jYXRpb25Db3VsZEJlU2Nyb2xsZWQobW92ZURpcmVjdGlvbiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuQmVTY3JvbGxlZEluTWFpbkRpcmVjdGlvbikge1xuICAgICAgICAgICAgY3VycmVudEF4aXMgPSBtb3ZlRGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEF4aXMgPSBtb3ZlRGlyZWN0aW9uID09PSAndicgPyAnaCcgOiAndic7XG4gICAgICAgICAgICBjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uID0gbG9jYXRpb25Db3VsZEJlU2Nyb2xsZWQobW92ZURpcmVjdGlvbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIG90aGVyIGF4aXMgbWlnaHQgYmUgbm90IHNjcm9sbGFibGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjdGl2ZUF4aXMuY3VycmVudCAmJiAnY2hhbmdlZFRvdWNoZXMnIGluIGV2ZW50ICYmIChkZWx0YVggfHwgZGVsdGFZKSkge1xuICAgICAgICAgICAgYWN0aXZlQXhpcy5jdXJyZW50ID0gY3VycmVudEF4aXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50QXhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbmNlbGluZ0F4aXMgPSBhY3RpdmVBeGlzLmN1cnJlbnQgfHwgY3VycmVudEF4aXM7XG4gICAgICAgIHJldHVybiBoYW5kbGVTY3JvbGwoY2FuY2VsaW5nQXhpcywgcGFyZW50LCBldmVudCwgY2FuY2VsaW5nQXhpcyA9PT0gJ2gnID8gZGVsdGFYIDogZGVsdGFZLCB0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNob3VsZFByZXZlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoX2V2ZW50KSB7XG4gICAgICAgIHZhciBldmVudCA9IF9ldmVudDtcbiAgICAgICAgaWYgKCFsb2NrU3RhY2subGVuZ3RoIHx8IGxvY2tTdGFja1tsb2NrU3RhY2subGVuZ3RoIC0gMV0gIT09IFN0eWxlKSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIGxhc3QgYWN0aXZlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbHRhID0gJ2RlbHRhWScgaW4gZXZlbnQgPyBnZXREZWx0YVhZKGV2ZW50KSA6IGdldFRvdWNoWFkoZXZlbnQpO1xuICAgICAgICB2YXIgc291cmNlRXZlbnQgPSBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubmFtZSA9PT0gZXZlbnQudHlwZSAmJiAoZS50YXJnZXQgPT09IGV2ZW50LnRhcmdldCB8fCBldmVudC50YXJnZXQgPT09IGUuc2hhZG93UGFyZW50KSAmJiBkZWx0YUNvbXBhcmUoZS5kZWx0YSwgZGVsdGEpOyB9KVswXTtcbiAgICAgICAgLy8gc2VsZiBldmVudCwgYW5kIHNob3VsZCBiZSBjYW5jZWxlZFxuICAgICAgICBpZiAoc291cmNlRXZlbnQgJiYgc291cmNlRXZlbnQuc2hvdWxkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3V0c2lkZSBvciBzaGFyZCBldmVudFxuICAgICAgICBpZiAoIXNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgc2hhcmROb2RlcyA9IChsYXN0UHJvcHMuY3VycmVudC5zaGFyZHMgfHwgW10pXG4gICAgICAgICAgICAgICAgLm1hcChleHRyYWN0UmVmKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7IH0pO1xuICAgICAgICAgICAgdmFyIHNob3VsZFN0b3AgPSBzaGFyZE5vZGVzLmxlbmd0aCA+IDAgPyBzaG91bGRDYW5jZWxFdmVudChldmVudCwgc2hhcmROb2Rlc1swXSkgOiAhbGFzdFByb3BzLmN1cnJlbnQubm9Jc29sYXRpb247XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RvcCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHZhciBzaG91bGRDYW5jZWwgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobmFtZSwgZGVsdGEsIHRhcmdldCwgc2hvdWxkKSB7XG4gICAgICAgIHZhciBldmVudCA9IHsgbmFtZTogbmFtZSwgZGVsdGE6IGRlbHRhLCB0YXJnZXQ6IHRhcmdldCwgc2hvdWxkOiBzaG91bGQsIHNoYWRvd1BhcmVudDogZ2V0T3V0ZXJtb3N0U2hhZG93UGFyZW50KHRhcmdldCkgfTtcbiAgICAgICAgc2hvdWxkUHJldmVudFF1ZXVlLmN1cnJlbnQucHVzaChldmVudCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2hvdWxkUHJldmVudFF1ZXVlLmN1cnJlbnQgPSBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgIT09IGV2ZW50OyB9KTtcbiAgICAgICAgfSwgMSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxUb3VjaFN0YXJ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRvdWNoU3RhcnRSZWYuY3VycmVudCA9IGdldFRvdWNoWFkoZXZlbnQpO1xuICAgICAgICBhY3RpdmVBeGlzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxXaGVlbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzaG91bGRDYW5jZWwoZXZlbnQudHlwZSwgZ2V0RGVsdGFYWShldmVudCksIGV2ZW50LnRhcmdldCwgc2hvdWxkQ2FuY2VsRXZlbnQoZXZlbnQsIHByb3BzLmxvY2tSZWYuY3VycmVudCkpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2Nyb2xsVG91Y2hNb3ZlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNob3VsZENhbmNlbChldmVudC50eXBlLCBnZXRUb3VjaFhZKGV2ZW50KSwgZXZlbnQudGFyZ2V0LCBzaG91bGRDYW5jZWxFdmVudChldmVudCwgcHJvcHMubG9ja1JlZi5jdXJyZW50KSk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2tTdGFjay5wdXNoKFN0eWxlKTtcbiAgICAgICAgcHJvcHMuc2V0Q2FsbGJhY2tzKHtcbiAgICAgICAgICAgIG9uU2Nyb2xsQ2FwdHVyZTogc2Nyb2xsV2hlZWwsXG4gICAgICAgICAgICBvbldoZWVsQ2FwdHVyZTogc2Nyb2xsV2hlZWwsXG4gICAgICAgICAgICBvblRvdWNoTW92ZUNhcHR1cmU6IHNjcm9sbFRvdWNoTW92ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHNob3VsZFByZXZlbnQsIG5vblBhc3NpdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2Nyb2xsVG91Y2hTdGFydCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NrU3RhY2sgPSBsb2NrU3RhY2suZmlsdGVyKGZ1bmN0aW9uIChpbnN0KSB7IHJldHVybiBpbnN0ICE9PSBTdHlsZTsgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHNob3VsZFByZXZlbnQsIG5vblBhc3NpdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2Nyb2xsVG91Y2hTdGFydCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciByZW1vdmVTY3JvbGxCYXIgPSBwcm9wcy5yZW1vdmVTY3JvbGxCYXIsIGluZXJ0ID0gcHJvcHMuaW5lcnQ7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBpbmVydCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3R5bGUsIHsgc3R5bGVzOiBnZW5lcmF0ZVN0eWxlKGlkKSB9KSA6IG51bGwsXG4gICAgICAgIHJlbW92ZVNjcm9sbEJhciA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtb3ZlU2Nyb2xsQmFyLCB7IGdhcE1vZGU6IHByb3BzLmdhcE1vZGUgfSkgOiBudWxsKSk7XG59XG5mdW5jdGlvbiBnZXRPdXRlcm1vc3RTaGFkb3dQYXJlbnQobm9kZSkge1xuICAgIHZhciBzaGFkb3dQYXJlbnQgPSBudWxsO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgc2hhZG93UGFyZW50ID0gbm9kZS5ob3N0O1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93UGFyZW50O1xufVxuIiwiaW1wb3J0IHsgZXhwb3J0U2lkZWNhciB9IGZyb20gJ3VzZS1zaWRlY2FyJztcbmltcG9ydCB7IFJlbW92ZVNjcm9sbFNpZGVDYXIgfSBmcm9tICcuL1NpZGVFZmZlY3QnO1xuaW1wb3J0IHsgZWZmZWN0Q2FyIH0gZnJvbSAnLi9tZWRpdW0nO1xuZXhwb3J0IGRlZmF1bHQgZXhwb3J0U2lkZWNhcihlZmZlY3RDYXIsIFJlbW92ZVNjcm9sbFNpZGVDYXIpO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlbW92ZVNjcm9sbCB9IGZyb20gJy4vVUknO1xuaW1wb3J0IFNpZGVDYXIgZnJvbSAnLi9zaWRlY2FyJztcbnZhciBSZWFjdFJlbW92ZVNjcm9sbCA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlbW92ZVNjcm9sbCwgX19hc3NpZ24oe30sIHByb3BzLCB7IHJlZjogcmVmLCBzaWRlQ2FyOiBTaWRlQ2FyIH0pKSk7IH0pO1xuUmVhY3RSZW1vdmVTY3JvbGwuY2xhc3NOYW1lcyA9IFJlbW92ZVNjcm9sbC5jbGFzc05hbWVzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3RSZW1vdmVTY3JvbGw7XG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3Qvc2VsZWN0L3NyYy9zZWxlY3QudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSBcIkByYWRpeC11aS9udW1iZXJcIjtcbmltcG9ydCB7IGNvbXBvc2VFdmVudEhhbmRsZXJzIH0gZnJvbSBcIkByYWRpeC11aS9wcmltaXRpdmVcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbGxlY3Rpb24gfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbGxlY3Rpb25cIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0U2NvcGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7IHVzZURpcmVjdGlvbiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtZGlyZWN0aW9uXCI7XG5pbXBvcnQgeyBEaXNtaXNzYWJsZUxheWVyIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1kaXNtaXNzYWJsZS1sYXllclwiO1xuaW1wb3J0IHsgdXNlRm9jdXNHdWFyZHMgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWZvY3VzLWd1YXJkc1wiO1xuaW1wb3J0IHsgRm9jdXNTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtZm9jdXMtc2NvcGVcIjtcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1pZFwiO1xuaW1wb3J0ICogYXMgUG9wcGVyUHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcG9wcGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVQb3BwZXJTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcG9wcGVyXCI7XG5pbXBvcnQgeyBQb3J0YWwgYXMgUG9ydGFsUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wb3J0YWxcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuaW1wb3J0IHsgdXNlQ29udHJvbGxhYmxlU3RhdGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1jb250cm9sbGFibGUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZVByZXZpb3VzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtcHJldmlvdXNcIjtcbmltcG9ydCB7IFZpc3VhbGx5SGlkZGVuIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC12aXN1YWxseS1oaWRkZW5cIjtcbmltcG9ydCB7IGhpZGVPdGhlcnMgfSBmcm9tIFwiYXJpYS1oaWRkZW5cIjtcbmltcG9ydCB7IFJlbW92ZVNjcm9sbCB9IGZyb20gXCJyZWFjdC1yZW1vdmUtc2Nyb2xsXCI7XG5pbXBvcnQgeyBGcmFnbWVudCwganN4LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgT1BFTl9LRVlTID0gW1wiIFwiLCBcIkVudGVyXCIsIFwiQXJyb3dVcFwiLCBcIkFycm93RG93blwiXTtcbnZhciBTRUxFQ1RJT05fS0VZUyA9IFtcIiBcIiwgXCJFbnRlclwiXTtcbnZhciBTRUxFQ1RfTkFNRSA9IFwiU2VsZWN0XCI7XG52YXIgW0NvbGxlY3Rpb24sIHVzZUNvbGxlY3Rpb24sIGNyZWF0ZUNvbGxlY3Rpb25TY29wZV0gPSBjcmVhdGVDb2xsZWN0aW9uKFNFTEVDVF9OQU1FKTtcbnZhciBbY3JlYXRlU2VsZWN0Q29udGV4dCwgY3JlYXRlU2VsZWN0U2NvcGVdID0gY3JlYXRlQ29udGV4dFNjb3BlKFNFTEVDVF9OQU1FLCBbXG4gIGNyZWF0ZUNvbGxlY3Rpb25TY29wZSxcbiAgY3JlYXRlUG9wcGVyU2NvcGVcbl0pO1xudmFyIHVzZVBvcHBlclNjb3BlID0gY3JlYXRlUG9wcGVyU2NvcGUoKTtcbnZhciBbU2VsZWN0UHJvdmlkZXIsIHVzZVNlbGVjdENvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChTRUxFQ1RfTkFNRSk7XG52YXIgW1NlbGVjdE5hdGl2ZU9wdGlvbnNQcm92aWRlciwgdXNlU2VsZWN0TmF0aXZlT3B0aW9uc0NvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChTRUxFQ1RfTkFNRSk7XG52YXIgU2VsZWN0ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBfX3Njb3BlU2VsZWN0LFxuICAgIGNoaWxkcmVuLFxuICAgIG9wZW46IG9wZW5Qcm9wLFxuICAgIGRlZmF1bHRPcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICB2YWx1ZTogdmFsdWVQcm9wLFxuICAgIGRlZmF1bHRWYWx1ZSxcbiAgICBvblZhbHVlQ2hhbmdlLFxuICAgIGRpcixcbiAgICBuYW1lLFxuICAgIGF1dG9Db21wbGV0ZSxcbiAgICBkaXNhYmxlZCxcbiAgICByZXF1aXJlZCxcbiAgICBmb3JtXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgW3RyaWdnZXIsIHNldFRyaWdnZXJdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFt2YWx1ZU5vZGUsIHNldFZhbHVlTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3ZhbHVlTm9kZUhhc0NoaWxkcmVuLCBzZXRWYWx1ZU5vZGVIYXNDaGlsZHJlbl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IHVzZURpcmVjdGlvbihkaXIpO1xuICBjb25zdCBbb3BlbiA9IGZhbHNlLCBzZXRPcGVuXSA9IHVzZUNvbnRyb2xsYWJsZVN0YXRlKHtcbiAgICBwcm9wOiBvcGVuUHJvcCxcbiAgICBkZWZhdWx0UHJvcDogZGVmYXVsdE9wZW4sXG4gICAgb25DaGFuZ2U6IG9uT3BlbkNoYW5nZVxuICB9KTtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VDb250cm9sbGFibGVTdGF0ZSh7XG4gICAgcHJvcDogdmFsdWVQcm9wLFxuICAgIGRlZmF1bHRQcm9wOiBkZWZhdWx0VmFsdWUsXG4gICAgb25DaGFuZ2U6IG9uVmFsdWVDaGFuZ2VcbiAgfSk7XG4gIGNvbnN0IHRyaWdnZXJQb2ludGVyRG93blBvc1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNGb3JtQ29udHJvbCA9IHRyaWdnZXIgPyBmb3JtIHx8ICEhdHJpZ2dlci5jbG9zZXN0KFwiZm9ybVwiKSA6IHRydWU7XG4gIGNvbnN0IFtuYXRpdmVPcHRpb25zU2V0LCBzZXROYXRpdmVPcHRpb25zU2V0XSA9IFJlYWN0LnVzZVN0YXRlKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICBjb25zdCBuYXRpdmVTZWxlY3RLZXkgPSBBcnJheS5mcm9tKG5hdGl2ZU9wdGlvbnNTZXQpLm1hcCgob3B0aW9uKSA9PiBvcHRpb24ucHJvcHMudmFsdWUpLmpvaW4oXCI7XCIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQb3BwZXJQcmltaXRpdmUuUm9vdCwgeyAuLi5wb3BwZXJTY29wZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIFNlbGVjdFByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHJlcXVpcmVkLFxuICAgICAgc2NvcGU6IF9fc2NvcGVTZWxlY3QsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgb25UcmlnZ2VyQ2hhbmdlOiBzZXRUcmlnZ2VyLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgb25WYWx1ZU5vZGVDaGFuZ2U6IHNldFZhbHVlTm9kZSxcbiAgICAgIHZhbHVlTm9kZUhhc0NoaWxkcmVuLFxuICAgICAgb25WYWx1ZU5vZGVIYXNDaGlsZHJlbkNoYW5nZTogc2V0VmFsdWVOb2RlSGFzQ2hpbGRyZW4sXG4gICAgICBjb250ZW50SWQ6IHVzZUlkKCksXG4gICAgICB2YWx1ZSxcbiAgICAgIG9uVmFsdWVDaGFuZ2U6IHNldFZhbHVlLFxuICAgICAgb3BlbixcbiAgICAgIG9uT3BlbkNoYW5nZTogc2V0T3BlbixcbiAgICAgIGRpcjogZGlyZWN0aW9uLFxuICAgICAgdHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb24uUHJvdmlkZXIsIHsgc2NvcGU6IF9fc2NvcGVTZWxlY3QsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIFNlbGVjdE5hdGl2ZU9wdGlvbnNQcm92aWRlcixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogcHJvcHMuX19zY29wZVNlbGVjdCxcbiAgICAgICAgICAgIG9uTmF0aXZlT3B0aW9uQWRkOiBSZWFjdC51c2VDYWxsYmFjaygob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgIHNldE5hdGl2ZU9wdGlvbnNTZXQoKHByZXYpID0+IG5ldyBTZXQocHJldikuYWRkKG9wdGlvbikpO1xuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgb25OYXRpdmVPcHRpb25SZW1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgc2V0TmF0aXZlT3B0aW9uc1NldCgocHJldikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNTZXQgPSBuZXcgU2V0KHByZXYpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnNTZXQuZGVsZXRlKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnNTZXQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICB9XG4gICAgICAgICkgfSksXG4gICAgICAgIGlzRm9ybUNvbnRyb2wgPyAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICBCdWJibGVTZWxlY3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXV0b0NvbXBsZXRlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBvbkNoYW5nZTogKGV2ZW50KSA9PiBzZXRWYWx1ZShldmVudC50YXJnZXQudmFsdWUpLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgdmFsdWUgPT09IHZvaWQgMCA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJvcHRpb25cIiwgeyB2YWx1ZTogXCJcIiB9KSA6IG51bGwsXG4gICAgICAgICAgICAgIEFycmF5LmZyb20obmF0aXZlT3B0aW9uc1NldClcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdGl2ZVNlbGVjdEtleVxuICAgICAgICApIDogbnVsbFxuICAgICAgXVxuICAgIH1cbiAgKSB9KTtcbn07XG5TZWxlY3QuZGlzcGxheU5hbWUgPSBTRUxFQ1RfTkFNRTtcbnZhciBUUklHR0VSX05BTUUgPSBcIlNlbGVjdFRyaWdnZXJcIjtcbnZhciBTZWxlY3RUcmlnZ2VyID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIGRpc2FibGVkID0gZmFsc2UsIC4uLnRyaWdnZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChUUklHR0VSX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBjb250ZXh0LmRpc2FibGVkIHx8IGRpc2FibGVkO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRleHQub25UcmlnZ2VyQ2hhbmdlKTtcbiAgICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoXCJ0b3VjaFwiKTtcbiAgICBjb25zdCBbc2VhcmNoUmVmLCBoYW5kbGVUeXBlYWhlYWRTZWFyY2gsIHJlc2V0VHlwZWFoZWFkXSA9IHVzZVR5cGVhaGVhZFNlYXJjaCgoc2VhcmNoKSA9PiB7XG4gICAgICBjb25zdCBlbmFibGVkSXRlbXMgPSBnZXRJdGVtcygpLmZpbHRlcigoaXRlbSkgPT4gIWl0ZW0uZGlzYWJsZWQpO1xuICAgICAgY29uc3QgY3VycmVudEl0ZW0gPSBlbmFibGVkSXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS52YWx1ZSA9PT0gY29udGV4dC52YWx1ZSk7XG4gICAgICBjb25zdCBuZXh0SXRlbSA9IGZpbmROZXh0SXRlbShlbmFibGVkSXRlbXMsIHNlYXJjaCwgY3VycmVudEl0ZW0pO1xuICAgICAgaWYgKG5leHRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5vblZhbHVlQ2hhbmdlKG5leHRJdGVtLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVPcGVuID0gKHBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgaWYgKCFpc0Rpc2FibGVkKSB7XG4gICAgICAgIGNvbnRleHQub25PcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgICByZXNldFR5cGVhaGVhZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50ZXJFdmVudCkge1xuICAgICAgICBjb250ZXh0LnRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIHg6IE1hdGgucm91bmQocG9pbnRlckV2ZW50LnBhZ2VYKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHBvaW50ZXJFdmVudC5wYWdlWSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFBvcHBlclByaW1pdGl2ZS5BbmNob3IsIHsgYXNDaGlsZDogdHJ1ZSwgLi4ucG9wcGVyU2NvcGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgUHJpbWl0aXZlLmJ1dHRvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgcm9sZTogXCJjb21ib2JveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogY29udGV4dC5jb250ZW50SWQsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBjb250ZXh0Lm9wZW4sXG4gICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBjb250ZXh0LnJlcXVpcmVkLFxuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibm9uZVwiLFxuICAgICAgICBkaXI6IGNvbnRleHQuZGlyLFxuICAgICAgICBcImRhdGEtc3RhdGVcIjogY29udGV4dC5vcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwiLFxuICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgXCJkYXRhLWRpc2FibGVkXCI6IGlzRGlzYWJsZWQgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICBcImRhdGEtcGxhY2Vob2xkZXJcIjogc2hvdWxkU2hvd1BsYWNlaG9sZGVyKGNvbnRleHQudmFsdWUpID8gXCJcIiA6IHZvaWQgMCxcbiAgICAgICAgLi4udHJpZ2dlclByb3BzLFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgb25DbGljazogY29tcG9zZUV2ZW50SGFuZGxlcnModHJpZ2dlclByb3BzLm9uQ2xpY2ssIChldmVudCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCAhPT0gXCJtb3VzZVwiKSB7XG4gICAgICAgICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvblBvaW50ZXJEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyh0cmlnZ2VyUHJvcHMub25Qb2ludGVyRG93biwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICBpZiAodGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiBldmVudC5jdHJsS2V5ID09PSBmYWxzZSAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgb25LZXlEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyh0cmlnZ2VyUHJvcHMub25LZXlEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBpc1R5cGluZ0FoZWFkID0gc2VhcmNoUmVmLmN1cnJlbnQgIT09IFwiXCI7XG4gICAgICAgICAgY29uc3QgaXNNb2RpZmllcktleSA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG4gICAgICAgICAgaWYgKCFpc01vZGlmaWVyS2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT09IDEpIGhhbmRsZVR5cGVhaGVhZFNlYXJjaChldmVudC5rZXkpO1xuICAgICAgICAgIGlmIChpc1R5cGluZ0FoZWFkICYmIGV2ZW50LmtleSA9PT0gXCIgXCIpIHJldHVybjtcbiAgICAgICAgICBpZiAoT1BFTl9LRVlTLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIGhhbmRsZU9wZW4oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICkgfSk7XG4gIH1cbik7XG5TZWxlY3RUcmlnZ2VyLmRpc3BsYXlOYW1lID0gVFJJR0dFUl9OQU1FO1xudmFyIFZBTFVFX05BTUUgPSBcIlNlbGVjdFZhbHVlXCI7XG52YXIgU2VsZWN0VmFsdWUgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgY2xhc3NOYW1lLCBzdHlsZSwgY2hpbGRyZW4sIHBsYWNlaG9sZGVyID0gXCJcIiwgLi4udmFsdWVQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoVkFMVUVfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgeyBvblZhbHVlTm9kZUhhc0NoaWxkcmVuQ2hhbmdlIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gY2hpbGRyZW4gIT09IHZvaWQgMDtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCBjb250ZXh0Lm9uVmFsdWVOb2RlQ2hhbmdlKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgb25WYWx1ZU5vZGVIYXNDaGlsZHJlbkNoYW5nZShoYXNDaGlsZHJlbik7XG4gICAgfSwgW29uVmFsdWVOb2RlSGFzQ2hpbGRyZW5DaGFuZ2UsIGhhc0NoaWxkcmVuXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuc3BhbixcbiAgICAgIHtcbiAgICAgICAgLi4udmFsdWVQcm9wcyxcbiAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgIHN0eWxlOiB7IHBvaW50ZXJFdmVudHM6IFwibm9uZVwiIH0sXG4gICAgICAgIGNoaWxkcmVuOiBzaG91bGRTaG93UGxhY2Vob2xkZXIoY29udGV4dC52YWx1ZSkgPyAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBwbGFjZWhvbGRlciB9KSA6IGNoaWxkcmVuXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblNlbGVjdFZhbHVlLmRpc3BsYXlOYW1lID0gVkFMVUVfTkFNRTtcbnZhciBJQ09OX05BTUUgPSBcIlNlbGVjdEljb25cIjtcbnZhciBTZWxlY3RJY29uID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIGNoaWxkcmVuLCAuLi5pY29uUHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5zcGFuLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgLi4uaWNvblByb3BzLCByZWY6IGZvcndhcmRlZFJlZiwgY2hpbGRyZW46IGNoaWxkcmVuIHx8IFwiXFx1MjVCQ1wiIH0pO1xuICB9XG4pO1xuU2VsZWN0SWNvbi5kaXNwbGF5TmFtZSA9IElDT05fTkFNRTtcbnZhciBQT1JUQUxfTkFNRSA9IFwiU2VsZWN0UG9ydGFsXCI7XG52YXIgU2VsZWN0UG9ydGFsID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhbFByaW1pdGl2ZSwgeyBhc0NoaWxkOiB0cnVlLCAuLi5wcm9wcyB9KTtcbn07XG5TZWxlY3RQb3J0YWwuZGlzcGxheU5hbWUgPSBQT1JUQUxfTkFNRTtcbnZhciBDT05URU5UX05BTUUgPSBcIlNlbGVjdENvbnRlbnRcIjtcbnZhciBTZWxlY3RDb250ZW50ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChDT05URU5UX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IFtmcmFnbWVudCwgc2V0RnJhZ21lbnRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgc2V0RnJhZ21lbnQobmV3IERvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgfSwgW10pO1xuICAgIGlmICghY29udGV4dC5vcGVuKSB7XG4gICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnQ7XG4gICAgICByZXR1cm4gZnJhZyA/IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RDb250ZW50UHJvdmlkZXIsIHsgc2NvcGU6IHByb3BzLl9fc2NvcGVTZWxlY3QsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb24uU2xvdCwgeyBzY29wZTogcHJvcHMuX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSkgfSkgfSksXG4gICAgICAgIGZyYWdcbiAgICAgICkgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RDb250ZW50SW1wbCwgeyAuLi5wcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSk7XG4gIH1cbik7XG5TZWxlY3RDb250ZW50LmRpc3BsYXlOYW1lID0gQ09OVEVOVF9OQU1FO1xudmFyIENPTlRFTlRfTUFSR0lOID0gMTA7XG52YXIgW1NlbGVjdENvbnRlbnRQcm92aWRlciwgdXNlU2VsZWN0Q29udGVudENvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChDT05URU5UX05BTUUpO1xudmFyIENPTlRFTlRfSU1QTF9OQU1FID0gXCJTZWxlY3RDb250ZW50SW1wbFwiO1xudmFyIFNlbGVjdENvbnRlbnRJbXBsID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBfX3Njb3BlU2VsZWN0LFxuICAgICAgcG9zaXRpb24gPSBcIml0ZW0tYWxpZ25lZFwiLFxuICAgICAgb25DbG9zZUF1dG9Gb2N1cyxcbiAgICAgIG9uRXNjYXBlS2V5RG93bixcbiAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlLFxuICAgICAgLy9cbiAgICAgIC8vIFBvcHBlckNvbnRlbnQgcHJvcHNcbiAgICAgIHNpZGUsXG4gICAgICBzaWRlT2Zmc2V0LFxuICAgICAgYWxpZ24sXG4gICAgICBhbGlnbk9mZnNldCxcbiAgICAgIGFycm93UGFkZGluZyxcbiAgICAgIGNvbGxpc2lvbkJvdW5kYXJ5LFxuICAgICAgY29sbGlzaW9uUGFkZGluZyxcbiAgICAgIHN0aWNreSxcbiAgICAgIGhpZGVXaGVuRGV0YWNoZWQsXG4gICAgICBhdm9pZENvbGxpc2lvbnMsXG4gICAgICAvL1xuICAgICAgLi4uY29udGVudFByb3BzXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgW2NvbnRlbnQsIHNldENvbnRlbnRdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3ZpZXdwb3J0LCBzZXRWaWV3cG9ydF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCAobm9kZSkgPT4gc2V0Q29udGVudChub2RlKSk7XG4gICAgY29uc3QgW3NlbGVjdGVkSXRlbSwgc2V0U2VsZWN0ZWRJdGVtXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtzZWxlY3RlZEl0ZW1UZXh0LCBzZXRTZWxlY3RlZEl0ZW1UZXh0XSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSB1c2VDb2xsZWN0aW9uKF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IFtpc1Bvc2l0aW9uZWQsIHNldElzUG9zaXRpb25lZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZW50KSByZXR1cm4gaGlkZU90aGVycyhjb250ZW50KTtcbiAgICB9LCBbY29udGVudF0pO1xuICAgIHVzZUZvY3VzR3VhcmRzKCk7XG4gICAgY29uc3QgZm9jdXNGaXJzdCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKGNhbmRpZGF0ZXMpID0+IHtcbiAgICAgICAgY29uc3QgW2ZpcnN0SXRlbSwgLi4ucmVzdEl0ZW1zXSA9IGdldEl0ZW1zKCkubWFwKChpdGVtKSA9PiBpdGVtLnJlZi5jdXJyZW50KTtcbiAgICAgICAgY29uc3QgW2xhc3RJdGVtXSA9IHJlc3RJdGVtcy5zbGljZSgtMSk7XG4gICAgICAgIGNvbnN0IFBSRVZJT1VTTFlfRk9DVVNFRF9FTEVNRU5UID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT09IFBSRVZJT1VTTFlfRk9DVVNFRF9FTEVNRU5UKSByZXR1cm47XG4gICAgICAgICAgY2FuZGlkYXRlPy5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcIm5lYXJlc3RcIiB9KTtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBmaXJzdEl0ZW0gJiYgdmlld3BvcnQpIHZpZXdwb3J0LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gbGFzdEl0ZW0gJiYgdmlld3BvcnQpIHZpZXdwb3J0LnNjcm9sbFRvcCA9IHZpZXdwb3J0LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICBjYW5kaWRhdGU/LmZvY3VzKCk7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IFBSRVZJT1VTTFlfRk9DVVNFRF9FTEVNRU5UKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbZ2V0SXRlbXMsIHZpZXdwb3J0XVxuICAgICk7XG4gICAgY29uc3QgZm9jdXNTZWxlY3RlZEl0ZW0gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICgpID0+IGZvY3VzRmlyc3QoW3NlbGVjdGVkSXRlbSwgY29udGVudF0pLFxuICAgICAgW2ZvY3VzRmlyc3QsIHNlbGVjdGVkSXRlbSwgY29udGVudF1cbiAgICApO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaXNQb3NpdGlvbmVkKSB7XG4gICAgICAgIGZvY3VzU2VsZWN0ZWRJdGVtKCk7XG4gICAgICB9XG4gICAgfSwgW2lzUG9zaXRpb25lZCwgZm9jdXNTZWxlY3RlZEl0ZW1dKTtcbiAgICBjb25zdCB7IG9uT3BlbkNoYW5nZSwgdHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmIH0gPSBjb250ZXh0O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBsZXQgcG9pbnRlck1vdmVEZWx0YSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBjb25zdCBoYW5kbGVQb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgIHBvaW50ZXJNb3ZlRGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLmFicyhNYXRoLnJvdW5kKGV2ZW50LnBhZ2VYKSAtICh0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudD8ueCA/PyAwKSksXG4gICAgICAgICAgICB5OiBNYXRoLmFicyhNYXRoLnJvdW5kKGV2ZW50LnBhZ2VZKSAtICh0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudD8ueSA/PyAwKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVQb2ludGVyVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAocG9pbnRlck1vdmVEZWx0YS54IDw9IDEwICYmIHBvaW50ZXJNb3ZlRGVsdGEueSA8PSAxMCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjb250ZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBoYW5kbGVQb2ludGVyVXAsIHsgY2FwdHVyZTogdHJ1ZSwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBoYW5kbGVQb2ludGVyVXAsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBbY29udGVudCwgb25PcGVuQ2hhbmdlLCB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWZdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgY2xvc2UgPSAoKSA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNsb3NlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNsb3NlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBjbG9zZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNsb3NlKTtcbiAgICAgIH07XG4gICAgfSwgW29uT3BlbkNoYW5nZV0pO1xuICAgIGNvbnN0IFtzZWFyY2hSZWYsIGhhbmRsZVR5cGVhaGVhZFNlYXJjaF0gPSB1c2VUeXBlYWhlYWRTZWFyY2goKHNlYXJjaCkgPT4ge1xuICAgICAgY29uc3QgZW5hYmxlZEl0ZW1zID0gZ2V0SXRlbXMoKS5maWx0ZXIoKGl0ZW0pID0+ICFpdGVtLmRpc2FibGVkKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJdGVtID0gZW5hYmxlZEl0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0ucmVmLmN1cnJlbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgY29uc3QgbmV4dEl0ZW0gPSBmaW5kTmV4dEl0ZW0oZW5hYmxlZEl0ZW1zLCBzZWFyY2gsIGN1cnJlbnRJdGVtKTtcbiAgICAgIGlmIChuZXh0SXRlbSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG5leHRJdGVtLnJlZi5jdXJyZW50LmZvY3VzKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGl0ZW1SZWZDYWxsYmFjayA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKG5vZGUsIHZhbHVlLCBkaXNhYmxlZCkgPT4ge1xuICAgICAgICBjb25zdCBpc0ZpcnN0VmFsaWRJdGVtID0gIWZpcnN0VmFsaWRJdGVtRm91bmRSZWYuY3VycmVudCAmJiAhZGlzYWJsZWQ7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWRJdGVtID0gY29udGV4dC52YWx1ZSAhPT0gdm9pZCAwICYmIGNvbnRleHQudmFsdWUgPT09IHZhbHVlO1xuICAgICAgICBpZiAoaXNTZWxlY3RlZEl0ZW0gfHwgaXNGaXJzdFZhbGlkSXRlbSkge1xuICAgICAgICAgIHNldFNlbGVjdGVkSXRlbShub2RlKTtcbiAgICAgICAgICBpZiAoaXNGaXJzdFZhbGlkSXRlbSkgZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtjb250ZXh0LnZhbHVlXVxuICAgICk7XG4gICAgY29uc3QgaGFuZGxlSXRlbUxlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gY29udGVudD8uZm9jdXMoKSwgW2NvbnRlbnRdKTtcbiAgICBjb25zdCBpdGVtVGV4dFJlZkNhbGxiYWNrID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAobm9kZSwgdmFsdWUsIGRpc2FibGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RWYWxpZEl0ZW0gPSAhZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZi5jdXJyZW50ICYmICFkaXNhYmxlZDtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZEl0ZW0gPSBjb250ZXh0LnZhbHVlICE9PSB2b2lkIDAgJiYgY29udGV4dC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkSXRlbSB8fCBpc0ZpcnN0VmFsaWRJdGVtKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRJdGVtVGV4dChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtjb250ZXh0LnZhbHVlXVxuICAgICk7XG4gICAgY29uc3QgU2VsZWN0UG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gXCJwb3BwZXJcIiA/IFNlbGVjdFBvcHBlclBvc2l0aW9uIDogU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvbjtcbiAgICBjb25zdCBwb3BwZXJDb250ZW50UHJvcHMgPSBTZWxlY3RQb3NpdGlvbiA9PT0gU2VsZWN0UG9wcGVyUG9zaXRpb24gPyB7XG4gICAgICBzaWRlLFxuICAgICAgc2lkZU9mZnNldCxcbiAgICAgIGFsaWduLFxuICAgICAgYWxpZ25PZmZzZXQsXG4gICAgICBhcnJvd1BhZGRpbmcsXG4gICAgICBjb2xsaXNpb25Cb3VuZGFyeSxcbiAgICAgIGNvbGxpc2lvblBhZGRpbmcsXG4gICAgICBzdGlja3ksXG4gICAgICBoaWRlV2hlbkRldGFjaGVkLFxuICAgICAgYXZvaWRDb2xsaXNpb25zXG4gICAgfSA6IHt9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgU2VsZWN0Q29udGVudFByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIG9uVmlld3BvcnRDaGFuZ2U6IHNldFZpZXdwb3J0LFxuICAgICAgICBpdGVtUmVmQ2FsbGJhY2ssXG4gICAgICAgIHNlbGVjdGVkSXRlbSxcbiAgICAgICAgb25JdGVtTGVhdmU6IGhhbmRsZUl0ZW1MZWF2ZSxcbiAgICAgICAgaXRlbVRleHRSZWZDYWxsYmFjayxcbiAgICAgICAgZm9jdXNTZWxlY3RlZEl0ZW0sXG4gICAgICAgIHNlbGVjdGVkSXRlbVRleHQsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBpc1Bvc2l0aW9uZWQsXG4gICAgICAgIHNlYXJjaFJlZixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVtb3ZlU2Nyb2xsLCB7IGFzOiBTbG90LCBhbGxvd1BpbmNoWm9vbTogdHJ1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgRm9jdXNTY29wZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhc0NoaWxkOiB0cnVlLFxuICAgICAgICAgICAgdHJhcHBlZDogY29udGV4dC5vcGVuLFxuICAgICAgICAgICAgb25Nb3VudEF1dG9Gb2N1czogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Vbm1vdW50QXV0b0ZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkNsb3NlQXV0b0ZvY3VzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgY29udGV4dC50cmlnZ2VyPy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICBEaXNtaXNzYWJsZUxheWVyLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXNDaGlsZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgb25Fc2NhcGVLZXlEb3duLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlLFxuICAgICAgICAgICAgICAgIG9uRm9jdXNPdXRzaWRlOiAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgICAgICAgb25EaXNtaXNzOiAoKSA9PiBjb250ZXh0Lm9uT3BlbkNoYW5nZShmYWxzZSksXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgICAgICBTZWxlY3RQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJsaXN0Ym94XCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb250ZXh0LmNvbnRlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXN0YXRlXCI6IGNvbnRleHQub3BlbiA/IFwib3BlblwiIDogXCJjbG9zZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZGlyOiBjb250ZXh0LmRpcixcbiAgICAgICAgICAgICAgICAgICAgb25Db250ZXh0TWVudTogKGV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBvcHBlckNvbnRlbnRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgb25QbGFjZWQ6ICgpID0+IHNldElzUG9zaXRpb25lZCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gZmxleCBsYXlvdXQgc28gd2UgY2FuIHBsYWNlIHRoZSBzY3JvbGwgYnV0dG9ucyBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIG91dGxpbmUgYnkgZGVmYXVsdCBhcyB0aGUgY29udGVudCBNQVkgZ2V0IGZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMuc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyhjb250ZW50UHJvcHMub25LZXlEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc01vZGlmaWVyS2V5ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNb2RpZmllcktleSAmJiBldmVudC5rZXkubGVuZ3RoID09PSAxKSBoYW5kbGVUeXBlYWhlYWRTZWFyY2goZXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoW1wiQXJyb3dVcFwiLCBcIkFycm93RG93blwiLCBcIkhvbWVcIiwgXCJFbmRcIl0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZXRJdGVtcygpLmZpbHRlcigoaXRlbSkgPT4gIWl0ZW0uZGlzYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZU5vZGVzID0gaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLnJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbXCJBcnJvd1VwXCIsIFwiRW5kXCJdLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlTm9kZXMgPSBjYW5kaWRhdGVOb2Rlcy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCJdLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGNhbmRpZGF0ZU5vZGVzLmluZGV4T2YoY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVOb2RlcyA9IGNhbmRpZGF0ZU5vZGVzLnNsaWNlKGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBmb2N1c0ZpcnN0KGNhbmRpZGF0ZU5vZGVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICkgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuU2VsZWN0Q29udGVudEltcGwuZGlzcGxheU5hbWUgPSBDT05URU5UX0lNUExfTkFNRTtcbnZhciBJVEVNX0FMSUdORURfUE9TSVRJT05fTkFNRSA9IFwiU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvblwiO1xudmFyIFNlbGVjdEl0ZW1BbGlnbmVkUG9zaXRpb24gPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgb25QbGFjZWQsIC4uLnBvcHBlclByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoQ09OVEVOVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChDT05URU5UX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBbY29udGVudFdyYXBwZXIsIHNldENvbnRlbnRXcmFwcGVyXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgKG5vZGUpID0+IHNldENvbnRlbnQobm9kZSkpO1xuICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IHNob3VsZEV4cGFuZE9uU2Nyb2xsUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgc2hvdWxkUmVwb3NpdGlvblJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgeyB2aWV3cG9ydCwgc2VsZWN0ZWRJdGVtLCBzZWxlY3RlZEl0ZW1UZXh0LCBmb2N1c1NlbGVjdGVkSXRlbSB9ID0gY29udGVudENvbnRleHQ7XG4gIGNvbnN0IHBvc2l0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChjb250ZXh0LnRyaWdnZXIgJiYgY29udGV4dC52YWx1ZU5vZGUgJiYgY29udGVudFdyYXBwZXIgJiYgY29udGVudCAmJiB2aWV3cG9ydCAmJiBzZWxlY3RlZEl0ZW0gJiYgc2VsZWN0ZWRJdGVtVGV4dCkge1xuICAgICAgY29uc3QgdHJpZ2dlclJlY3QgPSBjb250ZXh0LnRyaWdnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB2YWx1ZU5vZGVSZWN0ID0gY29udGV4dC52YWx1ZU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBpdGVtVGV4dFJlY3QgPSBzZWxlY3RlZEl0ZW1UZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKGNvbnRleHQuZGlyICE9PSBcInJ0bFwiKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1UZXh0T2Zmc2V0ID0gaXRlbVRleHRSZWN0LmxlZnQgLSBjb250ZW50UmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCBsZWZ0ID0gdmFsdWVOb2RlUmVjdC5sZWZ0IC0gaXRlbVRleHRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxlZnREZWx0YSA9IHRyaWdnZXJSZWN0LmxlZnQgLSBsZWZ0O1xuICAgICAgICBjb25zdCBtaW5Db250ZW50V2lkdGggPSB0cmlnZ2VyUmVjdC53aWR0aCArIGxlZnREZWx0YTtcbiAgICAgICAgY29uc3QgY29udGVudFdpZHRoID0gTWF0aC5tYXgobWluQ29udGVudFdpZHRoLCBjb250ZW50UmVjdC53aWR0aCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0RWRnZSA9IHdpbmRvdy5pbm5lcldpZHRoIC0gQ09OVEVOVF9NQVJHSU47XG4gICAgICAgIGNvbnN0IGNsYW1wZWRMZWZ0ID0gY2xhbXAobGVmdCwgW1xuICAgICAgICAgIENPTlRFTlRfTUFSR0lOLFxuICAgICAgICAgIC8vIFByZXZlbnRzIHRoZSBjb250ZW50IGZyb20gZ29pbmcgb2ZmIHRoZSBzdGFydGluZyBlZGdlIG9mIHRoZVxuICAgICAgICAgIC8vIHZpZXdwb3J0LiBJdCBtYXkgc3RpbGwgZ28gb2ZmIHRoZSBlbmRpbmcgZWRnZSwgYnV0IHRoaXMgY2FuIGJlXG4gICAgICAgICAgLy8gY29udHJvbGxlZCBieSB0aGUgdXNlciBzaW5jZSB0aGV5IG1heSB3YW50IHRvIG1hbmFnZSBvdmVyZmxvdyBpbiBhXG4gICAgICAgICAgLy8gc3BlY2lmaWMgd2F5LlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWRpeC11aS9wcmltaXRpdmVzL2lzc3Vlcy8yMDQ5XG4gICAgICAgICAgTWF0aC5tYXgoQ09OVEVOVF9NQVJHSU4sIHJpZ2h0RWRnZSAtIGNvbnRlbnRXaWR0aClcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1pbldpZHRoID0gbWluQ29udGVudFdpZHRoICsgXCJweFwiO1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5sZWZ0ID0gY2xhbXBlZExlZnQgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtVGV4dE9mZnNldCA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gaXRlbVRleHRSZWN0LnJpZ2h0O1xuICAgICAgICBjb25zdCByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gdmFsdWVOb2RlUmVjdC5yaWdodCAtIGl0ZW1UZXh0T2Zmc2V0O1xuICAgICAgICBjb25zdCByaWdodERlbHRhID0gd2luZG93LmlubmVyV2lkdGggLSB0cmlnZ2VyUmVjdC5yaWdodCAtIHJpZ2h0O1xuICAgICAgICBjb25zdCBtaW5Db250ZW50V2lkdGggPSB0cmlnZ2VyUmVjdC53aWR0aCArIHJpZ2h0RGVsdGE7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KG1pbkNvbnRlbnRXaWR0aCwgY29udGVudFJlY3Qud2lkdGgpO1xuICAgICAgICBjb25zdCBsZWZ0RWRnZSA9IHdpbmRvdy5pbm5lcldpZHRoIC0gQ09OVEVOVF9NQVJHSU47XG4gICAgICAgIGNvbnN0IGNsYW1wZWRSaWdodCA9IGNsYW1wKHJpZ2h0LCBbXG4gICAgICAgICAgQ09OVEVOVF9NQVJHSU4sXG4gICAgICAgICAgTWF0aC5tYXgoQ09OVEVOVF9NQVJHSU4sIGxlZnRFZGdlIC0gY29udGVudFdpZHRoKVxuICAgICAgICBdKTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUubWluV2lkdGggPSBtaW5Db250ZW50V2lkdGggKyBcInB4XCI7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLnJpZ2h0ID0gY2xhbXBlZFJpZ2h0ICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBnZXRJdGVtcygpO1xuICAgICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gQ09OVEVOVF9NQVJHSU4gKiAyO1xuICAgICAgY29uc3QgaXRlbXNIZWlnaHQgPSB2aWV3cG9ydC5zY3JvbGxIZWlnaHQ7XG4gICAgICBjb25zdCBjb250ZW50U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudCk7XG4gICAgICBjb25zdCBjb250ZW50Qm9yZGVyVG9wV2lkdGggPSBwYXJzZUludChjb250ZW50U3R5bGVzLmJvcmRlclRvcFdpZHRoLCAxMCk7XG4gICAgICBjb25zdCBjb250ZW50UGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbnRlbnRTdHlsZXMucGFkZGluZ1RvcCwgMTApO1xuICAgICAgY29uc3QgY29udGVudEJvcmRlckJvdHRvbVdpZHRoID0gcGFyc2VJbnQoY29udGVudFN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCwgMTApO1xuICAgICAgY29uc3QgY29udGVudFBhZGRpbmdCb3R0b20gPSBwYXJzZUludChjb250ZW50U3R5bGVzLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICAgIGNvbnN0IGZ1bGxDb250ZW50SGVpZ2h0ID0gY29udGVudEJvcmRlclRvcFdpZHRoICsgY29udGVudFBhZGRpbmdUb3AgKyBpdGVtc0hlaWdodCArIGNvbnRlbnRQYWRkaW5nQm90dG9tICsgY29udGVudEJvcmRlckJvdHRvbVdpZHRoO1xuICAgICAgY29uc3QgbWluQ29udGVudEhlaWdodCA9IE1hdGgubWluKHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQgKiA1LCBmdWxsQ29udGVudEhlaWdodCk7XG4gICAgICBjb25zdCB2aWV3cG9ydFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0UGFkZGluZ1RvcCA9IHBhcnNlSW50KHZpZXdwb3J0U3R5bGVzLnBhZGRpbmdUb3AsIDEwKTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0UGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHZpZXdwb3J0U3R5bGVzLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICAgIGNvbnN0IHRvcEVkZ2VUb1RyaWdnZXJNaWRkbGUgPSB0cmlnZ2VyUmVjdC50b3AgKyB0cmlnZ2VyUmVjdC5oZWlnaHQgLyAyIC0gQ09OVEVOVF9NQVJHSU47XG4gICAgICBjb25zdCB0cmlnZ2VyTWlkZGxlVG9Cb3R0b21FZGdlID0gYXZhaWxhYmxlSGVpZ2h0IC0gdG9wRWRnZVRvVHJpZ2dlck1pZGRsZTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkSXRlbUhhbGZIZWlnaHQgPSBzZWxlY3RlZEl0ZW0ub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGl0ZW1PZmZzZXRNaWRkbGUgPSBzZWxlY3RlZEl0ZW0ub2Zmc2V0VG9wICsgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodDtcbiAgICAgIGNvbnN0IGNvbnRlbnRUb3BUb0l0ZW1NaWRkbGUgPSBjb250ZW50Qm9yZGVyVG9wV2lkdGggKyBjb250ZW50UGFkZGluZ1RvcCArIGl0ZW1PZmZzZXRNaWRkbGU7XG4gICAgICBjb25zdCBpdGVtTWlkZGxlVG9Db250ZW50Qm90dG9tID0gZnVsbENvbnRlbnRIZWlnaHQgLSBjb250ZW50VG9wVG9JdGVtTWlkZGxlO1xuICAgICAgY29uc3Qgd2lsbEFsaWduV2l0aG91dFRvcE92ZXJmbG93ID0gY29udGVudFRvcFRvSXRlbU1pZGRsZSA8PSB0b3BFZGdlVG9UcmlnZ2VyTWlkZGxlO1xuICAgICAgaWYgKHdpbGxBbGlnbldpdGhvdXRUb3BPdmVyZmxvdykge1xuICAgICAgICBjb25zdCBpc0xhc3RJdGVtID0gaXRlbXMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEl0ZW0gPT09IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnJlZi5jdXJyZW50O1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgICAgICBjb25zdCB2aWV3cG9ydE9mZnNldEJvdHRvbSA9IGNvbnRlbnQuY2xpZW50SGVpZ2h0IC0gdmlld3BvcnQub2Zmc2V0VG9wIC0gdmlld3BvcnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBjbGFtcGVkVHJpZ2dlck1pZGRsZVRvQm90dG9tRWRnZSA9IE1hdGgubWF4KFxuICAgICAgICAgIHRyaWdnZXJNaWRkbGVUb0JvdHRvbUVkZ2UsXG4gICAgICAgICAgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodCArIC8vIHZpZXdwb3J0IG1pZ2h0IGhhdmUgcGFkZGluZyBib3R0b20sIGluY2x1ZGUgaXQgdG8gYXZvaWQgYSBzY3JvbGxhYmxlIHZpZXdwb3J0XG4gICAgICAgICAgKGlzTGFzdEl0ZW0gPyB2aWV3cG9ydFBhZGRpbmdCb3R0b20gOiAwKSArIHZpZXdwb3J0T2Zmc2V0Qm90dG9tICsgY29udGVudEJvcmRlckJvdHRvbVdpZHRoXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNvbnRlbnRUb3BUb0l0ZW1NaWRkbGUgKyBjbGFtcGVkVHJpZ2dlck1pZGRsZVRvQm90dG9tRWRnZTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdEl0ZW0gPSBpdGVtcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSXRlbSA9PT0gaXRlbXNbMF0ucmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnN0IGNsYW1wZWRUb3BFZGdlVG9UcmlnZ2VyTWlkZGxlID0gTWF0aC5tYXgoXG4gICAgICAgICAgdG9wRWRnZVRvVHJpZ2dlck1pZGRsZSxcbiAgICAgICAgICBjb250ZW50Qm9yZGVyVG9wV2lkdGggKyB2aWV3cG9ydC5vZmZzZXRUb3AgKyAvLyB2aWV3cG9ydCBtaWdodCBoYXZlIHBhZGRpbmcgdG9wLCBpbmNsdWRlIGl0IHRvIGF2b2lkIGEgc2Nyb2xsYWJsZSB2aWV3cG9ydFxuICAgICAgICAgIChpc0ZpcnN0SXRlbSA/IHZpZXdwb3J0UGFkZGluZ1RvcCA6IDApICsgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBjbGFtcGVkVG9wRWRnZVRvVHJpZ2dlck1pZGRsZSArIGl0ZW1NaWRkbGVUb0NvbnRlbnRCb3R0b207XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdmlld3BvcnQuc2Nyb2xsVG9wID0gY29udGVudFRvcFRvSXRlbU1pZGRsZSAtIHRvcEVkZ2VUb1RyaWdnZXJNaWRkbGUgKyB2aWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgICB9XG4gICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5tYXJnaW4gPSBgJHtDT05URU5UX01BUkdJTn1weCAwYDtcbiAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1pbkhlaWdodCA9IG1pbkNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5tYXhIZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQgKyBcInB4XCI7XG4gICAgICBvblBsYWNlZD8uKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYuY3VycmVudCA9IHRydWUpO1xuICAgIH1cbiAgfSwgW1xuICAgIGdldEl0ZW1zLFxuICAgIGNvbnRleHQudHJpZ2dlcixcbiAgICBjb250ZXh0LnZhbHVlTm9kZSxcbiAgICBjb250ZW50V3JhcHBlcixcbiAgICBjb250ZW50LFxuICAgIHZpZXdwb3J0LFxuICAgIHNlbGVjdGVkSXRlbSxcbiAgICBzZWxlY3RlZEl0ZW1UZXh0LFxuICAgIGNvbnRleHQuZGlyLFxuICAgIG9uUGxhY2VkXG4gIF0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4gcG9zaXRpb24oKSwgW3Bvc2l0aW9uXSk7XG4gIGNvbnN0IFtjb250ZW50WkluZGV4LCBzZXRDb250ZW50WkluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnQpIHNldENvbnRlbnRaSW5kZXgod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudCkuekluZGV4KTtcbiAgfSwgW2NvbnRlbnRdKTtcbiAgY29uc3QgaGFuZGxlU2Nyb2xsQnV0dG9uQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlICYmIHNob3VsZFJlcG9zaXRpb25SZWYuY3VycmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBwb3NpdGlvbigpO1xuICAgICAgICBmb2N1c1NlbGVjdGVkSXRlbT8uKCk7XG4gICAgICAgIHNob3VsZFJlcG9zaXRpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3Bvc2l0aW9uLCBmb2N1c1NlbGVjdGVkSXRlbV1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgU2VsZWN0Vmlld3BvcnRQcm92aWRlcixcbiAgICB7XG4gICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgIGNvbnRlbnRXcmFwcGVyLFxuICAgICAgc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYsXG4gICAgICBvblNjcm9sbEJ1dHRvbkNoYW5nZTogaGFuZGxlU2Nyb2xsQnV0dG9uQ2hhbmdlLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IHNldENvbnRlbnRXcmFwcGVyLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICAgICAgekluZGV4OiBjb250ZW50WkluZGV4XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLnBvcHBlclByb3BzLFxuICAgICAgICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCB0aGUgaGVpZ2h0IG9mIHRoZSBjb250ZW50LCBpdCBpbmNsdWRlcyBib3JkZXJzLiBJZiB3ZSB3ZXJlIHRvIHNldFxuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgd2l0aG91dCBoYXZpbmcgYGJveFNpemluZzogJ2JvcmRlci1ib3gnYCBpdCB3b3VsZCBiZSB0b28gYmlnLlxuICAgICAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhlIGNvbnRlbnQgZG9lc24ndCBnZXQgdGFsbGVyIHRoYW4gdGhlIHdyYXBwZXJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIC4uLnBvcHBlclByb3BzLnN0eWxlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gICk7XG59KTtcblNlbGVjdEl0ZW1BbGlnbmVkUG9zaXRpb24uZGlzcGxheU5hbWUgPSBJVEVNX0FMSUdORURfUE9TSVRJT05fTkFNRTtcbnZhciBQT1BQRVJfUE9TSVRJT05fTkFNRSA9IFwiU2VsZWN0UG9wcGVyUG9zaXRpb25cIjtcbnZhciBTZWxlY3RQb3BwZXJQb3NpdGlvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgYWxpZ24gPSBcInN0YXJ0XCIsXG4gICAgY29sbGlzaW9uUGFkZGluZyA9IENPTlRFTlRfTUFSR0lOLFxuICAgIC4uLnBvcHBlclByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlU2VsZWN0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgUG9wcGVyUHJpbWl0aXZlLkNvbnRlbnQsXG4gICAge1xuICAgICAgLi4ucG9wcGVyU2NvcGUsXG4gICAgICAuLi5wb3BwZXJQcm9wcyxcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgYWxpZ24sXG4gICAgICBjb2xsaXNpb25QYWRkaW5nLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gRW5zdXJlIGJvcmRlci1ib3ggZm9yIGZsb2F0aW5nLXVpIGNhbGN1bGF0aW9uc1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICAuLi5wb3BwZXJQcm9wcy5zdHlsZSxcbiAgICAgICAgLy8gcmUtbmFtZXNwYWNlIGV4cG9zZWQgY29udGVudCBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICAuLi57XG4gICAgICAgICAgXCItLXJhZGl4LXNlbGVjdC1jb250ZW50LXRyYW5zZm9ybS1vcmlnaW5cIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItdHJhbnNmb3JtLW9yaWdpbilcIixcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LWNvbnRlbnQtYXZhaWxhYmxlLXdpZHRoXCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS13aWR0aClcIixcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LWNvbnRlbnQtYXZhaWxhYmxlLWhlaWdodFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hdmFpbGFibGUtaGVpZ2h0KVwiLFxuICAgICAgICAgIFwiLS1yYWRpeC1zZWxlY3QtdHJpZ2dlci13aWR0aFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hbmNob3Itd2lkdGgpXCIsXG4gICAgICAgICAgXCItLXJhZGl4LXNlbGVjdC10cmlnZ2VyLWhlaWdodFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hbmNob3ItaGVpZ2h0KVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59KTtcblNlbGVjdFBvcHBlclBvc2l0aW9uLmRpc3BsYXlOYW1lID0gUE9QUEVSX1BPU0lUSU9OX05BTUU7XG52YXIgW1NlbGVjdFZpZXdwb3J0UHJvdmlkZXIsIHVzZVNlbGVjdFZpZXdwb3J0Q29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSwge30pO1xudmFyIFZJRVdQT1JUX05BTUUgPSBcIlNlbGVjdFZpZXdwb3J0XCI7XG52YXIgU2VsZWN0Vmlld3BvcnQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgbm9uY2UsIC4uLnZpZXdwb3J0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoVklFV1BPUlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3Qgdmlld3BvcnRDb250ZXh0ID0gdXNlU2VsZWN0Vmlld3BvcnRDb250ZXh0KFZJRVdQT1JUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRlbnRDb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UpO1xuICAgIGNvbnN0IHByZXZTY3JvbGxUb3BSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgX19odG1sOiBgW2RhdGEtcmFkaXgtc2VsZWN0LXZpZXdwb3J0XXtzY3JvbGxiYXItd2lkdGg6bm9uZTstbXMtb3ZlcmZsb3ctc3R5bGU6bm9uZTstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDt9W2RhdGEtcmFkaXgtc2VsZWN0LXZpZXdwb3J0XTo6LXdlYmtpdC1zY3JvbGxiYXJ7ZGlzcGxheTpub25lfWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vbmNlXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb24uU2xvdCwgeyBzY29wZTogX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgIHtcbiAgICAgICAgICBcImRhdGEtcmFkaXgtc2VsZWN0LXZpZXdwb3J0XCI6IFwiXCIsXG4gICAgICAgICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICAgICAgICAuLi52aWV3cG9ydFByb3BzLFxuICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgcG9zaXRpb246ICdyZWxhdGl2ZScgaGVyZSBvbiB0aGUgYHZpZXdwb3J0YCBzbyB0aGF0IHdoZW4gd2UgY2FsbFxuICAgICAgICAgICAgLy8gYHNlbGVjdGVkSXRlbS5vZmZzZXRUb3BgIGluIGNhbGN1bGF0aW9ucywgdGhlIG9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgIC8vIChpbmRlcGVuZGVudCBvZiB0aGUgc2Nyb2xsVXBCdXR0b24pLlxuICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAvLyBWaWV3cG9ydCBzaG91bGQgb25seSBiZSBzY3JvbGxhYmxlIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAvLyBUaGlzIHdvbid0IHdvcmsgaW4gdmVydGljYWwgd3JpdGluZyBtb2Rlcywgc28gd2UnbGwgbmVlZCB0b1xuICAgICAgICAgICAgLy8gcmV2aXNpdCB0aGlzIGlmL3doZW4gdGhhdCBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vYmxvZy92ZXJ0aWNhbC1mb3JtLWNvbnRyb2xzXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW4gYXV0b1wiLFxuICAgICAgICAgICAgLi4udmlld3BvcnRQcm9wcy5zdHlsZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TY3JvbGw6IGNvbXBvc2VFdmVudEhhbmRsZXJzKHZpZXdwb3J0UHJvcHMub25TY3JvbGwsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgeyBjb250ZW50V3JhcHBlciwgc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYgfSA9IHZpZXdwb3J0Q29udGV4dDtcbiAgICAgICAgICAgIGlmIChzaG91bGRFeHBhbmRPblNjcm9sbFJlZj8uY3VycmVudCAmJiBjb250ZW50V3JhcHBlcikge1xuICAgICAgICAgICAgICBjb25zdCBzY3JvbGxlZEJ5ID0gTWF0aC5hYnMocHJldlNjcm9sbFRvcFJlZi5jdXJyZW50IC0gdmlld3BvcnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgaWYgKHNjcm9sbGVkQnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gQ09OVEVOVF9NQVJHSU4gKiAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzc01pbkhlaWdodCA9IHBhcnNlRmxvYXQoY29udGVudFdyYXBwZXIuc3R5bGUubWluSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjc3NIZWlnaHQgPSBwYXJzZUZsb2F0KGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkhlaWdodCA9IE1hdGgubWF4KGNzc01pbkhlaWdodCwgY3NzSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkhlaWdodCA8IGF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEhlaWdodCA9IHByZXZIZWlnaHQgKyBzY3JvbGxlZEJ5O1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2xhbXBlZE5leHRIZWlnaHQgPSBNYXRoLm1pbihhdmFpbGFibGVIZWlnaHQsIG5leHRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0RGlmZiA9IG5leHRIZWlnaHQgLSBjbGFtcGVkTmV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGNsYW1wZWROZXh0SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRXcmFwcGVyLnN0eWxlLmJvdHRvbSA9PT0gXCIwcHhcIikge1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5zY3JvbGxUb3AgPSBoZWlnaHREaWZmID4gMCA/IGhlaWdodERpZmYgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IHZpZXdwb3J0LnNjcm9sbFRvcDtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICApIH0pXG4gICAgXSB9KTtcbiAgfVxuKTtcblNlbGVjdFZpZXdwb3J0LmRpc3BsYXlOYW1lID0gVklFV1BPUlRfTkFNRTtcbnZhciBHUk9VUF9OQU1FID0gXCJTZWxlY3RHcm91cFwiO1xudmFyIFtTZWxlY3RHcm91cENvbnRleHRQcm92aWRlciwgdXNlU2VsZWN0R3JvdXBDb250ZXh0XSA9IGNyZWF0ZVNlbGVjdENvbnRleHQoR1JPVVBfTkFNRSk7XG52YXIgU2VsZWN0R3JvdXAgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgLi4uZ3JvdXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgZ3JvdXBJZCA9IHVzZUlkKCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0R3JvdXBDb250ZXh0UHJvdmlkZXIsIHsgc2NvcGU6IF9fc2NvcGVTZWxlY3QsIGlkOiBncm91cElkLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IHJvbGU6IFwiZ3JvdXBcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogZ3JvdXBJZCwgLi4uZ3JvdXBQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSkgfSk7XG4gIH1cbik7XG5TZWxlY3RHcm91cC5kaXNwbGF5TmFtZSA9IEdST1VQX05BTUU7XG52YXIgTEFCRUxfTkFNRSA9IFwiU2VsZWN0TGFiZWxcIjtcbnZhciBTZWxlY3RMYWJlbCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5sYWJlbFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBncm91cENvbnRleHQgPSB1c2VTZWxlY3RHcm91cENvbnRleHQoTEFCRUxfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyBpZDogZ3JvdXBDb250ZXh0LmlkLCAuLi5sYWJlbFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KTtcbiAgfVxuKTtcblNlbGVjdExhYmVsLmRpc3BsYXlOYW1lID0gTEFCRUxfTkFNRTtcbnZhciBJVEVNX05BTUUgPSBcIlNlbGVjdEl0ZW1cIjtcbnZhciBbU2VsZWN0SXRlbUNvbnRleHRQcm92aWRlciwgdXNlU2VsZWN0SXRlbUNvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChJVEVNX05BTUUpO1xudmFyIFNlbGVjdEl0ZW0gPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZVByb3AsXG4gICAgICAuLi5pdGVtUHJvcHNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoSVRFTV9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZVNlbGVjdENvbnRlbnRDb250ZXh0KElURU1fTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNvbnRleHQudmFsdWUgPT09IHZhbHVlO1xuICAgIGNvbnN0IFt0ZXh0VmFsdWUsIHNldFRleHRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSh0ZXh0VmFsdWVQcm9wID8/IFwiXCIpO1xuICAgIGNvbnN0IFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKFxuICAgICAgZm9yd2FyZGVkUmVmLFxuICAgICAgKG5vZGUpID0+IGNvbnRlbnRDb250ZXh0Lml0ZW1SZWZDYWxsYmFjaz8uKG5vZGUsIHZhbHVlLCBkaXNhYmxlZClcbiAgICApO1xuICAgIGNvbnN0IHRleHRJZCA9IHVzZUlkKCk7XG4gICAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoXCJ0b3VjaFwiKTtcbiAgICBjb25zdCBoYW5kbGVTZWxlY3QgPSAoKSA9PiB7XG4gICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgIGNvbnRleHQub25WYWx1ZUNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRleHQub25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkEgPFNlbGVjdC5JdGVtIC8+IG11c3QgaGF2ZSBhIHZhbHVlIHByb3AgdGhhdCBpcyBub3QgYW4gZW1wdHkgc3RyaW5nLiBUaGlzIGlzIGJlY2F1c2UgdGhlIFNlbGVjdCB2YWx1ZSBjYW4gYmUgc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgc2VsZWN0aW9uIGFuZCBzaG93IHRoZSBwbGFjZWhvbGRlci5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBTZWxlY3RJdGVtQ29udGV4dFByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICB0ZXh0SWQsXG4gICAgICAgIGlzU2VsZWN0ZWQsXG4gICAgICAgIG9uSXRlbVRleHRDaGFuZ2U6IFJlYWN0LnVzZUNhbGxiYWNrKChub2RlKSA9PiB7XG4gICAgICAgICAgc2V0VGV4dFZhbHVlKChwcmV2VGV4dFZhbHVlKSA9PiBwcmV2VGV4dFZhbHVlIHx8IChub2RlPy50ZXh0Q29udGVudCA/PyBcIlwiKS50cmltKCkpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIENvbGxlY3Rpb24uSXRlbVNsb3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2NvcGU6IF9fc2NvcGVTZWxlY3QsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgdGV4dFZhbHVlLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb2xlOiBcIm9wdGlvblwiLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRleHRJZCxcbiAgICAgICAgICAgICAgICBcImRhdGEtaGlnaGxpZ2h0ZWRcIjogaXNGb2N1c2VkID8gXCJcIiA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNTZWxlY3RlZCAmJiBpc0ZvY3VzZWQsXG4gICAgICAgICAgICAgICAgXCJkYXRhLXN0YXRlXCI6IGlzU2VsZWN0ZWQgPyBcImNoZWNrZWRcIiA6IFwidW5jaGVja2VkXCIsXG4gICAgICAgICAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGRpc2FibGVkIHx8IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHRhYkluZGV4OiBkaXNhYmxlZCA/IHZvaWQgMCA6IC0xLFxuICAgICAgICAgICAgICAgIC4uLml0ZW1Qcm9wcyxcbiAgICAgICAgICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Gb2N1cywgKCkgPT4gc2V0SXNGb2N1c2VkKHRydWUpKSxcbiAgICAgICAgICAgICAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vbkJsdXIsICgpID0+IHNldElzRm9jdXNlZChmYWxzZSkpLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vbkNsaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCAhPT0gXCJtb3VzZVwiKSBoYW5kbGVTZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvblBvaW50ZXJVcDogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uUG9pbnRlclVwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gXCJtb3VzZVwiKSBoYW5kbGVTZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvblBvaW50ZXJEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyRG93biwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb25Qb2ludGVyTW92ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uUG9pbnRlck1vdmUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRDb250ZXh0Lm9uSXRlbUxlYXZlPy4oKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckxlYXZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyTGVhdmUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudENvbnRleHQub25JdGVtTGVhdmU/LigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uS2V5RG93biwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpc1R5cGluZ0FoZWFkID0gY29udGVudENvbnRleHQuc2VhcmNoUmVmPy5jdXJyZW50ICE9PSBcIlwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVHlwaW5nQWhlYWQgJiYgZXZlbnQua2V5ID09PSBcIiBcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgaWYgKFNFTEVDVElPTl9LRVlTLmluY2x1ZGVzKGV2ZW50LmtleSkpIGhhbmRsZVNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5TZWxlY3RJdGVtLmRpc3BsYXlOYW1lID0gSVRFTV9OQU1FO1xudmFyIElURU1fVEVYVF9OQU1FID0gXCJTZWxlY3RJdGVtVGV4dFwiO1xudmFyIFNlbGVjdEl0ZW1UZXh0ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIGNsYXNzTmFtZSwgc3R5bGUsIC4uLml0ZW1UZXh0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZVNlbGVjdENvbnRlbnRDb250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBpdGVtQ29udGV4dCA9IHVzZVNlbGVjdEl0ZW1Db250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBuYXRpdmVPcHRpb25zQ29udGV4dCA9IHVzZVNlbGVjdE5hdGl2ZU9wdGlvbnNDb250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBbaXRlbVRleHROb2RlLCBzZXRJdGVtVGV4dE5vZGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKFxuICAgICAgZm9yd2FyZGVkUmVmLFxuICAgICAgKG5vZGUpID0+IHNldEl0ZW1UZXh0Tm9kZShub2RlKSxcbiAgICAgIGl0ZW1Db250ZXh0Lm9uSXRlbVRleHRDaGFuZ2UsXG4gICAgICAobm9kZSkgPT4gY29udGVudENvbnRleHQuaXRlbVRleHRSZWZDYWxsYmFjaz8uKG5vZGUsIGl0ZW1Db250ZXh0LnZhbHVlLCBpdGVtQ29udGV4dC5kaXNhYmxlZClcbiAgICApO1xuICAgIGNvbnN0IHRleHRDb250ZW50ID0gaXRlbVRleHROb2RlPy50ZXh0Q29udGVudDtcbiAgICBjb25zdCBuYXRpdmVPcHRpb24gPSBSZWFjdC51c2VNZW1vKFxuICAgICAgKCkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcIm9wdGlvblwiLCB7IHZhbHVlOiBpdGVtQ29udGV4dC52YWx1ZSwgZGlzYWJsZWQ6IGl0ZW1Db250ZXh0LmRpc2FibGVkLCBjaGlsZHJlbjogdGV4dENvbnRlbnQgfSwgaXRlbUNvbnRleHQudmFsdWUpLFxuICAgICAgW2l0ZW1Db250ZXh0LmRpc2FibGVkLCBpdGVtQ29udGV4dC52YWx1ZSwgdGV4dENvbnRlbnRdXG4gICAgKTtcbiAgICBjb25zdCB7IG9uTmF0aXZlT3B0aW9uQWRkLCBvbk5hdGl2ZU9wdGlvblJlbW92ZSB9ID0gbmF0aXZlT3B0aW9uc0NvbnRleHQ7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTmF0aXZlT3B0aW9uQWRkKG5hdGl2ZU9wdGlvbik7XG4gICAgICByZXR1cm4gKCkgPT4gb25OYXRpdmVPcHRpb25SZW1vdmUobmF0aXZlT3B0aW9uKTtcbiAgICB9LCBbb25OYXRpdmVPcHRpb25BZGQsIG9uTmF0aXZlT3B0aW9uUmVtb3ZlLCBuYXRpdmVPcHRpb25dKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLnNwYW4sIHsgaWQ6IGl0ZW1Db250ZXh0LnRleHRJZCwgLi4uaXRlbVRleHRQcm9wcywgcmVmOiBjb21wb3NlZFJlZnMgfSksXG4gICAgICBpdGVtQ29udGV4dC5pc1NlbGVjdGVkICYmIGNvbnRleHQudmFsdWVOb2RlICYmICFjb250ZXh0LnZhbHVlTm9kZUhhc0NoaWxkcmVuID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKGl0ZW1UZXh0UHJvcHMuY2hpbGRyZW4sIGNvbnRleHQudmFsdWVOb2RlKSA6IG51bGxcbiAgICBdIH0pO1xuICB9XG4pO1xuU2VsZWN0SXRlbVRleHQuZGlzcGxheU5hbWUgPSBJVEVNX1RFWFRfTkFNRTtcbnZhciBJVEVNX0lORElDQVRPUl9OQU1FID0gXCJTZWxlY3RJdGVtSW5kaWNhdG9yXCI7XG52YXIgU2VsZWN0SXRlbUluZGljYXRvciA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5pdGVtSW5kaWNhdG9yUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGl0ZW1Db250ZXh0ID0gdXNlU2VsZWN0SXRlbUNvbnRleHQoSVRFTV9JTkRJQ0FUT1JfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgcmV0dXJuIGl0ZW1Db250ZXh0LmlzU2VsZWN0ZWQgPyAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5zcGFuLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgLi4uaXRlbUluZGljYXRvclByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KSA6IG51bGw7XG4gIH1cbik7XG5TZWxlY3RJdGVtSW5kaWNhdG9yLmRpc3BsYXlOYW1lID0gSVRFTV9JTkRJQ0FUT1JfTkFNRTtcbnZhciBTQ1JPTExfVVBfQlVUVE9OX05BTUUgPSBcIlNlbGVjdFNjcm9sbFVwQnV0dG9uXCI7XG52YXIgU2VsZWN0U2Nyb2xsVXBCdXR0b24gPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoU0NST0xMX1VQX0JVVFRPTl9OQU1FLCBwcm9wcy5fX3Njb3BlU2VsZWN0KTtcbiAgY29uc3Qgdmlld3BvcnRDb250ZXh0ID0gdXNlU2VsZWN0Vmlld3BvcnRDb250ZXh0KFNDUk9MTF9VUF9CVVRUT05fTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IFtjYW5TY3JvbGxVcCwgc2V0Q2FuU2Nyb2xsVXBdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCB2aWV3cG9ydENvbnRleHQub25TY3JvbGxCdXR0b25DaGFuZ2UpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjb250ZW50Q29udGV4dC52aWV3cG9ydCAmJiBjb250ZW50Q29udGV4dC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGxldCBoYW5kbGVTY3JvbGwyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNhblNjcm9sbFVwMiA9IHZpZXdwb3J0LnNjcm9sbFRvcCA+IDA7XG4gICAgICAgIHNldENhblNjcm9sbFVwKGNhblNjcm9sbFVwMik7XG4gICAgICB9O1xuICAgICAgdmFyIGhhbmRsZVNjcm9sbCA9IGhhbmRsZVNjcm9sbDI7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGNvbnRlbnRDb250ZXh0LnZpZXdwb3J0O1xuICAgICAgaGFuZGxlU2Nyb2xsMigpO1xuICAgICAgdmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwyKTtcbiAgICAgIHJldHVybiAoKSA9PiB2aWV3cG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbDIpO1xuICAgIH1cbiAgfSwgW2NvbnRlbnRDb250ZXh0LnZpZXdwb3J0LCBjb250ZW50Q29udGV4dC5pc1Bvc2l0aW9uZWRdKTtcbiAgcmV0dXJuIGNhblNjcm9sbFVwID8gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTZWxlY3RTY3JvbGxCdXR0b25JbXBsLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICBvbkF1dG9TY3JvbGw6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyB2aWV3cG9ydCwgc2VsZWN0ZWRJdGVtIH0gPSBjb250ZW50Q29udGV4dDtcbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgIHZpZXdwb3J0LnNjcm9sbFRvcCA9IHZpZXdwb3J0LnNjcm9sbFRvcCAtIHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsO1xufSk7XG5TZWxlY3RTY3JvbGxVcEJ1dHRvbi5kaXNwbGF5TmFtZSA9IFNDUk9MTF9VUF9CVVRUT05fTkFNRTtcbnZhciBTQ1JPTExfRE9XTl9CVVRUT05fTkFNRSA9IFwiU2VsZWN0U2Nyb2xsRG93bkJ1dHRvblwiO1xudmFyIFNlbGVjdFNjcm9sbERvd25CdXR0b24gPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoU0NST0xMX0RPV05fQlVUVE9OX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCB2aWV3cG9ydENvbnRleHQgPSB1c2VTZWxlY3RWaWV3cG9ydENvbnRleHQoU0NST0xMX0RPV05fQlVUVE9OX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBbY2FuU2Nyb2xsRG93biwgc2V0Q2FuU2Nyb2xsRG93bl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHZpZXdwb3J0Q29udGV4dC5vblNjcm9sbEJ1dHRvbkNoYW5nZSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnRDb250ZXh0LnZpZXdwb3J0ICYmIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZCkge1xuICAgICAgbGV0IGhhbmRsZVNjcm9sbDIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdmlld3BvcnQuc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBjYW5TY3JvbGxEb3duMiA9IE1hdGguY2VpbCh2aWV3cG9ydC5zY3JvbGxUb3ApIDwgbWF4U2Nyb2xsO1xuICAgICAgICBzZXRDYW5TY3JvbGxEb3duKGNhblNjcm9sbERvd24yKTtcbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlU2Nyb2xsID0gaGFuZGxlU2Nyb2xsMjtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gY29udGVudENvbnRleHQudmlld3BvcnQ7XG4gICAgICBoYW5kbGVTY3JvbGwyKCk7XG4gICAgICB2aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbDIpO1xuICAgICAgcmV0dXJuICgpID0+IHZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsMik7XG4gICAgfVxuICB9LCBbY29udGVudENvbnRleHQudmlld3BvcnQsIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZF0pO1xuICByZXR1cm4gY2FuU2Nyb2xsRG93biA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgU2VsZWN0U2Nyb2xsQnV0dG9uSW1wbCxcbiAgICB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgb25BdXRvU2Nyb2xsOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdmlld3BvcnQsIHNlbGVjdGVkSXRlbSB9ID0gY29udGVudENvbnRleHQ7XG4gICAgICAgIGlmICh2aWV3cG9ydCAmJiBzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICB2aWV3cG9ydC5zY3JvbGxUb3AgPSB2aWV3cG9ydC5zY3JvbGxUb3AgKyBzZWxlY3RlZEl0ZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApIDogbnVsbDtcbn0pO1xuU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbi5kaXNwbGF5TmFtZSA9IFNDUk9MTF9ET1dOX0JVVFRPTl9OQU1FO1xudmFyIFNlbGVjdFNjcm9sbEJ1dHRvbkltcGwgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgb25BdXRvU2Nyb2xsLCAuLi5zY3JvbGxJbmRpY2F0b3JQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoXCJTZWxlY3RTY3JvbGxCdXR0b25cIiwgX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IGF1dG9TY3JvbGxUaW1lclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZ2V0SXRlbXMgPSB1c2VDb2xsZWN0aW9uKF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBjbGVhckF1dG9TY3JvbGxUaW1lciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50KTtcbiAgICAgIGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJBdXRvU2Nyb2xsVGltZXIoKTtcbiAgfSwgW2NsZWFyQXV0b1Njcm9sbFRpbWVyXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEl0ZW1zKCkuZmluZCgoaXRlbSkgPT4gaXRlbS5yZWYuY3VycmVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgYWN0aXZlSXRlbT8ucmVmLmN1cnJlbnQ/LnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwibmVhcmVzdFwiIH0pO1xuICB9LCBbZ2V0SXRlbXNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgUHJpbWl0aXZlLmRpdixcbiAgICB7XG4gICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICAuLi5zY3JvbGxJbmRpY2F0b3JQcm9wcyxcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgc3R5bGU6IHsgZmxleFNocmluazogMCwgLi4uc2Nyb2xsSW5kaWNhdG9yUHJvcHMuc3R5bGUgfSxcbiAgICAgIG9uUG9pbnRlckRvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKHNjcm9sbEluZGljYXRvclByb3BzLm9uUG9pbnRlckRvd24sICgpID0+IHtcbiAgICAgICAgaWYgKGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwob25BdXRvU2Nyb2xsLCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgb25Qb2ludGVyTW92ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMoc2Nyb2xsSW5kaWNhdG9yUHJvcHMub25Qb2ludGVyTW92ZSwgKCkgPT4ge1xuICAgICAgICBjb250ZW50Q29udGV4dC5vbkl0ZW1MZWF2ZT8uKCk7XG4gICAgICAgIGlmIChhdXRvU2Nyb2xsVGltZXJSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID0gd2luZG93LnNldEludGVydmFsKG9uQXV0b1Njcm9sbCwgNTApO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIG9uUG9pbnRlckxlYXZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhzY3JvbGxJbmRpY2F0b3JQcm9wcy5vblBvaW50ZXJMZWF2ZSwgKCkgPT4ge1xuICAgICAgICBjbGVhckF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgfSlcbiAgICB9XG4gICk7XG59KTtcbnZhciBTRVBBUkFUT1JfTkFNRSA9IFwiU2VsZWN0U2VwYXJhdG9yXCI7XG52YXIgU2VsZWN0U2VwYXJhdG9yID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLnNlcGFyYXRvclByb3BzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgLi4uc2VwYXJhdG9yUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pO1xuICB9XG4pO1xuU2VsZWN0U2VwYXJhdG9yLmRpc3BsYXlOYW1lID0gU0VQQVJBVE9SX05BTUU7XG52YXIgQVJST1dfTkFNRSA9IFwiU2VsZWN0QXJyb3dcIjtcbnZhciBTZWxlY3RBcnJvdyA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5hcnJvd1Byb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KEFSUk9XX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoQVJST1dfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgcmV0dXJuIGNvbnRleHQub3BlbiAmJiBjb250ZW50Q29udGV4dC5wb3NpdGlvbiA9PT0gXCJwb3BwZXJcIiA/IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9wcGVyUHJpbWl0aXZlLkFycm93LCB7IC4uLnBvcHBlclNjb3BlLCAuLi5hcnJvd1Byb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KSA6IG51bGw7XG4gIH1cbik7XG5TZWxlY3RBcnJvdy5kaXNwbGF5TmFtZSA9IEFSUk9XX05BTUU7XG5mdW5jdGlvbiBzaG91bGRTaG93UGxhY2Vob2xkZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB2b2lkIDA7XG59XG52YXIgQnViYmxlU2VsZWN0ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IHZhbHVlLCAuLi5zZWxlY3RQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHJlZik7XG4gICAgY29uc3QgcHJldlZhbHVlID0gdXNlUHJldmlvdXModmFsdWUpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3QgPSByZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHNlbGVjdFByb3RvID0gd2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICBzZWxlY3RQcm90byxcbiAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICApO1xuICAgICAgY29uc3Qgc2V0VmFsdWUgPSBkZXNjcmlwdG9yLnNldDtcbiAgICAgIGlmIChwcmV2VmFsdWUgIT09IHZhbHVlICYmIHNldFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KFwiY2hhbmdlXCIsIHsgYnViYmxlczogdHJ1ZSB9KTtcbiAgICAgICAgc2V0VmFsdWUuY2FsbChzZWxlY3QsIHZhbHVlKTtcbiAgICAgICAgc2VsZWN0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIFtwcmV2VmFsdWUsIHZhbHVlXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVmlzdWFsbHlIaWRkZW4sIHsgYXNDaGlsZDogdHJ1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzZWxlY3RcIiwgeyAuLi5zZWxlY3RQcm9wcywgcmVmOiBjb21wb3NlZFJlZnMsIGRlZmF1bHRWYWx1ZTogdmFsdWUgfSkgfSk7XG4gIH1cbik7XG5CdWJibGVTZWxlY3QuZGlzcGxheU5hbWUgPSBcIkJ1YmJsZVNlbGVjdFwiO1xuZnVuY3Rpb24gdXNlVHlwZWFoZWFkU2VhcmNoKG9uU2VhcmNoQ2hhbmdlKSB7XG4gIGNvbnN0IGhhbmRsZVNlYXJjaENoYW5nZSA9IHVzZUNhbGxiYWNrUmVmKG9uU2VhcmNoQ2hhbmdlKTtcbiAgY29uc3Qgc2VhcmNoUmVmID0gUmVhY3QudXNlUmVmKFwiXCIpO1xuICBjb25zdCB0aW1lclJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3QgaGFuZGxlVHlwZWFoZWFkU2VhcmNoID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGtleSkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUmVmLmN1cnJlbnQgKyBrZXk7XG4gICAgICBoYW5kbGVTZWFyY2hDaGFuZ2Uoc2VhcmNoKTtcbiAgICAgIChmdW5jdGlvbiB1cGRhdGVTZWFyY2godmFsdWUpIHtcbiAgICAgICAgc2VhcmNoUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBcIlwiKSB0aW1lclJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdXBkYXRlU2VhcmNoKFwiXCIpLCAxZTMpO1xuICAgICAgfSkoc2VhcmNoKTtcbiAgICB9LFxuICAgIFtoYW5kbGVTZWFyY2hDaGFuZ2VdXG4gICk7XG4gIGNvbnN0IHJlc2V0VHlwZWFoZWFkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNlYXJjaFJlZi5jdXJyZW50ID0gXCJcIjtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyUmVmLmN1cnJlbnQpO1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXJSZWYuY3VycmVudCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtzZWFyY2hSZWYsIGhhbmRsZVR5cGVhaGVhZFNlYXJjaCwgcmVzZXRUeXBlYWhlYWRdO1xufVxuZnVuY3Rpb24gZmluZE5leHRJdGVtKGl0ZW1zLCBzZWFyY2gsIGN1cnJlbnRJdGVtKSB7XG4gIGNvbnN0IGlzUmVwZWF0ZWQgPSBzZWFyY2gubGVuZ3RoID4gMSAmJiBBcnJheS5mcm9tKHNlYXJjaCkuZXZlcnkoKGNoYXIpID0+IGNoYXIgPT09IHNlYXJjaFswXSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRTZWFyY2ggPSBpc1JlcGVhdGVkID8gc2VhcmNoWzBdIDogc2VhcmNoO1xuICBjb25zdCBjdXJyZW50SXRlbUluZGV4ID0gY3VycmVudEl0ZW0gPyBpdGVtcy5pbmRleE9mKGN1cnJlbnRJdGVtKSA6IC0xO1xuICBsZXQgd3JhcHBlZEl0ZW1zID0gd3JhcEFycmF5KGl0ZW1zLCBNYXRoLm1heChjdXJyZW50SXRlbUluZGV4LCAwKSk7XG4gIGNvbnN0IGV4Y2x1ZGVDdXJyZW50SXRlbSA9IG5vcm1hbGl6ZWRTZWFyY2gubGVuZ3RoID09PSAxO1xuICBpZiAoZXhjbHVkZUN1cnJlbnRJdGVtKSB3cmFwcGVkSXRlbXMgPSB3cmFwcGVkSXRlbXMuZmlsdGVyKCh2KSA9PiB2ICE9PSBjdXJyZW50SXRlbSk7XG4gIGNvbnN0IG5leHRJdGVtID0gd3JhcHBlZEl0ZW1zLmZpbmQoXG4gICAgKGl0ZW0pID0+IGl0ZW0udGV4dFZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChub3JtYWxpemVkU2VhcmNoLnRvTG93ZXJDYXNlKCkpXG4gICk7XG4gIHJldHVybiBuZXh0SXRlbSAhPT0gY3VycmVudEl0ZW0gPyBuZXh0SXRlbSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHdyYXBBcnJheShhcnJheSwgc3RhcnRJbmRleCkge1xuICByZXR1cm4gYXJyYXkubWFwKChfLCBpbmRleCkgPT4gYXJyYXlbKHN0YXJ0SW5kZXggKyBpbmRleCkgJSBhcnJheS5sZW5ndGhdKTtcbn1cbnZhciBSb290MiA9IFNlbGVjdDtcbnZhciBUcmlnZ2VyID0gU2VsZWN0VHJpZ2dlcjtcbnZhciBWYWx1ZSA9IFNlbGVjdFZhbHVlO1xudmFyIEljb24gPSBTZWxlY3RJY29uO1xudmFyIFBvcnRhbCA9IFNlbGVjdFBvcnRhbDtcbnZhciBDb250ZW50MiA9IFNlbGVjdENvbnRlbnQ7XG52YXIgVmlld3BvcnQgPSBTZWxlY3RWaWV3cG9ydDtcbnZhciBHcm91cCA9IFNlbGVjdEdyb3VwO1xudmFyIExhYmVsID0gU2VsZWN0TGFiZWw7XG52YXIgSXRlbSA9IFNlbGVjdEl0ZW07XG52YXIgSXRlbVRleHQgPSBTZWxlY3RJdGVtVGV4dDtcbnZhciBJdGVtSW5kaWNhdG9yID0gU2VsZWN0SXRlbUluZGljYXRvcjtcbnZhciBTY3JvbGxVcEJ1dHRvbiA9IFNlbGVjdFNjcm9sbFVwQnV0dG9uO1xudmFyIFNjcm9sbERvd25CdXR0b24gPSBTZWxlY3RTY3JvbGxEb3duQnV0dG9uO1xudmFyIFNlcGFyYXRvciA9IFNlbGVjdFNlcGFyYXRvcjtcbnZhciBBcnJvdzIgPSBTZWxlY3RBcnJvdztcbmV4cG9ydCB7XG4gIEFycm93MiBhcyBBcnJvdyxcbiAgQ29udGVudDIgYXMgQ29udGVudCxcbiAgR3JvdXAsXG4gIEljb24sXG4gIEl0ZW0sXG4gIEl0ZW1JbmRpY2F0b3IsXG4gIEl0ZW1UZXh0LFxuICBMYWJlbCxcbiAgUG9ydGFsLFxuICBSb290MiBhcyBSb290LFxuICBTY3JvbGxEb3duQnV0dG9uLFxuICBTY3JvbGxVcEJ1dHRvbixcbiAgU2VsZWN0LFxuICBTZWxlY3RBcnJvdyxcbiAgU2VsZWN0Q29udGVudCxcbiAgU2VsZWN0R3JvdXAsXG4gIFNlbGVjdEljb24sXG4gIFNlbGVjdEl0ZW0sXG4gIFNlbGVjdEl0ZW1JbmRpY2F0b3IsXG4gIFNlbGVjdEl0ZW1UZXh0LFxuICBTZWxlY3RMYWJlbCxcbiAgU2VsZWN0UG9ydGFsLFxuICBTZWxlY3RTY3JvbGxEb3duQnV0dG9uLFxuICBTZWxlY3RTY3JvbGxVcEJ1dHRvbixcbiAgU2VsZWN0U2VwYXJhdG9yLFxuICBTZWxlY3RUcmlnZ2VyLFxuICBTZWxlY3RWYWx1ZSxcbiAgU2VsZWN0Vmlld3BvcnQsXG4gIFNlcGFyYXRvcixcbiAgVHJpZ2dlcixcbiAgVmFsdWUsXG4gIFZpZXdwb3J0LFxuICBjcmVhdGVTZWxlY3RTY29wZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5jb25zdCB0b0tlYmFiQ2FzZSA9IChzdHJpbmcpID0+IHN0cmluZy5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG5jb25zdCBtZXJnZUNsYXNzZXMgPSAoLi4uY2xhc3NlcykgPT4gY2xhc3Nlcy5maWx0ZXIoKGNsYXNzTmFtZSwgaW5kZXgsIGFycmF5KSA9PiB7XG4gIHJldHVybiBCb29sZWFuKGNsYXNzTmFtZSkgJiYgY2xhc3NOYW1lLnRyaW0oKSAhPT0gXCJcIiAmJiBhcnJheS5pbmRleE9mKGNsYXNzTmFtZSkgPT09IGluZGV4O1xufSkuam9pbihcIiBcIikudHJpbSgpO1xuXG5leHBvcnQgeyBtZXJnZUNsYXNzZXMsIHRvS2ViYWJDYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7XG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHdpZHRoOiAyNCxcbiAgaGVpZ2h0OiAyNCxcbiAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxufTtcblxuZXhwb3J0IHsgZGVmYXVsdEF0dHJpYnV0ZXMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdEF0dHJpYnV0ZXMuanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZm9yd2FyZFJlZiwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IG1lcmdlQ2xhc3NlcyB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy5qcyc7XG5cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBzaXplID0gMjQsXG4gICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgIGFic29sdXRlU3Ryb2tlV2lkdGgsXG4gICAgY2xhc3NOYW1lID0gXCJcIixcbiAgICBjaGlsZHJlbixcbiAgICBpY29uTm9kZSxcbiAgICAuLi5yZXN0XG4gIH0sIHJlZikgPT4ge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgXCJzdmdcIixcbiAgICAgIHtcbiAgICAgICAgcmVmLFxuICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlcyxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGggPyBOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQgLyBOdW1iZXIoc2l6ZSkgOiBzdHJva2VXaWR0aCxcbiAgICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoXCJsdWNpZGVcIiwgY2xhc3NOYW1lKSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgLi4uaWNvbk5vZGUubWFwKChbdGFnLCBhdHRyc10pID0+IGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykpLFxuICAgICAgICAuLi5BcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogW2NoaWxkcmVuXVxuICAgICAgXVxuICAgICk7XG4gIH1cbik7XG5cbmV4cG9ydCB7IEljb24gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbi5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuXG5jb25zdCBjcmVhdGVMdWNpZGVJY29uID0gKGljb25OYW1lLCBpY29uTm9kZSkgPT4ge1xuICBjb25zdCBDb21wb25lbnQgPSBmb3J3YXJkUmVmKFxuICAgICh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiBjcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAgIHJlZixcbiAgICAgIGljb25Ob2RlLFxuICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKGljb25OYW1lKX1gLCBjbGFzc05hbWUpLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICApO1xuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBgJHtpY29uTmFtZX1gO1xuICByZXR1cm4gQ29tcG9uZW50O1xufTtcblxuZXhwb3J0IHsgY3JlYXRlTHVjaWRlSWNvbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVMdWNpZGVJY29uLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDaGVjayA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDaGVja1wiLCBbW1wicGF0aFwiLCB7IGQ6IFwiTTIwIDYgOSAxN2wtNS01XCIsIGtleTogXCIxZ21mMmNcIiB9XV0pO1xuXG5leHBvcnQgeyBDaGVjayBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVjay5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgQ2hldnJvbkRvd24gPSBjcmVhdGVMdWNpZGVJY29uKFwiQ2hldnJvbkRvd25cIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJtNiA5IDYgNiA2LTZcIiwga2V5OiBcInFydW5zbFwiIH1dXG5dKTtcblxuZXhwb3J0IHsgQ2hldnJvbkRvd24gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hldnJvbi1kb3duLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDaGV2cm9uVXAgPSBjcmVhdGVMdWNpZGVJY29uKFwiQ2hldnJvblVwXCIsIFtbXCJwYXRoXCIsIHsgZDogXCJtMTggMTUtNi02LTYgNlwiLCBrZXk6IFwiMTUzdWR6XCIgfV1dKTtcblxuZXhwb3J0IHsgQ2hldnJvblVwIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZXZyb24tdXAuanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IENvcHkgPSBjcmVhdGVMdWNpZGVJY29uKFwiQ29weVwiLCBbXG4gIFtcInJlY3RcIiwgeyB3aWR0aDogXCIxNFwiLCBoZWlnaHQ6IFwiMTRcIiwgeDogXCI4XCIsIHk6IFwiOFwiLCByeDogXCIyXCIsIHJ5OiBcIjJcIiwga2V5OiBcIjE3anllYVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNNCAxNmMtMS4xIDAtMi0uOS0yLTJWNGMwLTEuMS45LTIgMi0yaDEwYzEuMSAwIDIgLjkgMiAyXCIsIGtleTogXCJ6aXg5dWZcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IENvcHkgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29weS5qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFNlbGVjdFByaW1pdGl2ZSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNlbGVjdFwiO1xuaW1wb3J0IHsgQ2hlY2ssIENoZXZyb25Eb3duLCBDaGV2cm9uVXAgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcblxuY29uc3QgU2VsZWN0ID0gU2VsZWN0UHJpbWl0aXZlLlJvb3Q7XG5cbmNvbnN0IFNlbGVjdEdyb3VwID0gU2VsZWN0UHJpbWl0aXZlLkdyb3VwO1xuXG5jb25zdCBTZWxlY3RWYWx1ZSA9IFNlbGVjdFByaW1pdGl2ZS5WYWx1ZTtcblxuY29uc3QgU2VsZWN0VHJpZ2dlciA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuVHJpZ2dlcj5cbj4oKHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuVHJpZ2dlclxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICBcInJpbmctb2Zmc2V0LWJhY2tncm91bmQgZm9jdXM6cmluZy1yaW5nIGZsZXggaC00IHctZnVsbCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHdoaXRlc3BhY2Utbm93cmFwIHJvdW5kZWQtbWQgYmctdHJhbnNwYXJlbnQgcHgtMyBweS0yIHRleHQteHMgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMSBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6b3BhY2l0eS01MCBbJj5zcGFuXTpsaW5lLWNsYW1wLTFcIixcbiAgICAgIFwiZGFyazpwbGFjZWhvbGRlci10ZXh0LXppbmMtNjAwIHRleHQtYmxhY2sgcGxhY2Vob2xkZXI6dGV4dC1ub2lyLTQwMCBkYXJrOnRleHQtd2hpdGVcIixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICApfVxuICAgIHsuLi5wcm9wc31cbiAgPlxuICAgIHtjaGlsZHJlbn1cbiAgICA8U2VsZWN0UHJpbWl0aXZlLkljb24gYXNDaGlsZD5cbiAgICAgIDxDaGV2cm9uRG93biBjbGFzc05hbWU9XCJtbC0xIGgtNCB3LTQgdGV4dC1ibGFjayBvcGFjaXR5LTUwIGRhcms6dGV4dC13aGl0ZVwiIC8+XG4gICAgPC9TZWxlY3RQcmltaXRpdmUuSWNvbj5cbiAgPC9TZWxlY3RQcmltaXRpdmUuVHJpZ2dlcj5cbikpO1xuU2VsZWN0VHJpZ2dlci5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RTY3JvbGxVcEJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5TY3JvbGxVcEJ1dHRvbj4sXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uPlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uXG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwiZmxleCBjdXJzb3ItZGVmYXVsdCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcHktMVwiLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICA+XG4gICAgPENoZXZyb25VcCBjbGFzc05hbWU9XCJoLTQgdy00XCIgLz5cbiAgPC9TZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24+XG4pKTtcblNlbGVjdFNjcm9sbFVwQnV0dG9uLmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RTY3JvbGxEb3duQnV0dG9uID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b24+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5TY3JvbGxEb3duQnV0dG9uPlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b25cbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgXCJmbGV4IGN1cnNvci1kZWZhdWx0IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBweS0xXCIsXG4gICAgICBjbGFzc05hbWUsXG4gICAgKX1cbiAgICB7Li4ucHJvcHN9XG4gID5cbiAgICA8Q2hldnJvbkRvd24gY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+XG4gIDwvU2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b24+XG4pKTtcblNlbGVjdFNjcm9sbERvd25CdXR0b24uZGlzcGxheU5hbWUgPVxuICBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbi5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0Q29udGVudCA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5Db250ZW50PixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuQ29udGVudD5cbj4oKHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcG9zaXRpb24gPSBcInBvcHBlclwiLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5Qb3J0YWw+XG4gICAgPFNlbGVjdFByaW1pdGl2ZS5Db250ZW50XG4gICAgICByZWY9e3JlZn1cbiAgICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICAgIFwiZGF0YS1bc3RhdGU9b3Blbl06YW5pbWF0ZS1pbiBkYXRhLVtzdGF0ZT1jbG9zZWRdOmFuaW1hdGUtb3V0IGRhdGEtW3N0YXRlPWNsb3NlZF06ZmFkZS1vdXQtMCBkYXRhLVtzdGF0ZT1vcGVuXTpmYWRlLWluLTAgZGF0YS1bc3RhdGU9Y2xvc2VkXTp6b29tLW91dC05NSBkYXRhLVtzdGF0ZT1vcGVuXTp6b29tLWluLTk1IGRhdGEtW3NpZGU9Ym90dG9tXTpzbGlkZS1pbi1mcm9tLXRvcC0yIGRhdGEtW3NpZGU9bGVmdF06c2xpZGUtaW4tZnJvbS1yaWdodC0yIGRhdGEtW3NpZGU9cmlnaHRdOnNsaWRlLWluLWZyb20tbGVmdC0yIGRhdGEtW3NpZGU9dG9wXTpzbGlkZS1pbi1mcm9tLWJvdHRvbS0yIHJlbGF0aXZlIHotNTAgbWF4LWgtOTYgbWluLXctWzhyZW1dIG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLW1kIGJvcmRlciBzaGFkb3ctbWRcIixcbiAgICAgICAgcG9zaXRpb24gPT09IFwicG9wcGVyXCIgJiZcbiAgICAgICAgICBcImRhdGEtW3NpZGU9Ym90dG9tXTp0cmFuc2xhdGUteS0xIGRhdGEtW3NpZGU9bGVmdF06LXRyYW5zbGF0ZS14LTEgZGF0YS1bc2lkZT1yaWdodF06dHJhbnNsYXRlLXgtMSBkYXRhLVtzaWRlPXRvcF06LXRyYW5zbGF0ZS15LTFcIixcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICAgIHBvc2l0aW9uPXtwb3NpdGlvbn1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICA8U2VsZWN0U2Nyb2xsVXBCdXR0b24gLz5cbiAgICAgIDxTZWxlY3RQcmltaXRpdmUuVmlld3BvcnRcbiAgICAgICAgY2xhc3NOYW1lPXtjbihcbiAgICAgICAgICBcInAtMVwiLFxuICAgICAgICAgIHBvc2l0aW9uID09PSBcInBvcHBlclwiICYmXG4gICAgICAgICAgICBcImgtW3ZhcigtLXJhZGl4LXNlbGVjdC10cmlnZ2VyLWhlaWdodCldIHctZnVsbCBtaW4tdy1bdmFyKC0tcmFkaXgtc2VsZWN0LXRyaWdnZXItd2lkdGgpXVwiLFxuICAgICAgICApfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1NlbGVjdFByaW1pdGl2ZS5WaWV3cG9ydD5cbiAgICAgIDxTZWxlY3RTY3JvbGxEb3duQnV0dG9uIC8+XG4gICAgPC9TZWxlY3RQcmltaXRpdmUuQ29udGVudD5cbiAgPC9TZWxlY3RQcmltaXRpdmUuUG9ydGFsPlxuKSk7XG5TZWxlY3RDb250ZW50LmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLkNvbnRlbnQuZGlzcGxheU5hbWU7XG5cbmNvbnN0IFNlbGVjdExhYmVsID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLkxhYmVsPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuTGFiZWw+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuTGFiZWxcbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFwicHgtMiBweS0xLjUgdGV4dC1zbSBmb250LXNlbWlib2xkXCIsIGNsYXNzTmFtZSl9XG4gICAgey4uLnByb3BzfVxuICAvPlxuKSk7XG5TZWxlY3RMYWJlbC5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5MYWJlbC5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0SXRlbSA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5JdGVtPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuSXRlbT5cbj4oKHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuSXRlbVxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICBcInJlbGF0aXZlIGZsZXggdy1mdWxsIGN1cnNvci1kZWZhdWx0IHNlbGVjdC1ub25lIGl0ZW1zLWNlbnRlciByb3VuZGVkLXNtIHB5LTEuNSBwbC0yIHByLTggdGV4dC1zbSBvdXRsaW5lLW5vbmUgZGF0YS1bZGlzYWJsZWRdOnBvaW50ZXItZXZlbnRzLW5vbmUgZGF0YS1bZGlzYWJsZWRdOm9wYWNpdHktNTBcIixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICApfVxuICAgIHsuLi5wcm9wc31cbiAgPlxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImFic29sdXRlIHJpZ2h0LTIgZmxleCBoLTMuNSB3LTMuNSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgIDxTZWxlY3RQcmltaXRpdmUuSXRlbUluZGljYXRvcj5cbiAgICAgICAgPENoZWNrIGNsYXNzTmFtZT1cImgtNCB3LTRcIiAvPlxuICAgICAgPC9TZWxlY3RQcmltaXRpdmUuSXRlbUluZGljYXRvcj5cbiAgICA8L3NwYW4+XG4gICAgPFNlbGVjdFByaW1pdGl2ZS5JdGVtVGV4dD57Y2hpbGRyZW59PC9TZWxlY3RQcmltaXRpdmUuSXRlbVRleHQ+XG4gIDwvU2VsZWN0UHJpbWl0aXZlLkl0ZW0+XG4pKTtcblNlbGVjdEl0ZW0uZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuSXRlbS5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0U2VwYXJhdG9yID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNlcGFyYXRvcj4sXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNlcGFyYXRvcj5cbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5TZXBhcmF0b3JcbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFwiYmctbXV0ZWQgLW14LTEgbXktMSBoLXB4XCIsIGNsYXNzTmFtZSl9XG4gICAgey4uLnByb3BzfVxuICAvPlxuKSk7XG5TZWxlY3RTZXBhcmF0b3IuZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yLmRpc3BsYXlOYW1lO1xuXG5leHBvcnQge1xuICBTZWxlY3QsXG4gIFNlbGVjdEdyb3VwLFxuICBTZWxlY3RWYWx1ZSxcbiAgU2VsZWN0VHJpZ2dlcixcbiAgU2VsZWN0Q29udGVudCxcbiAgU2VsZWN0TGFiZWwsXG4gIFNlbGVjdEl0ZW0sXG4gIFNlbGVjdFNlcGFyYXRvcixcbiAgU2VsZWN0U2Nyb2xsVXBCdXR0b24sXG4gIFNlbGVjdFNjcm9sbERvd25CdXR0b24sXG59O1xuIiwiaW1wb3J0IHsgY24gfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyBDaGVja0ljb24sIENvcHlJY29uIH0gZnJvbSBcImx1Y2lkZS1yZWFjdFwiO1xuaW1wb3J0IHsgUmVhY3ROb2RlLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgQ29weUJ1dHRvbiA9ICh7XG4gIGxhYmVsLFxuICBidXR0b25DbGFzc05hbWUsXG4gIGxvZ29DbGFzc05hbWUsXG4gIHRleHRUb0NvcHksXG4gIGRpc2FibGVkLFxufToge1xuICBsYWJlbDogUmVhY3ROb2RlO1xuICB0ZXh0VG9Db3B5OiAoKSA9PiBzdHJpbmc7XG4gIGJ1dHRvbkNsYXNzTmFtZT86IHN0cmluZztcbiAgbG9nb0NsYXNzTmFtZT86IHN0cmluZztcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xufSkgPT4ge1xuICBjb25zdCBbbG9nbywgc2V0TG9nb10gPSB1c2VTdGF0ZTxSZWFjdE5vZGU+KFxuICAgIDxDb3B5SWNvbiBjbGFzc05hbWU9e2NuKFwiaC0zIHctM1wiLCBsb2dvQ2xhc3NOYW1lKX0gLz4sXG4gICk7XG4gIGNvbnN0IFtpbnRlcm5hbExhYmVsLCBzZXRJbnRlcm5hbExhYmVsXSA9IHVzZVN0YXRlPFJlYWN0Tm9kZT4obGFiZWwpO1xuICBjb25zdCBvbkNsaXBib2FyZENvcHkgPSAoKSA9PiB7XG4gICAgc2V0TG9nbyg8Q2hlY2tJY29uIGNsYXNzTmFtZT17Y24oXCJoLTMgdy0zXCIsIGxvZ29DbGFzc05hbWUpfSAvPik7XG4gICAgc2V0SW50ZXJuYWxMYWJlbChcIkNvcGllZCFcIik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRMb2dvKDxDb3B5SWNvbiBjbGFzc05hbWU9e2NuKFwiaC0zIHctM1wiLCBsb2dvQ2xhc3NOYW1lKX0gLz4pO1xuICAgICAgc2V0SW50ZXJuYWxMYWJlbChsYWJlbCk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgYXJpYS1sYWJlbD1cIkNvcHkgdG8gY2xpcGJvYXJkXCJcbiAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICAgIFwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkIGRpc2FibGVkOnRleHQtbm9pci00MDAgZGFyazp0ZXh0LW5vaXItMTAwIGRhcms6ZGlzYWJsZWQ6dGV4dC16aW5jLTYwMFwiLFxuICAgICAgICBidXR0b25DbGFzc05hbWUsXG4gICAgICApfVxuICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dFRvQ29weSgpO1xuICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcbiAgICAgICAgb25DbGlwYm9hcmRDb3B5KCk7XG4gICAgICB9fVxuICAgID5cbiAgICAgIHtsb2dvfVxuICAgICAge2ludGVybmFsTGFiZWx9XG4gICAgPC9idXR0b24+XG4gICk7XG59O1xuIiwiaW1wb3J0IHtcbiAgYmFzZUluU2VsZWN0aW9uLFxuICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcCxcbn0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgQW5ub3RhdGVkQmFzZSxcbiAgQW5ub3RhdGlvbixcbiAgQXJpYWRuZVNlbGVjdGlvbixcbiAgU3RhY2tlZEFubm90YXRpb24sXG59IGZyb20gXCIuLi90eXBlc1wiO1xuXG5pbXBvcnQge1xuICBTZWxlY3QsXG4gIFNlbGVjdENvbnRlbnQsXG4gIFNlbGVjdEl0ZW0sXG4gIFNlbGVjdFZhbHVlLFxuICBTZWxlY3RUcmlnZ2VyLFxufSBmcm9tIFwiQHVpL3NlbGVjdFwiO1xuaW1wb3J0IHsgQ29weUJ1dHRvbiB9IGZyb20gXCJAdWkvY29weS1idXR0b25cIjtcblxuZXhwb3J0IGNvbnN0IFNlcXVlbmNlVmlld2VyID0gKHtcbiAgc2VxdWVuY2VzLFxuICBhbm5vdGF0aW9ucyxcbiAgc2VsZWN0aW9uLFxuICBzZXRTZWxlY3Rpb24sXG4gIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgY2hhckNsYXNzTmFtZSxcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxuICBoaWRlTWV0YWRhdGFCYXIsXG4gIG5vVmFsaWRhdGUsXG59OiB7XG4gIHNlcXVlbmNlczogc3RyaW5nW107XG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW107XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIGNvbnRhaW5lckNsYXNzTmFtZT86IHN0cmluZztcbiAgY2hhckNsYXNzTmFtZTogKHtcbiAgICBiYXNlLFxuICAgIHNlcXVlbmNlSWR4LFxuICB9OiB7XG4gICAgYmFzZTogQW5ub3RhdGVkQmFzZTtcbiAgICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICB9KSA9PiBzdHJpbmc7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IHN0cmluZztcbiAgaGlkZU1ldGFkYXRhQmFyPzogYm9vbGVhbjtcbiAgbm9WYWxpZGF0ZT86IGJvb2xlYW47XG59KSA9PiB7XG4gIGNvbnN0IFtob3ZlcmVkUG9zaXRpb24sIHNldEhvdmVyZWRQb3NpdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3NlcUlkeFRvQ29weSwgc2V0U2VxSWR4VG9Db3B5XSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFthY3RpdmVBbm5vdGF0aW9uLCBzZXRBY3RpdmVBbm5vdGF0aW9uXSA9IHVzZVN0YXRlPEFubm90YXRpb24gfCBudWxsPihcbiAgICBudWxsLFxuICApO1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSB1c2VNZW1vKFxuICAgIGZ1bmN0aW9uIG1lbW9pemUoKSB7XG4gICAgICByZXR1cm4gc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcChcbiAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgIE1hdGgubWF4KC4uLnNlcXVlbmNlcy5tYXAoKHNlcSkgPT4gc2VxLmxlbmd0aCkpLFxuICAgICAgKTtcbiAgICB9LFxuICAgIFthbm5vdGF0aW9uc10sXG4gICk7XG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlcyA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZXMubWFwKChzZXF1ZW5jZSkgPT5cbiAgICAgICAgZ2V0QW5ub3RhdGVkU2VxdWVuY2UoeyBzZXF1ZW5jZSwgc3RhY2tlZEFubm90YXRpb25zLCBub1ZhbGlkYXRlIH0pLFxuICAgICAgKTtcbiAgICB9LFxuICAgIFtzZXF1ZW5jZXMsIHN0YWNrZWRBbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgbWVtb2l6ZWRTZXFDb250ZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxTZXFDb250ZW50XG4gICAgICAgIGFubm90YXRlZFNlcXVlbmNlcz17YW5ub3RhdGVkU2VxdWVuY2VzfVxuICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgc2V0U2VsZWN0aW9uPXtzZXRTZWxlY3Rpb259XG4gICAgICAgIHNldEhvdmVyZWRQb3NpdGlvbj17c2V0SG92ZXJlZFBvc2l0aW9ufVxuICAgICAgICBzZXRBY3RpdmVBbm5vdGF0aW9uPXtzZXRBY3RpdmVBbm5vdGF0aW9ufVxuICAgICAgICBzdGFja2VkQW5ub3RhdGlvbnM9e3N0YWNrZWRBbm5vdGF0aW9uc31cbiAgICAgICAgY2hhckNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZX1cbiAgICAgICAgc2VsZWN0aW9uQ2xhc3NOYW1lPXtzZWxlY3Rpb25DbGFzc05hbWV9XG4gICAgICAvPlxuICAgICk7XG4gIH0sIFthbm5vdGF0ZWRTZXF1ZW5jZXMsIHNlbGVjdGlvbiwgc3RhY2tlZEFubm90YXRpb25zXSk7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwicmVsYXRpdmUgaXNvbGF0ZSBmbGV4IGZsZXgtd3JhcFwiLFxuICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgICAgKX1cbiAgICAgID5cbiAgICAgICAgICA8U2VxTWV0YWRhdGFCYXJcbiAgICAgICAgICAgIGhvdmVyZWRQb3NpdGlvbj17aG92ZXJlZFBvc2l0aW9ufVxuICAgICAgICAgICAgYWN0aXZlQW5ub3RhdGlvbj17YWN0aXZlQW5ub3RhdGlvbn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcInN0aWNreSBpbnNldC14LTAgdG9wLTAgei1bM10gdy1mdWxsIHB4LTIgcHktMSBiYWNrZHJvcC1ibHVyLW1kXCIsIGhpZGVNZXRhZGF0YUJhciA/ICdoaWRkZW4nIDogJycpfVxuICAgICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2VzPXthbm5vdGF0ZWRTZXF1ZW5jZXN9XG4gICAgICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjaGFyQ2xhc3NOYW1lfVxuICAgICAgICAgICAgc2VxSWR4VG9Db3B5PXtzZXFJZHhUb0NvcHl9XG4gICAgICAgICAgICBzZXRTZXFJZHhUb0NvcHk9e3NldFNlcUlkeFRvQ29weX1cbiAgICAgICAgICAgIHNlbGVjdGlvbj17c2VsZWN0aW9ufVxuICAgICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXdyYXAgcHgtMlwiPnttZW1vaXplZFNlcUNvbnRlbnR9PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn07XG5leHBvcnQgY29uc3QgU2VxQ29udGVudCA9ICh7XG4gIGFubm90YXRlZFNlcXVlbmNlcyxcbiAgc2VsZWN0aW9uLFxuICBzZXRTZWxlY3Rpb24sXG4gIHNldEhvdmVyZWRQb3NpdGlvbixcbiAgc2V0QWN0aXZlQW5ub3RhdGlvbixcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBjaGFyQ2xhc3NOYW1lLFxuICBzZWxlY3Rpb25DbGFzc05hbWUsXG59OiB7XG4gIGFubm90YXRlZFNlcXVlbmNlczogQW5ub3RhdGVkQmFzZVtdW107XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEhvdmVyZWRQb3NpdGlvbjogKHBvc2l0aW9uOiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRBY3RpdmVBbm5vdGF0aW9uOiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogU3RhY2tlZEFubm90YXRpb25bXTtcbiAgY2hhckNsYXNzTmFtZTogKHtcbiAgICBiYXNlLFxuICAgIHNlcXVlbmNlSWR4LFxuICB9OiB7XG4gICAgYmFzZTogQW5ub3RhdGVkQmFzZTtcbiAgICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICB9KSA9PiBzdHJpbmc7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3QgbW91c2VEb3duID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaW5kaWNlc0NsYXNzTmFtZSA9ICh7XG4gICAgYmFzZSxcbiAgICBzZXF1ZW5jZUlkeCxcbiAgfToge1xuICAgIGJhc2U6IEFubm90YXRlZEJhc2U7XG4gICAgc2VxdWVuY2VJZHg6IG51bWJlcjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGlzTm90Rmlyc3RTZXEgPSBzZXF1ZW5jZUlkeCAhPT0gMDtcbiAgICBjb25zdCBpc05vdE11bHRpcGxlT2ZUZW4gPSBiYXNlLmluZGV4ICUgMTAgIT09IDA7XG5cbiAgICBpZiAoaXNOb3RGaXJzdFNlcSB8fCBpc05vdE11bHRpcGxlT2ZUZW4pIHtcbiAgICAgIHJldHVybiBcIm9wYWNpdHktMFwiO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcyhcbiAgICAgIFwidGV4dC14cyB6LTFcIixcbiAgICAgIC8vIGRvbid0IGFsbG93IHNlbGVjdGlvbiBvZiBpbmRpY2VzXG4gICAgICBcImRhcms6Z3JvdXAtaG92ZXI6dGV4dC1ub2lyLTMwMCBncm91cC1ob3Zlcjp0ZXh0LW5vaXItODAwXCIsXG4gICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICBiYXNlSW5kZXg6IGJhc2UuaW5kZXgsXG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgc2VxdWVuY2VMZW5ndGg6IGFubm90YXRlZFNlcXVlbmNlc1tzZXF1ZW5jZUlkeF0ubGVuZ3RoLFxuICAgICAgfSlcbiAgICAgICAgPyBcInRleHQtYnJhbmQtNzAwIGRhcms6dGV4dC1icmFuZC0zMDBcIlxuICAgICAgICA6IFwidGV4dC1ub2lyLTQwMCBkYXJrOnRleHQtbm9pci02MDBcIixcbiAgICApO1xuICB9O1xuICBjb25zdCBoYW5kbGVNb3VzZVVwID0gKCkgPT4ge1xuICAgIG1vdXNlRG93bi5jdXJyZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIGFkZE1vdXNlVXBMaXN0ZW5lcigpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAoKSA9PiB7XG4gICAgICBoYW5kbGVNb3VzZVVwKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZU1vdXNlVXBMaXN0ZW5lcigpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgICAgaGFuZGxlTW91c2VVcCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXNbMF0ubWFwKCh7IGluZGV4OiBiYXNlSWR4IH0pID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgIFwicmVsYXRpdmUgbXQtNCBmbGV4IGZsZXgtY29sIGp1c3RpZnktYmV0d2VlblwiLFxuICAgICAgICAgICAgICBcImdyb3VwIGhvdmVyOmJnLW5vaXItMjAwIGRhcms6aG92ZXI6Ymctbm9pci02MDBcIixcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBrZXk9e2BiYXNlLSR7YmFzZUlkeH1gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKFxuICAgICAgICAgICAgICAoc2VxdWVuY2U6IEFubm90YXRlZEJhc2VbXSwgc2VxdWVuY2VJZHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gc2VxdWVuY2UuZmluZChcbiAgICAgICAgICAgICAgICAgIChiYXNlOiBBbm5vdGF0ZWRCYXNlKSA9PiBiYXNlLmluZGV4ID09PSBiYXNlSWR4LFxuICAgICAgICAgICAgICAgICkgfHwgeyBiYXNlOiBcIiBcIiwgYW5ub3RhdGlvbnM6IFtdLCBpbmRleDogYmFzZUlkeCB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAga2V5PXtgc2VxdWVuY2UtJHtzZXF1ZW5jZUlkeH0tYmFzZS0ke2Jhc2VJZHh9YH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwid2hpdGVzcGFjZS1wcmUgdGV4dC1jZW50ZXJcIil9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHNldEhvdmVyZWRQb3NpdGlvbihiYXNlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBtb3VzZSBpcyBkb3duLCB1cGRhdGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlRG93bi5jdXJyZW50ICYmIHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGJhc2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0SG92ZXJlZFBvc2l0aW9uKG51bGwpfVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGJhc2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGJhc2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZm9yd2FyZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2hhbmRsZU1vdXNlVXB9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxDaGFyQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgY2hhcj17YHwgJHtiYXNlLmluZGV4fWB9XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXg9e2Jhc2VJZHh9XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWJzb2x1dGUgLXRvcC00IGxlZnQtMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJncm91cC1ob3Zlcjp0ZXh0LWJyYW5kLTIwMCBib3JkZXItYiBib3JkZXItbm9pci02MDAgZ3JvdXAtaG92ZXI6Ym9yZGVyLW5vaXItMzAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8Q2hhckNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgIGNoYXI9e2Jhc2UuYmFzZX1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRleD17YmFzZUlkeH1cbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlSW5kZXg6IGJhc2VJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VMZW5ndGg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2VzW3NlcXVlbmNlSWR4XS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlLmJhc2UgIT09IFwiIFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8U2VxdWVuY2VBbm5vdGF0aW9uXG4gICAgICAgICAgICAgIGFubm90YXRpb25zPXtzdGFja2VkQW5ub3RhdGlvbnN9XG4gICAgICAgICAgICAgIGluZGV4PXtiYXNlSWR4fVxuICAgICAgICAgICAgICBtYXhBbm5vdGF0aW9uU3RhY2s9e01hdGgubWF4KFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoLi4uc3RhY2tlZEFubm90YXRpb25zLm1hcCgoYW5uKSA9PiBhbm4uc3RhY2spKSxcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgc2V0SG92ZXJlZFBvc2l0aW9uPXtzZXRIb3ZlcmVkUG9zaXRpb259XG4gICAgICAgICAgICAgIHNldEFjdGl2ZUFubm90YXRpb249e3NldEFjdGl2ZUFubm90YXRpb259XG4gICAgICAgICAgICAgIG1heFNlcXVlbmNlTGVuZ3RoPXtNYXRoLm1heChcbiAgICAgICAgICAgICAgICAuLi5hbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKChzZXEpID0+IHNlcS5sZW5ndGgpLFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNlcU1ldGFkYXRhQmFyID0gKHtcbiAgaG92ZXJlZFBvc2l0aW9uLFxuICBhY3RpdmVBbm5vdGF0aW9uLFxuICBhbm5vdGF0ZWRTZXF1ZW5jZXMsXG4gIGNoYXJDbGFzc05hbWUsXG4gIHNlcUlkeFRvQ29weSxcbiAgc2V0U2VxSWR4VG9Db3B5LFxuICBzZWxlY3Rpb24sXG4gIGNsYXNzTmFtZSxcbn06IHtcbiAgaG92ZXJlZFBvc2l0aW9uOiBudW1iZXIgfCBudWxsO1xuICBhY3RpdmVBbm5vdGF0aW9uOiBBbm5vdGF0aW9uIHwgbnVsbDtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgYW5ub3RhdGVkU2VxdWVuY2VzOiBBbm5vdGF0ZWRCYXNlW11bXTtcbiAgc2VxSWR4VG9Db3B5OiBudW1iZXI7XG4gIHNldFNlcUlkeFRvQ29weTogKGlkeDogbnVtYmVyKSA9PiB2b2lkO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBhbm5vdGF0aW9uRGlzcGxheSA9IGFjdGl2ZUFubm90YXRpb24gPyAoXG4gICAgPHNwYW5cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgXCJmbGV4IGdhcC0yIHJvdW5kZWQtZnVsbCBweC0yIHB5LXB4IHRleHQteHMgIW9wYWNpdHktMTAwXCIsXG4gICAgICAgIFwibWwtYXV0b1wiLFxuICAgICAgICBhY3RpdmVBbm5vdGF0aW9uLmNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgPlxuICAgICAgPHNwYW4+TGFiZWw6IHthY3RpdmVBbm5vdGF0aW9uLnRleHR9PC9zcGFuPlxuICAgICAgPHNwYW4+VHlwZToge2FjdGl2ZUFubm90YXRpb24udHlwZX08L3NwYW4+XG4gICAgICA8c3Bhbj5EaXJlY3Rpb246IHthY3RpdmVBbm5vdGF0aW9uLmRpcmVjdGlvbn08L3NwYW4+XG4gICAgICA8c3Bhbj5cbiAgICAgICAgZnJvbSB7YWN0aXZlQW5ub3RhdGlvbi5zdGFydH0gLSB7YWN0aXZlQW5ub3RhdGlvbi5lbmR9XG4gICAgICA8L3NwYW4+XG4gICAgPC9zcGFuPlxuICApIDogbnVsbDtcbiAgY29uc3QgcG9zaXRpb25EaXNwbGF5ID0gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT1cIm1pbi13LTE2IHRleHQteHMgdGV4dC1ibGFjayBkYXJrOnRleHQtd2hpdGVcIj5cbiAgICAgIFBvczoge2hvdmVyZWRQb3NpdGlvbiA/PyAwfVxuICAgIDwvc3Bhbj5cbiAgKTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgIFwiZmxleCBoLTggaXRlbXMtY2VudGVyIGdhcC0xIHB5LTEgdGV4dC14c1wiLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICApfVxuICAgID5cbiAgICAgIHtwb3NpdGlvbkRpc3BsYXl9XG4gICAgICA8Q29weURpc3BsYXlcbiAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2VzPXthbm5vdGF0ZWRTZXF1ZW5jZXN9XG4gICAgICAgIGNoYXJDbGFzc05hbWU9e2NoYXJDbGFzc05hbWV9XG4gICAgICAgIHNlcUlkeFRvQ29weT17c2VxSWR4VG9Db3B5fVxuICAgICAgICBzZXRTZXFJZHhUb0NvcHk9e3NldFNlcUlkeFRvQ29weX1cbiAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAvPlxuICAgICAge2Fubm90YXRpb25EaXNwbGF5fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNlcXVlbmNlQW5ub3RhdGlvbiA9ICh7XG4gIGFubm90YXRpb25zLFxuICBtYXhBbm5vdGF0aW9uU3RhY2ssXG4gIGluZGV4LFxuICBzZXRIb3ZlcmVkUG9zaXRpb24sXG4gIHNldEFjdGl2ZUFubm90YXRpb24sXG4gIG1heFNlcXVlbmNlTGVuZ3RoLFxufToge1xuICBhbm5vdGF0aW9uczogU3RhY2tlZEFubm90YXRpb25bXTtcbiAgbWF4QW5ub3RhdGlvblN0YWNrOiBudW1iZXI7XG4gIHNldEhvdmVyZWRQb3NpdGlvbjogKHBvc2l0aW9uOiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRBY3RpdmVBbm5vdGF0aW9uOiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIG1heFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIGluZGV4OiBudW1iZXI7XG59KSA9PiB7XG4gIGNvbnN0IG9yZGVyZWRBbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLnNvcnQoKGEsIGIpID0+IGEuc3RhY2sgLSBiLnN0YWNrKTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9XCIgXCJcbiAgICAgIGtleT17YGFubm90YXRpb24tJHtpbmRleH1gfVxuICAgICAgb25Nb3VzZUVudGVyPXsoKSA9PiBzZXRIb3ZlcmVkUG9zaXRpb24oaW5kZXgpfVxuICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRIb3ZlcmVkUG9zaXRpb24obnVsbCl9XG4gICAgPlxuICAgICAge1suLi5BcnJheShtYXhBbm5vdGF0aW9uU3RhY2spLmtleXMoKV0ubWFwKChpKSA9PiB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb24gPSBvcmRlcmVkQW5ub3RhdGlvbnNcbiAgICAgICAgICAuZmlsdGVyKChhbm4pID0+XG4gICAgICAgICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICAgICAgICBiYXNlSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICBzZWxlY3Rpb246IGFubixcbiAgICAgICAgICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKVxuICAgICAgICAgIC5maW5kKChhbm4pID0+IGFubi5zdGFjayA9PT0gaSk7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgICAgICAgIGJhc2VJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogYW5ub3RhdGlvbixcbiAgICAgICAgICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBrZXk9e2Bhbm5vdGF0aW9uLSR7aW5kZXh9LSR7aX1gfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XCJoLTMgYm9yZGVyLWItMiBib3JkZXItbm9pci0xMDAgb3BhY2l0eS0xMCBcIn1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAga2V5PXtgYW5ub3RhdGlvbi0ke2luZGV4fS0ke2l9YH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgIFwiZ3JvdXAvYW5ub3RhdGlvbiBoLTMgYm9yZGVyLWJsYWNrIGdyb3VwLWhvdmVyL2Fubm90YXRpb246Ym9yZGVyXCIsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5vbkNsaWNrPy4oe1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IGFubm90YXRpb24uc3RhcnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IGFubm90YXRpb24uZW5kLFxuICAgICAgICAgICAgICAgICAgZGllY3Rpb246IGFubm90YXRpb24uZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoKSA9PiBzZXRBY3RpdmVBbm5vdGF0aW9uKGFubm90YXRpb24pfVxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHNldEFjdGl2ZUFubm90YXRpb24obnVsbCl9XG4gICAgICAgICAgICA+PC9kaXY+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e2BwbGFjZWhvbGRlci0ke2luZGV4fS0ke2l9YH0gY2xhc3NOYW1lPXtcImgtM1wifSAvPjtcbiAgICAgICAgfVxuICAgICAgfSl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5pbnRlcmZhY2UgQ2hhclByb3BzIHtcbiAgY2hhcjogc3RyaW5nO1xuICBpbmRleDogbnVtYmVyO1xuICBjaGFyQ2xhc3NOYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBDaGFyQ29tcG9uZW50ID0gKHsgY2hhciwgY2hhckNsYXNzTmFtZSB9OiBDaGFyUHJvcHMpID0+IHtcbiAgLy8gZG9uJ3QgYWxsb3cgc2VsZWN0aW9uIG9mIGNoYXJzXG4gIGNvbnN0IHNoYXJlZENsYXNzTmFtZSA9IFwiZm9udC1tb25vIHNlbGVjdC1ub25lXCI7XG4gIGlmIChjaGFyID09PSBcIiBcIikge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhzaGFyZWRDbGFzc05hbWUsIGNoYXJDbGFzc05hbWUsIFwib3BhY2l0eS0yMFwiKX0+XG4gICAgICAgIC5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhzaGFyZWRDbGFzc05hbWUsIGNoYXJDbGFzc05hbWUsIFwibXItcHhcIil9PlxuICAgICAge2NoYXJ9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ29weURpc3BsYXkgPSAoe1xuICBzZXFJZHhUb0NvcHksXG4gIHNldFNlcUlkeFRvQ29weSxcbiAgYW5ub3RhdGVkU2VxdWVuY2VzLFxuICBjaGFyQ2xhc3NOYW1lLFxuICBzZWxlY3Rpb24sXG59OiB7XG4gIHNlcUlkeFRvQ29weTogbnVtYmVyO1xuICBzZXRTZXFJZHhUb0NvcHk6IChpZHg6IG51bWJlcikgPT4gdm9pZDtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgYW5ub3RhdGVkU2VxdWVuY2VzOiBBbm5vdGF0ZWRCYXNlW11bXTtcbiAgY2hhckNsYXNzTmFtZTogKHtcbiAgICBiYXNlLFxuICAgIHNlcXVlbmNlSWR4LFxuICB9OiB7XG4gICAgYmFzZTogQW5ub3RhdGVkQmFzZTtcbiAgICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICB9KSA9PiBzdHJpbmc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3QgZ2V0U3RyaW5nVG9Db3B5ID0gKCkgPT4ge1xuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlcSA9IGFubm90YXRlZFNlcXVlbmNlc1tzZXFJZHhUb0NvcHldO1xuICAgIGNvbnN0IHN0cmluZ1RvQ29weSA9IHNlcVxuICAgICAgLmZpbHRlcigoYmFzZSkgPT5cbiAgICAgICAgYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgICAgICBiYXNlSW5kZXg6IGJhc2UuaW5kZXgsXG4gICAgICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24sXG4gICAgICAgICAgc2VxdWVuY2VMZW5ndGg6IGFubm90YXRlZFNlcXVlbmNlc1tzZXFJZHhUb0NvcHldLmxlbmd0aCxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgICAubWFwKChiYXNlKSA9PiBiYXNlLmJhc2UpXG4gICAgICAuam9pbihcIlwiKTtcbiAgICByZXR1cm4gc3RyaW5nVG9Db3B5O1xuICB9O1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gbW91bnRDb3B5SGFuZGxlcigpIHtcbiAgICBjb25zdCBjb3B5SGFuZGxlciA9IChlOiBDbGlwYm9hcmRFdmVudCkgPT4ge1xuICAgICAgY29uc3Qgc3RyaW5nVG9Db3B5ID0gZ2V0U3RyaW5nVG9Db3B5KCk7XG4gICAgICBpZiAoIXN0cmluZ1RvQ29weSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLmNsaXBib2FyZERhdGE/LnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHN0cmluZ1RvQ29weSk7XG4gICAgICBhbGVydChcIkNvcGllZCB0byBjbGlwYm9hcmQhXCIpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgY29weUhhbmRsZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50Q29weUhhbmRsZXIoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29weVwiLCBjb3B5SGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZmxleFwiPlxuICAgICAgPFNlbGVjdFxuICAgICAgICB2YWx1ZT17c2VxSWR4VG9Db3B5LnRvU3RyaW5nKCl9XG4gICAgICAgIG9uVmFsdWVDaGFuZ2U9eyh2YWx1ZSkgPT4gc2V0U2VxSWR4VG9Db3B5KHBhcnNlSW50KHZhbHVlKSl9XG4gICAgICA+XG4gICAgICAgIDxTZWxlY3RUcmlnZ2VyIGNsYXNzTmFtZT1cInctZml0XCI+XG4gICAgICAgICAgPFNlbGVjdFZhbHVlXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NoYXJDbGFzc05hbWUoe1xuICAgICAgICAgICAgICBiYXNlOiB7IGJhc2U6IFwiQVwiLCBhbm5vdGF0aW9uczogW10sIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgIHNlcXVlbmNlSWR4OiBzZXFJZHhUb0NvcHksXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBTZXF1ZW5jZSB7c2VxSWR4VG9Db3B5ICsgMX1cbiAgICAgICAgICA8L1NlbGVjdFZhbHVlPlxuICAgICAgICA8L1NlbGVjdFRyaWdnZXI+XG4gICAgICAgIDxTZWxlY3RDb250ZW50IGNsYXNzTmFtZT1cImJnLXdoaXRlIGRhcms6YmctYmxhY2tcIj5cbiAgICAgICAgICB7YW5ub3RhdGVkU2VxdWVuY2VzLm1hcCgoXywgaWR4KSA9PiAoXG4gICAgICAgICAgICA8U2VsZWN0SXRlbVxuICAgICAgICAgICAgICBrZXk9e2BzZXF1ZW5jZS0ke2lkeH1gfVxuICAgICAgICAgICAgICB2YWx1ZT17aWR4LnRvU3RyaW5nKCl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgICAgYmFzZTogeyBiYXNlOiBcIkFcIiwgYW5ub3RhdGlvbnM6IFtdLCBpbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlSWR4OiBpZHgsXG4gICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBTZXF1ZW5jZSB7aWR4ICsgMX17XCIgXCJ9XG4gICAgICAgICAgICA8L1NlbGVjdEl0ZW0+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvU2VsZWN0Q29udGVudD5cbiAgICAgIDwvU2VsZWN0PlxuICAgICAgPENvcHlCdXR0b25cbiAgICAgICAgdGV4dFRvQ29weT17KCkgPT4gZ2V0U3RyaW5nVG9Db3B5KCkgPz8gXCJcIn1cbiAgICAgICAgbGFiZWw9e1wiXCJ9XG4gICAgICAgIGRpc2FibGVkPXshc2VsZWN0aW9ufVxuICAgICAgLz5cbiAgICA8L3NwYW4+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgQW5ub3RhdGVkQmFzZSwgQW5ub3RhdGVkU2VxdWVuY2UgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBSZWZlcmVuY2VUaWNrcyA9ICh7XG4gIHNlcXVlbmNlLFxuICBjbGFzc05hbWUsXG59OiB7XG4gIHNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwib3ZlcmZsb3ctaGlkZGVudGV4dC13aGl0ZSBmbGV4XCIsIGNsYXNzTmFtZSl9PlxuICAgICAge3NlcXVlbmNlLm1hcCgobnVjbDogQW5ub3RhdGVkQmFzZSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNob3dUaWNrcyA9IG51Y2wuYmFzZSAhPT0gXCItXCIgJiYgKG51Y2wuaW5kZXggKyAxKSAlIDEwID09PSAwOyAvLyB3ZSBkb24ndCB3YW50IHRvIHNob3cgdGlja3MgZm9yIGdhcHNcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZSBmbGV4IGgtMTIgZmxleC1jb2wgaXRlbXMtZW5kIGp1c3RpZnktZW5kXCJcbiAgICAgICAgICAgIGtleT17YGJhc2UtJHtpfS1pbmRleC13cmFwcGVyYH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICBcImZvbnQtbW9ubyBcIixcbiAgICAgICAgICAgICAgICBcImFic29sdXRlIGJvdHRvbS0wIGxlZnQtMCByaWdodC0wXCIsXG5cbiAgICAgICAgICAgICAgICBzaG93VGlja3MgPyBcIm9wYWNpdHktMTAwXCIgOiBcIm9wYWNpdHktMFwiLFxuICAgICAgICAgICAgICAgIG51Y2wuYmFzZSA9PT0gXCJHXCIgJiYgXCJ0ZXh0LXJlZC01MDBcIixcbiAgICAgICAgICAgICAgICBudWNsLmJhc2UgPT09IFwiQVwiICYmIFwidGV4dC15ZWxsb3ctNTAwXCIsXG4gICAgICAgICAgICAgICAgbnVjbC5iYXNlID09PSBcIlRcIiAmJiBcInRleHQtZ3JlZW4tNTAwXCIsXG4gICAgICAgICAgICAgICAgbnVjbC5iYXNlID09PSBcIkNcIiAmJiBcInRleHQtYmx1ZS01MDBcIixcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14c1wiPiB7bnVjbC5pbmRleCArIDF9PC9wPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJteC1hdXRvIHRleHQteHNcIj58PC9wPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibXItcHggZm9udC1tb25vIG9wYWNpdHktMFwiKX0+XG4gICAgICAgICAgICAgIHtudWNsLmJhc2V9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvZGl2PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlJCQwIiwiUmVhY3QiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic2VsZiIsImpzeFJ1bnRpbWVNb2R1bGUiLCJyZXF1aXJlJCQxIiwib2Zmc2V0IiwiaW5kZXgiLCJzaXplIiwidXRpbCIsIm9iamVjdFV0aWwiLCJlcnJvclV0aWwiLCJlcnJvck1hcCIsImN0eCIsIm9wdGlvbnMiLCJtaW4iLCJtYXgiLCJyZXN1bHQiLCJpc3N1ZXMiLCJlbGVtZW50cyIsInByb2Nlc3NlZCIsInIiLCJfYSIsIl9iIiwiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsImpzeCIsImpzeHMiLCJGcmFnbWVudCIsInVzZU1lbW8iLCJzdGFydCIsImVuZCIsIm1pc21hdGNoQ2xhc3NOYW1lIiwiY2xhbXAiLCJGcmFnbWVudDIiLCJjcmVhdGVDb2xsZWN0aW9uU2NvcGUiLCJ1c2VDb2xsZWN0aW9uIiwiTm9kZSIsIlJlYWN0RE9NIiwidXNlQ2FsbGJhY2tSZWYiLCJjb3VudCIsInVzZUxheW91dEVmZmVjdCIsImNvbXB1dGVQb3NpdGlvbiIsInBsYXRmb3JtIiwiYXJyb3ciLCJmbGlwIiwic2lkZXMiLCJzaWRlIiwicGxhY2VtZW50Iiwib3ZlcmZsb3ciLCJoaWRlIiwic2hpZnQiLCJ4IiwieSIsImxpbWl0U2hpZnQiLCJnZXRDb21wdXRlZFN0eWxlIiwib2Zmc2V0JDEiLCJzaGlmdCQxIiwiZmxpcCQxIiwic2l6ZSQxIiwiaGlkZSQxIiwiYXJyb3ckMSIsImxpbWl0U2hpZnQkMSIsImRhdGEiLCJOQU1FIiwiQXJyb3ciLCJDT05URU5UX05BTUUiLCJmbG9hdGluZ1VJYXJyb3ciLCJBUlJPV19OQU1FIiwiQXJyb3dQcmltaXRpdmUuUm9vdCIsIlJvb3QyIiwiUE9SVEFMX05BTUUiLCJQb3J0YWwiLCJfX2Fzc2lnbiIsImNicyIsIlNpZGVDYXIiLCJTdHlsZSIsIlNlbGVjdCIsIlBvcHBlclByaW1pdGl2ZS5Sb290IiwiU2VsZWN0VHJpZ2dlciIsIlBvcHBlclByaW1pdGl2ZS5BbmNob3IiLCJTZWxlY3RWYWx1ZSIsIlBvcnRhbFByaW1pdGl2ZSIsIlNlbGVjdENvbnRlbnQiLCJmb2N1c0ZpcnN0IiwiUmVtb3ZlU2Nyb2xsIiwiUG9wcGVyUHJpbWl0aXZlLkNvbnRlbnQiLCJTZWxlY3RMYWJlbCIsIlNlbGVjdEl0ZW0iLCJTZWxlY3RTY3JvbGxVcEJ1dHRvbiIsIlNlbGVjdFNjcm9sbERvd25CdXR0b24iLCJTZWxlY3RTZXBhcmF0b3IiLCJQb3BwZXJQcmltaXRpdmUuQXJyb3ciLCJJY29uIiwiZm9yd2FyZFJlZiIsImNyZWF0ZUVsZW1lbnQiLCJTZWxlY3RQcmltaXRpdmUuUm9vdCIsIlNlbGVjdFByaW1pdGl2ZS5WYWx1ZSIsIlNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyIiwiU2VsZWN0UHJpbWl0aXZlLkljb24iLCJTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24iLCJTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbiIsIlNlbGVjdFByaW1pdGl2ZS5Qb3J0YWwiLCJTZWxlY3RQcmltaXRpdmUuQ29udGVudCIsIlNlbGVjdFByaW1pdGl2ZS5WaWV3cG9ydCIsIlNlbGVjdFByaW1pdGl2ZS5MYWJlbCIsIlNlbGVjdFByaW1pdGl2ZS5JdGVtIiwiU2VsZWN0UHJpbWl0aXZlLkl0ZW1JbmRpY2F0b3IiLCJTZWxlY3RQcmltaXRpdmUuSXRlbVRleHQiLCJTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yIiwiQ29weUljb24iLCJDaGVja0ljb24iLCJiYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNh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QUFDVixhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLElBQ2xFO0FBQUEsSUFDSSxJQUFJLFNBQVM7QUFDVCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLElBQ2pFO0FBQUEsSUFDSSxJQUFJLFdBQVc7QUFDWCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsUUFBUTtBQUFBLElBQ25FO0FBQUEsSUFDSSxJQUFJLFNBQVM7QUFDVCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLElBQ2pFO0FBQUEsSUFDSSxJQUFJLFVBQVU7QUFDVixhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLElBQ2xFO0FBQUEsSUFDSSxJQUFJLFNBQVM7QUFDVCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLElBQ2pFO0FBQUEsSUFDSSxJQUFJLE9BQU87QUFDUCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsSUFBSTtBQUFBLElBQy9EO0FBQUEsSUFDSSxJQUFJLFNBQVM7QUFDVCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLElBQ2pFO0FBQUEsSUFDSSxJQUFJLFdBQVc7QUFDWCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsUUFBUTtBQUFBLElBQ25FO0FBQUEsSUFDSSxJQUFJLGNBQWM7QUFFZCxhQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxL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U0FBUyxPQUFPO0FBQUEsa0JBQ3JCLEtBQUssU0FBUyxPQUFPO0FBQUEsZ0JBQ3ZCO0FBQUEsZ0JBRUEsVUFBQTtBQUFBLGtCQUFDQSxrQ0FBQUEsS0FBQSxLQUFBLEVBQUUsV0FBVSxXQUFVLFVBQUE7QUFBQSxvQkFBQTtBQUFBLG9CQUFFLEtBQUssUUFBUTtBQUFBLGtCQUFBLEdBQUU7QUFBQSxrQkFDdkNELGtDQUFBLElBQUEsS0FBQSxFQUFFLFdBQVUsbUJBQWtCLFVBQUMsSUFBQSxDQUFBO0FBQUEsZ0JBQUE7QUFBQSxjQUFBO0FBQUEsWUFDbEM7QUFBQSxrREFFQyxPQUFJLEVBQUEsV0FBVyxXQUFXLDJCQUEyQixHQUNuRCxlQUFLLEtBQ1IsQ0FBQTtBQUFBLFVBQUE7QUFBQSxRQUFBO0FBQUEsUUFwQkssUUFBUSxDQUFDO0FBQUEsTUFxQmhCO0FBQUEsSUFFSCxDQUFBLEdBQ0g7QUFBQSxFQUVKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyLDQsNSw2LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1XX0=
