import * as React from "react";
import React__default, { useRef, useState, useCallback, useEffect, Fragment, useMemo, useLayoutEffect, forwardRef, createElement } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default from "react-dom";
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = React__default;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self) ;
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
if (process.env.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
const genArc = ({
  center,
  innerRadius,
  largeArc,
  length,
  offset: offset2,
  outerRadius,
  seqLength
}) => {
  const leftBottom = findCoor({
    index: offset2,
    radius: innerRadius,
    center,
    seqLength
  });
  const leftTop = findCoor({
    index: offset2,
    radius: outerRadius,
    center,
    seqLength
  });
  const rightBottom = findCoor({
    index: length + offset2,
    radius: innerRadius,
    center,
    seqLength
  });
  const rightTop = findCoor({
    index: length + offset2,
    radius: outerRadius,
    center,
    seqLength
  });
  const sFlagF = 1;
  const sFlagR = 0;
  const lArc = largeArc ? 1 : 0;
  return `M ${rightBottom.x} ${rightBottom.y}
      A ${innerRadius} ${innerRadius}, 0, ${lArc}, ${sFlagR}, ${leftBottom.x} ${leftBottom.y}
      L ${leftBottom.x} ${leftBottom.y}
      L ${leftTop.x} ${leftTop.y}
      A ${outerRadius} ${outerRadius}, 0, ${lArc}, ${sFlagF}, ${rightTop.x} ${rightTop.y}
      Z`;
};
const findCoor = ({
  index: index2,
  radius,
  center,
  seqLength
}) => {
  const lengthPerc = index2 / seqLength;
  const lengthPercCentered = lengthPerc - 0.25;
  const radians = lengthPercCentered * Math.PI * 2;
  const xAdjust = Math.cos(radians) * radius;
  const yAdjust = Math.sin(radians) * radius;
  return {
    x: center.x + xAdjust,
    y: center.y + yAdjust
  };
};
const findAngleFromCoor = ({
  coor,
  center
}) => {
  const x = coor.x - center.x;
  const y = coor.y - center.y;
  let radians = Math.atan2(y, x);
  if (radians < 0) {
    radians = radians + Math.PI * 2;
  }
  return radians * (180 / Math.PI);
};
const findIndexFromAngle = ({
  angle,
  seqLength
}) => {
  let effectiveAngle = angle.degrees + 90;
  if (effectiveAngle < 0) {
    effectiveAngle = 360 + effectiveAngle;
  }
  effectiveAngle = effectiveAngle % 360;
  const arcPerc = effectiveAngle / 360;
  const rawBaseIdx = arcPerc * seqLength;
  return Math.round(rawBaseIdx < 0 ? seqLength + rawBaseIdx : rawBaseIdx);
};
const clampSlice = ({
  slice,
  firstIdx,
  lastIdx
}) => {
  if (!slice) {
    return null;
  }
  let { start, end } = slice;
  const outOfBoundsBefore = start < firstIdx && end < firstIdx;
  const outOfBoundsAfter = start > lastIdx && end > lastIdx;
  if (outOfBoundsBefore || outOfBoundsAfter) {
    return null;
  }
  if (start >= end) {
    start = Math.min(start, lastIdx);
    end = Math.max(end, firstIdx);
  } else {
    end = Math.min(end, lastIdx);
    start = Math.max(start, firstIdx);
  }
  return {
    start,
    end,
    direction: slice.direction
  };
};
var months = [
  "JAN",
  "FEB",
  "MAR",
  "APR",
  "MAY",
  "JUN",
  "JUL",
  "AUG",
  "SEP",
  "OCT",
  "NOV",
  "DEC"
];
const MONTHS = months;
function genbankToJson(sequence) {
  if (typeof sequence !== "string") {
    throw new TypeError("input must be a string");
  }
  let resultsArray = [];
  let result;
  let currentFeatureNote;
  let genbankAnnotationKey = {
    // Contains in order: locus name, sequence length, molecule type (e.g. DNA), genbank division (see 1-18 below), modification date
    // locus definition has changed with time, use accession number for a unique identifier
    LOCUS_TAG: "LOCUS",
    DEFINITION_TAG: "DEFINITION",
    // Accession tag
    // Example: Z78533
    ACCESSION_TAG: "ACCESSION",
    // The version tag contains 2 informations
    // The accession number with a revision
    // The GI (GenInfo Identifier), a ncbi sequential number
    // Example: Z78533.1  GI:2765658
    // Unicity garanteed with respect to sequence. If 1 nucleotide changes, the version is different.
    VERSION_TAG: "VERSION",
    KEYWORDS_TAG: "KEYWORDS",
    // SEGMENT_TAG:"SEGMENT"
    // Source is free text
    SOURCE_TAG: "SOURCE",
    ORGANISM_TAG: "ORGANISM",
    REFERENCE_TAG: "REFERENCE",
    FEATURES_TAG: "FEATURES",
    // CONTIG_TAG: "CONTIG"
    ORIGIN_TAG: "ORIGIN",
    END_SEQUENCE_TAG: "//"
  };
  let lines = sequence.split(/\r?\n/);
  let fieldName;
  let subFieldType;
  let featureLocationIndentation;
  let lastLineWasFeaturesTag;
  let lastLineWasLocation;
  let hasFoundLocus = false;
  for (let line of lines) {
    if (line === null) break;
    let lineFieldName = getLineFieldName(line);
    let val = getLineVal(line);
    let isSubKey = isSubKeyword(line);
    let isKey = isKeyword(line);
    if (lineFieldName === genbankAnnotationKey.END_SEQUENCE_TAG || isKey) {
      fieldName = lineFieldName;
      subFieldType = null;
    } else if (isSubKey) {
      subFieldType = lineFieldName;
    }
    if (line.trim() === "" || lineFieldName === ";") {
      continue;
    }
    if (!hasFoundLocus && fieldName !== genbankAnnotationKey.LOCUS_TAG) {
      break;
    }
    switch (fieldName) {
      case genbankAnnotationKey.LOCUS_TAG:
        hasFoundLocus = true;
        parseLocus(line);
        break;
      case genbankAnnotationKey.FEATURES_TAG:
        parseFeatures(line, lineFieldName, val);
        break;
      case genbankAnnotationKey.ORIGIN_TAG:
        parseOrigin(line, lineFieldName);
        break;
      case genbankAnnotationKey.DEFINITION_TAG:
      case genbankAnnotationKey.ACCESSION_TAG:
      case genbankAnnotationKey.VERSION_TAG:
      case genbankAnnotationKey.KEYWORDS_TAG:
        parseMultiLineField(fieldName, line, fieldName.toLowerCase());
        break;
      case genbankAnnotationKey.SOURCE_TAG:
        if (subFieldType === genbankAnnotationKey.ORGANISM_TAG) {
          parseMultiLineField(subFieldType, line, "organism");
        } else {
          parseMultiLineField(lineFieldName, line, "source");
        }
        break;
      case genbankAnnotationKey.REFERENCE_TAG:
        if (lineFieldName === genbankAnnotationKey.REFERENCE_TAG) {
          const ref = result.references || [];
          result.references = ref;
          ref.push({});
        }
        parseReference(line, subFieldType);
        break;
      case genbankAnnotationKey.END_SEQUENCE_TAG:
        endSeq();
        break;
    }
  }
  if (resultsArray[resultsArray.length - 1] !== result) {
    endSeq();
  }
  return resultsArray;
  function endSeq() {
    postProcessCurSeq();
    resultsArray.push(result);
  }
  function getCurrentFeature() {
    return result.features[result.features.length - 1];
  }
  function postProcessCurSeq() {
    if (result && result.features) {
      for (let i = 0; i < result.features.length; i++) {
        result.features[i] = postProcessGenbankFeature(result.features[i]);
      }
    }
  }
  function parseOrigin(line, key) {
    if (key !== genbankAnnotationKey.ORIGIN_TAG) {
      let newLine = line.replace(/[\s]*[0-9]*/g, "");
      result.sequence += newLine;
    }
  }
  function parseLocus(line) {
    result = {
      features: [],
      name: "Untitled sequence",
      sequence: "",
      references: []
    };
    line = removeFieldName(genbankAnnotationKey.LOCUS_TAG, line);
    const m = line.match(
      /^([^\s]+)\s+(\d+)\s+bp\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*([^\s]+)?$/
    );
    let locusName = m[1];
    let size2 = +m[2];
    let moleculeType = m[3];
    let circular = m[4] === "circular";
    const seq = result;
    let dateStr = "";
    if (!m[6]) {
      dateStr = m[5];
    } else {
      seq.genbankDivision = m[5];
      dateStr = m[6];
    }
    seq.circular = circular;
    seq.moleculeType = moleculeType;
    const dateMatch = dateStr.match(/^(\d{2})-(.{3})-(\d{4})$/);
    const date = /* @__PURE__ */ new Date();
    date.setFullYear(+dateMatch[3]);
    date.setUTCMonth(MONTHS.indexOf(dateMatch[2].toUpperCase()));
    date.setDate(+dateMatch[1]);
    date.setUTCHours(12);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    seq.date = date.toISOString();
    seq.name = locusName;
    seq.size = size2;
  }
  function removeFieldName(fName, line) {
    line = line.replace(/^\s*/, "");
    if (line.indexOf(fName) === 0) {
      line = line.replace(fName, "");
    }
    return line.trim();
  }
  function parseReference(line, subType) {
    const refs = result.references;
    let lastRef = refs[refs.length - 1];
    if (!subType) {
      parseMultiLineField(
        genbankAnnotationKey.REFERENCE_TAG,
        line,
        "description",
        lastRef
      );
    } else {
      parseMultiLineField(subType, line, subType.toLowerCase(), lastRef);
    }
  }
  function parseFeatures(line, key, val) {
    let strand;
    if (key === genbankAnnotationKey.FEATURES_TAG) {
      lastLineWasFeaturesTag = true;
      return;
    }
    if (lastLineWasFeaturesTag) {
      featureLocationIndentation = getLengthOfWhiteSpaceBeforeStartOfLetters(
        line
      );
      lastLineWasFeaturesTag = false;
    }
    if (isFeatureLineRunon(line, featureLocationIndentation)) {
      if (lastLineWasLocation) {
        parseFeatureLocation(line.trim());
        lastLineWasLocation = true;
      } else {
        if (currentFeatureNote) {
          currentFeatureNote[currentFeatureNote.length - 1] += line.trim().replace(/"/g, "");
        }
        lastLineWasLocation = false;
      }
    } else {
      if (isNote(line)) {
        if (getCurrentFeature()) {
          parseFeatureNote(line);
          lastLineWasLocation = false;
        }
      } else {
        if (val.match(/complement/g)) {
          strand = -1;
        } else {
          strand = 1;
        }
        newFeature();
        let feat = getCurrentFeature();
        feat.type = key;
        feat.strand = strand;
        parseFeatureLocation(val);
        lastLineWasLocation = true;
      }
    }
  }
  function newFeature() {
    result.features.push({
      notes: {}
    });
  }
  function isNote(line) {
    let qual = false;
    if (line.trim().charAt(0).match(/\//)) {
      qual = true;
    } else if (line.match(/^[\s]*\/[\w]+=[\S]+/)) {
      qual = true;
    }
    return qual;
  }
  function parseFeatureLocation(locStr) {
    locStr = locStr.trim();
    let locArr = [];
    locStr.replace(/(\d+)/g, function(string, match) {
      locArr.push(match);
    });
    let feat = getCurrentFeature();
    feat.start = +locArr[0];
    feat.end = locArr[1] === void 0 ? +locArr[0] : +locArr[1];
  }
  function parseFeatureNote(line) {
    let newLine, lineArr;
    newLine = line.trim();
    newLine = newLine.replace(/^\/|"$/g, "");
    lineArr = newLine.split(/="|=/);
    let val = lineArr[1];
    if (val) {
      val = val.replace(/\\/g, " ");
      if (line.match(/="/g)) {
        val = val.replace(/".*/g, "");
      } else if (val.match(/^\d+$/g)) {
        val = +val;
      }
    }
    let key = lineArr[0];
    let currentNotes = getCurrentFeature().notes;
    if (currentNotes[key]) {
      currentNotes[key].push(val);
    } else {
      currentNotes[key] = [val];
    }
    currentFeatureNote = currentNotes[key];
  }
  function getLineFieldName(line) {
    let arr;
    line = line.trim();
    arr = line.split(/[\s]+/);
    return arr[0];
  }
  function parseMultiLineField(fName, line, resultKey, r) {
    r = r || result;
    let fieldValue = removeFieldName(fName, line);
    r[resultKey] = r[resultKey] ? `${r[resultKey]} ` : "";
    r[resultKey] += fieldValue;
  }
  function getLineVal(line) {
    let arr;
    if (line.indexOf("=") < 0) {
      line = line.replace(/^[\s]*[\S]+[\s]+|[\s]+$/, "");
      line = line.trim();
      return line;
    } else {
      arr = line.split(/=/);
      return arr[1];
    }
  }
  function isKeyword(line) {
    let isKey = false;
    if (line.substr(0, 10).match(/^[\S]+/)) {
      isKey = true;
    }
    return isKey;
  }
  function isSubKeyword(line) {
    let isSubKey = false;
    if (line.substr(0, 10).match(/^[\s]+[\S]+/)) {
      isSubKey = true;
    }
    return isSubKey;
  }
  function postProcessGenbankFeature(feat) {
    if (feat.notes.label) {
      feat.name = feat.notes.label[0];
    } else if (feat.notes.gene) {
      feat.name = feat.notes.gene[0];
    } else if (feat.notes.ApEinfo_label) {
      feat.name = feat.notes.ApEinfo_label[0];
    } else if (feat.notes.name) {
      feat.name = feat.notes.name[0];
    } else if (feat.notes.organism) {
      feat.name = feat.notes.organism[0];
    } else if (feat.notes.locus_tag) {
      feat.name = feat.notes.locus_tag[0];
    } else if (feat.notes.note) {
      feat.name = feat.notes.note[0];
    } else {
      feat.name = "Untitled Feature";
    }
    feat.name = typeof feat.name === "string" ? feat.name : String(feat.name);
    return feat;
  }
}
function isFeatureLineRunon(line, featureLocationIndentation) {
  let indentationOfLine = getLengthOfWhiteSpaceBeforeStartOfLetters(line);
  if (featureLocationIndentation === indentationOfLine) {
    return false;
  }
  let trimmed = line.trim();
  if (trimmed.charAt(0).match(/\//)) {
    return false;
  }
  return true;
}
function getLengthOfWhiteSpaceBeforeStartOfLetters(string) {
  let match = /^\s*/.exec(string);
  if (match !== null) {
    return match[0].length;
  } else {
    return 0;
  }
}
var src = genbankToJson;
const genbankParser = /* @__PURE__ */ getDefaultExportFromCjs(src);
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const coorSchema = z.object({
  x: z.number(),
  y: z.number()
});
const angleSchema = z.object({
  degrees: z.number(),
  center: coorSchema
});
const annotationTypeSchema = z.union([
  z.literal("CDS"),
  z.literal("enhancer"),
  z.literal("intron"),
  z.literal("misc_feature"),
  z.literal("polyA_signal"),
  z.literal("promoter"),
  z.literal("protein_bind"),
  z.literal("rep_origin"),
  z.literal("LTR"),
  z.string()
]);
const annotationSchema = z.object({
  type: annotationTypeSchema,
  direction: z.union([z.literal("forward"), z.literal("reverse")]),
  start: z.number(),
  end: z.number(),
  className: z.string().optional(),
  text: z.string(),
  onClick: z.function().args(z.any()).optional()
  // circular reference
});
const stackedAnnotationSchema = annotationSchema.extend({
  stack: z.number()
});
const nuclSchema = z.union([
  z.literal("A"),
  z.literal("C"),
  z.literal("G"),
  z.literal("T")
]);
const aaSchema = z.union([
  // Add all your amino acids literals here
  z.literal("A"),
  z.literal("C"),
  z.literal("D"),
  z.literal("E"),
  z.literal("F"),
  z.literal("G"),
  z.literal("H"),
  z.literal("I"),
  z.literal("K"),
  z.literal("L"),
  z.literal("M"),
  z.literal("N"),
  z.literal("P"),
  z.literal("Q"),
  z.literal("R"),
  z.literal("S"),
  z.literal("T"),
  z.literal("V"),
  z.literal("W"),
  z.literal("Y")
]);
const GapSchema = z.literal("-");
const StopSchema = z.literal("*");
const SpaceSchema = z.literal(" ");
const UnknownSchema = z.literal("?");
const annotatedBaseSchema = z.object({
  base: z.string().length(1),
  annotations: z.array(stackedAnnotationSchema),
  index: z.number()
});
const annotatedSequenceSchema = z.array(annotatedBaseSchema);
const ariadneSelectionSchema = z.object({
  start: z.number(),
  end: z.number(),
  direction: z.union([z.literal("forward"), z.literal("reverse")])
});
const GenbankFeatureSchema = z.object({
  name: z.string().min(1),
  start: z.number(),
  end: z.number(),
  strand: z.union([z.literal(1), z.literal(-1)]),
  type: annotationTypeSchema,
  notes: z.record(z.array(z.string())).optional()
});
const genbankToAnnotatedSequence = ({
  genbank,
  annotationOnClick
}) => {
  const features = genbank.features.map((feature) => {
    return GenbankFeatureSchema.parse(feature);
  });
  const annotations = genbankFeaturesToAnnotations({
    features,
    annotationOnClick
  });
  const stackedAnnotations = stackAnnsByType(annotations);
  const { successes, failures } = safeAnythingToAnnotatedSequences({
    payload: genbank.sequence,
    payloadType: "raw",
    annotations: stackedAnnotations
  });
  if (failures.length > 0) {
    throw new Error(`Failed to parse genbank: ${failures[0]}`);
  }
  if (successes.length !== 1 || successes[0].sequences.length !== 1) {
    throw new Error(`Expected exactly one annotated sequence`);
  }
  return {
    annotatedSequence: annotatedSequenceSchema.parse(successes[0].sequences[0]),
    annotations
  };
};
const genbankFeaturesToAnnotations = ({
  features,
  annotationOnClick
}) => {
  return features.map((feature) => {
    const [start, end] = [feature.start, feature.end];
    return {
      type: feature.type,
      start,
      end,
      label: feature.type,
      text: feature.name,
      direction: feature.strand === 1 ? "forward" : "reverse",
      className: getClassNameFromFeatureType(feature.type),
      onClick: annotationOnClick
    };
  });
};
function getClassNameFromFeatureType(annType) {
  const common = "cursor-pointer opacity-60 group-hover:opacity-100 !text-xs hover:opacity-100 pointer-events-all text-white text-clip overflow-hidden whitespace-nowrap";
  const classNameMap = zipArrays(
    [
      "CDS",
      "enhancer",
      "intron",
      "misc_feature",
      "polyA_signal",
      "promoter",
      "protein_bind",
      "rep_origin",
      "LTR",
      "source",
      "insertion"
    ],
    [
      "bg-red-600 fill-red-600 stroke-red-600",
      "bg-blue-600 fill-blue-600 stroke-blue-600",
      "bg-green-600 fill-green-600 stroke-green-600",
      "bg-yellow-600 fill-yellow-600 stroke-yellow-600",
      "bg-orange-600 fill-orange-600 stroke-orange-600",
      "bg-purple-600 fill-purple-600 stroke-purple-600",
      "bg-sky-600 fill-sky-600 stroke-sky-600",
      "bg-teal-600 fill-teal-600 stroke-teal-600",
      "bg-gray-600 fill-gray-600 stroke-gray-600",
      "bg-pink-600 fill-pink-600 stroke-pink-600"
    ]
  );
  if (annType in classNameMap) {
    return `${common} ${classNameMap[annType]}`;
  }
  return common;
}
const zipArrays = (keys, values) => {
  return Object.fromEntries(
    keys.map((key, i) => {
      const val = values[i];
      return [key, val];
    })
  );
};
const parseGenbank = (genbankString) => {
  const result = genbankParser(genbankString);
  return result;
};
const getComplement = (sequence) => {
  const complement = {
    A: "T",
    T: "A",
    C: "G",
    G: "C",
    N: "N"
  };
  return sequence.split("").map((base) => {
    if (base in complement) {
      return complement[base];
    } else {
      return "?";
    }
  }).join("");
};
const getAnnotatedSequence = ({
  sequence,
  stackedAnnotations,
  noValidate
}) => {
  const mapFn = (base, idx) => {
    const annotationsForBase = stackedAnnotations.filter((annotation) => {
      if (annotation.start > annotation.end) {
        const isBetweenAnnotationStartAndEndofSequence = idx >= annotation.start && idx <= sequence.length;
        const isBetweenStartOfSequenceAndAnnotationEnd = idx >= 0 && idx <= annotation.end;
        return isBetweenAnnotationStartAndEndofSequence || isBetweenStartOfSequenceAndAnnotationEnd;
      } else {
        return idx >= annotation.start && idx <= annotation.end;
      }
    });
    return {
      base,
      index: idx,
      annotations: annotationsForBase,
      complement: getComplement(base)
    };
  };
  const raw = sequence.split("").map(mapFn).filter((x) => x.base !== " ");
  const annotatedSequence = annotatedSequenceSchema.safeParse(raw);
  if (noValidate) {
    if (annotatedSequence.success === false) {
      console.warn(annotatedSequence.error);
    }
    return raw;
  }
  if (annotatedSequence.success === false) {
    throw new Error(annotatedSequence.error.message);
  }
  return annotatedSequence.data;
};
const stackElements = (elements) => {
  if (elements.length === 0) {
    return [];
  }
  const last = (arr) => arr[arr.length - 1];
  const first = (arr) => arr[0];
  const maxIndex = elements.map((e) => e.end).reduce((a, b) => Math.max(a, b));
  const stack = [];
  elements.forEach((a) => {
    const insertIndex = stack.findIndex((elems) => {
      if (a.end === a.start) {
        return -1;
      }
      if (last(elems).end <= last(elems).start) {
        return last(elems).end + maxIndex <= a.start;
      }
      if (a.end > a.start) {
        return last(elems).end <= a.start;
      }
      return last(elems).end < a.start && a.end < first(elems).start;
    });
    if (insertIndex > -1) {
      stack[insertIndex].push(a);
    } else {
      stack.push([a]);
    }
  });
  return stack.map((row) => row.sort((a, b) => a.start - b.start));
};
const getStackedAnnotations = (annotations) => {
  const stackedAnnotations = stackElements(annotations);
  return stackedAnnotations.map((row, idx) => row.map((annotation) => ({ ...annotation, stack: idx }))).flat();
};
const baseInSelection = ({
  baseIndex,
  selection,
  sequenceLength
}) => {
  if (!selection) {
    return false;
  }
  const { start, end } = selection;
  if (start === end) {
    return baseIndex === start;
  }
  if (start < end) {
    return inRange(baseIndex, start, end);
  } else {
    return inRange(baseIndex, start, sequenceLength) || inRange(baseIndex, 0, end);
  }
};
const inRange = (value, min2, max2) => {
  return value >= min2 && value <= max2;
};
const getSubsequenceLength = ({ start, end }, sequenceLength) => {
  if (start < end) {
    return end - start;
  } else {
    return sequenceLength - start + end;
  }
};
const anythingToAnnotatedSequences = ({
  payload,
  payloadType,
  annotations,
  annotationOnClick
}) => {
  const { successes, failures } = safeAnythingToAnnotatedSequences({
    payload,
    payloadType,
    annotations,
    annotationOnClick
  });
  if (failures.length > 0) {
    const failString = failures.map((f) => f.error).join("\n");
    throw new Error(`Parse failures: ${failString}`);
  }
  const sequences = successes.map((s) => s.sequences).flat();
  const newAnnotations = successes.map((s) => s.annotations).flat();
  const stackedAnnotations = getStackedAnnotations(newAnnotations);
  return { sequences, stackedAnnotations };
};
const safeAnythingToAnnotatedSequences = ({
  payload,
  payloadType,
  annotations,
  annotationOnClick
}) => {
  const successes = [];
  const failures = [];
  switch (payloadType) {
    case "raw": {
      try {
        const sequences = [
          stringToAnnotatedSequence({
            sequence: payload,
            annotations: annotations ?? []
          })
        ];
        successes.push({
          source: {
            payload,
            annotations,
            annotationOnClick,
            payloadType
          },
          sequences,
          annotations: annotations ?? []
        });
      } catch (e) {
        failures.push({
          source: {
            payload,
            annotations,
            annotationOnClick,
            payloadType
          },
          error: `Failed to parse raw sequence: ${e}`
        });
      }
      break;
    }
    case "parsed-genbank":
    case "genbank": {
      const parsed = payloadType === "parsed-genbank" ? [payload] : genbankParser(payload);
      parsed.forEach((genbank) => {
        try {
          const sequence = genbankToAnnotatedSequence({
            genbank,
            annotationOnClick
          }).annotatedSequence;
          successes.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            sequences: [sequence],
            annotations: []
          });
        } catch (e) {
          failures.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            error: `Failed to parse genbank: ${e}`
          });
        }
      });
      break;
    }
    case "fasta": {
      let records;
      if (payloadType === "fasta") {
        records = parseFasta(payload);
      } else {
        records = parseFastq(payload);
      }
      records.forEach((record) => {
        try {
          const res = safeAnythingToAnnotatedSequences({
            payload: record.sequence,
            payloadType: "raw"
          });
          failures.push(...res.failures);
          successes.push(...res.successes);
        } catch (e) {
          failures.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            error: `Failed to parse ${payloadType}: ${e}`
          });
        }
      });
      break;
    }
    default: {
      failures.push({
        source: {
          payload,
          annotations,
          annotationOnClick,
          payloadType
        },
        error: `Unknown payload type: ${payloadType}`
      });
      break;
    }
  }
  return {
    successes,
    failures
  };
};
const stringToAnnotatedSequence = ({
  sequence,
  annotations
}) => {
  const stackedAnnotations = getStackedAnnotations(annotations ?? []);
  const annotatedSequence = getAnnotatedSequence({
    sequence,
    stackedAnnotations
  });
  return annotatedSequence;
};
const annotationsHaveOverlap = (a1, a2, maxLen) => {
  if (baseInSelection({
    baseIndex: a1.start,
    selection: a2,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a1.end,
    selection: a2,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a2.start,
    selection: a1,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a2.end,
    selection: a1,
    sequenceLength: maxLen
  })) {
    return true;
  }
  return false;
};
const stackAnnotationsNoOverlap = (annotations, maxLen) => {
  const annotationsByStack = [];
  annotations.map((annotation) => {
    let curStack = 0;
    while (true) {
      const stackAnns = annotationsByStack[curStack];
      if (!stackAnns) {
        annotationsByStack[curStack] = [annotation];
        return;
      }
      let overlap = false;
      for (const stackedAnn of stackAnns) {
        if (annotationsHaveOverlap(annotation, stackedAnn, maxLen)) {
          overlap = true;
          break;
        }
      }
      if (overlap) {
        curStack += 1;
      } else {
        annotationsByStack[curStack].push(annotation);
        return;
      }
    }
  });
  const stackedAnnotations = [];
  annotationsByStack.forEach((stackedAnns, index2) => {
    stackedAnns.forEach((annotation) => {
      stackedAnnotations.push({
        ...annotation,
        stack: index2
      });
    });
  });
  return stackedAnnotations;
};
const stackAnnsByType = (annotations) => {
  const annotationMap = annotations.reduce(
    (acc, annotation) => {
      if (acc[annotation.type] === void 0) {
        acc[annotation.type] = [];
      }
      acc[annotation.type].push(annotation);
      return acc;
    },
    {}
  );
  const stacks = Object.values(annotationMap).map((stack, stackIdx) => {
    return stack.map((annotation) => {
      const res = {
        ...annotation,
        stack: stackIdx
      };
      return res;
    });
  }).flat();
  return stacks;
};
function parseFastq(data) {
  const lines = data.trim().split("\n");
  const records = [];
  for (let i = 0; i < lines.length; i += 4) {
    const record = {
      id: lines[i].substring(1),
      sequence: lines[i + 1],
      optionalId: lines[i + 2].substring(1),
      quality: lines[i + 3]
    };
    records.push(record);
  }
  return records;
}
function parseFasta(data) {
  const lines = data.trim().split("\n");
  const records = [];
  for (let i = 0; i < lines.length; i += 2) {
    const record = {
      id: lines[i].substring(1),
      sequence: lines[i + 1]
    };
    records.push(record);
  }
  return records;
}
const useStateRef = (initialValue) => {
  const ref = useRef(initialValue);
  const [state, internalSetState] = useState(initialValue);
  const setState = useCallback((value) => {
    ref.current = value;
    internalSetState(value);
  }, []);
  return [state, setState, ref];
};
const useLinearSelectionRect = ({
  ref,
  onMouseUp,
  onMouseDown,
  onMouseMove
}) => {
  const [start, setStart, startRef] = useStateRef(null);
  const [end, setEnd, endRef] = useStateRef(null);
  const [direction, setDirection] = useState("forward");
  const active = useRef(false);
  const _onMouseDown = (e) => {
    var _a;
    const { clientX, clientY } = e;
    const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
      left: 0,
      top: 0
    };
    const x = clientX - left;
    const y = clientY - top;
    active.current = true;
    setStart({ x, y });
    setEnd({ x, y });
    onMouseDown == null ? void 0 : onMouseDown({ start: { x, y } });
  };
  const _onMouseUp = () => {
    active.current = false;
    if (startRef.current && endRef.current) {
      onMouseUp == null ? void 0 : onMouseUp({ start: startRef.current, end: endRef.current });
    } else {
      console.error("start or end is null when mouseup");
    }
  };
  const _onMouseMove = (e) => {
    var _a, _b;
    if (active.current) {
      const { clientX, clientY } = e;
      const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
        left: 0,
        top: 0
      };
      const x = clientX - left;
      const y = clientY - top;
      const { startX } = {
        startX: (_b = startRef.current) == null ? void 0 : _b.x
      };
      if (startX && startX > x) {
        setDirection("reverse");
      } else {
        setDirection("forward");
      }
      setEnd({ x, y });
      if (startRef.current && endRef.current) {
        onMouseMove == null ? void 0 : onMouseMove({ start: startRef.current, end: endRef.current });
      } else {
        console.error("start is null when mousemove");
      }
    }
  };
  useEffect(() => {
    const node = ref == null ? void 0 : ref.current;
    if (node) {
      node.addEventListener("mousedown", _onMouseDown);
      node.addEventListener("mousemove", _onMouseMove);
    }
    if (window) {
      window.addEventListener("mouseup", _onMouseUp);
    }
    return () => {
      node == null ? void 0 : node.removeEventListener("mousedown", _onMouseDown);
      node == null ? void 0 : node.removeEventListener("mousemove", _onMouseMove);
      window == null ? void 0 : window.removeEventListener("mouseup", _onMouseUp);
    };
  }, [ref]);
  return { start, end, direction };
};
const useCircularSelectionRect = (ref) => {
  const [start, setStart, startRef] = useStateRef(null);
  const [end, setEnd] = useStateRef(null);
  const [direction, setDirection] = useState(null);
  const ANGLE_DELTA_THRESHOLD_IN_DEGREES = 2;
  const active = useRef(false);
  const onMouseDown = (e) => {
    if (ref.current) {
      console.debug("resetting start and end");
      setStart(null);
      setEnd(null);
      setDirection(null);
      active.current = true;
      const { clientX, clientY } = e;
      const { left, top, width, height } = ref.current.getBoundingClientRect();
      const x = clientX - left;
      const y = clientY - top;
      const center = { x: width / 2, y: height / 2 };
      const startAngle = findAngleFromCoor({ coor: { x, y }, center });
      setStart({
        degrees: startAngle,
        center
      });
    }
  };
  const onMouseUp = () => {
    active.current = false;
    setDirection(null);
  };
  const onMouseMove = (e) => {
    if (active.current && ref.current) {
      const { clientX, clientY } = e;
      const { left, top, width, height } = ref.current.getBoundingClientRect();
      const x = clientX - left;
      const y = clientY - top;
      const center = { x: width / 2, y: height / 2 };
      if (Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) < 0.4 * (width / 2)) {
        console.debug("within 0.5 radius of center, not updating selection");
        return;
      }
      const endAngle = findAngleFromCoor({ coor: { x, y }, center });
      if (startRef.current) {
        const startAngle = startRef.current.degrees;
        const endAngleIsNearStartAngle = inRange(
          endAngle,
          startAngle - ANGLE_DELTA_THRESHOLD_IN_DEGREES,
          startAngle + ANGLE_DELTA_THRESHOLD_IN_DEGREES
        );
        if (endAngleIsNearStartAngle) {
          setDirection(null);
        }
      }
      setEnd({
        degrees: endAngle,
        center
      });
    }
  };
  useEffect(
    function determineDirection() {
      if (start && end && direction === null) {
        const startAngle = start.degrees;
        const endAngle = end.degrees;
        const delta = endAngle - startAngle;
        const guessedDirection = delta > 0 ? "clockwise" : "counterclockwise";
        setDirection(guessedDirection);
      }
    },
    [start, end]
  );
  useEffect(
    function handleEventListeners() {
      const node = ref.current;
      if (node) {
        node.addEventListener("mousedown", onMouseDown);
        node.addEventListener("mousemove", onMouseMove);
        node.addEventListener("mouseup", onMouseUp);
      }
      if (window) {
        window.addEventListener("mouseup", onMouseUp);
      }
      return () => {
        node == null ? void 0 : node.removeEventListener("mousedown", onMouseDown);
        node == null ? void 0 : node.removeEventListener("mousemove", onMouseMove);
        node == null ? void 0 : node.removeEventListener("mouseup", onMouseUp);
        window == null ? void 0 : window.removeEventListener("mouseup", onMouseUp);
      };
    },
    [ref.current, start, direction]
  );
  return { start, end, direction };
};
function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}
const cn = classNames;
const CircularAnnotation = ({
  sequence,
  annotation,
  radius,
  center
}) => {
  const { x: cx, y: cy } = center;
  const annotationLength = getSubsequenceLength(annotation, sequence.length);
  if (annotationLength > sequence.length) {
    console.error(
      `Annotation ${annotation.text}'s length is greater than sequence length: ${annotationLength} > ${sequence.length}`
    );
  }
  const arcPath = genArc({
    innerRadius: radius,
    outerRadius: radius + 5,
    largeArc: annotationLength > sequence.length / 2,
    length: annotationLength,
    seqLength: sequence.length,
    offset: annotation.start,
    center: { x: cx, y: cy }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      className: classNames(annotation.className),
      onClick: () => {
        var _a;
        (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("path", { d: arcPath, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: annotation.text }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: "Annotation" })
      ] })
    }
  );
};
const CircularAnnotationGutter = ({
  stackedAnnotations,
  cx,
  cy,
  radius,
  annotatedSequence
}) => {
  const gutterRadius = radius * 0.3;
  const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
  const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
  stackedAnnotations = stackedAnnotations.map((annotation) => {
    const clampedBounds = clampSlice({
      slice: annotation,
      firstIdx,
      lastIdx
    });
    if (!clampedBounds) {
      return null;
    }
    return {
      ...annotation,
      start: clampedBounds.start,
      end: clampedBounds.end
    };
  }).filter(Boolean);
  const stacks = [];
  stackedAnnotations.forEach((ann) => {
    stacks[ann.stack] = stacks[ann.stack] || [];
    stacks[ann.stack].push(ann);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx, cy, r: gutterRadius, fill: "none", strokeWidth: 0.8 }),
    ";",
    stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Fragment, { children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CircularAnnotation,
      {
        annotation,
        radius: gutterRadius + stackIdx * 6,
        center: { x: cx, y: cy },
        sequence: annotatedSequence
      },
      `stack-${stackIdx}-${annotation.start}-${annotation.end}-${annotation.text}`
    )) }, `annotation-stack-${stackIdx}`))
  ] });
};
const CircularIndex = ({
  annotatedSequence,
  cx,
  cy,
  radius,
  ticks
}) => {
  const basesPerTick = Math.floor(annotatedSequence.length / ticks);
  if (annotatedSequence.length > 50) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `fill-current`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "circle",
        {
          cx,
          cy,
          r: radius * 0.75,
          fill: "none",
          stroke: "currentColor",
          strokeWidth: 2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ticks,
        {
          cx,
          cy,
          radius: radius * 0.75,
          basesPerTick,
          totalBases: annotatedSequence.length
        }
      )
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: annotatedSequence.map(({ base: letter }, index2) => {
    const { x, y } = findCoor({
      index: index2,
      radius: radius * 0.7,
      center: { x: cx, y: cy },
      seqLength: annotatedSequence.length
    });
    const rotateDegrees = index2 / annotatedSequence.length * 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tspan",
      {
        x,
        y,
        transform: `rotate(${rotateDegrees} ${x} ${y})`,
        textAnchor: "middle",
        dominantBaseline: "middle",
        color: "currentColor",
        fill: "currentColor",
        fontSize: "0.5rem",
        fontWeight: "thin",
        fontFamily: "inherit",
        "data-seq-index": index2,
        children: letter
      },
      `base-${index2}`
    );
  }) });
};
const Ticks = ({
  radius,
  cx,
  cy,
  basesPerTick,
  totalBases
}) => {
  const numberOfTicks = Math.floor(totalBases / basesPerTick);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { children: [...Array(numberOfTicks).keys()].map((i) => {
    const { x: x1, y: y1 } = findCoor({
      index: i,
      radius,
      center: { x: cx, y: cy },
      seqLength: totalBases
    });
    const { x: x2, y: y2 } = findCoor({
      index: i,
      radius: radius * 1.1,
      center: { x: cx, y: cy },
      seqLength: totalBases
    });
    const rotateDegrees = i / numberOfTicks * 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          id: `tick-${i}`,
          x1,
          y1,
          x2,
          y2,
          stroke: "currentColor",
          strokeWidth: 1,
          opacity: 0.5,
          transform: `rotate(${rotateDegrees} ${cx} ${cy})`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "text",
        {
          x: x2,
          y: y2 - 4,
          textAnchor: "middle",
          fontSize: ".8rem",
          transform: `rotate(${rotateDegrees} ${cx} ${cy})`,
          fill: "currentColor",
          opacity: 0.75,
          children: i * basesPerTick
        }
      )
    ] }, `tick-${i}`);
  }) });
};
const CircularViewer = ({
  sequence,
  annotations,
  selection,
  setSelection,
  containerClassName,
  svgSizePX = 300,
  svgPadding = 20
}) => {
  const { cx, cy, sizeX, sizeY, radius } = {
    cx: svgSizePX / 2,
    cy: svgSizePX / 2,
    sizeX: svgSizePX,
    sizeY: svgSizePX,
    radius: (svgSizePX - svgPadding) / 2
  };
  const stackedAnnotations = stackAnnsByType(annotations);
  const annotatedSequence = useMemo(
    function memoize() {
      return getAnnotatedSequence({
        sequence,
        stackedAnnotations: getStackedAnnotations(annotations)
      });
    },
    [sequence, annotations]
  );
  if (annotatedSequence && selection && annotatedSequence.length > 0) {
    const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
    const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
    selection = clampSlice({ slice: selection, firstIdx, lastIdx });
  }
  const selectionRef = useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames(
        "flex select-none items-center justify-center font-thin",
        containerClassName
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref: selectionRef,
          viewBox: `0 0 ${sizeX} ${sizeY}`,
          xmlns: "http://www.w3.org/2000/svg",
          fontFamily: "inherit",
          fontSize: "inherit",
          fontWeight: "inherit",
          className: `stroke-current`,
          width: sizeX,
          height: sizeY,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularIndex,
              {
                cx,
                cy,
                radius,
                annotatedSequence,
                ticks: 4
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularAnnotationGutter,
              {
                annotatedSequence,
                stackedAnnotations,
                cx,
                cy,
                radius
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularSelection,
              {
                annotatedSequence,
                selection,
                cx,
                cy,
                radius,
                selectionRef,
                setSelection
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "text",
              {
                x: cx,
                y: cy,
                textAnchor: "middle",
                fill: "currentColor",
                stroke: "currentColor",
                alignmentBaseline: "middle",
                fontSize: "1rem",
                children: [
                  annotatedSequence.length,
                  " bp"
                ]
              }
            )
          ]
        }
      )
    }
  );
};
const CircularSelection = ({
  radius,
  cx,
  cy,
  selection,
  selectionRef,
  setSelection,
  annotatedSequence
}) => {
  var _a, _b;
  const {
    start: internalSelectionStart,
    end: internalSelectionEnd,
    direction: internalDirection
  } = useCircularSelectionRect(selectionRef);
  useEffect(
    function propagateSelectionUp() {
      if (selectionRef.current && internalSelectionStart && internalSelectionEnd && internalDirection) {
        const start2 = findIndexFromAngle({
          angle: internalSelectionStart,
          seqLength: annotatedSequence.length
        });
        const end2 = findIndexFromAngle({
          angle: internalSelectionEnd,
          seqLength: annotatedSequence.length
        });
        const direction = internalDirection === "clockwise" ? "forward" : "reverse";
        const prevLength = selection ? Math.abs(selection.end - selection.start) : 0;
        const newLength = getSubsequenceLength(
          { start: start2, end: end2 },
          annotatedSequence.length
        );
        const deltaLength = Math.abs(prevLength - newLength);
        const deltaThreshold = Math.max(0.7 * annotatedSequence.length, 10);
        if (deltaLength > deltaThreshold && selection) {
          setSelection({
            start: start2,
            end: end2,
            direction: selection == null ? void 0 : selection.direction
          });
          return;
        }
        setSelection({
          start: start2,
          end: end2,
          direction
        });
      }
    },
    [internalSelectionStart, internalSelectionEnd]
  );
  if (selection === null) {
    return null;
  }
  const { start, end } = selection;
  if (start === null || end === null) {
    return null;
  }
  const center = { x: cx, y: cy };
  const innerRadius = radius;
  const outerRadius = radius + 10;
  const length = getSubsequenceLength(selection, annotatedSequence.length);
  const [startIdx, endIdx] = [
    (_a = annotatedSequence.at(0)) == null ? void 0 : _a.index,
    (_b = annotatedSequence.at(-1)) == null ? void 0 : _b.index
  ];
  if (startIdx === void 0 || endIdx === void 0) {
    console.error("CircularViewer: sequence has no indices");
    return null;
  }
  const offset2 = start - startIdx;
  const seqLength = annotatedSequence.length;
  const arc = genArc({
    center,
    innerRadius,
    largeArc: length > seqLength / 2,
    length,
    offset: offset2,
    outerRadius,
    seqLength
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      d: arc,
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) });
};
const LinearAnnotationGutter = ({
  stackedAnnotations,
  sequence,
  containerClassName
}) => {
  const stacks = [];
  stackedAnnotations.forEach((ann) => {
    stacks[ann.stack] = stacks[ann.stack] || [];
    stacks[ann.stack].push(ann);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames(
        "grid-rows-auto block grid grid-cols-1 gap-1",
        containerClassName
      ),
      children: stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-8", children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation,
          sequence,
          stackIdx
        },
        `annotation-${annotation.text}-${annotation.start}-${annotation.end}-${annotation.direction}`
      )) }, `annotation-stack-${stackIdx}`))
    }
  );
};
const LinearAnnotation = ({
  annotation,
  sequence,
  stackIdx
}) => {
  const annotationSpansSeam = annotation.start > annotation.end;
  if (annotationSpansSeam) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation: {
            ...annotation,
            end: sequence.length,
            onClick: () => {
              var _a;
              (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
            }
          },
          sequence,
          stackIdx
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation: {
            ...annotation,
            start: 0,
            onClick: () => {
              var _a;
              (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
            }
          },
          sequence,
          stackIdx
        }
      )
    ] });
  }
  const annotationRectangleWidthPerc = getSubsequenceLength(annotation, sequence.length) / sequence.length * 100;
  const xPerc = Math.min(annotation.start, annotation.end) / sequence.length * 100;
  const forwardClipPath = "polygon(0 0, 90% 0, 100% 50%, 90% 100%, 0 100%)";
  const reverseClipPath = "polygon(0 50%, 10% 0, 100% 0, 100% 100%, 10% 100%)";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "group absolute",
      style: {
        marginLeft: `${xPerc}%`,
        width: `${annotationRectangleWidthPerc}%`
      },
      onClick: () => {
        var _a;
        (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classNames(
              "px-2",
              annotation.direction === "forward" ? "text-left" : "text-right",
              annotation.className
            ),
            style: {
              clipPath: annotation.direction === "forward" ? forwardClipPath : reverseClipPath
            },
            children: annotation.text
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: classNames(
              "absolute left-1/2 z-10 hidden -translate-x-1/2 translate-y-4 flex-col rounded-md px-2 py-1 text-sm group-hover:flex",
              annotation.className
            ),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.text }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.type })
            ]
          }
        )
      ]
    }
  );
};
const MISMATCH_DIST_PERC_THRESHOLD = 0.01;
const LinearViewer = (props) => {
  const {
    sequences,
    selection,
    annotations,
    setSelection,
    onDoubleClick,
    selectionClassName,
    mismatchClassName,
    containerClassName,
    sequenceClassName,
    stackingFn
  } = props;
  const stackedAnnotations = useMemo(
    function memoize() {
      return stackingFn ? stackingFn(annotations) : stackAnnotationsNoOverlap(
        annotations,
        Math.max(...sequences.map((seq) => seq.length))
      );
    },
    [annotations]
  );
  const annotatedSequences = useMemo(
    function memoize() {
      return sequences.map(
        (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations })
      );
    },
    [sequences, stackedAnnotations]
  );
  const baseSequence = annotatedSequences[0];
  const selectionRef = useRef(null);
  const SVG_WIDTH = 500;
  const SVG_HEIGHT = sequences.length * 10 + 10;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClassName || "", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref: selectionRef,
        className: classNames("select-none font-thin"),
        onDoubleClick,
        viewBox: `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`,
        width: "100%",
        height: "100%",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: annotatedSequences.map((sequence, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SequenceLine,
            {
              sequenceClassName,
              baseSequence: sequence,
              alignedSequences: annotatedSequences.filter((_, j) => j !== i),
              sequenceIdx: i,
              mismatchClassName
            }
          ) }, `Sequence-${i}`)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            LinearSelection,
            {
              selectionClassName,
              selectionRef,
              selection,
              setSelection,
              sequence: baseSequence
            }
          )
        ]
      }
    ),
    stackedAnnotations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      LinearAnnotationGutter,
      {
        containerClassName: "",
        stackedAnnotations,
        sequence: baseSequence
      }
    )
  ] });
};
const SequenceLine = ({
  baseSequence,
  sequenceIdx,
  alignedSequences,
  sequenceClassName,
  mismatchClassName
}) => {
  var _a, _b;
  const start = (_a = baseSequence[0]) == null ? void 0 : _a.index;
  if (start === void 0) {
    throw new Error(`Sequence must have at least one base ${baseSequence}`);
  }
  const end = (_b = baseSequence[baseSequence.length - 1]) == null ? void 0 : _b.index;
  if (end === void 0) {
    throw new Error(`Sequence must have at least one base ${baseSequence}`);
  }
  let maxEnd = end;
  alignedSequences.forEach((alignedSequence) => {
    var _a2;
    const otherEnd = (_a2 = alignedSequence.at(alignedSequence.length - 1)) == null ? void 0 : _a2.index;
    if (otherEnd === void 0) {
      throw new Error(
        `otherSequence must have at least one base ${alignedSequence}`
      );
    }
    if (otherEnd > maxEnd) {
      maxEnd = otherEnd;
    }
  });
  const startPerc = start / maxEnd;
  const endPerc = end / maxEnd;
  const mismatches = baseSequence.filter((base) => {
    const rootBase = baseSequence.at(base.index);
    return rootBase && rootBase.base !== base.base;
  });
  mismatchClassName = mismatchClassName ?? function mismatchClassName2(mismatch) {
    if (mismatch.base === "-") {
      return "fill-black stroke-black opacity-80";
    } else {
      return "dark:fill-red-600 dark:stroke-red-600 fill-red-700 stroke-red-700";
    }
  };
  let lastXPerc = -1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("", sequenceClassName({ sequenceIdx })),
        x1: `${startPerc * 100}%`,
        y1: `${sequenceIdx * 10 + 10}`,
        x2: `${endPerc * 100}%`,
        y2: `${sequenceIdx * 10 + 10}`,
        strokeWidth: 5,
        stroke: "currentColor"
      }
    ),
    mismatches.map((base) => {
      const xPerc = base.index / maxEnd * 100;
      const width = Math.max(1 / baseSequence.length * 100, 0.01);
      const diff = xPerc - lastXPerc;
      if (diff < MISMATCH_DIST_PERC_THRESHOLD) {
        return null;
      }
      lastXPerc = xPerc;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "g",
        {
          className: classNames((mismatchClassName == null ? void 0 : mismatchClassName(base)) || "bg-red-400"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "line",
            {
              x1: `${xPerc - width / 2}%`,
              y1: `${sequenceIdx * 10 + 10}`,
              x2: `${xPerc + width / 2}%`,
              y2: `${sequenceIdx * 10 + 10}`,
              strokeWidth: 5
            }
          )
        },
        `sequence-${sequenceIdx}-mismatch-${base.index}`
      );
    })
  ] });
};
const LinearSelection = ({
  selection,
  selectionRef,
  setSelection,
  sequence,
  selectionClassName
}) => {
  const {
    start: internalSelectionStart,
    end: internalSelectionEnd,
    direction: internalDirection
  } = useLinearSelectionRect({ ref: selectionRef });
  useEffect(
    function propagateSelectionUp() {
      var _a;
      if (selectionRef.current && internalSelectionStart && internalSelectionEnd) {
        const svgWidth = (_a = selectionRef.current) == null ? void 0 : _a.getBoundingClientRect().width;
        const start2 = Math.floor(
          internalSelectionStart.x / svgWidth * sequence.length
        );
        const end2 = Math.floor(
          internalSelectionEnd.x / svgWidth * sequence.length
        );
        if (selection == null || start2 === end2) {
          setSelection({
            start: start2,
            end: start2 + 1,
            direction: internalDirection
          });
          return;
        } else {
          setSelection({ start: start2, end: end2, direction: internalDirection });
        }
      }
    },
    [internalSelectionStart, internalSelectionEnd]
  );
  if (!selection) {
    return null;
  }
  const { start, end } = selection;
  let firstRectStart = Math.min(start, end) / sequence.length * 100;
  let firstRectWidth = getSubsequenceLength(selection, sequence.length) / sequence.length * 100;
  let secondRectStart = null;
  let secondRectWidth = null;
  const selectionSpansSeam = selection.start > selection.end;
  if (selectionSpansSeam) {
    firstRectStart = 0;
    firstRectWidth = end / sequence.length * 100;
    secondRectStart = start / sequence.length * 100;
    secondRectWidth = (sequence.length - start) / sequence.length * 100;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "g",
    {
      className: classNames(
        "fill-current stroke-current",
        selectionClassName == null ? void 0 : selectionClassName(selection)
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: `${firstRectStart}%`,
            width: `${firstRectWidth}%`,
            y: `0%`,
            height: `100%`,
            fill: "currentColor",
            fillOpacity: 0.2,
            strokeWidth: 1.5
          }
        ),
        secondRectStart && secondRectWidth && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: `${secondRectStart}%`,
            width: `${secondRectWidth}%`,
            y: `0%`,
            height: `100%`,
            fill: "currentColor",
            fillOpacity: 0.2,
            strokeWidth: 1.5
          }
        )
      ]
    }
  );
};
function clamp$1(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      var _a;
      const { scope, children, ...context } = props;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const value = React.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
var Slot = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React.Children.count(newElement) > 1) return React.Children.only(null);
        return React.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    const props2 = mergeProps(slotProps, children.props);
    if (children.type !== React.Fragment) {
      props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
    }
    return React.cloneElement(children, props2);
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return React.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React__default.useRef(null);
    const itemMap = React__default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React__default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React__default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React__default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = React.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  React.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React.useContext(DismissableLayerContext);
    const [node, setNode] = React.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React.forwardRef((props, forwardedRef) => {
  const context = React.useContext(DismissableLayerContext);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React.useRef(false);
  const handleClickRef = React.useRef(() => {
  });
  React.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = React.useRef(false);
  React.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count$1 = 0;
function useFocusGuards() {
  React.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$1++;
    return () => {
      if (count$1 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$1--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : () => {
};
var useReactId = React["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return id ? `radix-${id}` : "";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? useLayoutEffect : useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1 = React.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root = Arrow$1;
function useSize(element) {
  const [size2, setSize] = React.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME$1 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1);
var PopperContent = React.forwardRef(
  (props, forwardedRef) => {
    var _a, _b, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$1, __scopePopper);
    const [content, setContent] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = React.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a = middlewareData.arrow) == null ? void 0 : _a.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$1;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$1 = "Portal";
var Portal$1 = React.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? ReactDOM__default.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$1.displayName = PORTAL_NAME$1;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = React.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  React.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
function usePrevious(value) {
  const ref = React.useRef({ value, previous: value });
  return React.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var NAME = "VisuallyHidden";
var VisuallyHidden = React.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id = React.useState(idCounter++)[0];
  var Style2 = React.useState(styleSingleton)[0];
  var lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope,
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  const [trigger, setTrigger] = React.useState(null);
  const [valueNode, setValueNode] = React.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME = "SelectTrigger";
var SelectTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection(__scopeSelect);
    const pointerTypeRef = React.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "SelectContent";
var SelectContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);
    const [fragment, setFragment] = React.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME, __scopeSelect);
    const [content, setContent] = React.useState(null);
    const [viewport, setViewport] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React.useState(null);
    const [selectedItemText, setSelectedItemText] = React.useState(
      null
    );
    const getItems = useCollection(__scopeSelect);
    const [isPositioned, setIsPositioned] = React.useState(false);
    const firstValidItemFoundRef = React.useRef(false);
    React.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = React.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    React.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a = triggerPointerDownPosRef.current) == null ? void 0 : _a.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a;
              (_a = context.trigger) == null ? void 0 : _a.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection(__scopeSelect);
  const shouldExpandOnScrollRef = React.useRef(false);
  const shouldRepositionRef = React.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp$1(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp$1(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a;
        return (_a = contentContext.itemRefCallback) == null ? void 0 : _a.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId();
    const pointerTypeRef = React.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a;
                  if (event.currentTarget === document.activeElement) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a;
                  const isTypingAhead = ((_a = contentContext.searchRef) == null ? void 0 : _a.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a;
        return (_a = contentContext.itemTextRefCallback) == null ? void 0 : _a.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React.useRef(null);
  const getItems = useCollection(__scopeSelect);
  const clearAutoScrollTimer = React.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    var _a;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a;
        (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow";
var SelectArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(ARROW_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = React.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = React.useRef("");
  const timerRef = React.useRef(0);
  const handleTypeaheadSearch = React.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root2 = Select$1;
var Trigger = SelectTrigger$1;
var Value = SelectValue$1;
var Icon$1 = SelectIcon;
var Portal = SelectPortal;
var Content2 = SelectContent$1;
var Viewport = SelectViewport;
var Label = SelectLabel$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator = SelectSeparator$1;
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size2,
        height: size2,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = forwardRef(
    ({ className, ...props }, ref) => createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Copy = createLucideIcon("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
const Select = Root2;
const SelectValue = Value;
const SelectTrigger = React.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Trigger,
  {
    ref,
    className: cn(
      "ring-offset-background focus:ring-ring flex h-4 w-full items-center justify-between whitespace-nowrap rounded-md bg-transparent px-3 py-2 text-xs focus:outline-none focus:ring-1 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      "dark:placeholder-text-zinc-600 text-black placeholder:text-noir-400 dark:text-white",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "ml-1 h-4 w-4 text-black opacity-50 dark:text-white" }) })
    ]
  }
));
SelectTrigger.displayName = Trigger.displayName;
const SelectScrollUpButton = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollUpButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-4 w-4" })
  }
));
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollDownButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4" })
  }
));
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = React.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Content2,
  {
    ref,
    className: cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
      position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      className
    ),
    position,
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Viewport,
        {
          className: cn(
            "p-1",
            position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
    ]
  }
) }));
SelectContent.displayName = Content2.displayName;
const SelectLabel = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label,
  {
    ref,
    className: cn("px-2 py-1.5 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel.displayName = Label.displayName;
const SelectItem = React.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Item,
  {
    ref,
    className: cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
    ]
  }
));
SelectItem.displayName = Item.displayName;
const SelectSeparator = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator,
  {
    ref,
    className: cn("bg-muted -mx-1 my-1 h-px", className),
    ...props
  }
));
SelectSeparator.displayName = Separator.displayName;
const CopyButton = ({
  label,
  buttonClassName,
  logoClassName,
  textToCopy,
  disabled
}) => {
  const [logo, setLogo] = useState(
    /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) })
  );
  const [internalLabel, setInternalLabel] = useState(label);
  const onClipboardCopy = () => {
    setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: cn("h-3 w-3", logoClassName) }));
    setInternalLabel("Copied!");
    setTimeout(() => {
      setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) }));
      setInternalLabel(label);
    }, 1e3);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      "aria-label": "Copy to clipboard",
      disabled,
      className: cn(
        "flex items-center gap-2 disabled:cursor-not-allowed disabled:text-noir-400 dark:text-noir-100 dark:disabled:text-zinc-600",
        buttonClassName
      ),
      onClick: () => {
        const text = textToCopy();
        navigator.clipboard.writeText(text);
        onClipboardCopy();
      },
      children: [
        logo,
        internalLabel
      ]
    }
  );
};
const SequenceViewer = ({
  sequences,
  annotations,
  selection,
  setSelection,
  containerClassName,
  charClassName,
  selectionClassName,
  hideMetadataBar,
  noValidate
}) => {
  const [hoveredPosition, setHoveredPosition] = useState(null);
  const [seqIdxToCopy, setSeqIdxToCopy] = useState(0);
  const [activeAnnotation, setActiveAnnotation] = useState(
    null
  );
  const stackedAnnotations = useMemo(
    function memoize() {
      return stackAnnotationsNoOverlap(
        annotations,
        Math.max(...sequences.map((seq) => seq.length))
      );
    },
    [annotations]
  );
  const annotatedSequences = useMemo(
    function memoize() {
      return sequences.map(
        (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations, noValidate })
      );
    },
    [sequences, stackedAnnotations]
  );
  const memoizedSeqContent = useMemo(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SeqContent,
      {
        annotatedSequences,
        selection,
        setSelection,
        setHoveredPosition,
        setActiveAnnotation,
        stackedAnnotations,
        charClassName,
        selectionClassName
      }
    );
  }, [annotatedSequences, selection, stackedAnnotations]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "relative isolate flex flex-wrap",
        containerClassName
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SeqMetadataBar,
          {
            hoveredPosition,
            activeAnnotation,
            className: classNames("sticky inset-x-0 top-0 z-[3] w-full px-2 py-1 backdrop-blur-md", hideMetadataBar ? "hidden" : ""),
            annotatedSequences,
            charClassName,
            seqIdxToCopy,
            setSeqIdxToCopy,
            selection
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap px-2", children: memoizedSeqContent })
      ]
    }
  ) });
};
const SeqContent = ({
  annotatedSequences,
  selection,
  setSelection,
  setHoveredPosition,
  setActiveAnnotation,
  stackedAnnotations,
  charClassName,
  selectionClassName
}) => {
  const mouseDown = useRef(false);
  const indicesClassName = ({
    base,
    sequenceIdx
  }) => {
    const isNotFirstSeq = sequenceIdx !== 0;
    const isNotMultipleOfTen = base.index % 10 !== 0;
    if (isNotFirstSeq || isNotMultipleOfTen) {
      return "opacity-0";
    }
    return classNames(
      "text-xs z-1",
      // don't allow selection of indices
      "dark:group-hover:text-noir-300 group-hover:text-noir-800",
      baseInSelection({
        baseIndex: base.index,
        selection,
        sequenceLength: annotatedSequences[sequenceIdx].length
      }) ? "text-brand-700 dark:text-brand-300" : "text-noir-400 dark:text-noir-600"
    );
  };
  const handleMouseUp = () => {
    mouseDown.current = false;
  };
  useEffect(function addMouseUpListener() {
    document.addEventListener("mouseup", () => {
      handleMouseUp();
    });
    return function removeMouseUpListener() {
      document.removeEventListener("mouseup", () => {
        handleMouseUp();
      });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: annotatedSequences[0].map(({ index: baseIdx }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: classNames(
          "relative mt-4 flex flex-col justify-between",
          "group hover:bg-noir-200 dark:hover:bg-noir-600"
        ),
        children: [
          annotatedSequences.map(
            (sequence, sequenceIdx) => {
              const base = sequence.find(
                (base2) => base2.index === baseIdx
              ) || { base: " ", annotations: [], index: baseIdx };
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: classNames("whitespace-pre text-center"),
                  onMouseEnter: () => {
                    setHoveredPosition(base.index);
                    if (mouseDown.current && selection) {
                      setSelection({
                        ...selection,
                        end: base.index
                      });
                    }
                  },
                  onMouseLeave: () => setHoveredPosition(null),
                  onMouseDown: () => {
                    mouseDown.current = true;
                    setSelection({
                      start: base.index,
                      end: base.index,
                      direction: "forward"
                    });
                  },
                  onMouseUp: handleMouseUp,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CharComponent,
                      {
                        char: `| ${base.index}`,
                        index: baseIdx,
                        charClassName: classNames(
                          "absolute -top-4 left-0",
                          "group-hover:text-brand-200 border-b border-noir-600 group-hover:border-noir-300",
                          indicesClassName({
                            base,
                            sequenceIdx
                          })
                        )
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CharComponent,
                      {
                        char: base.base,
                        index: baseIdx,
                        charClassName: classNames(
                          charClassName({
                            base,
                            sequenceIdx
                          }),
                          baseInSelection({
                            baseIndex: baseIdx,
                            selection,
                            sequenceLength: annotatedSequences[sequenceIdx].length
                          }) && base.base !== " " && selectionClassName
                        )
                      }
                    )
                  ]
                },
                `sequence-${sequenceIdx}-base-${baseIdx}`
              );
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SequenceAnnotation,
            {
              annotations: stackedAnnotations,
              index: baseIdx,
              maxAnnotationStack: Math.max(
                1,
                Math.max(...stackedAnnotations.map((ann) => ann.stack))
              ),
              setHoveredPosition,
              setActiveAnnotation,
              maxSequenceLength: Math.max(
                ...annotatedSequences.map((seq) => seq.length)
              )
            }
          )
        ]
      },
      `base-${baseIdx}`
    );
  }) });
};
const SeqMetadataBar = ({
  hoveredPosition,
  activeAnnotation,
  annotatedSequences,
  charClassName,
  seqIdxToCopy,
  setSeqIdxToCopy,
  selection,
  className
}) => {
  const annotationDisplay = activeAnnotation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: classNames(
        "flex gap-1 rounded-full px-2 py-px text-xs !opacity-100",
        "ml-auto",
        activeAnnotation.className
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "opacity-70", children: "Label: " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: activeAnnotation.text })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "opacity-70", children: "Type: " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: activeAnnotation.type })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "opacity-70", children: "Direction: " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "", children: activeAnnotation.direction })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex gap-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "opacity-70", children: "from" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "", children: [
            activeAnnotation.start,
            " - ",
            activeAnnotation.end
          ] })
        ] })
      ]
    }
  ) : null;
  const positionDisplay = /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "min-w-16 text-xs text-black dark:text-white", children: [
    "Pos: ",
    hoveredPosition ?? 0
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "flex h-8 items-center gap-1 py-1 text-xs",
        className
      ),
      children: [
        positionDisplay,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CopyDisplay,
          {
            annotatedSequences,
            charClassName,
            seqIdxToCopy,
            setSeqIdxToCopy,
            selection
          }
        ),
        annotationDisplay
      ]
    }
  );
};
const SequenceAnnotation = ({
  annotations,
  maxAnnotationStack,
  index: index2,
  setHoveredPosition,
  setActiveAnnotation,
  maxSequenceLength
}) => {
  const orderedAnnotations = annotations.sort((a, b) => a.stack - b.stack);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: " ",
      onMouseEnter: () => setHoveredPosition(index2),
      onMouseLeave: () => setHoveredPosition(null),
      children: [...Array(maxAnnotationStack).keys()].map((i) => {
        const annotation = orderedAnnotations.filter(
          (ann) => baseInSelection({
            baseIndex: index2,
            selection: ann,
            sequenceLength: maxSequenceLength
          })
        ).find((ann) => ann.stack === i);
        if (annotation) {
          if (!baseInSelection({
            baseIndex: index2,
            selection: annotation,
            sequenceLength: maxSequenceLength
          })) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-3 border-b-2 border-noir-100 opacity-10 "
              },
              `annotation-${index2}-${i}`
            );
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: classNames(
                "group/annotation h-3 border-black group-hover/annotation:border",
                annotation.className
              ),
              onClick: () => {
                var _a;
                return (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, {
                  start: annotation.start,
                  end: annotation.end,
                  diection: annotation.direction
                });
              },
              onMouseEnter: () => setActiveAnnotation(annotation),
              onMouseLeave: () => setActiveAnnotation(null)
            },
            `annotation-${index2}-${i}`
          );
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3" }, `placeholder-${index2}-${i}`);
        }
      })
    },
    `annotation-${index2}`
  );
};
const CharComponent = ({ char, charClassName }) => {
  const sharedClassName = "font-mono select-none";
  if (char === " ") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "opacity-20"), children: "." });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "mr-px"), children: char });
};
const CopyDisplay = ({
  seqIdxToCopy,
  setSeqIdxToCopy,
  annotatedSequences,
  charClassName,
  selection
}) => {
  const getStringToCopy = () => {
    if (!selection) {
      return;
    }
    const seq = annotatedSequences[seqIdxToCopy];
    const stringToCopy = seq.filter(
      (base) => baseInSelection({
        baseIndex: base.index,
        selection,
        sequenceLength: annotatedSequences[seqIdxToCopy].length
      })
    ).map((base) => base.base).join("");
    return stringToCopy;
  };
  useEffect(function mountCopyHandler() {
    const copyHandler = (e) => {
      var _a;
      const stringToCopy = getStringToCopy();
      if (!stringToCopy) {
        return;
      }
      (_a = e.clipboardData) == null ? void 0 : _a.setData("text/plain", stringToCopy);
      alert("Copied to clipboard!");
      e.preventDefault();
    };
    document.addEventListener("copy", copyHandler);
    return function unmountCopyHandler() {
      document.removeEventListener("copy", copyHandler);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        value: seqIdxToCopy.toString(),
        onValueChange: (value) => setSeqIdxToCopy(parseInt(value)),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-fit", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            SelectValue,
            {
              className: charClassName({
                base: { base: "A", annotations: [], index: 0 },
                sequenceIdx: seqIdxToCopy
              }),
              children: [
                "Sequence ",
                seqIdxToCopy + 1
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { className: "bg-white dark:bg-black", children: annotatedSequences.map((_, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            SelectItem,
            {
              value: idx.toString(),
              className: charClassName({
                base: { base: "A", annotations: [], index: 0 },
                sequenceIdx: idx
              }),
              children: [
                "Sequence ",
                idx + 1,
                " "
              ]
            },
            `sequence-${idx}`
          )) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CopyButton,
      {
        textToCopy: () => getStringToCopy() ?? "",
        label: "",
        disabled: !selection
      }
    )
  ] });
};
const ReferenceTicks = ({
  sequence,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("overflow-hiddentext-white flex", className), children: sequence.map((nucl, i) => {
    const showTicks = nucl.base !== "-" && (nucl.index + 1) % 10 === 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "relative flex h-12 flex-col items-end justify-end",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: classNames(
                "font-mono ",
                "absolute bottom-0 left-0 right-0",
                showTicks ? "opacity-100" : "opacity-0",
                nucl.base === "G" && "text-red-500",
                nucl.base === "A" && "text-yellow-500",
                nucl.base === "T" && "text-green-500",
                nucl.base === "C" && "text-blue-500"
              ),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs", children: [
                  " ",
                  nucl.index + 1
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mx-auto text-xs", children: "|" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("mr-px font-mono opacity-0"), children: nucl.base })
        ]
      },
      `base-${i}-index-wrapper`
    );
  }) });
};
export {
  CircularViewer,
  GapSchema,
  GenbankFeatureSchema,
  LinearAnnotationGutter,
  LinearViewer,
  ReferenceTicks,
  SequenceViewer,
  SpaceSchema,
  StopSchema,
  UnknownSchema,
  aaSchema,
  angleSchema,
  annotatedBaseSchema,
  annotatedSequenceSchema,
  annotationSchema,
  annotationTypeSchema,
  annotationsHaveOverlap,
  anythingToAnnotatedSequences,
  ariadneSelectionSchema,
  baseInSelection,
  coorSchema,
  genbankFeaturesToAnnotations,
  genbankToAnnotatedSequence,
  getAnnotatedSequence,
  getClassNameFromFeatureType,
  getComplement,
  getStackedAnnotations,
  getSubsequenceLength,
  inRange,
  nuclSchema,
  parseFasta,
  parseFastq,
  parseGenbank,
  safeAnythingToAnnotatedSequences,
  stackAnnotationsNoOverlap,
  stackAnnsByType,
  stackElements,
  stackedAnnotationSchema,
  stringToAnnotatedSequence,
  useCircularSelectionRect,
  useLinearSelectionRect,
  zipArrays
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibml0cm8tc2VxdWVuY2Utdmlld2Vycy5lcy5qcyIsInNvdXJjZXMiOlsiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0NpcmN1bGFyVmlld2VyL2NpcmN1bGFyVXRpbHMudHMiLCIuLi9ub2RlX21vZHVsZXMvZ2VuYmFuay1wYXJzZXIvc3JjL3V0aWxzL21vbnRocy5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZW5iYW5rLXBhcnNlci9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL3NjaGVtYXMudHMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL2dlbmJhbmtVdGlscy50cyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvdXRpbHMudHMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL2hvb2tzL3VzZVN0YXRlUmVmLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9ob29rcy91c2VTZWxlY3Rpb24udHMiLCIuLi9zcmMvdXRpbHMvc3RyaW5nVXRpbHMudHMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0NpcmN1bGFyVmlld2VyL0NpcmN1bGFyQW5ub3RhdGlvbnMvQ2lyY3VsYXJBbm5vdGF0aW9uLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvQ2lyY3VsYXJBbm5vdGF0aW9ucy9DaXJjdWxhckFubm90YXRpb25HdXR0ZXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9DaXJjdWxhclZpZXdlci9DaXJjdWxhckluZGV4L0NpcmN1bGFySW5kZXgudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9DaXJjdWxhclZpZXdlci9DaXJjdWxhclZpZXdlci50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0xpbmVhclZpZXdlci9MaW5lYXJBbm5vdGF0aW9uR3V0dGVyLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvTGluZWFyVmlld2VyL0xpbmVhclZpZXdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL251bWJlci9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcHJpbWl0aXZlL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1jb250ZXh0L2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnMvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXNsb3QvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWNvbGxlY3Rpb24vZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWRpcmVjdGlvbi9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2UtZXNjYXBlLWtleWRvd24vZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWRpc21pc3NhYmxlLWxheWVyL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1mb2N1cy1ndWFyZHMvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWZvY3VzLXNjb3BlL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2UtbGF5b3V0LWVmZmVjdC9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtaWQvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanMiLCIuLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QtZG9tL2Rpc3QvZmxvYXRpbmctdWkucmVhY3QtZG9tLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtYXJyb3cvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1zaXplL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1wb3BwZXIvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXBvcnRhbC9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWNvbnRyb2xsYWJsZS1zdGF0ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLXByZXZpb3VzL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC12aXN1YWxseS1oaWRkZW4vZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvYXJpYS1oaWRkZW4vZGlzdC9lczIwMTUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsLWJhci9kaXN0L2VzMjAxNS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvdXNlLWNhbGxiYWNrLXJlZi9kaXN0L2VzMjAxNS9hc3NpZ25SZWYuanMiLCIuLi9ub2RlX21vZHVsZXMvdXNlLWNhbGxiYWNrLXJlZi9kaXN0L2VzMjAxNS91c2VSZWYuanMiLCIuLi9ub2RlX21vZHVsZXMvdXNlLWNhbGxiYWNrLXJlZi9kaXN0L2VzMjAxNS91c2VNZXJnZVJlZi5qcyIsIi4uL25vZGVfbW9kdWxlcy91c2Utc2lkZWNhci9kaXN0L2VzMjAxNS9tZWRpdW0uanMiLCIuLi9ub2RlX21vZHVsZXMvdXNlLXNpZGVjYXIvZGlzdC9lczIwMTUvZXhwb3J0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L21lZGl1bS5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L1VJLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2dldC1ub25jZS9kaXN0L2VzMjAxNS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1zdHlsZS1zaW5nbGV0b24vZGlzdC9lczIwMTUvc2luZ2xldG9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXN0eWxlLXNpbmdsZXRvbi9kaXN0L2VzMjAxNS9ob29rLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXN0eWxlLXNpbmdsZXRvbi9kaXN0L2VzMjAxNS9jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC1iYXIvZGlzdC9lczIwMTUvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC1iYXIvZGlzdC9lczIwMTUvY29tcG9uZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvYWdncmVzaXZlQ2FwdHVyZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L2hhbmRsZVNjcm9sbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L1NpZGVFZmZlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9zaWRlY2FyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvQ29tYmluYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXNlbGVjdC9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vc2hhcmVkL3NyYy91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL0ljb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2NyZWF0ZUx1Y2lkZUljb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2NoZWNrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jaGV2cm9uLWRvd24uanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2NoZXZyb24tdXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2NvcHkuanMiLCIuLi9zcmMvY29tcG9uZW50cy91aS9zZWxlY3QudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvdWkvY29weS1idXR0b24udHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9TZXF1ZW5jZVZpZXdlci9TZXF1ZW5jZVZpZXdlci50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL1JlZmVyZW5jZVRpY2tzL1JlZmVyZW5jZVRpY2tzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7dmFyIGY9cmVxdWlyZShcInJlYWN0XCIpLGs9U3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksbD1TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksbT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG49Zi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcixwPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5mdW5jdGlvbiBxKGMsYSxnKXt2YXIgYixkPXt9LGU9bnVsbCxoPW51bGw7dm9pZCAwIT09ZyYmKGU9XCJcIitnKTt2b2lkIDAhPT1hLmtleSYmKGU9XCJcIithLmtleSk7dm9pZCAwIT09YS5yZWYmJihoPWEucmVmKTtmb3IoYiBpbiBhKW0uY2FsbChhLGIpJiYhcC5oYXNPd25Qcm9wZXJ0eShiKSYmKGRbYl09YVtiXSk7aWYoYyYmYy5kZWZhdWx0UHJvcHMpZm9yKGIgaW4gYT1jLmRlZmF1bHRQcm9wcyxhKXZvaWQgMD09PWRbYl0mJihkW2JdPWFbYl0pO3JldHVybnskJHR5cGVvZjprLHR5cGU6YyxrZXk6ZSxyZWY6aCxwcm9wczpkLF9vd25lcjpuLmN1cnJlbnR9fWV4cG9ydHMuRnJhZ21lbnQ9bDtleHBvcnRzLmpzeD1xO2V4cG9ydHMuanN4cz1xO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdrZXknKSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIGsgIT09ICdrZXknO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSkge1xuICAgICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHtcbiAgICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBqc3ggPSAganN4V2l0aFZhbGlkYXRpb25EeW5hbWljIDsgLy8gd2UgbWF5IHdhbnQgdG8gc3BlY2lhbCBjYXNlIGpzeHMgaW50ZXJuYWxseSB0byB0YWtlIGFkdmFudGFnZSBvZiBzdGF0aWMgY2hpbGRyZW4uXG4vLyBmb3Igbm93IHdlIGNhbiBzaGlwIGlkZW50aWNhbCBwcm9kIGZ1bmN0aW9uc1xuXG52YXIganN4cyA9ICBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3ggPSBqc3g7XG5leHBvcnRzLmpzeHMgPSBqc3hzO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgeyBBbmdsZSwgQXJpYWRuZVNlbGVjdGlvbiwgQ29vciB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG4vKipcbiAqIFRha2VuIGZyb20gc2Vxdml6XG4gKiBHaXZlbiBhbiBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudCwgcmV0dXJuIHRoZVxuICogcGF0aCBmb3IgYW4gYXJjIHRoYXQgY2lyY2xlcyB0aGUgcGxhc21pZC4gVGhlIG9wdGlvbmFsIHBhcmFtdGVycyBzd2VlcEZXRCBhbmQgc3dlZXBSRVZcbiAqIGFyZSBuZWVkZWQgZm9yIHNlbGVjdGlvbiBhcmNzICh3aGVyZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcmMgaXNuJ3Qga25vd24gYmVmb3JlaGFuZClcbiAqIGFuZCBhcnJvd0ZXRCBhbmQgYXJyb3dSRVYgYXJlIG5lZWRlZCBmb3IgYW5ub3RhdGlvbnMsIHdoZXJlIHRoZXJlIG1heSBiZSBkaXJlY3Rpb25hbGl0eVxuICovXG5leHBvcnQgY29uc3QgZ2VuQXJjID0gKHtcbiAgY2VudGVyLFxuICBpbm5lclJhZGl1cyxcbiAgbGFyZ2VBcmMsXG4gIGxlbmd0aCxcbiAgb2Zmc2V0LFxuICBvdXRlclJhZGl1cyxcbiAgc2VxTGVuZ3RoLFxufToge1xuICBjZW50ZXI6IENvb3I7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIGxhcmdlQXJjOiBib29sZWFuO1xuICBsZW5ndGg6IG51bWJlcjtcbiAgb2Zmc2V0OiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGxlZnRCb3R0b20gPSBmaW5kQ29vcih7XG4gICAgaW5kZXg6IG9mZnNldCxcbiAgICByYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIGNlbnRlcixcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICBjb25zdCBsZWZ0VG9wID0gZmluZENvb3Ioe1xuICAgIGluZGV4OiBvZmZzZXQsXG4gICAgcmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICBjZW50ZXIsXG4gICAgc2VxTGVuZ3RoLFxuICB9KTtcbiAgY29uc3QgcmlnaHRCb3R0b20gPSBmaW5kQ29vcih7XG4gICAgaW5kZXg6IGxlbmd0aCArIG9mZnNldCxcbiAgICByYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIGNlbnRlcixcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICBjb25zdCByaWdodFRvcCA9IGZpbmRDb29yKHtcbiAgICBpbmRleDogbGVuZ3RoICsgb2Zmc2V0LFxuICAgIHJhZGl1czogb3V0ZXJSYWRpdXMsXG4gICAgY2VudGVyLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIGNvbnN0IHNGbGFnRiA9IDE7XG4gIGNvbnN0IHNGbGFnUiA9IDA7XG5cbiAgY29uc3QgbEFyYyA9IGxhcmdlQXJjID8gMSA6IDA7XG5cbiAgcmV0dXJuIGBNICR7cmlnaHRCb3R0b20ueH0gJHtyaWdodEJvdHRvbS55fVxuICAgICAgQSAke2lubmVyUmFkaXVzfSAke2lubmVyUmFkaXVzfSwgMCwgJHtsQXJjfSwgJHtzRmxhZ1J9LCAke2xlZnRCb3R0b20ueH0gJHtsZWZ0Qm90dG9tLnl9XG4gICAgICBMICR7bGVmdEJvdHRvbS54fSAke2xlZnRCb3R0b20ueX1cbiAgICAgIEwgJHtsZWZ0VG9wLnh9ICR7bGVmdFRvcC55fVxuICAgICAgQSAke291dGVyUmFkaXVzfSAke291dGVyUmFkaXVzfSwgMCwgJHtsQXJjfSwgJHtzRmxhZ0Z9LCAke3JpZ2h0VG9wLnh9ICR7cmlnaHRUb3AueX1cbiAgICAgIFpgO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbmRleCBhbG9uZyB0aGUgcGxhc21pZCBhbmQgaXRzIHJhZGl1cywgZmluZCBzdmcgY29vcmRpbmF0ZVxuICogZnJvbSBzZXF2aXpcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRDb29yID0gKHtcbiAgaW5kZXgsXG4gIHJhZGl1cyxcbiAgY2VudGVyLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICBjZW50ZXI6IENvb3I7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IENvb3IgPT4ge1xuICBjb25zdCBsZW5ndGhQZXJjID0gaW5kZXggLyBzZXFMZW5ndGg7XG4gIGNvbnN0IGxlbmd0aFBlcmNDZW50ZXJlZCA9IGxlbmd0aFBlcmMgLSAwLjI1O1xuICBjb25zdCByYWRpYW5zID0gbGVuZ3RoUGVyY0NlbnRlcmVkICogTWF0aC5QSSAqIDI7XG4gIGNvbnN0IHhBZGp1c3QgPSBNYXRoLmNvcyhyYWRpYW5zKSAqIHJhZGl1cztcbiAgY29uc3QgeUFkanVzdCA9IE1hdGguc2luKHJhZGlhbnMpICogcmFkaXVzO1xuXG4gIHJldHVybiB7XG4gICAgeDogY2VudGVyLnggKyB4QWRqdXN0LFxuICAgIHk6IGNlbnRlci55ICsgeUFkanVzdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaW5kSW5kZXhGcm9tQ29vciA9ICh7XG4gIGNvb3IsXG4gIGNlbnRlcixcbiAgc2VxTGVuZ3RoLFxufToge1xuICBjb29yOiBDb29yO1xuICBjZW50ZXI6IENvb3I7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHggPSBjb29yLnggLSBjZW50ZXIueDtcbiAgY29uc3QgeSA9IGNvb3IueSAtIGNlbnRlci55O1xuICBjb25zdCByYWRpYW5zID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgY29uc3QgbGVuZ3RoUGVyYyA9IHJhZGlhbnMgLyAoTWF0aC5QSSAqIDIpICsgMC4yNTtcbiAgY29uc3QgcmF3QmFzZUlkeCA9IGxlbmd0aFBlcmMgKiBzZXFMZW5ndGg7XG4gIC8vIGlmIHdlJ3JlIGluIG5lZ2F0aXZlIGluZGljZXMsIGNvbnZlcnQgdG8gdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2VcbiAgcmV0dXJuIE1hdGgucm91bmQocmF3QmFzZUlkeCA8IDAgPyBzZXFMZW5ndGggKyByYXdCYXNlSWR4IDogcmF3QmFzZUlkeCk7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZEFuZ2xlRnJvbUNvb3IgPSAoe1xuICBjb29yLFxuICBjZW50ZXIsXG59OiB7XG4gIGNvb3I6IENvb3I7XG4gIGNlbnRlcjogQ29vcjtcbn0pOiBudW1iZXIgPT4ge1xuICBjb25zdCB4ID0gY29vci54IC0gY2VudGVyLng7XG4gIGNvbnN0IHkgPSBjb29yLnkgLSBjZW50ZXIueTtcbiAgbGV0IHJhZGlhbnMgPSBNYXRoLmF0YW4yKHksIHgpO1xuICBpZiAocmFkaWFucyA8IDApIHtcbiAgICByYWRpYW5zID0gcmFkaWFucyArIE1hdGguUEkgKiAyO1xuICB9XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIE1hdGguUEkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRBbmdsZUJldHdlZW5Db29ycyA9ICh7XG4gIGNvb3IxLFxuICBjb29yMixcbiAgY2VudGVyLFxufToge1xuICBjb29yMTogQ29vcjtcbiAgY29vcjI6IENvb3I7XG4gIGNlbnRlcjogQ29vcjtcbn0pOiBudW1iZXIgPT4ge1xuICBjb25zdCBhbmdsZTEgPSBmaW5kQW5nbGVGcm9tQ29vcih7IGNvb3I6IGNvb3IxLCBjZW50ZXIgfSk7XG4gIGNvbnN0IGFuZ2xlMiA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogY29vcjIsIGNlbnRlciB9KTtcbiAgY29uc3QgYW5nbGUgPSBhbmdsZTIgLSBhbmdsZTE7XG4gIHJldHVybiBhbmdsZTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaW5kSW5kZXhGcm9tQW5nbGUgPSAoe1xuICBhbmdsZSxcbiAgc2VxTGVuZ3RoLFxufToge1xuICBhbmdsZTogQW5nbGU7XG4gIHNlcUxlbmd0aDogbnVtYmVyO1xufSk6IG51bWJlciA9PiB7XG4gIC8vIHplcm8gZGVncmVzcyBpcyAyNSUgb2YgdGhlIHNlcXVlbmNlLCBhbmQgd2Ugd2FudCBrZWVwIGRlZ3JlZXMgYmV0d2VlbiAwIGFuZCAzNjBcbiAgbGV0IGVmZmVjdGl2ZUFuZ2xlID0gYW5nbGUuZGVncmVlcyArIDkwO1xuICBpZiAoZWZmZWN0aXZlQW5nbGUgPCAwKSB7XG4gICAgZWZmZWN0aXZlQW5nbGUgPSAzNjAgKyBlZmZlY3RpdmVBbmdsZTtcbiAgfVxuICBlZmZlY3RpdmVBbmdsZSA9IGVmZmVjdGl2ZUFuZ2xlICUgMzYwO1xuICBjb25zdCBhcmNQZXJjID0gZWZmZWN0aXZlQW5nbGUgLyAzNjA7XG5cbiAgY29uc3QgcmF3QmFzZUlkeCA9IGFyY1BlcmMgKiBzZXFMZW5ndGg7XG4gIHJldHVybiBNYXRoLnJvdW5kKHJhd0Jhc2VJZHggPCAwID8gc2VxTGVuZ3RoICsgcmF3QmFzZUlkeCA6IHJhd0Jhc2VJZHgpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsYW1wU2xpY2UgPSAoe1xuICBzbGljZSxcbiAgZmlyc3RJZHgsXG4gIGxhc3RJZHgsXG59OiB7XG4gIHNsaWNlOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgZmlyc3RJZHg6IG51bWJlcjtcbiAgbGFzdElkeDogbnVtYmVyO1xufSk6IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsID0+IHtcbiAgaWYgKCFzbGljZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHNsaWNlO1xuXG4gIGNvbnN0IG91dE9mQm91bmRzQmVmb3JlID0gc3RhcnQgPCBmaXJzdElkeCAmJiBlbmQgPCBmaXJzdElkeDtcbiAgY29uc3Qgb3V0T2ZCb3VuZHNBZnRlciA9IHN0YXJ0ID4gbGFzdElkeCAmJiBlbmQgPiBsYXN0SWR4O1xuXG4gIGlmIChvdXRPZkJvdW5kc0JlZm9yZSB8fCBvdXRPZkJvdW5kc0FmdGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgc3RhcnQgPSBNYXRoLm1pbihzdGFydCwgbGFzdElkeCk7XG4gICAgZW5kID0gTWF0aC5tYXgoZW5kLCBmaXJzdElkeCk7XG4gIH0gZWxzZSB7XG4gICAgZW5kID0gTWF0aC5taW4oZW5kLCBsYXN0SWR4KTtcbiAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBmaXJzdElkeCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgZGlyZWN0aW9uOiBzbGljZS5kaXJlY3Rpb24sXG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ0pBTicsXG4gICdGRUInLFxuICAnTUFSJyxcbiAgJ0FQUicsXG4gICdNQVknLFxuICAnSlVOJyxcbiAgJ0pVTCcsXG4gICdBVUcnLFxuICAnU0VQJyxcbiAgJ09DVCcsXG4gICdOT1YnLFxuICAnREVDJyxcbl07XG4iLCIvKiBlc2xpbnQgbm8tZGl2LXJlZ2V4OiAwKi9cbi8qIGVzbGludCBwcmVmZXItbmFtZWQtY2FwdHVyZS1ncm91cDogMCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1PTlRIUyA9IHJlcXVpcmUoJy4vdXRpbHMvbW9udGhzJyk7XG5cbmZ1bmN0aW9uIGdlbmJhbmtUb0pzb24oc2VxdWVuY2UpIHtcbiAgaWYgKHR5cGVvZiBzZXF1ZW5jZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBsZXQgcmVzdWx0c0FycmF5ID0gW107XG4gIGxldCByZXN1bHQ7XG4gIGxldCBjdXJyZW50RmVhdHVyZU5vdGU7XG5cbiAgLy8gR2VuYmFuayBzcGVjaWZpY2F0aW9uOiBodHRwczovL3d3dy5uY2JpLm5sbS5uaWguZ292L1NpdGVtYXAvc2FtcGxlcmVjb3JkLmh0bWxcbiAgbGV0IGdlbmJhbmtBbm5vdGF0aW9uS2V5ID0ge1xuICAgIC8vIENvbnRhaW5zIGluIG9yZGVyOiBsb2N1cyBuYW1lLCBzZXF1ZW5jZSBsZW5ndGgsIG1vbGVjdWxlIHR5cGUgKGUuZy4gRE5BKSwgZ2VuYmFuayBkaXZpc2lvbiAoc2VlIDEtMTggYmVsb3cpLCBtb2RpZmljYXRpb24gZGF0ZVxuICAgIC8vIGxvY3VzIGRlZmluaXRpb24gaGFzIGNoYW5nZWQgd2l0aCB0aW1lLCB1c2UgYWNjZXNzaW9uIG51bWJlciBmb3IgYSB1bmlxdWUgaWRlbnRpZmllclxuICAgIExPQ1VTX1RBRzogJ0xPQ1VTJyxcbiAgICBERUZJTklUSU9OX1RBRzogJ0RFRklOSVRJT04nLFxuICAgIC8vIEFjY2Vzc2lvbiB0YWdcbiAgICAvLyBFeGFtcGxlOiBaNzg1MzNcbiAgICBBQ0NFU1NJT05fVEFHOiAnQUNDRVNTSU9OJyxcbiAgICAvLyBUaGUgdmVyc2lvbiB0YWcgY29udGFpbnMgMiBpbmZvcm1hdGlvbnNcbiAgICAvLyBUaGUgYWNjZXNzaW9uIG51bWJlciB3aXRoIGEgcmV2aXNpb25cbiAgICAvLyBUaGUgR0kgKEdlbkluZm8gSWRlbnRpZmllciksIGEgbmNiaSBzZXF1ZW50aWFsIG51bWJlclxuICAgIC8vIEV4YW1wbGU6IFo3ODUzMy4xICBHSToyNzY1NjU4XG4gICAgLy8gVW5pY2l0eSBnYXJhbnRlZWQgd2l0aCByZXNwZWN0IHRvIHNlcXVlbmNlLiBJZiAxIG51Y2xlb3RpZGUgY2hhbmdlcywgdGhlIHZlcnNpb24gaXMgZGlmZmVyZW50LlxuICAgIFZFUlNJT05fVEFHOiAnVkVSU0lPTicsXG4gICAgS0VZV09SRFNfVEFHOiAnS0VZV09SRFMnLFxuICAgIC8vIFNFR01FTlRfVEFHOlwiU0VHTUVOVFwiXG4gICAgLy8gU291cmNlIGlzIGZyZWUgdGV4dFxuICAgIFNPVVJDRV9UQUc6ICdTT1VSQ0UnLFxuICAgIE9SR0FOSVNNX1RBRzogJ09SR0FOSVNNJyxcbiAgICBSRUZFUkVOQ0VfVEFHOiAnUkVGRVJFTkNFJyxcbiAgICBBVVRIT1JTX1RBRzogJ0FVVEhPUlMnLFxuICAgIENPTlNPUlRJVU1fVEFHOiAnQ09OU1JUTScsXG4gICAgVElUTEVfVEFHOiAnVElUTEUnLFxuICAgIC8vIENhbiBiZSBtdWx0aXBsZSBqb3VybmFsIHRhZ3NcbiAgICBKT1VSTkFMX1RBRzogJ0pPVVJOQUwnLFxuICAgIFBVQk1FRF9UQUc6ICdQVUJNRUQnLFxuICAgIFJFTUFSS19UQUc6ICdSRU1BUksnLFxuICAgIEZFQVRVUkVTX1RBRzogJ0ZFQVRVUkVTJyxcbiAgICBCQVNFX0NPVU5UX1RBRzogJ0JBU0UgQ09VTlQnLFxuICAgIC8vIENPTlRJR19UQUc6IFwiQ09OVElHXCJcbiAgICBPUklHSU5fVEFHOiAnT1JJR0lOJyxcbiAgICBFTkRfU0VRVUVOQ0VfVEFHOiAnLy8nLFxuICB9O1xuXG4gIC8vIEdlbmJhbmsgZGl2aXNpb25zXG4gIC8vICAgMS4gUFJJIC0gcHJpbWF0ZSBzZXF1ZW5jZXNcbiAgLy8gICAyLiBST0QgLSByb2RlbnQgc2VxdWVuY2VzXG4gIC8vICAgMy4gTUFNIC0gb3RoZXIgbWFtbWFsaWFuIHNlcXVlbmNlc1xuICAvLyAgIDQuIFZSVCAtIG90aGVyIHZlcnRlYnJhdGUgc2VxdWVuY2VzXG4gIC8vICAgNS4gSU5WIC0gaW52ZXJ0ZWJyYXRlIHNlcXVlbmNlc1xuICAvLyAgIDYuIFBMTiAtIHBsYW50LCBmdW5nYWwsIGFuZCBhbGdhbCBzZXF1ZW5jZXNcbiAgLy8gICA3LiBCQ1QgLSBiYWN0ZXJpYWwgc2VxdWVuY2VzXG4gIC8vICAgOC4gVlJMIC0gdmlyYWwgc2VxdWVuY2VzXG4gIC8vICAgOS4gUEhHIC0gYmFjdGVyaW9waGFnZSBzZXF1ZW5jZXNcbiAgLy8gMTAuIFNZTiAtIHN5bnRoZXRpYyBzZXF1ZW5jZXNcbiAgLy8gMTEuIFVOQSAtIHVuYW5ub3RhdGVkIHNlcXVlbmNlc1xuICAvLyAxMi4gRVNUIC0gRVNUIHNlcXVlbmNlcyAoZXhwcmVzc2VkIHNlcXVlbmNlIHRhZ3MpXG4gIC8vIDEzLiBQQVQgLSBwYXRlbnQgc2VxdWVuY2VzXG4gIC8vIDE0LiBTVFMgLSBTVFMgc2VxdWVuY2VzIChzZXF1ZW5jZSB0YWdnZWQgc2l0ZXMpXG4gIC8vIDE1LiBHU1MgLSBHU1Mgc2VxdWVuY2VzIChnZW5vbWUgc3VydmV5IHNlcXVlbmNlcylcbiAgLy8gMTYuIEhURyAtIEhURyBzZXF1ZW5jZXMgKGhpZ2gtdGhyb3VnaHB1dCBnZW5vbWljIHNlcXVlbmNlcylcbiAgLy8gMTcuIEhUQyAtIHVuZmluaXNoZWQgaGlnaC10aHJvdWdocHV0IGNETkEgc2VxdWVuY2luZ1xuICAvLyAxOC4gRU5WIC0gZW52aXJvbm1lbnRhbCBzYW1wbGluZyBzZXF1ZW5jZXNcblxuICBsZXQgbGluZXMgPSBzZXF1ZW5jZS5zcGxpdCgvXFxyP1xcbi8pO1xuICBsZXQgZmllbGROYW1lO1xuICBsZXQgc3ViRmllbGRUeXBlO1xuICBsZXQgZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb247XG4gIGxldCBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnO1xuICBsZXQgbGFzdExpbmVXYXNMb2NhdGlvbjtcblxuICBsZXQgaGFzRm91bmRMb2N1cyA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBpZiAobGluZSA9PT0gbnVsbCkgYnJlYWs7XG4gICAgbGV0IGxpbmVGaWVsZE5hbWUgPSBnZXRMaW5lRmllbGROYW1lKGxpbmUpO1xuICAgIGxldCB2YWwgPSBnZXRMaW5lVmFsKGxpbmUpO1xuICAgIGxldCBpc1N1YktleSA9IGlzU3ViS2V5d29yZChsaW5lKTtcbiAgICBsZXQgaXNLZXkgPSBpc0tleXdvcmQobGluZSk7XG5cbiAgICBpZiAobGluZUZpZWxkTmFtZSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuRU5EX1NFUVVFTkNFX1RBRyB8fCBpc0tleSkge1xuICAgICAgZmllbGROYW1lID0gbGluZUZpZWxkTmFtZTtcbiAgICAgIHN1YkZpZWxkVHlwZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChpc1N1YktleSkge1xuICAgICAgc3ViRmllbGRUeXBlID0gbGluZUZpZWxkTmFtZTtcbiAgICB9XG4gICAgLy8gSUdOT1JFIExJTkVTOiBETyBOT1QgRVZFTiBQUk9DRVNTXG4gICAgaWYgKGxpbmUudHJpbSgpID09PSAnJyB8fCBsaW5lRmllbGROYW1lID09PSAnOycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghaGFzRm91bmRMb2N1cyAmJiBmaWVsZE5hbWUgIT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5LkxPQ1VTX1RBRykge1xuICAgICAgLy8gJ0dlbmJhbmsgZmlsZXMgbXVzdCBzdGFydCB3aXRoIGEgTE9DVVMgdGFnIHNvIHRoaXMgbXVzdCBub3QgYmUgYSBnZW5iYW5rJ1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmaWVsZE5hbWUpIHtcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuTE9DVVNfVEFHOlxuICAgICAgICBoYXNGb3VuZExvY3VzID0gdHJ1ZTtcbiAgICAgICAgcGFyc2VMb2N1cyhsaW5lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LkZFQVRVUkVTX1RBRzpcbiAgICAgICAgcGFyc2VGZWF0dXJlcyhsaW5lLCBsaW5lRmllbGROYW1lLCB2YWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuT1JJR0lOX1RBRzpcbiAgICAgICAgcGFyc2VPcmlnaW4obGluZSwgbGluZUZpZWxkTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5ERUZJTklUSU9OX1RBRzpcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuQUNDRVNTSU9OX1RBRzpcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuVkVSU0lPTl9UQUc6XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LktFWVdPUkRTX1RBRzpcbiAgICAgICAgcGFyc2VNdWx0aUxpbmVGaWVsZChmaWVsZE5hbWUsIGxpbmUsIGZpZWxkTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LlNPVVJDRV9UQUc6XG4gICAgICAgIGlmIChzdWJGaWVsZFR5cGUgPT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5Lk9SR0FOSVNNX1RBRykge1xuICAgICAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQoc3ViRmllbGRUeXBlLCBsaW5lLCAnb3JnYW5pc20nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZU11bHRpTGluZUZpZWxkKGxpbmVGaWVsZE5hbWUsIGxpbmUsICdzb3VyY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuUkVGRVJFTkNFX1RBRzpcbiAgICAgICAgaWYgKGxpbmVGaWVsZE5hbWUgPT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5LlJFRkVSRU5DRV9UQUcpIHtcbiAgICAgICAgICBjb25zdCByZWYgPSByZXN1bHQucmVmZXJlbmNlcyB8fCBbXTtcbiAgICAgICAgICByZXN1bHQucmVmZXJlbmNlcyA9IHJlZjtcbiAgICAgICAgICByZWYucHVzaCh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VSZWZlcmVuY2UobGluZSwgc3ViRmllbGRUeXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LkVORF9TRVFVRU5DRV9UQUc6XG4gICAgICAgIGVuZFNlcSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFVuaGFuZGxlZCB0YWdcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2F0Y2ggdGhlIGNhc2Ugd2hlcmUgd2UndmUgc3VjY2Vzc2Z1bGx5IHN0YXJ0ZWQgYSBzZXF1ZW5jZSBhbmQgcGFyc2VkIGl0LCBidXQgZW5kU2VxIGlzbid0IGNhbGxlZCBjb3JyZWN0bHlcbiAgaWYgKHJlc3VsdHNBcnJheVtyZXN1bHRzQXJyYXkubGVuZ3RoIC0gMV0gIT09IHJlc3VsdCkge1xuICAgIC8vIGN1cnJlbnQgcmVzdWx0IGlzbid0IGluIHJlc3VsdHNBcnJheSB5ZXRcbiAgICAvLyBzbyB3ZSBjYWxsIGVuZFNlcSBoZXJlXG4gICAgZW5kU2VxKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHNBcnJheTtcblxuICBmdW5jdGlvbiBlbmRTZXEoKSB7XG4gICAgLy8gZG8gc29tZSBwb3N0IHByb2Nlc3NpbmcgY2xlYW4tdXBcbiAgICBwb3N0UHJvY2Vzc0N1clNlcSgpO1xuICAgIC8vIHB1c2ggdGhlIHJlc3VsdCBpbnRvIHRoZSByZXN1bHRzQXJyYXlcbiAgICByZXN1bHRzQXJyYXkucHVzaChyZXN1bHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudEZlYXR1cmUoKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5mZWF0dXJlc1tyZXN1bHQuZmVhdHVyZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0UHJvY2Vzc0N1clNlcSgpIHtcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5mZWF0dXJlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LmZlYXR1cmVzW2ldID0gcG9zdFByb2Nlc3NHZW5iYW5rRmVhdHVyZShyZXN1bHQuZmVhdHVyZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT3JpZ2luKGxpbmUsIGtleSkge1xuICAgIGlmIChrZXkgIT09IGdlbmJhbmtBbm5vdGF0aW9uS2V5Lk9SSUdJTl9UQUcpIHtcbiAgICAgIGxldCBuZXdMaW5lID0gbGluZS5yZXBsYWNlKC9bXFxzXSpbMC05XSovZywgJycpO1xuICAgICAgcmVzdWx0LnNlcXVlbmNlICs9IG5ld0xpbmU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2N1cyhsaW5lKSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgbmFtZTogJ1VudGl0bGVkIHNlcXVlbmNlJyxcbiAgICAgIHNlcXVlbmNlOiAnJyxcbiAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgIH07XG4gICAgbGluZSA9IHJlbW92ZUZpZWxkTmFtZShnZW5iYW5rQW5ub3RhdGlvbktleS5MT0NVU19UQUcsIGxpbmUpO1xuICAgIGNvbnN0IG0gPSBsaW5lLm1hdGNoKFxuICAgICAgL14oW15cXHNdKylcXHMrKFxcZCspXFxzK2JwXFxzKyhbXlxcc10rKVxccysoW15cXHNdKylcXHMrKFteXFxzXSspXFxzKihbXlxcc10rKT8kLyxcbiAgICApO1xuICAgIGxldCBsb2N1c05hbWUgPSBtWzFdO1xuICAgIGxldCBzaXplID0gK21bMl07XG4gICAgbGV0IG1vbGVjdWxlVHlwZSA9IG1bM107XG4gICAgbGV0IGNpcmN1bGFyID0gbVs0XSA9PT0gJ2NpcmN1bGFyJztcbiAgICBjb25zdCBzZXEgPSByZXN1bHQ7XG4gICAgbGV0IGRhdGVTdHIgPSAnJztcbiAgICBpZiAoIW1bNl0pIHtcbiAgICAgIGRhdGVTdHIgPSBtWzVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXEuZ2VuYmFua0RpdmlzaW9uID0gbVs1XTtcbiAgICAgIGRhdGVTdHIgPSBtWzZdO1xuICAgIH1cbiAgICBzZXEuY2lyY3VsYXIgPSBjaXJjdWxhcjtcbiAgICBzZXEubW9sZWN1bGVUeXBlID0gbW9sZWN1bGVUeXBlO1xuICAgIGNvbnN0IGRhdGVNYXRjaCA9IGRhdGVTdHIubWF0Y2goL14oXFxkezJ9KS0oLnszfSktKFxcZHs0fSkkLyk7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcigrZGF0ZU1hdGNoWzNdKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKE1PTlRIUy5pbmRleE9mKGRhdGVNYXRjaFsyXS50b1VwcGVyQ2FzZSgpKSk7XG4gICAgZGF0ZS5zZXREYXRlKCtkYXRlTWF0Y2hbMV0pO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMTIpO1xuICAgIGRhdGUuc2V0TWludXRlcygwKTtcbiAgICBkYXRlLnNldFNlY29uZHMoMCk7XG4gICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgc2VxLmRhdGUgPSBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgc2VxLm5hbWUgPSBsb2N1c05hbWU7XG4gICAgc2VxLnNpemUgPSBzaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRmllbGROYW1lKGZOYW1lLCBsaW5lKSB7XG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXlxccyovLCAnJyk7XG4gICAgaWYgKGxpbmUuaW5kZXhPZihmTmFtZSkgPT09IDApIHtcbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoZk5hbWUsICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2UobGluZSwgc3ViVHlwZSkge1xuICAgIGNvbnN0IHJlZnMgPSByZXN1bHQucmVmZXJlbmNlcztcbiAgICBsZXQgbGFzdFJlZiA9IHJlZnNbcmVmcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIXN1YlR5cGUpIHtcbiAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQoXG4gICAgICAgIGdlbmJhbmtBbm5vdGF0aW9uS2V5LlJFRkVSRU5DRV9UQUcsXG4gICAgICAgIGxpbmUsXG4gICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgIGxhc3RSZWYsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZU11bHRpTGluZUZpZWxkKHN1YlR5cGUsIGxpbmUsIHN1YlR5cGUudG9Mb3dlckNhc2UoKSwgbGFzdFJlZik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGZWF0dXJlcyhsaW5lLCBrZXksIHZhbCkge1xuICAgIGxldCBzdHJhbmQ7XG4gICAgLy8gRk9SIFRIRSBNQUlOIEZFQVRVUkVTIExPQ0FUSU9OL1FVQUxJRklFUiBMSU5FXG4gICAgaWYgKGtleSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuRkVBVFVSRVNfVEFHKSB7XG4gICAgICBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGFzdExpbmVXYXNGZWF0dXJlc1RhZykge1xuICAgICAgLy8gd2UgbmVlZCB0byBnZXQgdGhlIGluZGVudGF0aW9uIG9mIGZlYXR1cmUgbG9jYXRpb25zXG4gICAgICBmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbiA9IGdldExlbmd0aE9mV2hpdGVTcGFjZUJlZm9yZVN0YXJ0T2ZMZXR0ZXJzKFxuICAgICAgICBsaW5lLFxuICAgICAgKTtcbiAgICAgIC8vIHNldCBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnIHRvIGZhbHNlXG4gICAgICBsYXN0TGluZVdhc0ZlYXR1cmVzVGFnID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRk9SIExPQ0FUSU9OICYmIFFVQUxJRklFUiBMSU5FU1xuICAgIGlmIChpc0ZlYXR1cmVMaW5lUnVub24obGluZSwgZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb24pKSB7XG4gICAgICAvLyB0aGUgbGluZSBpcyBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgYWJvdmUgbGluZVxuICAgICAgaWYgKGxhc3RMaW5lV2FzTG9jYXRpb24pIHtcbiAgICAgICAgLy8gdGhlIGxhc3QgbGluZSB3YXMgYSBsb2NhdGlvbiwgc28gdGhlIHJ1bi1vbiBsaW5lIGlzIGV4cGVjdGVkIHRvIGJlIGEgZmVhdHVyZSBsb2NhdGlvbiBhcyB3ZWxsXG4gICAgICAgIHBhcnNlRmVhdHVyZUxvY2F0aW9uKGxpbmUudHJpbSgpKTtcbiAgICAgICAgbGFzdExpbmVXYXNMb2NhdGlvbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgbGFzdCBsaW5lIHdhcyBhIG5vdGVcbiAgICAgICAgaWYgKGN1cnJlbnRGZWF0dXJlTm90ZSkge1xuICAgICAgICAgIC8vIGFwcGVuZCB0byB0aGUgY3VycmVudEZlYXR1cmVOb3RlXG4gICAgICAgICAgY3VycmVudEZlYXR1cmVOb3RlW1xuICAgICAgICAgICAgY3VycmVudEZlYXR1cmVOb3RlLmxlbmd0aCAtIDFcbiAgICAgICAgICBdICs9IGxpbmUudHJpbSgpLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGluZVdhc0xvY2F0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyBFbGVtZW50L1F1YWxpZmllciBsaW5lcy4gTm90IHJ1bm9uIGxpbmVzLlxuICAgICAgaWYgKGlzTm90ZShsaW5lKSkge1xuICAgICAgICAvLyBpcyBhIG5ldyBGZWF0dXJlIEVsZW1lbnQgKGUuZy4gc291cmNlLCBDRFMpIGluIHRoZSBmb3JtIG9mICBcIltcXHNdIEtFWSAgU0VRTE9DQVRJT05cIlxuICAgICAgICAvLyBpcyBhIEZlYXR1cmVRdWFsaWZpZXIgaW4gdGhlIC9LRVk9XCJCTEFIXCIgZm9ybWF0OyBjb3VsZCBiZSBtdWx0aXBsZSBwZXIgRWxlbWVudFxuICAgICAgICAvLyBDaGVjayB0aGF0IGZlYXR1cmUgZGlkIG5vdCBnZXQgc2tpcHBlZCBmb3IgbWlzc2luZyBsb2NhdGlvblxuICAgICAgICBpZiAoZ2V0Q3VycmVudEZlYXR1cmUoKSkge1xuICAgICAgICAgIHBhcnNlRmVhdHVyZU5vdGUobGluZSk7XG4gICAgICAgICAgbGFzdExpbmVXYXNMb2NhdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgbGluZSBpcyBhIGxvY2F0aW9uLCBzbyB3ZSBtYWtlIGEgbmV3IGZlYXR1cmUgZnJvbSBpdFxuICAgICAgICBpZiAodmFsLm1hdGNoKC9jb21wbGVtZW50L2cpKSB7XG4gICAgICAgICAgc3RyYW5kID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyYW5kID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0ZlYXR1cmUoKTtcbiAgICAgICAgbGV0IGZlYXQgPSBnZXRDdXJyZW50RmVhdHVyZSgpO1xuICAgICAgICBmZWF0LnR5cGUgPSBrZXk7XG4gICAgICAgIGZlYXQuc3RyYW5kID0gc3RyYW5kO1xuXG4gICAgICAgIHBhcnNlRmVhdHVyZUxvY2F0aW9uKHZhbCk7XG4gICAgICAgIGxhc3RMaW5lV2FzTG9jYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld0ZlYXR1cmUoKSB7XG4gICAgcmVzdWx0LmZlYXR1cmVzLnB1c2goe1xuICAgICAgbm90ZXM6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb3RlKGxpbmUpIHtcbiAgICBsZXQgcXVhbCA9IGZhbHNlO1xuICAgIC8qIGlmIChsaW5lLmNoYXJBdCgyMSkgPT09IFwiL1wiKSB7Ly9ULkguIEhhcmQgY29kZWQgbWV0aG9kXG4gICAgICAgICAgIHF1YWwgPSB0cnVlO1xuICAgICAgICAgfSovXG4gICAgaWYgKGxpbmUudHJpbSgpLmNoYXJBdCgwKS5tYXRjaCgvXFwvLykpIHtcbiAgICAgIC8vIHNlYXJjaGVzIGJhc2VkIG9uIGxvb2tpbmcgZm9yIC8gaW4gYmVnaW5uaW5nIG9mIGxpbmVcbiAgICAgIHF1YWwgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaCgvXltcXHNdKlxcL1tcXHddKz1bXFxTXSsvKSkge1xuICAgICAgLy8gc2VhcmNoZXMgYmFzZWQgb24gXCIgICAva2V5PUJMQUhcIiByZWdleFxuICAgICAgcXVhbCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBxdWFsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGZWF0dXJlTG9jYXRpb24obG9jU3RyKSB7XG4gICAgbG9jU3RyID0gbG9jU3RyLnRyaW0oKTtcbiAgICBsZXQgbG9jQXJyID0gW107XG4gICAgbG9jU3RyLnJlcGxhY2UoLyhcXGQrKS9nLCBmdW5jdGlvbiAoc3RyaW5nLCBtYXRjaCkge1xuICAgICAgbG9jQXJyLnB1c2gobWF0Y2gpO1xuICAgIH0pO1xuICAgIGxldCBmZWF0ID0gZ2V0Q3VycmVudEZlYXR1cmUoKTtcbiAgICBmZWF0LnN0YXJ0ID0gK2xvY0FyclswXTtcbiAgICBmZWF0LmVuZCA9IGxvY0FyclsxXSA9PT0gdW5kZWZpbmVkID8gK2xvY0FyclswXSA6ICtsb2NBcnJbMV07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZlYXR1cmVOb3RlKGxpbmUpIHtcbiAgICBsZXQgbmV3TGluZSwgbGluZUFycjtcblxuICAgIG5ld0xpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICBuZXdMaW5lID0gbmV3TGluZS5yZXBsYWNlKC9eXFwvfFwiJC9nLCAnJyk7XG4gICAgbGluZUFyciA9IG5ld0xpbmUuc3BsaXQoLz1cInw9Lyk7XG5cbiAgICBsZXQgdmFsID0gbGluZUFyclsxXTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXFxcL2csICcgJyk7XG5cbiAgICAgIGlmIChsaW5lLm1hdGNoKC89XCIvZykpIHtcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1wiLiovZywgJycpO1xuICAgICAgfSBlbHNlIGlmICh2YWwubWF0Y2goL15cXGQrJC9nKSkge1xuICAgICAgICB2YWwgPSArdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQga2V5ID0gbGluZUFyclswXTtcbiAgICBsZXQgY3VycmVudE5vdGVzID0gZ2V0Q3VycmVudEZlYXR1cmUoKS5ub3RlcztcbiAgICBpZiAoY3VycmVudE5vdGVzW2tleV0pIHtcbiAgICAgIC8vIGFycmF5IGFscmVhZHkgZXhpc3RzLCBzbyBwdXNoIHZhbHVlIGludG8gaXRcbiAgICAgIGN1cnJlbnROb3Rlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXJyYXkgZG9lc24ndCBleGlzdCB5ZXQsIHNvIGNyZWF0ZSBpdCBhbmQgcG9wdWxhdGUgaXQgd2l0aCB0aGUgdmFsdWVcbiAgICAgIGN1cnJlbnROb3Rlc1trZXldID0gW3ZhbF07XG4gICAgfVxuICAgIGN1cnJlbnRGZWF0dXJlTm90ZSA9IGN1cnJlbnROb3Rlc1trZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZUZpZWxkTmFtZShsaW5lKSB7XG4gICAgbGV0IGFycjtcbiAgICBsaW5lID0gbGluZS50cmltKCk7XG5cbiAgICBhcnIgPSBsaW5lLnNwbGl0KC9bXFxzXSsvKTtcblxuICAgIHJldHVybiBhcnJbMF07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU11bHRpTGluZUZpZWxkKGZOYW1lLCBsaW5lLCByZXN1bHRLZXksIHIpIHtcbiAgICByID0gciB8fCByZXN1bHQ7XG4gICAgbGV0IGZpZWxkVmFsdWUgPSByZW1vdmVGaWVsZE5hbWUoZk5hbWUsIGxpbmUpO1xuICAgIHJbcmVzdWx0S2V5XSA9IHJbcmVzdWx0S2V5XSA/IGAke3JbcmVzdWx0S2V5XX0gYCA6ICcnO1xuICAgIHJbcmVzdWx0S2V5XSArPSBmaWVsZFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZVZhbChsaW5lKSB7XG4gICAgbGV0IGFycjtcblxuICAgIGlmIChsaW5lLmluZGV4T2YoJz0nKSA8IDApIHtcbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL15bXFxzXSpbXFxTXStbXFxzXSt8W1xcc10rJC8sICcnKTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnIgPSBsaW5lLnNwbGl0KC89Lyk7XG4gICAgICByZXR1cm4gYXJyWzFdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzS2V5d29yZChsaW5lKSB7XG4gICAgbGV0IGlzS2V5ID0gZmFsc2U7XG4gICAgaWYgKGxpbmUuc3Vic3RyKDAsIDEwKS5tYXRjaCgvXltcXFNdKy8pKSB7XG4gICAgICBpc0tleSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc0tleTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ViS2V5d29yZChsaW5lKSB7XG4gICAgbGV0IGlzU3ViS2V5ID0gZmFsc2U7XG4gICAgaWYgKGxpbmUuc3Vic3RyKDAsIDEwKS5tYXRjaCgvXltcXHNdK1tcXFNdKy8pKSB7XG4gICAgICBpc1N1YktleSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1N1YktleTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RQcm9jZXNzR2VuYmFua0ZlYXR1cmUoZmVhdCkge1xuICAgIGlmIChmZWF0Lm5vdGVzLmxhYmVsKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLmxhYmVsWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5nZW5lKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLmdlbmVbMF07XG4gICAgfSBlbHNlIGlmIChmZWF0Lm5vdGVzLkFwRWluZm9fbGFiZWwpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMuQXBFaW5mb19sYWJlbFswXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMubmFtZSkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5uYW1lWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5vcmdhbmlzbSkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5vcmdhbmlzbVswXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMubG9jdXNfdGFnKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLmxvY3VzX3RhZ1swXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMubm90ZSkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5ub3RlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmZWF0Lm5hbWUgPSAnVW50aXRsZWQgRmVhdHVyZSc7XG4gICAgfVxuICAgIGZlYXQubmFtZSA9IHR5cGVvZiBmZWF0Lm5hbWUgPT09ICdzdHJpbmcnID8gZmVhdC5uYW1lIDogU3RyaW5nKGZlYXQubmFtZSk7XG4gICAgcmV0dXJuIGZlYXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGZWF0dXJlTGluZVJ1bm9uKGxpbmUsIGZlYXR1cmVMb2NhdGlvbkluZGVudGF0aW9uKSB7XG4gIGxldCBpbmRlbnRhdGlvbk9mTGluZSA9IGdldExlbmd0aE9mV2hpdGVTcGFjZUJlZm9yZVN0YXJ0T2ZMZXR0ZXJzKGxpbmUpO1xuICBpZiAoZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb24gPT09IGluZGVudGF0aW9uT2ZMaW5lKSB7XG4gICAgLy8gdGhlIGZlYXR1cmUgbG9jYXRpb24gaW5kZW50YXRpb24gY2FsY3VsYXRlZCByaWdodCBhZnRlciB0aGUgZmVhdHVyZSB0YWdcbiAgICAvLyBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBsaW5lXG4gICAgLy9cbiAgICAvLyBGRUFUVVJFUyAgICAgICAgICAgICBMb2NhdGlvbi9RdWFsaWZpZXJzXG4gICAgLy8gICAgIHJlcF9vcmlnaW4gICAgICBjb21wbGVtZW50KDEwNzQuLjMzMDIpXG4gICAgLy8gMDEyMzQgIDwtLSB0aGlzIGlzIHRoZSBpbmRlbnRhdGlvbiB3ZSdyZSB0YWxraW5nIGFib3V0XG4gICAgcmV0dXJuIGZhbHNlOyAvLyB0aGUgbGluZSBpcyBOT1QgYSBydW4gb25cbiAgfVxuXG4gIGxldCB0cmltbWVkID0gbGluZS50cmltKCk7XG4gIGlmICh0cmltbWVkLmNoYXJBdCgwKS5tYXRjaCgvXFwvLykpIHtcbiAgICAvLyB0aGUgZmlyc3QgY2hhciBpbiB0aGUgdHJpbW1lZCBsaW5lIGNhbm5vdCBiZSBhIC9cbiAgICByZXR1cm4gZmFsc2U7IC8vIHRoZSBsaW5lIGlzIE5PVCBhIHJ1biBvblxuICB9XG4gIC8vIHRoZSBsaW5lIGlzIGEgcnVuIG9uXG4gIHJldHVybiB0cnVlO1xuICAvLyBydW4tb24gbGluZSBleGFtcGxlOlxuICAvLyBGRUFUVVJFUyAgICAgICAgICAgICBMb2NhdGlvbi9RdWFsaWZpZXJzXG4gIC8vICAgICByZXBfb3JpZ2luICAgICAgY29tcGxlbWVudCgxMDc0Li4zMzAyKVxuICAvLyAgICAgICAgICAgICAgICAgL2xhYmVsPXBTQzEwMSoqXG4gIC8vICAgICAgICAgICAgICAgICAvbm90ZT1cIlJFUF9PUklHSU4gUkVQX09SSUdJTiBwU0MxMDEqIGFrYSBwTVBQNiwgZ2l2ZXMgcGxhc21cbiAgLy8gICAgICAgICAgICAgICAgIGlkIG51bWJlciAzIC00IGNvcGllcyBwZXIgY2VsbCwgQmdsSUkgc2l0ZSBpbiBwU0MxMDEqIG9yaSBoIDwtLXJ1bi1vbiBsaW5lIVxuICAvLyAgICAgICAgICAgICAgICAgYXMgYmVlbiBkZWxlIHRlZCBieSBxdWljayBjaGFuZ2UgYWdhdGNUIGNoYW5nZWQgdG8gYWdhdGNBIGcgPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICBpdmluZyBwU0MxMDEqICogcFNDMTAxKiBha2EgcE1QUDYsIGdpdmVzIHBsYXNtaWQgbnVtYmVyIDMtNCA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgIGNvcGllcyBwIGVyIGNlbGwsIEJnbElJIHNpdGUgaW4gcFNDMTAxKiBvcmkgaGFzIGJlZW4gZGVsZXQgIDwtLXJ1bi1vbiBsaW5lIVxuICAvLyAgICAgICAgICAgICAgICAgZWQgYnkgcXVpYyBrIGNoYW5nZSBhZ2F0Y1QgY2hhbmdlZCB0byBhZ2F0Y0EgZ2l2aW5nIHBTQzEwMSogPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICAqIFtwQmJTMGEtUkZQXVwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICAvZ2VuZT1cIlNDMTAxKiogT3JpXCJcbiAgLy8gICAgICAgICAgICAgICAgIC9ub3RlPVwicFNDMTAxKiBha2EgcE1QUDYsIGdpdmVzIHBsYXNtaWQgbnVtYmVyIDMtNCBjb3BpZXMgcFxuICAvLyAgICAgICAgICAgICAgICAgZXIgY2VsbCwgQmdsSUkgc2l0ZSBpbiBwU0MxMDEqIG9yaSBoYXMgYmVlbiBkZWxldGVkIGJ5IHF1aVxuICAvLyAgICAgICAgICAgICAgICAgYyBrIGNoYW5nZSBhZ2F0Y1QgY2hhbmdlZCB0byBhZ2F0Y0EgZ2l2aW5nIHBTQzEwMSoqXCJcbiAgLy8gICAgICAgICAgICAgICAgIC92bnRpZmtleT1cIjMzXCJcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoT2ZXaGl0ZVNwYWNlQmVmb3JlU3RhcnRPZkxldHRlcnMoc3RyaW5nKSB7XG4gIGxldCBtYXRjaCA9IC9eXFxzKi8uZXhlYyhzdHJpbmcpO1xuICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuYmFua1RvSnNvbjtcbiIsInZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgdXRpbC5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgICAgIC5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSlcbiAgICAgICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XG5jb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm5hblwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJ1bmRlZmluZWRcIixcbiAgICBcIm51bGxcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJtYXBcIixcbiAgICBcInNldFwiLFxuXSk7XG5jb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuXG5jb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5jb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcblxuY29uc3QgZXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5cbmxldCBvdmVycmlkZUVycm9yTWFwID0gZXJyb3JNYXA7XG5mdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG5cbmNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uKGlzc3VlRGF0YS5wYXRoIHx8IFtdKV07XG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIH07XG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5jb25zdCBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBlcnJvck1hcCA/IHVuZGVmaW5lZCA6IGVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5jb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5jb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5jb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5jb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxudmFyIF9ab2RFbnVtX2NhY2hlLCBfWm9kTmF0aXZlRW51bV9jYWNoZTtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IHJlcXVpcmVkX2Vycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2IgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBpbnZhbGlkX3R5cGVfZXJyb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5jbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5hc3luYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgXCJ+dmFsaWRhdGVcIihkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6ICEhdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcbi8vIGNvbnN0IHV1aWRSZWdleCA9XG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaTtcbmNvbnN0IG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbmNvbnN0IGp3dFJlZ2V4ID0gL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLztcbmNvbnN0IGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuLy8gZmFzdGVyLCBzaW1wbGVyLCBzYWZlclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbmNvbnN0IGlwdjRDaWRyUmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLztcbi8vIGNvbnN0IGlwdjZSZWdleCA9XG4vLyAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKSQvO1xuY29uc3QgaXB2NkNpZHJSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC87XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcbmNvbnN0IGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuLy8gaHR0cHM6Ly9iYXNlNjQuZ3VydS9zdGFuZGFyZHMvYmFzZTY0dXJsXG5jb25zdCBiYXNlNjR1cmxSZWdleCA9IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLztcbi8vIHNpbXBsZVxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9YDtcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tKCgwWzEzNTc4XXwxMHwxMiktMzF8KDBbMTMtOV18MVswLTJdKS0zMHwoMFsxLTldfDFbMC0yXSktKDBbMS05XXwxXFxcXGR8MlxcXFxkKSlgO1xuLy8gd2l0aCBsZWFwIHllYXIgdmFsaWRhdGlvblxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGBeJHtkYXRlUmVnZXhTb3VyY2V9JGApO1xuZnVuY3Rpb24gdGltZVJlZ2V4U291cmNlKGFyZ3MpIHtcbiAgICAvLyBsZXQgcmVnZXggPSBgXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn1gO1xuICAgIGxldCByZWdleCA9IGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZDpbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgcmVnZXggPSBgJHtyZWdleH0oXFxcXC5cXFxcZCspP2A7XG4gICAgfVxuICAgIHJldHVybiByZWdleDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcbiAgICBjb25zdCBvcHRzID0gW107XG4gICAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgICBpZiAoYXJncy5vZmZzZXQpXG4gICAgICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gICAgcmVnZXggPSBgJHtyZWdleH0oJHtvcHRzLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSldUKGp3dCwgYWxnKSB7XG4gICAgaWYgKCFqd3RSZWdleC50ZXN0KGp3dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0dXJsIHRvIGJhc2U2NFxuICAgICAgICBjb25zdCBiYXNlNjQgPSBoZWFkZXJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL18vZywgXCIvXCIpXG4gICAgICAgICAgICAucGFkRW5kKGhlYWRlci5sZW5ndGggKyAoKDQgLSAoaGVhZGVyLmxlbmd0aCAlIDQpKSAlIDQpLCBcIj1cIik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVjb2RlZCAhPT0gXCJvYmplY3RcIiB8fCBkZWNvZGVkID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQudHlwIHx8ICFkZWNvZGVkLmFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFsZyAmJiBkZWNvZGVkLmFsZyAhPT0gYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibmFub2lkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkMlJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpbmNsdWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZHVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJqd3RcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiand0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDaWRyKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjR1cmxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgZW1vamkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIG5hbm9pZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkMlwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVsaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NHVybChtZXNzYWdlKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgand0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBpcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBjaWRyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgIGxvY2FsOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcbiAgICB9XG4gICAgdGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgICAqL1xuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvd2VyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1VwcGVyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzTkFOT0lEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ0lEUigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xufVxuY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgIChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbCwgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgICAgICBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdGaWVsZCBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICAgIH1cbn1cblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbn1cblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3R5cGUudmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbCkge1xuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEJyYW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5jbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGRpc2NyaW1pbmF0b3IpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zTWFwLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gICAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xuICAgIGNvbnN0IGJUeXBlID0gZ2V0UGFyc2VkVHlwZShiKTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gdXRpbFxuICAgICAgICAgICAgLm9iamVjdEtleXMoYSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXG4gICAgICAgIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5jbGFzcyBab2RJbnRlcnNlY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlVmFsdWVzKHBhcnNlZExlZnQudmFsdWUsIHBhcnNlZFJpZ2h0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXG4gICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RNYXAgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZSwgbWVzc2FnZSkubWF4KHNpemUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIG1pblNpemU6IG51bGwsXG4gICAgICAgIG1heFNpemU6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJnc1xuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgICB9XG4gICAgcmV0dXJuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICAgIH1cbiAgICBhcmdzKC4uLml0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGFyZ3MsIHJldHVybnMsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IChhcmdzXG4gICAgICAgICAgICAgICAgPyBhcmdzXG4gICAgICAgICAgICAgICAgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5jbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9ab2RFbnVtX2NhY2hlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4Y2x1ZGUodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5fWm9kRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5jbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9ab2ROYXRpdmVFbnVtX2NhY2hlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiZcbiAgICAgICAgICAgIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuX1pvZE5hdGl2ZUVudW1fY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmXG4gICAgICAgICAgICBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlXG4gICAgICAgICAgICA/IGN0eC5kYXRhXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIHNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc2VkKS50aGVuKGFzeW5jIChwcm9jZXNzZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW5uZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gICAgfVxufVxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICBlZmZlY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RPcHRpb25hbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGxhYmxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kTnVsbGFibGUuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHBhcmFtcy5kZWZhdWx0XG4gICAgICAgICAgICA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxuICAgICAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IG5ld0N0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNvbnN0IEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxufVxuY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQaXBlbGluZSh7XG4gICAgICAgICAgICBpbjogYSxcbiAgICAgICAgICAgIG91dDogYixcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IE9iamVjdC5mcmVlemUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KVxuICAgICAgICAgICAgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKVxuICAgICAgICAgICAgOiBmcmVlemUocmVzdWx0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RSZWFkb25seS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICB6LmN1c3RvbSAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGNsZWFuUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBwYXJhbXMoZGF0YSlcbiAgICAgICAgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHsgbWVzc2FnZTogcGFyYW1zIH1cbiAgICAgICAgICAgIDogcGFyYW1zO1xuICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgcmV0dXJuIHAyO1xufVxuZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBfcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gKF9iID0gKF9hID0gcGFyYW1zLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gKF9iID0gKF9hID0gcGFyYW1zLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG5jb25zdCBsYXRlID0ge1xuICAgIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcbi8vIGNvbnN0IGluc3RhbmNlT2ZUeXBlID0gPFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuY2xzLCBwYXJhbXMgPSB7XG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IGNvZXJjZSA9IHtcbiAgICBzdHJpbmc6ICgoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAgICAgLi4uYXJnLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgfSkpLFxuICAgIGJpZ2ludDogKChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxufTtcbmNvbnN0IE5FVkVSID0gSU5WQUxJRDtcblxudmFyIHogPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHRFcnJvck1hcDogZXJyb3JNYXAsXG4gICAgc2V0RXJyb3JNYXA6IHNldEVycm9yTWFwLFxuICAgIGdldEVycm9yTWFwOiBnZXRFcnJvck1hcCxcbiAgICBtYWtlSXNzdWU6IG1ha2VJc3N1ZSxcbiAgICBFTVBUWV9QQVRIOiBFTVBUWV9QQVRILFxuICAgIGFkZElzc3VlVG9Db250ZXh0OiBhZGRJc3N1ZVRvQ29udGV4dCxcbiAgICBQYXJzZVN0YXR1czogUGFyc2VTdGF0dXMsXG4gICAgSU5WQUxJRDogSU5WQUxJRCxcbiAgICBESVJUWTogRElSVFksXG4gICAgT0s6IE9LLFxuICAgIGlzQWJvcnRlZDogaXNBYm9ydGVkLFxuICAgIGlzRGlydHk6IGlzRGlydHksXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBpc0FzeW5jOiBpc0FzeW5jLFxuICAgIGdldCB1dGlsICgpIHsgcmV0dXJuIHV0aWw7IH0sXG4gICAgZ2V0IG9iamVjdFV0aWwgKCkgeyByZXR1cm4gb2JqZWN0VXRpbDsgfSxcbiAgICBab2RQYXJzZWRUeXBlOiBab2RQYXJzZWRUeXBlLFxuICAgIGdldFBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUsXG4gICAgWm9kVHlwZTogWm9kVHlwZSxcbiAgICBkYXRldGltZVJlZ2V4OiBkYXRldGltZVJlZ2V4LFxuICAgIFpvZFN0cmluZzogWm9kU3RyaW5nLFxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxuICAgIFpvZEJpZ0ludDogWm9kQmlnSW50LFxuICAgIFpvZEJvb2xlYW46IFpvZEJvb2xlYW4sXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcbiAgICBab2RTeW1ib2w6IFpvZFN5bWJvbCxcbiAgICBab2RVbmRlZmluZWQ6IFpvZFVuZGVmaW5lZCxcbiAgICBab2ROdWxsOiBab2ROdWxsLFxuICAgIFpvZEFueTogWm9kQW55LFxuICAgIFpvZFVua25vd246IFpvZFVua25vd24sXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxuICAgIFpvZFZvaWQ6IFpvZFZvaWQsXG4gICAgWm9kQXJyYXk6IFpvZEFycmF5LFxuICAgIFpvZE9iamVjdDogWm9kT2JqZWN0LFxuICAgIFpvZFVuaW9uOiBab2RVbmlvbixcbiAgICBab2REaXNjcmltaW5hdGVkVW5pb246IFpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICBab2RJbnRlcnNlY3Rpb246IFpvZEludGVyc2VjdGlvbixcbiAgICBab2RUdXBsZTogWm9kVHVwbGUsXG4gICAgWm9kUmVjb3JkOiBab2RSZWNvcmQsXG4gICAgWm9kTWFwOiBab2RNYXAsXG4gICAgWm9kU2V0OiBab2RTZXQsXG4gICAgWm9kRnVuY3Rpb246IFpvZEZ1bmN0aW9uLFxuICAgIFpvZExhenk6IFpvZExhenksXG4gICAgWm9kTGl0ZXJhbDogWm9kTGl0ZXJhbCxcbiAgICBab2RFbnVtOiBab2RFbnVtLFxuICAgIFpvZE5hdGl2ZUVudW06IFpvZE5hdGl2ZUVudW0sXG4gICAgWm9kUHJvbWlzZTogWm9kUHJvbWlzZSxcbiAgICBab2RFZmZlY3RzOiBab2RFZmZlY3RzLFxuICAgIFpvZFRyYW5zZm9ybWVyOiBab2RFZmZlY3RzLFxuICAgIFpvZE9wdGlvbmFsOiBab2RPcHRpb25hbCxcbiAgICBab2ROdWxsYWJsZTogWm9kTnVsbGFibGUsXG4gICAgWm9kRGVmYXVsdDogWm9kRGVmYXVsdCxcbiAgICBab2RDYXRjaDogWm9kQ2F0Y2gsXG4gICAgWm9kTmFOOiBab2ROYU4sXG4gICAgQlJBTkQ6IEJSQU5ELFxuICAgIFpvZEJyYW5kZWQ6IFpvZEJyYW5kZWQsXG4gICAgWm9kUGlwZWxpbmU6IFpvZFBpcGVsaW5lLFxuICAgIFpvZFJlYWRvbmx5OiBab2RSZWFkb25seSxcbiAgICBjdXN0b206IGN1c3RvbSxcbiAgICBTY2hlbWE6IFpvZFR5cGUsXG4gICAgWm9kU2NoZW1hOiBab2RUeXBlLFxuICAgIGxhdGU6IGxhdGUsXG4gICAgZ2V0IFpvZEZpcnN0UGFydHlUeXBlS2luZCAoKSB7IHJldHVybiBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7IH0sXG4gICAgY29lcmNlOiBjb2VyY2UsXG4gICAgYW55OiBhbnlUeXBlLFxuICAgIGFycmF5OiBhcnJheVR5cGUsXG4gICAgYmlnaW50OiBiaWdJbnRUeXBlLFxuICAgIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxuICAgIGRhdGU6IGRhdGVUeXBlLFxuICAgIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcbiAgICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxuICAgICdlbnVtJzogZW51bVR5cGUsXG4gICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb25UeXBlLFxuICAgICdpbnN0YW5jZW9mJzogaW5zdGFuY2VPZlR5cGUsXG4gICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb25UeXBlLFxuICAgIGxhenk6IGxhenlUeXBlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxuICAgIG1hcDogbWFwVHlwZSxcbiAgICBuYW46IG5hblR5cGUsXG4gICAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXG4gICAgbmV2ZXI6IG5ldmVyVHlwZSxcbiAgICAnbnVsbCc6IG51bGxUeXBlLFxuICAgIG51bGxhYmxlOiBudWxsYWJsZVR5cGUsXG4gICAgbnVtYmVyOiBudW1iZXJUeXBlLFxuICAgIG9iamVjdDogb2JqZWN0VHlwZSxcbiAgICBvYm9vbGVhbjogb2Jvb2xlYW4sXG4gICAgb251bWJlcjogb251bWJlcixcbiAgICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxuICAgIG9zdHJpbmc6IG9zdHJpbmcsXG4gICAgcGlwZWxpbmU6IHBpcGVsaW5lVHlwZSxcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgICBwcm9taXNlOiBwcm9taXNlVHlwZSxcbiAgICByZWNvcmQ6IHJlY29yZFR5cGUsXG4gICAgc2V0OiBzZXRUeXBlLFxuICAgIHN0cmljdE9iamVjdDogc3RyaWN0T2JqZWN0VHlwZSxcbiAgICBzdHJpbmc6IHN0cmluZ1R5cGUsXG4gICAgc3ltYm9sOiBzeW1ib2xUeXBlLFxuICAgIHRyYW5zZm9ybWVyOiBlZmZlY3RzVHlwZSxcbiAgICB0dXBsZTogdHVwbGVUeXBlLFxuICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWRUeXBlLFxuICAgIHVuaW9uOiB1bmlvblR5cGUsXG4gICAgdW5rbm93bjogdW5rbm93blR5cGUsXG4gICAgJ3ZvaWQnOiB2b2lkVHlwZSxcbiAgICBORVZFUjogTkVWRVIsXG4gICAgWm9kSXNzdWVDb2RlOiBab2RJc3N1ZUNvZGUsXG4gICAgcXVvdGVsZXNzSnNvbjogcXVvdGVsZXNzSnNvbixcbiAgICBab2RFcnJvcjogWm9kRXJyb3Jcbn0pO1xuXG5leHBvcnQgeyBCUkFORCwgRElSVFksIEVNUFRZX1BBVEgsIElOVkFMSUQsIE5FVkVSLCBPSywgUGFyc2VTdGF0dXMsIFpvZFR5cGUgYXMgU2NoZW1hLCBab2RBbnksIFpvZEFycmF5LCBab2RCaWdJbnQsIFpvZEJvb2xlYW4sIFpvZEJyYW5kZWQsIFpvZENhdGNoLCBab2REYXRlLCBab2REZWZhdWx0LCBab2REaXNjcmltaW5hdGVkVW5pb24sIFpvZEVmZmVjdHMsIFpvZEVudW0sIFpvZEVycm9yLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQsIFpvZEZ1bmN0aW9uLCBab2RJbnRlcnNlY3Rpb24sIFpvZElzc3VlQ29kZSwgWm9kTGF6eSwgWm9kTGl0ZXJhbCwgWm9kTWFwLCBab2ROYU4sIFpvZE5hdGl2ZUVudW0sIFpvZE5ldmVyLCBab2ROdWxsLCBab2ROdWxsYWJsZSwgWm9kTnVtYmVyLCBab2RPYmplY3QsIFpvZE9wdGlvbmFsLCBab2RQYXJzZWRUeXBlLCBab2RQaXBlbGluZSwgWm9kUHJvbWlzZSwgWm9kUmVhZG9ubHksIFpvZFJlY29yZCwgWm9kVHlwZSBhcyBab2RTY2hlbWEsIFpvZFNldCwgWm9kU3RyaW5nLCBab2RTeW1ib2wsIFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIsIFpvZFR1cGxlLCBab2RUeXBlLCBab2RVbmRlZmluZWQsIFpvZFVuaW9uLCBab2RVbmtub3duLCBab2RWb2lkLCBhZGRJc3N1ZVRvQ29udGV4dCwgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGNvZXJjZSwgY3VzdG9tLCBkYXRlVHlwZSBhcyBkYXRlLCBkYXRldGltZVJlZ2V4LCB6IGFzIGRlZmF1bHQsIGVycm9yTWFwIGFzIGRlZmF1bHRFcnJvck1hcCwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBnZXRFcnJvck1hcCwgZ2V0UGFyc2VkVHlwZSwgaW5zdGFuY2VPZlR5cGUgYXMgaW5zdGFuY2VvZiwgaW50ZXJzZWN0aW9uVHlwZSBhcyBpbnRlcnNlY3Rpb24sIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbGF0ZSwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFrZUlzc3VlLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9iamVjdFV0aWwsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIHBpcGVsaW5lVHlwZSBhcyBwaXBlbGluZSwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcXVvdGVsZXNzSnNvbiwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzZXRFcnJvck1hcCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdXRpbCwgdm9pZFR5cGUgYXMgdm9pZCwgeiB9O1xuIiwiaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcblxuZXhwb3J0IGNvbnN0IGNvb3JTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHg6IHoubnVtYmVyKCksXG4gIHk6IHoubnVtYmVyKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IGFuZ2xlU2NoZW1hID0gei5vYmplY3Qoe1xuICBkZWdyZWVzOiB6Lm51bWJlcigpLFxuICBjZW50ZXI6IGNvb3JTY2hlbWEsXG59KTtcblxuZXhwb3J0IGNvbnN0IGFubm90YXRpb25UeXBlU2NoZW1hID0gei51bmlvbihbXG4gIHoubGl0ZXJhbChcIkNEU1wiKSxcbiAgei5saXRlcmFsKFwiZW5oYW5jZXJcIiksXG4gIHoubGl0ZXJhbChcImludHJvblwiKSxcbiAgei5saXRlcmFsKFwibWlzY19mZWF0dXJlXCIpLFxuICB6LmxpdGVyYWwoXCJwb2x5QV9zaWduYWxcIiksXG4gIHoubGl0ZXJhbChcInByb21vdGVyXCIpLFxuICB6LmxpdGVyYWwoXCJwcm90ZWluX2JpbmRcIiksXG4gIHoubGl0ZXJhbChcInJlcF9vcmlnaW5cIiksXG4gIHoubGl0ZXJhbChcIkxUUlwiKSxcbiAgei5zdHJpbmcoKSxcbl0pO1xuXG5leHBvcnQgY29uc3QgYW5ub3RhdGlvblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgdHlwZTogYW5ub3RhdGlvblR5cGVTY2hlbWEsXG4gIGRpcmVjdGlvbjogei51bmlvbihbei5saXRlcmFsKFwiZm9yd2FyZFwiKSwgei5saXRlcmFsKFwicmV2ZXJzZVwiKV0pLFxuICBzdGFydDogei5udW1iZXIoKSxcbiAgZW5kOiB6Lm51bWJlcigpLFxuICBjbGFzc05hbWU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdGV4dDogei5zdHJpbmcoKSxcbiAgb25DbGljazogei5mdW5jdGlvbigpLmFyZ3Moei5hbnkoKSkub3B0aW9uYWwoKSwgLy8gY2lyY3VsYXIgcmVmZXJlbmNlXG59KTtcblxuZXhwb3J0IGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9uU2NoZW1hID0gYW5ub3RhdGlvblNjaGVtYS5leHRlbmQoe1xuICBzdGFjazogei5udW1iZXIoKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgbnVjbFNjaGVtYSA9IHoudW5pb24oW1xuICB6LmxpdGVyYWwoXCJBXCIpLFxuICB6LmxpdGVyYWwoXCJDXCIpLFxuICB6LmxpdGVyYWwoXCJHXCIpLFxuICB6LmxpdGVyYWwoXCJUXCIpLFxuXSk7XG5cbmV4cG9ydCBjb25zdCBhYVNjaGVtYSA9IHoudW5pb24oW1xuICAvLyBBZGQgYWxsIHlvdXIgYW1pbm8gYWNpZHMgbGl0ZXJhbHMgaGVyZVxuICB6LmxpdGVyYWwoXCJBXCIpLFxuICB6LmxpdGVyYWwoXCJDXCIpLFxuICB6LmxpdGVyYWwoXCJEXCIpLFxuICB6LmxpdGVyYWwoXCJFXCIpLFxuICB6LmxpdGVyYWwoXCJGXCIpLFxuICB6LmxpdGVyYWwoXCJHXCIpLFxuICB6LmxpdGVyYWwoXCJIXCIpLFxuICB6LmxpdGVyYWwoXCJJXCIpLFxuICB6LmxpdGVyYWwoXCJLXCIpLFxuICB6LmxpdGVyYWwoXCJMXCIpLFxuICB6LmxpdGVyYWwoXCJNXCIpLFxuICB6LmxpdGVyYWwoXCJOXCIpLFxuICB6LmxpdGVyYWwoXCJQXCIpLFxuICB6LmxpdGVyYWwoXCJRXCIpLFxuICB6LmxpdGVyYWwoXCJSXCIpLFxuICB6LmxpdGVyYWwoXCJTXCIpLFxuICB6LmxpdGVyYWwoXCJUXCIpLFxuICB6LmxpdGVyYWwoXCJWXCIpLFxuICB6LmxpdGVyYWwoXCJXXCIpLFxuICB6LmxpdGVyYWwoXCJZXCIpLFxuXSk7XG5leHBvcnQgY29uc3QgR2FwU2NoZW1hID0gei5saXRlcmFsKFwiLVwiKTtcbmV4cG9ydCBjb25zdCBTdG9wU2NoZW1hID0gei5saXRlcmFsKFwiKlwiKTtcbmV4cG9ydCBjb25zdCBTcGFjZVNjaGVtYSA9IHoubGl0ZXJhbChcIiBcIik7XG5leHBvcnQgY29uc3QgVW5rbm93blNjaGVtYSA9IHoubGl0ZXJhbChcIj9cIik7XG5leHBvcnQgY29uc3QgYW5ub3RhdGVkQmFzZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgYmFzZTogei5zdHJpbmcoKS5sZW5ndGgoMSksXG4gIGFubm90YXRpb25zOiB6LmFycmF5KHN0YWNrZWRBbm5vdGF0aW9uU2NoZW1hKSxcbiAgaW5kZXg6IHoubnVtYmVyKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hID0gei5hcnJheShhbm5vdGF0ZWRCYXNlU2NoZW1hKTtcblxuZXhwb3J0IGNvbnN0IGFyaWFkbmVTZWxlY3Rpb25TY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHN0YXJ0OiB6Lm51bWJlcigpLFxuICBlbmQ6IHoubnVtYmVyKCksXG4gIGRpcmVjdGlvbjogei51bmlvbihbei5saXRlcmFsKFwiZm9yd2FyZFwiKSwgei5saXRlcmFsKFwicmV2ZXJzZVwiKV0pLFxufSk7XG4iLCJpbXBvcnQgZ2VuYmFua1BhcnNlciwgeyBQYXJzZWRHZW5iYW5rIH0gZnJvbSBcImdlbmJhbmstcGFyc2VyXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgYW5ub3RhdGVkU2VxdWVuY2VTY2hlbWEsIGFubm90YXRpb25UeXBlU2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hc1wiO1xuaW1wb3J0IHsgQW5ub3RhdGlvbiwgQW5ub3RhdGlvblR5cGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMsIHN0YWNrQW5uc0J5VHlwZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBHZW5iYW5rRmVhdHVyZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgbmFtZTogei5zdHJpbmcoKS5taW4oMSksXG4gIHN0YXJ0OiB6Lm51bWJlcigpLFxuICBlbmQ6IHoubnVtYmVyKCksXG4gIHN0cmFuZDogei51bmlvbihbei5saXRlcmFsKDEpLCB6LmxpdGVyYWwoLTEpXSksXG4gIHR5cGU6IGFubm90YXRpb25UeXBlU2NoZW1hLFxuICBub3Rlczogei5yZWNvcmQoei5hcnJheSh6LnN0cmluZygpKSkub3B0aW9uYWwoKSxcbn0pO1xuZXhwb3J0IHR5cGUgR2VuYmFua0ZlYXR1cmUgPSB6LmluZmVyPHR5cGVvZiBHZW5iYW5rRmVhdHVyZVNjaGVtYT47XG5cbmV4cG9ydCBjb25zdCBnZW5iYW5rVG9Bbm5vdGF0ZWRTZXF1ZW5jZSA9ICh7XG4gIGdlbmJhbmssXG4gIGFubm90YXRpb25PbkNsaWNrLFxufToge1xuICBnZW5iYW5rOiBQYXJzZWRHZW5iYW5rO1xuICBhbm5vdGF0aW9uT25DbGljaz86IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uKSA9PiB2b2lkO1xufSkgPT4ge1xuICBjb25zdCBmZWF0dXJlcyA9IGdlbmJhbmsuZmVhdHVyZXMubWFwKChmZWF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIEdlbmJhbmtGZWF0dXJlU2NoZW1hLnBhcnNlKGZlYXR1cmUpO1xuICB9KTtcbiAgY29uc3QgYW5ub3RhdGlvbnMgPSBnZW5iYW5rRmVhdHVyZXNUb0Fubm90YXRpb25zKHtcbiAgICBmZWF0dXJlcyxcbiAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgfSk7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrQW5uc0J5VHlwZShhbm5vdGF0aW9ucyk7XG4gIGNvbnN0IHsgc3VjY2Vzc2VzLCBmYWlsdXJlcyB9ID0gc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMoe1xuICAgIHBheWxvYWQ6IGdlbmJhbmsuc2VxdWVuY2UsXG4gICAgcGF5bG9hZFR5cGU6IFwicmF3XCIsXG4gICAgYW5ub3RhdGlvbnM6IHN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgfSk7XG4gIGlmIChmYWlsdXJlcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgZ2VuYmFuazogJHtmYWlsdXJlc1swXX1gKTtcbiAgfVxuICBpZiAoc3VjY2Vzc2VzLmxlbmd0aCAhPT0gMSB8fCBzdWNjZXNzZXNbMF0uc2VxdWVuY2VzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXhhY3RseSBvbmUgYW5ub3RhdGVkIHNlcXVlbmNlYCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFubm90YXRlZFNlcXVlbmNlOiBhbm5vdGF0ZWRTZXF1ZW5jZVNjaGVtYS5wYXJzZShzdWNjZXNzZXNbMF0uc2VxdWVuY2VzWzBdKSxcbiAgICBhbm5vdGF0aW9ucyxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5iYW5rRmVhdHVyZXNUb0Fubm90YXRpb25zID0gKHtcbiAgZmVhdHVyZXMsXG4gIGFubm90YXRpb25PbkNsaWNrLFxufToge1xuICBmZWF0dXJlczogR2VuYmFua0ZlYXR1cmVbXTtcbiAgYW5ub3RhdGlvbk9uQ2xpY2s/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4gdm9pZDtcbn0pOiBBbm5vdGF0aW9uW10gPT4ge1xuICByZXR1cm4gZmVhdHVyZXMubWFwKChmZWF0dXJlKSA9PiB7XG4gICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gW2ZlYXR1cmUuc3RhcnQsIGZlYXR1cmUuZW5kXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZmVhdHVyZS50eXBlLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBsYWJlbDogZmVhdHVyZS50eXBlLFxuICAgICAgdGV4dDogZmVhdHVyZS5uYW1lLFxuICAgICAgZGlyZWN0aW9uOiBmZWF0dXJlLnN0cmFuZCA9PT0gMSA/IFwiZm9yd2FyZFwiIDogXCJyZXZlcnNlXCIsXG4gICAgICBjbGFzc05hbWU6IGdldENsYXNzTmFtZUZyb21GZWF0dXJlVHlwZShmZWF0dXJlLnR5cGUpLFxuICAgICAgb25DbGljazogYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgfTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lRnJvbUZlYXR1cmVUeXBlKGFublR5cGU6IEFubm90YXRpb25UeXBlKTogc3RyaW5nIHtcbiAgY29uc3QgY29tbW9uID1cbiAgICBcImN1cnNvci1wb2ludGVyIG9wYWNpdHktNjAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgIXRleHQteHMgaG92ZXI6b3BhY2l0eS0xMDAgcG9pbnRlci1ldmVudHMtYWxsIHRleHQtd2hpdGUgdGV4dC1jbGlwIG92ZXJmbG93LWhpZGRlbiB3aGl0ZXNwYWNlLW5vd3JhcFwiO1xuICBjb25zdCBjbGFzc05hbWVNYXA6IHsgW2tleTogQW5ub3RhdGlvblR5cGVdOiBzdHJpbmcgfSA9IHppcEFycmF5cyhcbiAgICBbXG4gICAgICBcIkNEU1wiLFxuICAgICAgXCJlbmhhbmNlclwiLFxuICAgICAgXCJpbnRyb25cIixcbiAgICAgIFwibWlzY19mZWF0dXJlXCIsXG4gICAgICBcInBvbHlBX3NpZ25hbFwiLFxuICAgICAgXCJwcm9tb3RlclwiLFxuICAgICAgXCJwcm90ZWluX2JpbmRcIixcbiAgICAgIFwicmVwX29yaWdpblwiLFxuICAgICAgXCJMVFJcIixcbiAgICAgIFwic291cmNlXCIsXG4gICAgICBcImluc2VydGlvblwiLFxuICAgIF0sXG4gICAgW1xuICAgICAgXCJiZy1yZWQtNjAwIGZpbGwtcmVkLTYwMCBzdHJva2UtcmVkLTYwMFwiLFxuICAgICAgXCJiZy1ibHVlLTYwMCBmaWxsLWJsdWUtNjAwIHN0cm9rZS1ibHVlLTYwMFwiLFxuICAgICAgXCJiZy1ncmVlbi02MDAgZmlsbC1ncmVlbi02MDAgc3Ryb2tlLWdyZWVuLTYwMFwiLFxuICAgICAgXCJiZy15ZWxsb3ctNjAwIGZpbGwteWVsbG93LTYwMCBzdHJva2UteWVsbG93LTYwMFwiLFxuICAgICAgXCJiZy1vcmFuZ2UtNjAwIGZpbGwtb3JhbmdlLTYwMCBzdHJva2Utb3JhbmdlLTYwMFwiLFxuICAgICAgXCJiZy1wdXJwbGUtNjAwIGZpbGwtcHVycGxlLTYwMCBzdHJva2UtcHVycGxlLTYwMFwiLFxuICAgICAgXCJiZy1za3ktNjAwIGZpbGwtc2t5LTYwMCBzdHJva2Utc2t5LTYwMFwiLFxuICAgICAgXCJiZy10ZWFsLTYwMCBmaWxsLXRlYWwtNjAwIHN0cm9rZS10ZWFsLTYwMFwiLFxuICAgICAgXCJiZy1ncmF5LTYwMCBmaWxsLWdyYXktNjAwIHN0cm9rZS1ncmF5LTYwMFwiLFxuICAgICAgXCJiZy1waW5rLTYwMCBmaWxsLXBpbmstNjAwIHN0cm9rZS1waW5rLTYwMFwiLFxuICAgIF0sXG4gICk7XG4gIGlmIChhbm5UeXBlIGluIGNsYXNzTmFtZU1hcCkge1xuICAgIHJldHVybiBgJHtjb21tb259ICR7Y2xhc3NOYW1lTWFwW2FublR5cGVdIX1gO1xuICB9XG4gIHJldHVybiBjb21tb247XG59XG5cbmV4cG9ydCBjb25zdCB6aXBBcnJheXMgPSA8VDEsIFQyPihrZXlzOiBUMVtdLCB2YWx1ZXM6IFQyW10pID0+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBrZXlzLm1hcCgoa2V5OiBUMSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCB2YWw6IFQyIHwgdW5kZWZpbmVkID0gdmFsdWVzW2ldO1xuICAgICAgcmV0dXJuIFtrZXksIHZhbF07XG4gICAgfSksXG4gICkgYXMgeyBUMTogVDIgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdlbmJhbmsgPSAoZ2VuYmFua1N0cmluZzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGdlbmJhbmtQYXJzZXIoZ2VuYmFua1N0cmluZyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiaW1wb3J0IGdlbmJhbmtQYXJzZXIsIHsgUGFyc2VkR2VuYmFuayB9IGZyb20gXCJnZW5iYW5rLXBhcnNlclwiO1xuaW1wb3J0IHsgZ2VuYmFua1RvQW5ub3RhdGVkU2VxdWVuY2UgfSBmcm9tIFwiLi9nZW5iYW5rVXRpbHNcIjtcbmltcG9ydCB7IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hc1wiO1xuaW1wb3J0IHR5cGUge1xuICBBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgQW5ub3RhdGlvbixcbiAgQW5ub3RhdGlvblR5cGUsXG4gIEFyaWFkbmVTZWxlY3Rpb24sXG4gIFN0YWNrZWRBbm5vdGF0aW9uLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0Q29tcGxlbWVudCA9IChzZXF1ZW5jZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNvbXBsZW1lbnQ6IHtcbiAgICBba2V5OiBzdHJpbmddOiBcIkFcIiB8IFwiVFwiIHwgXCJDXCIgfCBcIkdcIiB8IFwiTlwiO1xuICB9ID0ge1xuICAgIEE6IFwiVFwiLFxuICAgIFQ6IFwiQVwiLFxuICAgIEM6IFwiR1wiLFxuICAgIEc6IFwiQ1wiLFxuICAgIE46IFwiTlwiLFxuICB9O1xuICByZXR1cm4gc2VxdWVuY2VcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKChiYXNlKSA9PiB7XG4gICAgICBpZiAoYmFzZSBpbiBjb21wbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBjb21wbGVtZW50W2Jhc2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmpvaW4oXCJcIik7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QW5ub3RhdGVkU2VxdWVuY2UgPSAoe1xuICBzZXF1ZW5jZSxcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBub1ZhbGlkYXRlLFxufToge1xuICBzZXF1ZW5jZTogc3RyaW5nO1xuICBzdGFja2VkQW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgbm9WYWxpZGF0ZT86IGJvb2xlYW47XG59KTogQW5ub3RhdGVkU2VxdWVuY2UgPT4ge1xuICAvKiBsb29wIHRocm91Z2ggc2VxdWVuY2UgZmluZGluZyBhbGwgYW5ub2F0YXRpb25zIHRoYXQgYXBwbHkgdG8gZWFjaCBiYXNlICovXG4gIGNvbnN0IG1hcEZuID0gKGJhc2U6IHN0cmluZywgaWR4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBhbm5vdGF0aW9uc0ZvckJhc2UgPSBzdGFja2VkQW5ub3RhdGlvbnMuZmlsdGVyKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAvLyBpZiB0aGUgYW5ub3RhdGlvbiBzcGFucyB0aGUgc2VhbSBvZiB0aGUgcGxhc21pZFxuICAgICAgaWYgKGFubm90YXRpb24uc3RhcnQgPiBhbm5vdGF0aW9uLmVuZCkge1xuICAgICAgICBjb25zdCBpc0JldHdlZW5Bbm5vdGF0aW9uU3RhcnRBbmRFbmRvZlNlcXVlbmNlID1cbiAgICAgICAgICBpZHggPj0gYW5ub3RhdGlvbi5zdGFydCAmJiBpZHggPD0gc2VxdWVuY2UubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc0JldHdlZW5TdGFydE9mU2VxdWVuY2VBbmRBbm5vdGF0aW9uRW5kID1cbiAgICAgICAgICBpZHggPj0gMCAmJiBpZHggPD0gYW5ub3RhdGlvbi5lbmQ7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaXNCZXR3ZWVuQW5ub3RhdGlvblN0YXJ0QW5kRW5kb2ZTZXF1ZW5jZSB8fFxuICAgICAgICAgIGlzQmV0d2VlblN0YXJ0T2ZTZXF1ZW5jZUFuZEFubm90YXRpb25FbmRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlZ3VsYXIgY2FzZVxuICAgICAgICByZXR1cm4gaWR4ID49IGFubm90YXRpb24uc3RhcnQgJiYgaWR4IDw9IGFubm90YXRpb24uZW5kO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlLFxuICAgICAgaW5kZXg6IGlkeCxcbiAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9uc0ZvckJhc2UsXG4gICAgICBjb21wbGVtZW50OiBnZXRDb21wbGVtZW50KGJhc2UpLFxuICAgIH07XG4gIH07XG4gIGNvbnN0IHJhdyA9IHNlcXVlbmNlXG4gICAgLnNwbGl0KFwiXCIpXG4gICAgLm1hcChtYXBGbilcbiAgICAuZmlsdGVyKCh4KSA9PiB4LmJhc2UgIT09IFwiIFwiKTsgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2UgPSBhbm5vdGF0ZWRTZXF1ZW5jZVNjaGVtYS5zYWZlUGFyc2UocmF3KTtcbiAgaWYgKG5vVmFsaWRhdGUpIHtcbiAgICBpZiAoYW5ub3RhdGVkU2VxdWVuY2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnNvbGUud2Fybihhbm5vdGF0ZWRTZXF1ZW5jZS5lcnJvcik7XG4gICAgfVxuICAgIHJldHVybiByYXcgYXMgdW5rbm93biBhcyBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgfVxuICBpZiAoYW5ub3RhdGVkU2VxdWVuY2Uuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYW5ub3RhdGVkU2VxdWVuY2UuZXJyb3IubWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIGFubm90YXRlZFNlcXVlbmNlLmRhdGE7XG59O1xuXG5pbnRlcmZhY2UgU3RhY2thYmxlIHtcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG59XG4vLyBtb2RpZmllZCBmcm9tIHNlcXZpelxuZXhwb3J0IGNvbnN0IHN0YWNrRWxlbWVudHMgPSA8VCBleHRlbmRzIFN0YWNrYWJsZT4oZWxlbWVudHM6IFRbXSkgPT4ge1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIHV0aWxpdHkgZnVuY3MgZm9yIHN0YWNrRWxlbWVudHNcbiAgY29uc3QgbGFzdCA9IChhcnI6IFRbXSk6IFQgPT4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgY29uc3QgZmlyc3QgPSAoYXJyOiBUW10pOiBUID0+IGFyclswXTtcbiAgY29uc3QgbWF4SW5kZXggPSBlbGVtZW50cy5tYXAoKGUpID0+IGUuZW5kKS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKTtcblxuICBjb25zdCBzdGFjazogVFtdW10gPSBbXTtcbiAgZWxlbWVudHMuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGNvbnN0IGluc2VydEluZGV4ID0gc3RhY2suZmluZEluZGV4KChlbGVtcykgPT4ge1xuICAgICAgaWYgKGEuZW5kID09PSBhLnN0YXJ0KSB7XG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGhhcyB0aGUgc2FtZSBzdGFydCBhbmQgZW5kIGluZGV4IGFuZCB0aGVyZWZvcmUgc3BhbnMgdGhlIHdob2xlIGFuZCBnZXRzIGl0cyBvd24gcm93XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0KGVsZW1zKS5lbmQgPD0gbGFzdChlbGVtcykuc3RhcnQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGlzIHJvdyBjcm9zc2VzIHplcm8gaW5kZXggaXQgZ2V0cyBpdHMgb3duIHJvd1xuICAgICAgICByZXR1cm4gbGFzdChlbGVtcykuZW5kICsgbWF4SW5kZXggPD0gYS5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChhLmVuZCA+IGEuc3RhcnQpIHtcbiAgICAgICAgLy8gdGhpcyBlbGVtZW50IGRvZXNuJ3QgY3Jvc3MgdGhlIHplcm8gaW5kZXggYW5kIHRoZSBsYXN0IGluIHJvdyBkb2Vzbid0XG4gICAgICAgIHJldHVybiBsYXN0KGVsZW1zKS5lbmQgPD0gYS5zdGFydDtcbiAgICAgIH1cbiAgICAgIC8vIGJvdGggdGhpcyBjdXJyIGVsZW1lbnQgYW5kIHRoZSBsYXN0IGluIHRoZSByb3cgY3Jvc3MgdGhlIHplcm8gaW5kZXhcbiAgICAgIHJldHVybiBsYXN0KGVsZW1zKS5lbmQgPCBhLnN0YXJ0ICYmIGEuZW5kIDwgZmlyc3QoZWxlbXMpLnN0YXJ0O1xuICAgIH0pO1xuXG4gICAgaWYgKGluc2VydEluZGV4ID4gLTEpIHtcbiAgICAgIC8vIGluc2VydCBpbiB0aGUgcm93IHdoZXJlIGl0J3MgdGhlIG5ldyBoaWdoZXN0XG4gICAgICBzdGFja1tpbnNlcnRJbmRleF0ucHVzaChhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IHJvdyBmb3IgdGhpcyBlbnRyeVxuICAgICAgc3RhY2sucHVzaChbYV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzdGFjay5tYXAoKHJvdykgPT4gcm93LnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KSk7XG59O1xuXG4vLyByZXR1cm5zIGFubm90YXRpb25zIHdpdGggdGhlaXIgc3RhY2sgaW5kZXggYW5kIG1heCBzdGFjayBpbmRleFxuZXhwb3J0IGNvbnN0IGdldFN0YWNrZWRBbm5vdGF0aW9ucyA9IChcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSxcbik6IFN0YWNrZWRBbm5vdGF0aW9uW10gPT4ge1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSBzdGFja0VsZW1lbnRzKGFubm90YXRpb25zKTtcbiAgcmV0dXJuIHN0YWNrZWRBbm5vdGF0aW9uc1xuICAgIC5tYXAoKHJvdywgaWR4KSA9PiByb3cubWFwKChhbm5vdGF0aW9uKSA9PiAoeyAuLi5hbm5vdGF0aW9uLCBzdGFjazogaWR4IH0pKSlcbiAgICAuZmxhdCgpO1xufTtcbmV4cG9ydCBjb25zdCBiYXNlSW5TZWxlY3Rpb24gPSAoe1xuICBiYXNlSW5kZXgsXG4gIHNlbGVjdGlvbixcbiAgc2VxdWVuY2VMZW5ndGgsXG59OiB7XG4gIGJhc2VJbmRleDogbnVtYmVyO1xuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xufSkgPT4ge1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlbGVjdGlvbjtcbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gYmFzZUluZGV4ID09PSBzdGFydDtcbiAgfVxuICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICByZXR1cm4gaW5SYW5nZShiYXNlSW5kZXgsIHN0YXJ0LCBlbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIHNwYW5zIHNlYW1cbiAgICByZXR1cm4gKFxuICAgICAgaW5SYW5nZShiYXNlSW5kZXgsIHN0YXJ0LCBzZXF1ZW5jZUxlbmd0aCkgfHwgaW5SYW5nZShiYXNlSW5kZXgsIDAsIGVuZClcbiAgICApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5SYW5nZSA9ICh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpID0+IHtcbiAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXg7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U3Vic2VxdWVuY2VMZW5ndGggPSAoXG4gIHsgc3RhcnQsIGVuZCB9OiBBcmlhZG5lU2VsZWN0aW9uLFxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuKSA9PiB7XG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIHJldHVybiBlbmQgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VxdWVuY2VMZW5ndGggLSBzdGFydCArIGVuZDtcbiAgfVxufTtcblxuaW50ZXJmYWNlIFN0cmluZ1NvdXJjZSB7XG4gIHBheWxvYWRUeXBlOiBcImdlbmJhbmtcIiB8IFwiZmFzdGFcIiB8IFwicmF3XCI7XG4gIHBheWxvYWQ6IHN0cmluZztcbiAgYW5ub3RhdGlvbnM/OiBBbm5vdGF0aW9uW107XG4gIGFubm90YXRpb25PbkNsaWNrPzogKGFubm90YXRpb246IEFubm90YXRpb24pID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBHZW5iYW5rU291cmNlIHtcbiAgcGF5bG9hZFR5cGU6IFwicGFyc2VkLWdlbmJhbmtcIjtcbiAgcGF5bG9hZDogUGFyc2VkR2VuYmFuaztcbiAgYW5ub3RhdGlvbnM/OiB1bmRlZmluZWQ7XG4gIGFubm90YXRpb25PbkNsaWNrPzogKGFubm90YXRpb246IEFubm90YXRpb24pID0+IHZvaWQ7XG59XG50eXBlIEFueXRoaW5nU291cmNlID0gU3RyaW5nU291cmNlIHwgR2VuYmFua1NvdXJjZTtcblxudHlwZSBQYXJzZUVycm9yID0ge1xuICBzb3VyY2U6IEFueXRoaW5nU291cmNlO1xuICBlcnJvcjogc3RyaW5nO1xufTtcbnR5cGUgUGFyc2VTdWNjZXNzID0ge1xuICBzb3VyY2U6IEFueXRoaW5nU291cmNlO1xuICBzZXF1ZW5jZXM6IEFubm90YXRlZFNlcXVlbmNlW107XG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW107XG59O1xuZXhwb3J0IGNvbnN0IGFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMgPSAoe1xuICBwYXlsb2FkLFxuICBwYXlsb2FkVHlwZSxcbiAgYW5ub3RhdGlvbnMsXG4gIGFubm90YXRpb25PbkNsaWNrLFxufTogQW55dGhpbmdTb3VyY2UpOiB7XG4gIHNlcXVlbmNlczogQW5ub3RhdGVkU2VxdWVuY2VbXTtcbiAgc3RhY2tlZEFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xufSA9PiB7XG4gIGNvbnN0IHsgc3VjY2Vzc2VzLCBmYWlsdXJlcyB9ID0gc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMoe1xuICAgIHBheWxvYWQsXG4gICAgcGF5bG9hZFR5cGUsXG4gICAgYW5ub3RhdGlvbnMsXG4gICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gIH0gYXMgQW55dGhpbmdTb3VyY2UpO1xuICBpZiAoZmFpbHVyZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZhaWxTdHJpbmcgPSBmYWlsdXJlcy5tYXAoKGYpID0+IGYuZXJyb3IpLmpvaW4oXCJcXG5cIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQYXJzZSBmYWlsdXJlczogJHtmYWlsU3RyaW5nfWApO1xuICB9XG4gIGNvbnN0IHNlcXVlbmNlcyA9IHN1Y2Nlc3Nlcy5tYXAoKHMpID0+IHMuc2VxdWVuY2VzKS5mbGF0KCk7XG4gIGNvbnN0IG5ld0Fubm90YXRpb25zOiBBbm5vdGF0aW9uW10gPSBzdWNjZXNzZXNcbiAgICAubWFwKChzKSA9PiBzLmFubm90YXRpb25zKVxuICAgIC5mbGF0KCk7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IGdldFN0YWNrZWRBbm5vdGF0aW9ucyhuZXdBbm5vdGF0aW9ucyk7XG4gIHJldHVybiB7IHNlcXVlbmNlcywgc3RhY2tlZEFubm90YXRpb25zIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2FmZUFueXRoaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZXMgPSAoe1xuICBwYXlsb2FkLFxuICBwYXlsb2FkVHlwZSxcbiAgYW5ub3RhdGlvbnMsXG4gIGFubm90YXRpb25PbkNsaWNrLFxufTogQW55dGhpbmdTb3VyY2UpOiB7IHN1Y2Nlc3NlczogUGFyc2VTdWNjZXNzW107IGZhaWx1cmVzOiBQYXJzZUVycm9yW10gfSA9PiB7XG4gIGNvbnN0IHN1Y2Nlc3NlczogUGFyc2VTdWNjZXNzW10gPSBbXTtcbiAgY29uc3QgZmFpbHVyZXM6IFBhcnNlRXJyb3JbXSA9IFtdO1xuICBzd2l0Y2ggKHBheWxvYWRUeXBlKSB7XG4gICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZXMgPSBbXG4gICAgICAgICAgc3RyaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZSh7XG4gICAgICAgICAgICBzZXF1ZW5jZTogcGF5bG9hZCxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9ucyA/PyBbXSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICAgICAgc3VjY2Vzc2VzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlcXVlbmNlczogc2VxdWVuY2VzLFxuICAgICAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9ucyA/PyBbXSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWx1cmVzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHBhcnNlIHJhdyBzZXF1ZW5jZTogJHtlfWAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJwYXJzZWQtZ2VuYmFua1wiOlxuICAgIGNhc2UgXCJnZW5iYW5rXCI6IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9XG4gICAgICAgIHBheWxvYWRUeXBlID09PSBcInBhcnNlZC1nZW5iYW5rXCIgPyBbcGF5bG9hZF0gOiBnZW5iYW5rUGFyc2VyKHBheWxvYWQpO1xuXG4gICAgICBwYXJzZWQuZm9yRWFjaCgoZ2VuYmFuaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNlcXVlbmNlID0gZ2VuYmFua1RvQW5ub3RhdGVkU2VxdWVuY2Uoe1xuICAgICAgICAgICAgZ2VuYmFuayxcbiAgICAgICAgICAgIGFubm90YXRpb25PbkNsaWNrLFxuICAgICAgICAgIH0pLmFubm90YXRlZFNlcXVlbmNlO1xuICAgICAgICAgIHN1Y2Nlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgfSBhcyBBbnl0aGluZ1NvdXJjZSxcbiAgICAgICAgICAgIHNlcXVlbmNlczogW3NlcXVlbmNlXSxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBbXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWx1cmVzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICB9IGFzIEFueXRoaW5nU291cmNlLFxuICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gcGFyc2UgZ2VuYmFuazogJHtlfWAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmYXN0YVwiOiB7XG4gICAgICBsZXQgcmVjb3JkczogKEZhc3RhUmVjb3JkIHwgRmFzdHFSZWNvcmQpW107XG4gICAgICBpZiAocGF5bG9hZFR5cGUgPT09IFwiZmFzdGFcIikge1xuICAgICAgICByZWNvcmRzID0gcGFyc2VGYXN0YShwYXlsb2FkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhc3RxXG4gICAgICAgIHJlY29yZHMgPSBwYXJzZUZhc3RxKHBheWxvYWQpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXMgPSBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyh7XG4gICAgICAgICAgICBwYXlsb2FkOiByZWNvcmQuc2VxdWVuY2UsXG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogXCJyYXdcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKC4uLnJlcy5mYWlsdXJlcyk7XG4gICAgICAgICAgc3VjY2Vzc2VzLnB1c2goLi4ucmVzLnN1Y2Nlc3Nlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKHtcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHBhcnNlICR7cGF5bG9hZFR5cGV9OiAke2V9YCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgIHNvdXJjZToge1xuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBgVW5rbm93biBwYXlsb2FkIHR5cGU6ICR7cGF5bG9hZFR5cGV9YCxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzZXMsXG4gICAgZmFpbHVyZXMsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5nVG9Bbm5vdGF0ZWRTZXF1ZW5jZSA9ICh7XG4gIHNlcXVlbmNlLFxuICBhbm5vdGF0aW9ucyxcbn06IHtcbiAgc2VxdWVuY2U6IHN0cmluZztcbiAgYW5ub3RhdGlvbnM/OiBBbm5vdGF0aW9uW107XG59KTogQW5ub3RhdGVkU2VxdWVuY2UgPT4ge1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSBnZXRTdGFja2VkQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMgPz8gW10pO1xuICBjb25zdCBhbm5vdGF0ZWRTZXF1ZW5jZSA9IGdldEFubm90YXRlZFNlcXVlbmNlKHtcbiAgICBzZXF1ZW5jZSxcbiAgICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIH0pO1xuICByZXR1cm4gYW5ub3RhdGVkU2VxdWVuY2U7XG59O1xuXG4vLyBEZXRlcm1pbmUgaWYgdHdvIGFubm90YXRpb25zIGZyb20gdGhlIHNhbWUgc2VxdWVuY2Ugb3ZlcmxhcC5cbmV4cG9ydCBjb25zdCBhbm5vdGF0aW9uc0hhdmVPdmVybGFwID0gKFxuICBhMTogQW5ub3RhdGlvbixcbiAgYTI6IEFubm90YXRpb24sXG4gIG1heExlbjogbnVtYmVyLFxuKTogYm9vbGVhbiA9PiB7XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMS5zdGFydCxcbiAgICAgIHNlbGVjdGlvbjogYTIsXG4gICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4TGVuLFxuICAgIH0pXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMS5lbmQsXG4gICAgICBzZWxlY3Rpb246IGEyLFxuICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heExlbixcbiAgICB9KVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgIGJhc2VJbmRleDogYTIuc3RhcnQsXG4gICAgICBzZWxlY3Rpb246IGExLFxuICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heExlbixcbiAgICB9KVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgIGJhc2VJbmRleDogYTIuZW5kLFxuICAgICAgc2VsZWN0aW9uOiBhMSxcbiAgICAgIHNlcXVlbmNlTGVuZ3RoOiBtYXhMZW4sXG4gICAgfSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQ3JlYXRlIFN0YWNrZWRBbm5vdGF0aW9ucyBzdWNoIHRoYXQgbm8gXCJzdGFja1wiIG9yIGxpbmUgb2YgYW5ub3RhdGlvbnMgaGF2ZVxuLy8gYW55IG92ZXJsYXBwaW5nIGFubm90YXRpb25zLlxuZXhwb3J0IGNvbnN0IHN0YWNrQW5ub3RhdGlvbnNOb092ZXJsYXAgPSAoXG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW10sXG4gIG1heExlbjogbnVtYmVyLFxuKTogU3RhY2tlZEFubm90YXRpb25bXSA9PiB7XG4gIGNvbnN0IGFubm90YXRpb25zQnlTdGFjayA9IFtdIGFzIEFubm90YXRpb25bXVtdO1xuXG4gIGFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgIGxldCBjdXJTdGFjayA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHN0YWNrQW5ucyA9IGFubm90YXRpb25zQnlTdGFja1tjdXJTdGFja107XG4gICAgICBpZiAoIXN0YWNrQW5ucykge1xuICAgICAgICBhbm5vdGF0aW9uc0J5U3RhY2tbY3VyU3RhY2tdID0gW2Fubm90YXRpb25dO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBvdmVybGFwID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IHN0YWNrZWRBbm4gb2Ygc3RhY2tBbm5zKSB7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uc0hhdmVPdmVybGFwKGFubm90YXRpb24sIHN0YWNrZWRBbm4sIG1heExlbikpIHtcbiAgICAgICAgICBvdmVybGFwID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxhcCkge1xuICAgICAgICAvLyBBIG92ZXJsYXAgd2FzIGRldGVjdGVkIHNvIHRyeSB0aGUgbmV4dCBsaW5lLlxuICAgICAgICBjdXJTdGFjayArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm8gb3ZlcmxhcHMgZGV0ZWN0ZWQgb24gdGhpcyBzdGFjayB0aGVuIGFkZCB0aGVcbiAgICAgICAgLy8gYW5ub3RhdGlvbiB0byB0aGlzIGxpbmUuXG4gICAgICAgIGFubm90YXRpb25zQnlTdGFja1tjdXJTdGFja10ucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29udmVydCBhbm5vdGF0aW9ucyB0byBzdGFja2VkIGFubm90YXRpb25zXG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IFtdIGFzIFN0YWNrZWRBbm5vdGF0aW9uW107XG4gIGFubm90YXRpb25zQnlTdGFjay5mb3JFYWNoKChzdGFja2VkQW5ucywgaW5kZXgpID0+IHtcbiAgICBzdGFja2VkQW5ucy5mb3JFYWNoKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICBzdGFja2VkQW5ub3RhdGlvbnMucHVzaCh7XG4gICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgIHN0YWNrOiBpbmRleCxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gc3RhY2tlZEFubm90YXRpb25zO1xufTtcblxuZXhwb3J0IGNvbnN0IHN0YWNrQW5uc0J5VHlwZSA9IChcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSxcbik6IFN0YWNrZWRBbm5vdGF0aW9uW10gPT4ge1xuICAvLyBjcmVhdGUgYSBtYXAgb2YgYW5ub3RhdGlvbiB0eXBlIHRvIGxpc3RcbiAgY29uc3QgYW5ub3RhdGlvbk1hcCA9IGFubm90YXRpb25zLnJlZHVjZShcbiAgICAoYWNjOiB7IFtrZXk6IEFubm90YXRpb25UeXBlXTogQW5ub3RhdGlvbltdIH0sIGFubm90YXRpb246IEFubm90YXRpb24pID0+IHtcbiAgICAgIGlmIChhY2NbYW5ub3RhdGlvbi50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY1thbm5vdGF0aW9uLnR5cGVdID0gW107XG4gICAgICB9XG4gICAgICBhY2NbYW5ub3RhdGlvbi50eXBlXSEucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fSBhcyB7IFtrZXk6IEFubm90YXRpb25UeXBlXTogQW5ub3RhdGlvbltdIH0sXG4gICk7XG5cbiAgY29uc3Qgc3RhY2tzID0gT2JqZWN0LnZhbHVlcyhhbm5vdGF0aW9uTWFwKVxuICAgIC5tYXAoKHN0YWNrLCBzdGFja0lkeCkgPT4ge1xuICAgICAgcmV0dXJuIHN0YWNrLm1hcCgoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4ge1xuICAgICAgICBjb25zdCByZXM6IFN0YWNrZWRBbm5vdGF0aW9uID0ge1xuICAgICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgICAgc3RhY2s6IHN0YWNrSWR4LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSk7XG4gICAgfSlcbiAgICAuZmxhdCgpO1xuXG4gIHJldHVybiBzdGFja3M7XG59O1xuXG5pbnRlcmZhY2UgRmFzdHFSZWNvcmQge1xuICBpZDogc3RyaW5nO1xuICBzZXF1ZW5jZTogc3RyaW5nO1xuICBvcHRpb25hbElkOiBzdHJpbmc7XG4gIHF1YWxpdHk6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmFzdHEoZGF0YTogc3RyaW5nKTogRmFzdHFSZWNvcmRbXSB7XG4gIGNvbnN0IGxpbmVzID0gZGF0YS50cmltKCkuc3BsaXQoXCJcXG5cIik7XG4gIGNvbnN0IHJlY29yZHM6IEZhc3RxUmVjb3JkW10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgcmVjb3JkOiBGYXN0cVJlY29yZCA9IHtcbiAgICAgIGlkOiBsaW5lc1tpXS5zdWJzdHJpbmcoMSksXG4gICAgICBzZXF1ZW5jZTogbGluZXNbaSArIDFdLFxuICAgICAgb3B0aW9uYWxJZDogbGluZXNbaSArIDJdLnN1YnN0cmluZygxKSxcbiAgICAgIHF1YWxpdHk6IGxpbmVzW2kgKyAzXSxcbiAgICB9O1xuXG4gICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cblxuICByZXR1cm4gcmVjb3Jkcztcbn1cblxuaW50ZXJmYWNlIEZhc3RhUmVjb3JkIHtcbiAgaWQ6IHN0cmluZztcbiAgc2VxdWVuY2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmFzdGEoZGF0YTogc3RyaW5nKTogRmFzdGFSZWNvcmRbXSB7XG4gIGNvbnN0IGxpbmVzID0gZGF0YS50cmltKCkuc3BsaXQoXCJcXG5cIik7XG4gIGNvbnN0IHJlY29yZHM6IEZhc3RhUmVjb3JkW10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgcmVjb3JkOiBGYXN0YVJlY29yZCA9IHtcbiAgICAgIGlkOiBsaW5lc1tpXS5zdWJzdHJpbmcoMSksXG4gICAgICBzZXF1ZW5jZTogbGluZXNbaSArIDFdLFxuICAgIH07XG5cbiAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvcmRzO1xufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IHVzZVN0YXRlUmVmID0gPFQ+KGluaXRpYWxWYWx1ZTogVCkgPT4ge1xuICBjb25zdCByZWYgPSB1c2VSZWY8VD4oaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgW3N0YXRlLCBpbnRlcm5hbFNldFN0YXRlXSA9IHVzZVN0YXRlPFQ+KGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2soKHZhbHVlOiBUKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICBpbnRlcm5hbFNldFN0YXRlKHZhbHVlKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCByZWZdIGFzIGNvbnN0O1xufTtcbiIsImltcG9ydCB7IGZpbmRBbmdsZUZyb21Db29yIH0gZnJvbSBcIkBBcmlhZG5lL0NpcmN1bGFyVmlld2VyL2NpcmN1bGFyVXRpbHNcIjtcbmltcG9ydCB7IEFuZ2xlLCBDb29yIH0gZnJvbSBcIkBBcmlhZG5lL3R5cGVzXCI7XG5pbXBvcnQgeyBpblJhbmdlIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBSZWZPYmplY3QsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGVSZWYgfSBmcm9tIFwiLi91c2VTdGF0ZVJlZlwiO1xuXG4vKiB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0IG1hbmFnZXMgdGhlIHNlbGVjdGlvbiBvZiBhIExpbmVhclNlbGVjdGlvbiB3aXRoaW5cbiAqIHRoZSBMaW5lYXJWaWV3ZXIuXG4gKlxuICogcmVmIChSZWZPYmplY3QpIEEgcmVmZXJlbmNlIHRvIHRoZSBzdmcgY29udGFpbmluZyB0aGUgTGluZWFyU2VsZWN0aW9uLlxuICogb25Nb3VzZVVwOiBPcHRpb25hbCBoYW5kbGVyIHdoZW4gdXNlciByZWxlYXNlcyB0aGUgbW91c2VcbiAqIG9uTW91c2VEb3duOiBPcHRpb25hbCBoYW5kbGVyIHdoZW4gdXNlciBwcmVzc2VzIHRoZSBtb3VzZSBvbiB0aGUgTGluZWFyU2VsZWN0aW9uLlxuICogb25Nb3VzZU1vdmU6IE9wdGlvbmFsIGhhbmRsZXIgd2hlbiB1c2VyIGRyYWdzLlxuICovXG5leHBvcnQgY29uc3QgdXNlTGluZWFyU2VsZWN0aW9uUmVjdCA9IDxcbiAgVCBleHRlbmRzIHtcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKTogRE9NUmVjdDtcbiAgICBhZGRFdmVudExpc3RlbmVyOiAodHlwZTogc3RyaW5nLCBsaXN0ZW5lcjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQpID0+IHZvaWQ7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogKFxuICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAgbGlzdGVuZXI6IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuICAgICkgPT4gdm9pZDtcbiAgfSxcbj4oe1xuICByZWYsXG4gIG9uTW91c2VVcCxcbiAgb25Nb3VzZURvd24sXG4gIG9uTW91c2VNb3ZlLFxufToge1xuICByZWY6IFJlZk9iamVjdDxUIHwgbnVsbD47XG4gIG9uTW91c2VVcD86IChwYXlsb2FkOiB7IHN0YXJ0OiBDb29yOyBlbmQ6IENvb3IgfSkgPT4gdm9pZDtcbiAgb25Nb3VzZURvd24/OiAocGF5bG9hZDogeyBzdGFydDogQ29vciB9KSA9PiB2b2lkO1xuICBvbk1vdXNlTW92ZT86IChwYXlsb2FkOiB7IHN0YXJ0OiBDb29yOyBlbmQ6IENvb3IgfSkgPT4gdm9pZDtcbn0pID0+IHtcbiAgY29uc3QgW3N0YXJ0LCBzZXRTdGFydCwgc3RhcnRSZWZdID0gdXNlU3RhdGVSZWY8Q29vciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZW5kLCBzZXRFbmQsIGVuZFJlZl0gPSB1c2VTdGF0ZVJlZjxDb29yIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgW2RpcmVjdGlvbiwgc2V0RGlyZWN0aW9uXSA9IHVzZVN0YXRlPFwiZm9yd2FyZFwiIHwgXCJyZXZlcnNlXCI+KFwiZm9yd2FyZFwiKTtcblxuICBjb25zdCBhY3RpdmUgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIGNvbnN0IF9vbk1vdXNlRG93biA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xuICAgIGNvbnN0IHsgbGVmdCwgdG9wIH0gPSByZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICB9O1xuICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICBjb25zdCB5ID0gY2xpZW50WSAtIHRvcDtcbiAgICBhY3RpdmUuY3VycmVudCA9IHRydWU7XG4gICAgc2V0U3RhcnQoeyB4LCB5IH0pO1xuICAgIHNldEVuZCh7IHgsIHkgfSk7XG4gICAgb25Nb3VzZURvd24/Lih7IHN0YXJ0OiB7IHgsIHkgfSB9KTtcbiAgfTtcbiAgY29uc3QgX29uTW91c2VVcCA9ICgpID0+IHtcbiAgICBhY3RpdmUuY3VycmVudCA9IGZhbHNlO1xuICAgIGlmIChzdGFydFJlZi5jdXJyZW50ICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICBvbk1vdXNlVXA/Lih7IHN0YXJ0OiBzdGFydFJlZi5jdXJyZW50LCBlbmQ6IGVuZFJlZi5jdXJyZW50IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwic3RhcnQgb3IgZW5kIGlzIG51bGwgd2hlbiBtb3VzZXVwXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBtdXN0IHVzZSByZWZzIGluIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBtb3N0IHVwIHRvIGRhdGUgdmFsdWVzXG4gIGNvbnN0IF9vbk1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKGFjdGl2ZS5jdXJyZW50KSB7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gcmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IHtcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgY29uc3QgeyBzdGFydFggfSA9IHtcbiAgICAgICAgc3RhcnRYOiBzdGFydFJlZi5jdXJyZW50Py54LFxuICAgICAgfTtcbiAgICAgIGlmIChzdGFydFggJiYgc3RhcnRYID4geCkge1xuICAgICAgICBzZXREaXJlY3Rpb24oXCJyZXZlcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RGlyZWN0aW9uKFwiZm9yd2FyZFwiKTtcbiAgICAgIH1cbiAgICAgIHNldEVuZCh7IHgsIHkgfSk7XG4gICAgICBpZiAoc3RhcnRSZWYuY3VycmVudCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICBvbk1vdXNlTW92ZT8uKHsgc3RhcnQ6IHN0YXJ0UmVmLmN1cnJlbnQsIGVuZDogZW5kUmVmLmN1cnJlbnQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwic3RhcnQgaXMgbnVsbCB3aGVuIG1vdXNlbW92ZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZj8uY3VycmVudDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF9vbk1vdXNlRG93bik7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX29uTW91c2VNb3ZlKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgLy8gc3RpbGwgd2FudCB0byBjYWxsIG1vdXNldXAgaWYgbW91c2UgbGVhdmVzIHBhcmVudFxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF9vbk1vdXNlVXApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfb25Nb3VzZURvd24pO1xuICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfb25Nb3VzZU1vdmUpO1xuICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfb25Nb3VzZVVwKTtcbiAgICB9O1xuICB9LCBbcmVmXSk7XG4gIHJldHVybiB7IHN0YXJ0LCBlbmQsIGRpcmVjdGlvbiB9O1xufTtcblxuLy8gZm9yIGNpcmN1bGFyIGNvb3JkaW5hdGVzXG5leHBvcnQgY29uc3QgdXNlQ2lyY3VsYXJTZWxlY3Rpb25SZWN0ID0gKFxuICByZWY6IFJlZk9iamVjdDxTVkdTVkdFbGVtZW50IHwgbnVsbD4sXG4pID0+IHtcbiAgY29uc3QgW3N0YXJ0LCBzZXRTdGFydCwgc3RhcnRSZWZdID0gdXNlU3RhdGVSZWY8QW5nbGUgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2VuZCwgc2V0RW5kXSA9IHVzZVN0YXRlUmVmPEFuZ2xlIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgW2RpcmVjdGlvbiwgc2V0RGlyZWN0aW9uXSA9IHVzZVN0YXRlPFxuICAgIFwiY2xvY2t3aXNlXCIgfCBcImNvdW50ZXJjbG9ja3dpc2VcIiB8IG51bGxcbiAgPihudWxsKTtcbiAgY29uc3QgQU5HTEVfREVMVEFfVEhSRVNIT0xEX0lOX0RFR1JFRVMgPSAyO1xuXG4gIGNvbnN0IGFjdGl2ZSA9IHVzZVJlZihmYWxzZSk7XG5cbiAgY29uc3Qgb25Nb3VzZURvd24gPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcInJlc2V0dGluZyBzdGFydCBhbmQgZW5kXCIpO1xuICAgICAgc2V0U3RhcnQobnVsbCk7XG4gICAgICBzZXRFbmQobnVsbCk7XG4gICAgICBzZXREaXJlY3Rpb24obnVsbCk7XG4gICAgICBhY3RpdmUuY3VycmVudCA9IHRydWU7XG5cbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSByZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgY29uc3QgY2VudGVyID0geyB4OiB3aWR0aCAvIDIsIHk6IGhlaWdodCAvIDIgfTtcbiAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBmaW5kQW5nbGVGcm9tQ29vcih7IGNvb3I6IHsgeCwgeSB9LCBjZW50ZXIgfSk7XG4gICAgICBzZXRTdGFydCh7XG4gICAgICAgIGRlZ3JlZXM6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGNlbnRlcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgYWN0aXZlLmN1cnJlbnQgPSBmYWxzZTtcblxuICAgIHNldERpcmVjdGlvbihudWxsKTtcbiAgfTtcblxuICBjb25zdCBvbk1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKGFjdGl2ZS5jdXJyZW50ICYmIHJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgICBjb25zdCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gcmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB4ID0gY2xpZW50WCAtIGxlZnQ7XG4gICAgICBjb25zdCB5ID0gY2xpZW50WSAtIHRvcDtcbiAgICAgIGNvbnN0IGNlbnRlciA9IHsgeDogd2lkdGggLyAyLCB5OiBoZWlnaHQgLyAyIH07XG4gICAgICAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgY2VudGVyLCBkb24ndCB1cGRhdGUgc2VsZWN0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIE1hdGguc3FydChNYXRoLnBvdyh4IC0gY2VudGVyLngsIDIpICsgTWF0aC5wb3coeSAtIGNlbnRlci55LCAyKSkgPFxuICAgICAgICAwLjQgKiAod2lkdGggLyAyKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJ3aXRoaW4gMC41IHJhZGl1cyBvZiBjZW50ZXIsIG5vdCB1cGRhdGluZyBzZWxlY3Rpb25cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW5kQW5nbGUgPSBmaW5kQW5nbGVGcm9tQ29vcih7IGNvb3I6IHsgeCwgeSB9LCBjZW50ZXIgfSk7XG4gICAgICBpZiAoc3RhcnRSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnRSZWYuY3VycmVudC5kZWdyZWVzO1xuICAgICAgICBjb25zdCBlbmRBbmdsZUlzTmVhclN0YXJ0QW5nbGUgPSBpblJhbmdlKFxuICAgICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICAgIHN0YXJ0QW5nbGUgLSBBTkdMRV9ERUxUQV9USFJFU0hPTERfSU5fREVHUkVFUyxcbiAgICAgICAgICBzdGFydEFuZ2xlICsgQU5HTEVfREVMVEFfVEhSRVNIT0xEX0lOX0RFR1JFRVMsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbmRBbmdsZUlzTmVhclN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICBzZXREaXJlY3Rpb24obnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldEVuZCh7XG4gICAgICAgIGRlZ3JlZXM6IGVuZEFuZ2xlLFxuICAgICAgICBjZW50ZXIsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIGRldGVybWluZURpcmVjdGlvbigpIHtcbiAgICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZGlyZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydC5kZWdyZWVzO1xuICAgICAgICBjb25zdCBlbmRBbmdsZSA9IGVuZC5kZWdyZWVzO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICAgICAgY29uc3QgZ3Vlc3NlZERpcmVjdGlvbiA9IGRlbHRhID4gMCA/IFwiY2xvY2t3aXNlXCIgOiBcImNvdW50ZXJjbG9ja3dpc2VcIjtcbiAgICAgICAgc2V0RGlyZWN0aW9uKGd1ZXNzZWREaXJlY3Rpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3N0YXJ0LCBlbmRdLFxuICApO1xuXG4gIHVzZUVmZmVjdChcbiAgICBmdW5jdGlvbiBoYW5kbGVFdmVudExpc3RlbmVycygpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG5vZGU/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24pO1xuICAgICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgfTtcbiAgICB9LFxuICAgIFtyZWYuY3VycmVudCwgc3RhcnQsIGRpcmVjdGlvbl0sXG4gICk7XG4gIHJldHVybiB7IHN0YXJ0LCBlbmQsIGRpcmVjdGlvbiB9O1xufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWVzKFxuICAuLi5jbGFzc2VzOiAoc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCB8IGJvb2xlYW4pW11cbikge1xuICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG59XG5leHBvcnQgY29uc3QgY24gPSBjbGFzc05hbWVzO1xuIiwiaW1wb3J0IHsgZ2VuQXJjIH0gZnJvbSBcIi4uL2NpcmN1bGFyVXRpbHNcIjtcbmltcG9ydCB0eXBlIHsgQW5ub3RhdGVkU2VxdWVuY2UsIEFubm90YXRpb24sIENvb3IgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyBnZXRTdWJzZXF1ZW5jZUxlbmd0aCB9IGZyb20gXCJAQXJpYWRuZS91dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgQ2lyY3VsYXJBbm5vdGF0aW9uID0gKHtcbiAgc2VxdWVuY2UsXG4gIGFubm90YXRpb24sXG4gIHJhZGl1cyxcbiAgY2VudGVyLFxufToge1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIHJhZGl1czogbnVtYmVyO1xuICBhbm5vdGF0aW9uOiBBbm5vdGF0aW9uO1xuXG4gIGNlbnRlcjogQ29vcjtcbn0pID0+IHtcbiAgY29uc3QgeyB4OiBjeCwgeTogY3kgfSA9IGNlbnRlcjtcbiAgY29uc3QgYW5ub3RhdGlvbkxlbmd0aCA9IGdldFN1YnNlcXVlbmNlTGVuZ3RoKGFubm90YXRpb24sIHNlcXVlbmNlLmxlbmd0aCk7XG4gIGlmIChhbm5vdGF0aW9uTGVuZ3RoID4gc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBBbm5vdGF0aW9uICR7YW5ub3RhdGlvbi50ZXh0fSdzIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gc2VxdWVuY2UgbGVuZ3RoOiAke2Fubm90YXRpb25MZW5ndGh9ID4gJHtzZXF1ZW5jZS5sZW5ndGh9YCxcbiAgICApO1xuICB9XG4gIGNvbnN0IGFyY1BhdGggPSBnZW5BcmMoe1xuICAgIGlubmVyUmFkaXVzOiByYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXM6IHJhZGl1cyArIDUsXG4gICAgbGFyZ2VBcmM6IGFubm90YXRpb25MZW5ndGggPiBzZXF1ZW5jZS5sZW5ndGggLyAyLFxuICAgIGxlbmd0aDogYW5ub3RhdGlvbkxlbmd0aCxcbiAgICBzZXFMZW5ndGg6IHNlcXVlbmNlLmxlbmd0aCxcbiAgICBvZmZzZXQ6IGFubm90YXRpb24uc3RhcnQsXG4gICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhhbm5vdGF0aW9uLmNsYXNzTmFtZSl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGFubm90YXRpb24ub25DbGljaz8uKGFubm90YXRpb24pO1xuICAgICAgfX1cbiAgICA+XG4gICAgICA8cGF0aCBkPXthcmNQYXRofT5cbiAgICAgICAgPHRpdGxlPnthbm5vdGF0aW9uLnRleHR9PC90aXRsZT5cbiAgICAgICAgPHRleHQ+QW5ub3RhdGlvbjwvdGV4dD5cbiAgICAgIDwvcGF0aD5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgdHlwZSB7IEFubm90YXRlZFNlcXVlbmNlLCBTdGFja2VkQW5ub3RhdGlvbiB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgQ2lyY3VsYXJBbm5vdGF0aW9uIH0gZnJvbSBcIi4vQ2lyY3VsYXJBbm5vdGF0aW9uXCI7XG5pbXBvcnQgeyBjbGFtcFNsaWNlIH0gZnJvbSBcIi4uL2NpcmN1bGFyVXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IENpcmN1bGFyQW5ub3RhdGlvbkd1dHRlciA9ICh7XG4gIHN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgY3gsXG4gIGN5LFxuICByYWRpdXMsXG4gIGFubm90YXRlZFNlcXVlbmNlLFxufToge1xuICBzdGFja2VkQW5ub3RhdGlvbnM6IFN0YWNrZWRBbm5vdGF0aW9uW107XG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG59KSA9PiB7XG4gIGNvbnN0IGd1dHRlclJhZGl1cyA9IHJhZGl1cyAqIDAuMztcbiAgY29uc3QgZmlyc3RJZHggPVxuICAgIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDAgPyBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgwKSEuaW5kZXggOiAwO1xuICBjb25zdCBsYXN0SWR4ID1cbiAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggPiAwID8gYW5ub3RhdGVkU2VxdWVuY2UuYXQoLTEpIS5pbmRleCA6IDA7XG4gIHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrZWRBbm5vdGF0aW9uc1xuICAgIC5tYXAoKGFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IGNsYW1wZWRCb3VuZHMgPSBjbGFtcFNsaWNlKHtcbiAgICAgICAgc2xpY2U6IGFubm90YXRpb24sXG4gICAgICAgIGZpcnN0SWR4LFxuICAgICAgICBsYXN0SWR4LFxuICAgICAgfSk7XG4gICAgICBpZiAoIWNsYW1wZWRCb3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICBzdGFydDogY2xhbXBlZEJvdW5kcy5zdGFydCxcbiAgICAgICAgZW5kOiBjbGFtcGVkQm91bmRzLmVuZCxcbiAgICAgIH07XG4gICAgfSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIFN0YWNrZWRBbm5vdGF0aW9uW107IC8vIGZpbHRlciBlbnN1cmVzIHRoYXQgdGhlIGFycmF5IGlzIG9mIHR5cGUgU3RhY2tlZEFubm90YXRpb25bXVxuICBjb25zdCBzdGFja3M6IFN0YWNrZWRBbm5vdGF0aW9uW11bXSA9IFtdO1xuICBzdGFja2VkQW5ub3RhdGlvbnMuZm9yRWFjaCgoYW5uKSA9PiB7XG4gICAgc3RhY2tzW2Fubi5zdGFja10gPSBzdGFja3NbYW5uLnN0YWNrXSB8fCBbXTtcbiAgICBzdGFja3NbYW5uLnN0YWNrXS5wdXNoKGFubik7XG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGc+XG4gICAgICA8Y2lyY2xlIGN4PXtjeH0gY3k9e2N5fSByPXtndXR0ZXJSYWRpdXN9IGZpbGw9XCJub25lXCIgc3Ryb2tlV2lkdGg9ezAuOH0gLz47XG4gICAgICB7c3RhY2tzLm1hcCgoYW5ub3RhdGlvbnMsIHN0YWNrSWR4KSA9PiAoXG4gICAgICAgIDxGcmFnbWVudCBrZXk9e2Bhbm5vdGF0aW9uLXN0YWNrLSR7c3RhY2tJZHh9YH0+XG4gICAgICAgICAge2Fubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKFxuICAgICAgICAgICAgPENpcmN1bGFyQW5ub3RhdGlvblxuICAgICAgICAgICAgICBrZXk9e2BzdGFjay0ke3N0YWNrSWR4fS0ke2Fubm90YXRpb24uc3RhcnR9LSR7YW5ub3RhdGlvbi5lbmR9LSR7YW5ub3RhdGlvbi50ZXh0fWB9XG4gICAgICAgICAgICAgIGFubm90YXRpb249e2Fubm90YXRpb259XG4gICAgICAgICAgICAgIHJhZGl1cz17Z3V0dGVyUmFkaXVzICsgc3RhY2tJZHggKiA2fVxuICAgICAgICAgICAgICBjZW50ZXI9e3sgeDogY3gsIHk6IGN5IH19XG4gICAgICAgICAgICAgIHNlcXVlbmNlPXthbm5vdGF0ZWRTZXF1ZW5jZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICApKX1cbiAgICA8L2c+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgQW5ub3RhdGVkU2VxdWVuY2UgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmaW5kQ29vciB9IGZyb20gXCIuLi9jaXJjdWxhclV0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBDaXJjdWxhckluZGV4ID0gKHtcbiAgYW5ub3RhdGVkU2VxdWVuY2UsXG4gIGN4LFxuICBjeSxcbiAgcmFkaXVzLFxuICB0aWNrcyxcbn06IHtcbiAgYW5ub3RhdGVkU2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBjeDogbnVtYmVyO1xuICBjeTogbnVtYmVyO1xuICByYWRpdXM6IG51bWJlcjtcbiAgdGlja3M6IG51bWJlcjtcbn0pID0+IHtcbiAgY29uc3QgYmFzZXNQZXJUaWNrID0gTWF0aC5mbG9vcihhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggLyB0aWNrcyk7XG5cbiAgaWYgKGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDUwKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxzdmcgY2xhc3NOYW1lPXtgZmlsbC1jdXJyZW50YH0+XG4gICAgICAgIDxnPlxuICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgIGN4PXtjeH1cbiAgICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICAgIHI9e3JhZGl1cyAqIDAuNzV9XG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8VGlja3NcbiAgICAgICAgICAgIGN4PXtjeH1cbiAgICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICAgIHJhZGl1cz17cmFkaXVzICogMC43NX1cbiAgICAgICAgICAgIGJhc2VzUGVyVGljaz17YmFzZXNQZXJUaWNrfVxuICAgICAgICAgICAgdG90YWxCYXNlcz17YW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RofVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIChcbiAgICA8dGV4dD5cbiAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZS5tYXAoKHsgYmFzZTogbGV0dGVyIH0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZmluZENvb3Ioe1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHJhZGl1czogcmFkaXVzICogMC43LFxuICAgICAgICAgIGNlbnRlcjogeyB4OiBjeCwgeTogY3kgfSxcbiAgICAgICAgICBzZXFMZW5ndGg6IGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZURlZ3JlZXMgPSAoaW5kZXggLyBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgpICogMzYwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDx0c3BhblxuICAgICAgICAgICAga2V5PXtgYmFzZS0ke2luZGV4fWB9XG4gICAgICAgICAgICB4PXt4fVxuICAgICAgICAgICAgeT17eX1cbiAgICAgICAgICAgIHRyYW5zZm9ybT17YHJvdGF0ZSgke3JvdGF0ZURlZ3JlZXN9ICR7eH0gJHt5fSlgfVxuICAgICAgICAgICAgdGV4dEFuY2hvcj1cIm1pZGRsZVwiXG4gICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGNvbG9yPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgZm9udFNpemU9XCIwLjVyZW1cIlxuICAgICAgICAgICAgZm9udFdlaWdodD1cInRoaW5cIlxuICAgICAgICAgICAgZm9udEZhbWlseT1cImluaGVyaXRcIlxuICAgICAgICAgICAgZGF0YS1zZXEtaW5kZXg9e2luZGV4fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtsZXR0ZXJ9XG4gICAgICAgICAgPC90c3Bhbj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvdGV4dD5cbiAgKTtcbn07XG5cbmNvbnN0IFRpY2tzID0gKHtcbiAgcmFkaXVzLFxuICBjeCxcbiAgY3ksXG4gIGJhc2VzUGVyVGljayxcbiAgdG90YWxCYXNlcyxcbn06IHtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIGJhc2VzUGVyVGljazogbnVtYmVyO1xuICB0b3RhbEJhc2VzOiBudW1iZXI7XG59KSA9PiB7XG4gIGNvbnN0IG51bWJlck9mVGlja3MgPSBNYXRoLmZsb29yKHRvdGFsQmFzZXMgLyBiYXNlc1BlclRpY2spO1xuICByZXR1cm4gKFxuICAgIDxzdmc+XG4gICAgICB7Wy4uLkFycmF5KG51bWJlck9mVGlja3MpLmtleXMoKV0ubWFwKChpKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSBmaW5kQ29vcih7XG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcmFkaXVzLFxuICAgICAgICAgIGNlbnRlcjogeyB4OiBjeCwgeTogY3kgfSxcbiAgICAgICAgICBzZXFMZW5ndGg6IHRvdGFsQmFzZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gZmluZENvb3Ioe1xuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHJhZGl1czogcmFkaXVzICogMS4xLFxuICAgICAgICAgIGNlbnRlcjogeyB4OiBjeCwgeTogY3kgfSxcbiAgICAgICAgICBzZXFMZW5ndGg6IHRvdGFsQmFzZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByb3RhdGVEZWdyZWVzID0gKGkgLyBudW1iZXJPZlRpY2tzKSAqIDM2MDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8RnJhZ21lbnQga2V5PXtgdGljay0ke2l9YH0+XG4gICAgICAgICAgICA8bGluZVxuICAgICAgICAgICAgICBpZD17YHRpY2stJHtpfWB9XG4gICAgICAgICAgICAgIHgxPXt4MX1cbiAgICAgICAgICAgICAgeTE9e3kxfVxuICAgICAgICAgICAgICB4Mj17eDJ9XG4gICAgICAgICAgICAgIHkyPXt5Mn1cbiAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgICAgIG9wYWNpdHk9ezAuNX1cbiAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgcm90YXRlKCR7cm90YXRlRGVncmVlc30gJHtjeH0gJHtjeX0pYH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICB4PXt4Mn1cbiAgICAgICAgICAgICAgeT17eTIgLSA0fVxuICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgZm9udFNpemU9XCIuOHJlbVwiXG4gICAgICAgICAgICAgIHRyYW5zZm9ybT17YHJvdGF0ZSgke3JvdGF0ZURlZ3JlZXN9ICR7Y3h9ICR7Y3l9KWB9XG4gICAgICAgICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICBvcGFjaXR5PXswLjc1fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7aSAqIGJhc2VzUGVyVGlja31cbiAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgdXNlQ2lyY3VsYXJTZWxlY3Rpb25SZWN0IH0gZnJvbSBcIkBBcmlhZG5lL2hvb2tzL3VzZVNlbGVjdGlvblwiO1xuaW1wb3J0IHtcbiAgQW5ub3RhdGVkU2VxdWVuY2UsXG4gIEFubm90YXRpb24sXG4gIEFyaWFkbmVTZWxlY3Rpb24sXG59IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHtcbiAgZ2V0QW5ub3RhdGVkU2VxdWVuY2UsXG4gIGdldFN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgZ2V0U3Vic2VxdWVuY2VMZW5ndGgsXG59IGZyb20gXCJAQXJpYWRuZS91dGlsc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzdGFja0FubnNCeVR5cGUgfSBmcm9tIFwiLi5cIjtcbmltcG9ydCB7IENpcmN1bGFyQW5ub3RhdGlvbkd1dHRlciB9IGZyb20gXCIuL0NpcmN1bGFyQW5ub3RhdGlvbnNcIjtcbmltcG9ydCB7IENpcmN1bGFySW5kZXggfSBmcm9tIFwiLi9DaXJjdWxhckluZGV4XCI7XG5pbXBvcnQgeyBjbGFtcFNsaWNlLCBmaW5kSW5kZXhGcm9tQW5nbGUsIGdlbkFyYyB9IGZyb20gXCIuL2NpcmN1bGFyVXRpbHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBQcm9wcyB7XG4gIHNlcXVlbmNlOiBzdHJpbmc7XG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW107XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbikgPT4gdm9pZDtcbiAgY29udGFpbmVyQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBzdmdTaXplUFg/OiBudW1iZXI7XG4gIHN2Z1BhZGRpbmc/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBDaXJjdWxhclZpZXdlciA9ICh7XG4gIHNlcXVlbmNlLFxuICBhbm5vdGF0aW9ucyxcbiAgc2VsZWN0aW9uLFxuICBzZXRTZWxlY3Rpb24sXG4gIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgc3ZnU2l6ZVBYID0gMzAwLFxuICBzdmdQYWRkaW5nID0gMjAsXG59OiBQcm9wcykgPT4ge1xuICBjb25zdCB7IGN4LCBjeSwgc2l6ZVgsIHNpemVZLCByYWRpdXMgfSA9IHtcbiAgICBjeDogc3ZnU2l6ZVBYIC8gMixcbiAgICBjeTogc3ZnU2l6ZVBYIC8gMixcbiAgICBzaXplWDogc3ZnU2l6ZVBYLFxuICAgIHNpemVZOiBzdmdTaXplUFgsXG4gICAgcmFkaXVzOiAoc3ZnU2l6ZVBYIC0gc3ZnUGFkZGluZykgLyAyLFxuICB9O1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSBzdGFja0FubnNCeVR5cGUoYW5ub3RhdGlvbnMpO1xuICBjb25zdCBhbm5vdGF0ZWRTZXF1ZW5jZSA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSh7XG4gICAgICAgIHNlcXVlbmNlLFxuICAgICAgICBzdGFja2VkQW5ub3RhdGlvbnM6IGdldFN0YWNrZWRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucyksXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtzZXF1ZW5jZSwgYW5ub3RhdGlvbnNdLFxuICApO1xuXG4gIGlmIChhbm5vdGF0ZWRTZXF1ZW5jZSAmJiBzZWxlY3Rpb24gJiYgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZpcnN0SWR4ID1cbiAgICAgIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDAgPyBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgwKSEuaW5kZXggOiAwO1xuICAgIGNvbnN0IGxhc3RJZHggPVxuICAgICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCA/IGFubm90YXRlZFNlcXVlbmNlLmF0KC0xKSEuaW5kZXggOiAwO1xuICAgIHNlbGVjdGlvbiA9IGNsYW1wU2xpY2UoeyBzbGljZTogc2VsZWN0aW9uLCBmaXJzdElkeCwgbGFzdElkeCB9KTtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb25SZWYgPSB1c2VSZWY8U1ZHU1ZHRWxlbWVudD4obnVsbCk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgIFwiZmxleCBzZWxlY3Qtbm9uZSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZm9udC10aGluXCIsXG4gICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgPlxuICAgICAgPHN2Z1xuICAgICAgICByZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgdmlld0JveD17YDAgMCAke3NpemVYfSAke3NpemVZfWB9XG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICBmb250RmFtaWx5PVwiaW5oZXJpdFwiXG4gICAgICAgIGZvbnRTaXplPVwiaW5oZXJpdFwiXG4gICAgICAgIGZvbnRXZWlnaHQ9XCJpbmhlcml0XCJcbiAgICAgICAgY2xhc3NOYW1lPXtgc3Ryb2tlLWN1cnJlbnRgfVxuICAgICAgICB3aWR0aD17c2l6ZVh9XG4gICAgICAgIGhlaWdodD17c2l6ZVl9XG4gICAgICA+XG4gICAgICAgIDxDaXJjdWxhckluZGV4XG4gICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICByYWRpdXM9e3JhZGl1c31cbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZT17YW5ub3RhdGVkU2VxdWVuY2V9XG4gICAgICAgICAgdGlja3M9ezR9XG4gICAgICAgIC8+XG4gICAgICAgIDxDaXJjdWxhckFubm90YXRpb25HdXR0ZXJcbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZT17YW5ub3RhdGVkU2VxdWVuY2V9XG4gICAgICAgICAgc3RhY2tlZEFubm90YXRpb25zPXtzdGFja2VkQW5ub3RhdGlvbnN9XG4gICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICByYWRpdXM9e3JhZGl1c31cbiAgICAgICAgLz5cbiAgICAgICAgPENpcmN1bGFyU2VsZWN0aW9uXG4gICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2U9e2Fubm90YXRlZFNlcXVlbmNlfVxuICAgICAgICAgIHNlbGVjdGlvbj17c2VsZWN0aW9ufVxuICAgICAgICAgIGN4PXtjeH1cbiAgICAgICAgICBjeT17Y3l9XG4gICAgICAgICAgcmFkaXVzPXtyYWRpdXN9XG4gICAgICAgICAgc2VsZWN0aW9uUmVmPXtzZWxlY3Rpb25SZWZ9XG4gICAgICAgICAgc2V0U2VsZWN0aW9uPXtzZXRTZWxlY3Rpb259XG4gICAgICAgIC8+XG5cbiAgICAgICAgPHRleHRcbiAgICAgICAgICB4PXtjeH1cbiAgICAgICAgICB5PXtjeX1cbiAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgIGFsaWdubWVudEJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICBmb250U2l6ZT17XCIxcmVtXCJ9XG4gICAgICAgID5cbiAgICAgICAgICB7YW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RofSBicFxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmNvbnN0IENpcmN1bGFyU2VsZWN0aW9uID0gKHtcbiAgcmFkaXVzLFxuICBjeCxcbiAgY3ksXG4gIHNlbGVjdGlvbixcbiAgc2VsZWN0aW9uUmVmLFxuICBzZXRTZWxlY3Rpb24sXG4gIGFubm90YXRlZFNlcXVlbmNlLFxufToge1xuICByYWRpdXM6IG51bWJlcjtcblxuICBjeDogbnVtYmVyO1xuICBjeTogbnVtYmVyO1xuICBzZWxlY3Rpb25SZWY6IFJlYWN0LlJlZk9iamVjdDxTVkdTVkdFbGVtZW50PjtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiB2b2lkO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG59KSA9PiB7XG4gIC8qIENvbGxlY3QgaW50ZXJuYWwgc2VsZWN0aW9uIGRhdGEgYW5kIHByb3BvZ2F0ZSB1cCAqL1xuICBjb25zdCB7XG4gICAgc3RhcnQ6IGludGVybmFsU2VsZWN0aW9uU3RhcnQsXG4gICAgZW5kOiBpbnRlcm5hbFNlbGVjdGlvbkVuZCxcbiAgICBkaXJlY3Rpb246IGludGVybmFsRGlyZWN0aW9uLFxuICB9ID0gdXNlQ2lyY3VsYXJTZWxlY3Rpb25SZWN0KHNlbGVjdGlvblJlZik7XG4gIHVzZUVmZmVjdChcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVTZWxlY3Rpb25VcCgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgc2VsZWN0aW9uUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgaW50ZXJuYWxTZWxlY3Rpb25TdGFydCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvbkVuZCAmJlxuICAgICAgICBpbnRlcm5hbERpcmVjdGlvblxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gZmluZEluZGV4RnJvbUFuZ2xlKHtcbiAgICAgICAgICBhbmdsZTogaW50ZXJuYWxTZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBzZXFMZW5ndGg6IGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGZpbmRJbmRleEZyb21BbmdsZSh7XG4gICAgICAgICAgYW5nbGU6IGludGVybmFsU2VsZWN0aW9uRW5kLFxuICAgICAgICAgIHNlcUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID1cbiAgICAgICAgICBpbnRlcm5hbERpcmVjdGlvbiA9PT0gXCJjbG9ja3dpc2VcIiA/IFwiZm9yd2FyZFwiIDogXCJyZXZlcnNlXCI7XG5cbiAgICAgICAgY29uc3QgcHJldkxlbmd0aCA9IHNlbGVjdGlvblxuICAgICAgICAgID8gTWF0aC5hYnMoc2VsZWN0aW9uLmVuZCAtIHNlbGVjdGlvbi5zdGFydClcbiAgICAgICAgICA6IDA7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGdldFN1YnNlcXVlbmNlTGVuZ3RoKFxuICAgICAgICAgIHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uIH0sXG4gICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBkZWx0YUxlbmd0aCA9IE1hdGguYWJzKHByZXZMZW5ndGggLSBuZXdMZW5ndGgpO1xuICAgICAgICBjb25zdCBkZWx0YVRocmVzaG9sZCA9IE1hdGgubWF4KDAuNyAqIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCwgMTApO1xuICAgICAgICBpZiAoZGVsdGFMZW5ndGggPiBkZWx0YVRocmVzaG9sZCAmJiBzZWxlY3Rpb24pIHtcbiAgICAgICAgICAvLyBwcmVzZXJ2ZSBpbml0aWFsIGRpcmVjdGlvblxuICAgICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogc2VsZWN0aW9uPy5kaXJlY3Rpb24sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LCBpbnRlcm5hbFNlbGVjdGlvbkVuZF0sXG4gICk7XG5cbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyogRGlzcGxheSBzZWxlY3Rpb24gZGF0YSB0aGF0IGhhcyB0cmlja2xlZCBkb3duICovXG4gIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uO1xuICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2VudGVyID0geyB4OiBjeCwgeTogY3kgfTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXM7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gcmFkaXVzICsgMTA7XG4gIGNvbnN0IGxlbmd0aCA9IGdldFN1YnNlcXVlbmNlTGVuZ3RoKHNlbGVjdGlvbiwgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoKTtcblxuICBjb25zdCBbc3RhcnRJZHgsIGVuZElkeF0gPSBbXG4gICAgYW5ub3RhdGVkU2VxdWVuY2UuYXQoMCk/LmluZGV4LFxuICAgIGFubm90YXRlZFNlcXVlbmNlLmF0KC0xKT8uaW5kZXgsXG4gIF07XG4gIGlmIChzdGFydElkeCA9PT0gdW5kZWZpbmVkIHx8IGVuZElkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkNpcmN1bGFyVmlld2VyOiBzZXF1ZW5jZSBoYXMgbm8gaW5kaWNlc1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSBzdGFydCAtIHN0YXJ0SWR4O1xuICBjb25zdCBzZXFMZW5ndGggPSBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGg7XG5cbiAgY29uc3QgYXJjID0gZ2VuQXJjKHtcbiAgICBjZW50ZXIsXG4gICAgaW5uZXJSYWRpdXMsXG4gICAgbGFyZ2VBcmM6IGxlbmd0aCA+IHNlcUxlbmd0aCAvIDIsXG4gICAgbGVuZ3RoLFxuICAgIG9mZnNldCxcbiAgICBvdXRlclJhZGl1cyxcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICByZXR1cm4gKFxuICAgIDxnPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD17YXJjfVxuICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIHN0cm9rZVdpZHRoPXsyfVxuICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgIC8+XG4gICAgPC9nPlxuICApO1xufTtcbiIsImltcG9ydCB7IGdldFN1YnNlcXVlbmNlTGVuZ3RoIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEFubm90YXRlZFNlcXVlbmNlLCBBbm5vdGF0aW9uLCBTdGFja2VkQW5ub3RhdGlvbiB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVhckFubm90YXRpb25HdXR0ZXJQcm9wcyB7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogU3RhY2tlZEFubm90YXRpb25bXTtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBjb250YWluZXJDbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBMaW5lYXJBbm5vdGF0aW9uR3V0dGVyID0gKHtcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBzZXF1ZW5jZSxcbiAgY29udGFpbmVyQ2xhc3NOYW1lLFxufTogTGluZWFyQW5ub3RhdGlvbkd1dHRlclByb3BzKSA9PiB7XG4gIGNvbnN0IHN0YWNrczogU3RhY2tlZEFubm90YXRpb25bXVtdID0gW107XG4gIHN0YWNrZWRBbm5vdGF0aW9ucy5mb3JFYWNoKChhbm4pID0+IHtcbiAgICBzdGFja3NbYW5uLnN0YWNrXSA9IHN0YWNrc1thbm4uc3RhY2tdIHx8IFtdO1xuICAgIHN0YWNrc1thbm4uc3RhY2tdLnB1c2goYW5uKTtcbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICBcImdyaWQtcm93cy1hdXRvIGJsb2NrIGdyaWQgZ3JpZC1jb2xzLTEgZ2FwLTFcIixcbiAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICA+XG4gICAgICB7c3RhY2tzLm1hcCgoYW5ub3RhdGlvbnMsIHN0YWNrSWR4KSA9PiAoXG4gICAgICAgIDxkaXYga2V5PXtgYW5ub3RhdGlvbi1zdGFjay0ke3N0YWNrSWR4fWB9IGNsYXNzTmFtZT1cInJlbGF0aXZlIGgtOFwiPlxuICAgICAgICAgIHthbm5vdGF0aW9ucy5tYXAoKGFubm90YXRpb24pID0+IChcbiAgICAgICAgICAgIDxMaW5lYXJBbm5vdGF0aW9uXG4gICAgICAgICAgICAgIGtleT17YGFubm90YXRpb24tJHthbm5vdGF0aW9uLnRleHR9LSR7YW5ub3RhdGlvbi5zdGFydH0tJHthbm5vdGF0aW9uLmVuZH0tJHthbm5vdGF0aW9uLmRpcmVjdGlvbn1gfVxuICAgICAgICAgICAgICBhbm5vdGF0aW9uPXthbm5vdGF0aW9ufVxuICAgICAgICAgICAgICBzZXF1ZW5jZT17c2VxdWVuY2V9XG4gICAgICAgICAgICAgIHN0YWNrSWR4PXtzdGFja0lkeH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuY29uc3QgTGluZWFyQW5ub3RhdGlvbiA9ICh7XG4gIGFubm90YXRpb24sXG4gIHNlcXVlbmNlLFxuICBzdGFja0lkeCxcbn06IHtcbiAgYW5ub3RhdGlvbjogQW5ub3RhdGlvbjtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBzdGFja0lkeDogbnVtYmVyO1xufSkgPT4ge1xuICAvKiBpZiB0aGUgYW5ub3RhdGlvbiBzcGFucyB0aGUgc2VhbSwgd2UgZHJhdyB0d28gbGluZXMgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGVuZCwgYW5kIGZyb20gc3RhcnQgdG8gZW5kICovXG5cbiAgY29uc3QgYW5ub3RhdGlvblNwYW5zU2VhbSA9IGFubm90YXRpb24uc3RhcnQgPiBhbm5vdGF0aW9uLmVuZDtcbiAgaWYgKGFubm90YXRpb25TcGFuc1NlYW0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEZyYWdtZW50PlxuICAgICAgICA8TGluZWFyQW5ub3RhdGlvblxuICAgICAgICAgIGFubm90YXRpb249e3tcbiAgICAgICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgICAgICBlbmQ6IHNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbi5vbkNsaWNrPy4oeyAuLi5hbm5vdGF0aW9uIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHNlcXVlbmNlPXtzZXF1ZW5jZX1cbiAgICAgICAgICBzdGFja0lkeD17c3RhY2tJZHh9XG4gICAgICAgIC8+XG4gICAgICAgIDxMaW5lYXJBbm5vdGF0aW9uXG4gICAgICAgICAgYW5ub3RhdGlvbj17e1xuICAgICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICBhbm5vdGF0aW9uLm9uQ2xpY2s/Lih7IC4uLmFubm90YXRpb24gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgICAgc2VxdWVuY2U9e3NlcXVlbmNlfVxuICAgICAgICAgIHN0YWNrSWR4PXtzdGFja0lkeH1cbiAgICAgICAgLz5cbiAgICAgIDwvRnJhZ21lbnQ+XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGFubm90YXRpb25SZWN0YW5nbGVXaWR0aFBlcmMgPVxuICAgIChnZXRTdWJzZXF1ZW5jZUxlbmd0aChhbm5vdGF0aW9uLCBzZXF1ZW5jZS5sZW5ndGgpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcblxuICBjb25zdCB4UGVyYyA9XG4gICAgKE1hdGgubWluKGFubm90YXRpb24uc3RhcnQsIGFubm90YXRpb24uZW5kKSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIC8vIGNsaXAgcGF0aCB0byBjcmVhdGUgcmVjdGFuZ2xlIHdpdGggYSBwb2ludCBhdCBvbmUgZW5kXG4gIGNvbnN0IGZvcndhcmRDbGlwUGF0aCA9IFwicG9seWdvbigwIDAsIDkwJSAwLCAxMDAlIDUwJSwgOTAlIDEwMCUsIDAgMTAwJSlcIjtcbiAgY29uc3QgcmV2ZXJzZUNsaXBQYXRoID0gXCJwb2x5Z29uKDAgNTAlLCAxMCUgMCwgMTAwJSAwLCAxMDAlIDEwMCUsIDEwJSAxMDAlKVwiO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cImdyb3VwIGFic29sdXRlXCJcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIG1hcmdpbkxlZnQ6IGAke3hQZXJjfSVgLFxuICAgICAgICB3aWR0aDogYCR7YW5ub3RhdGlvblJlY3RhbmdsZVdpZHRoUGVyY30lYCxcbiAgICAgIH19XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGFubm90YXRpb24ub25DbGljaz8uKGFubm90YXRpb24pO1xuICAgICAgfX1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICBcInB4LTJcIixcbiAgICAgICAgICBhbm5vdGF0aW9uLmRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCIgPyBcInRleHQtbGVmdFwiIDogXCJ0ZXh0LXJpZ2h0XCIsXG4gICAgICAgICAgYW5ub3RhdGlvbi5jbGFzc05hbWUsXG4gICAgICAgICl9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgY2xpcFBhdGg6XG4gICAgICAgICAgICBhbm5vdGF0aW9uLmRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCJcbiAgICAgICAgICAgICAgPyBmb3J3YXJkQ2xpcFBhdGhcbiAgICAgICAgICAgICAgOiByZXZlcnNlQ2xpcFBhdGgsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHthbm5vdGF0aW9uLnRleHR9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwiYWJzb2x1dGUgbGVmdC0xLzIgei0xMCBoaWRkZW4gLXRyYW5zbGF0ZS14LTEvMiB0cmFuc2xhdGUteS00IGZsZXgtY29sIHJvdW5kZWQtbWQgcHgtMiBweS0xIHRleHQtc20gZ3JvdXAtaG92ZXI6ZmxleFwiLFxuICAgICAgICAgIGFubm90YXRpb24uY2xhc3NOYW1lLFxuICAgICAgICApfVxuICAgICAgPlxuICAgICAgICA8c3Bhbj57YW5ub3RhdGlvbi50ZXh0fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4+e2Fubm90YXRpb24udHlwZX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0IH0gZnJvbSBcIkBBcmlhZG5lL2hvb2tzL3VzZVNlbGVjdGlvblwiO1xuaW1wb3J0IHsgZ2V0QW5ub3RhdGVkU2VxdWVuY2UsIGdldFN1YnNlcXVlbmNlTGVuZ3RoIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEFubm90YXRlZFNlcXVlbmNlLFxuICBBcmlhZG5lU2VsZWN0aW9uLFxuICBBbm5vdGF0aW9uLFxuICBBbm5vdGF0ZWRCYXNlLFxuICBTdGFja2VkQW5ub3RhdGlvbixcbn0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBzdGFja0Fubm90YXRpb25zTm9PdmVybGFwIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBMaW5lYXJBbm5vdGF0aW9uR3V0dGVyIH0gZnJvbSBcIi4vTGluZWFyQW5ub3RhdGlvbkd1dHRlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgc2VxdWVuY2VzOiBzdHJpbmdbXTtcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgb25Eb3VibGVDbGljaz86ICgpID0+IHZvaWQ7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24pID0+IHN0cmluZztcbiAgY29udGFpbmVyQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBzZXF1ZW5jZUNsYXNzTmFtZTogKHsgc2VxdWVuY2VJZHggfTogeyBzZXF1ZW5jZUlkeDogbnVtYmVyIH0pID0+IHN0cmluZztcbiAgbWlzbWF0Y2hDbGFzc05hbWU/OiAobWlzbWF0Y2hlZEJhc2U6IEFubm90YXRlZEJhc2UpID0+IHN0cmluZztcbiAgc3RhY2tpbmdGbj86IChhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdKSA9PiBTdGFja2VkQW5ub3RhdGlvbltdO1xufVxuXG5jb25zdCBNSVNNQVRDSF9ESVNUX1BFUkNfVEhSRVNIT0xEID0gMC4wMTtcblxuZXhwb3J0IGNvbnN0IExpbmVhclZpZXdlciA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIHNlcXVlbmNlcyxcbiAgICBzZWxlY3Rpb24sXG4gICAgYW5ub3RhdGlvbnMsXG4gICAgc2V0U2VsZWN0aW9uLFxuICAgIG9uRG91YmxlQ2xpY2ssXG4gICAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxuICAgIG1pc21hdGNoQ2xhc3NOYW1lLFxuICAgIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICBzZXF1ZW5jZUNsYXNzTmFtZSxcbiAgICBzdGFja2luZ0ZuLFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgLy8gaWYgYSBzdGFja2luZyBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIGl0LCBvdGhlcndpc2UgdXNlIHRoZSBkZWZhdWx0IHdoaWNoXG4gICAgICAvLyBzdGFja3MgYW5ub3RhdGlvbnMgdG8gcHJldmVudCBvdmVybGFwLlxuICAgICAgcmV0dXJuIHN0YWNraW5nRm5cbiAgICAgICAgPyBzdGFja2luZ0ZuKGFubm90YXRpb25zKVxuICAgICAgICA6IHN0YWNrQW5ub3RhdGlvbnNOb092ZXJsYXAoXG4gICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgIE1hdGgubWF4KC4uLnNlcXVlbmNlcy5tYXAoKHNlcSkgPT4gc2VxLmxlbmd0aCkpLFxuICAgICAgICAgICk7XG4gICAgfSxcbiAgICBbYW5ub3RhdGlvbnNdLFxuICApO1xuXG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlcyA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZXMubWFwKChzZXF1ZW5jZSkgPT5cbiAgICAgICAgZ2V0QW5ub3RhdGVkU2VxdWVuY2UoeyBzZXF1ZW5jZSwgc3RhY2tlZEFubm90YXRpb25zIH0pLFxuICAgICAgKTtcbiAgICB9LFxuICAgIFtzZXF1ZW5jZXMsIHN0YWNrZWRBbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgYmFzZVNlcXVlbmNlID0gYW5ub3RhdGVkU2VxdWVuY2VzWzBdO1xuICBjb25zdCBzZWxlY3Rpb25SZWYgPSB1c2VSZWY8U1ZHU1ZHRWxlbWVudD4obnVsbCk7XG5cbiAgLy8gY29uc3QgbnVtYmVyT2ZUaWNrcyA9IDU7XG4gIC8vIGNvbnN0IGJhc2VzUGVyVGljayA9IE1hdGguZmxvb3Ioc2VxdWVuY2UubGVuZ3RoIC8gbnVtYmVyT2ZUaWNrcyk7XG5cbiAgY29uc3QgU1ZHX1dJRFRIID0gNTAwO1xuICBjb25zdCBTVkdfSEVJR0hUID0gc2VxdWVuY2VzLmxlbmd0aCAqIDEwICsgMTA7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y29udGFpbmVyQ2xhc3NOYW1lIHx8IFwiXCJ9PlxuICAgICAgPHN2Z1xuICAgICAgICByZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwic2VsZWN0LW5vbmUgZm9udC10aGluXCIpfVxuICAgICAgICBvbkRvdWJsZUNsaWNrPXtvbkRvdWJsZUNsaWNrfVxuICAgICAgICB2aWV3Qm94PXtgMCAwICR7U1ZHX1dJRFRIfSAke1NWR19IRUlHSFR9YH1cbiAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgPlxuICAgICAgICA8Zz5cbiAgICAgICAgICB7YW5ub3RhdGVkU2VxdWVuY2VzLm1hcCgoc2VxdWVuY2UsIGkpID0+IChcbiAgICAgICAgICAgIDxnIGtleT17YFNlcXVlbmNlLSR7aX1gfT5cbiAgICAgICAgICAgICAgPFNlcXVlbmNlTGluZVxuICAgICAgICAgICAgICAgIHNlcXVlbmNlQ2xhc3NOYW1lPXtzZXF1ZW5jZUNsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICBiYXNlU2VxdWVuY2U9e3NlcXVlbmNlfVxuICAgICAgICAgICAgICAgIGFsaWduZWRTZXF1ZW5jZXM9e2Fubm90YXRlZFNlcXVlbmNlcy5maWx0ZXIoKF8sIGopID0+IGogIT09IGkpfVxuICAgICAgICAgICAgICAgIHNlcXVlbmNlSWR4PXtpfVxuICAgICAgICAgICAgICAgIG1pc21hdGNoQ2xhc3NOYW1lPXttaXNtYXRjaENsYXNzTmFtZX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9nPlxuICAgICAgICA8TGluZWFyU2VsZWN0aW9uXG4gICAgICAgICAgc2VsZWN0aW9uQ2xhc3NOYW1lPXtzZWxlY3Rpb25DbGFzc05hbWV9XG4gICAgICAgICAgc2VsZWN0aW9uUmVmPXtzZWxlY3Rpb25SZWZ9XG4gICAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgc2V0U2VsZWN0aW9uPXtzZXRTZWxlY3Rpb259XG4gICAgICAgICAgc2VxdWVuY2U9e2Jhc2VTZXF1ZW5jZX1cbiAgICAgICAgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAge3N0YWNrZWRBbm5vdGF0aW9ucy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPExpbmVhckFubm90YXRpb25HdXR0ZXJcbiAgICAgICAgICBjb250YWluZXJDbGFzc05hbWU9XCJcIlxuICAgICAgICAgIHN0YWNrZWRBbm5vdGF0aW9ucz17c3RhY2tlZEFubm90YXRpb25zfVxuICAgICAgICAgIHNlcXVlbmNlPXtiYXNlU2VxdWVuY2V9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuaW50ZXJmYWNlIFNlcXVlbmNlTGluZVByb3BzIHtcbiAgYmFzZVNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgc2VxdWVuY2VJZHg6IG51bWJlcjtcbiAgYWxpZ25lZFNlcXVlbmNlczogQW5ub3RhdGVkU2VxdWVuY2VbXTtcbiAgc2VxdWVuY2VDbGFzc05hbWU6ICh7IHNlcXVlbmNlSWR4IH06IHsgc2VxdWVuY2VJZHg6IG51bWJlciB9KSA9PiBzdHJpbmc7XG4gIG1pc21hdGNoQ2xhc3NOYW1lPzogKG1pc21hdGNoZWRCYXNlOiBBbm5vdGF0ZWRCYXNlKSA9PiBzdHJpbmc7XG59XG5cbmNvbnN0IFNlcXVlbmNlTGluZSA9ICh7XG4gIGJhc2VTZXF1ZW5jZSxcbiAgc2VxdWVuY2VJZHgsXG4gIGFsaWduZWRTZXF1ZW5jZXMsXG4gIHNlcXVlbmNlQ2xhc3NOYW1lLFxuICBtaXNtYXRjaENsYXNzTmFtZSxcbn06IFNlcXVlbmNlTGluZVByb3BzKSA9PiB7XG4gIGNvbnN0IHN0YXJ0ID0gYmFzZVNlcXVlbmNlWzBdPy5pbmRleDtcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcXVlbmNlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYmFzZSAke2Jhc2VTZXF1ZW5jZX1gKTtcbiAgfVxuICBjb25zdCBlbmQgPSBiYXNlU2VxdWVuY2VbYmFzZVNlcXVlbmNlLmxlbmd0aCAtIDFdPy5pbmRleDtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTZXF1ZW5jZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGJhc2UgJHtiYXNlU2VxdWVuY2V9YCk7XG4gIH1cblxuICBsZXQgbWF4RW5kID0gZW5kO1xuICBhbGlnbmVkU2VxdWVuY2VzLmZvckVhY2goKGFsaWduZWRTZXF1ZW5jZSkgPT4ge1xuICAgIGNvbnN0IG90aGVyRW5kID0gYWxpZ25lZFNlcXVlbmNlLmF0KGFsaWduZWRTZXF1ZW5jZS5sZW5ndGggLSAxKT8uaW5kZXg7XG4gICAgaWYgKG90aGVyRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYG90aGVyU2VxdWVuY2UgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBiYXNlICR7YWxpZ25lZFNlcXVlbmNlfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvdGhlckVuZCA+IG1heEVuZCkge1xuICAgICAgbWF4RW5kID0gb3RoZXJFbmQ7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3RhcnRQZXJjID0gc3RhcnQgLyBtYXhFbmQ7XG4gIGNvbnN0IGVuZFBlcmMgPSBlbmQgLyBtYXhFbmQ7XG5cbiAgLy8gbWlzbWF0Y2hlc1xuICBjb25zdCBtaXNtYXRjaGVzID0gYmFzZVNlcXVlbmNlLmZpbHRlcigoYmFzZSkgPT4ge1xuICAgIGNvbnN0IHJvb3RCYXNlID0gYmFzZVNlcXVlbmNlLmF0KGJhc2UuaW5kZXgpO1xuICAgIHJldHVybiByb290QmFzZSAmJiByb290QmFzZS5iYXNlICE9PSBiYXNlLmJhc2U7XG4gIH0pO1xuICBtaXNtYXRjaENsYXNzTmFtZSA9XG4gICAgbWlzbWF0Y2hDbGFzc05hbWUgPz9cbiAgICBmdW5jdGlvbiBtaXNtYXRjaENsYXNzTmFtZShtaXNtYXRjaDogQW5ub3RhdGVkQmFzZSkge1xuICAgICAgaWYgKG1pc21hdGNoLmJhc2UgPT09IFwiLVwiKSB7XG4gICAgICAgIHJldHVybiBcImZpbGwtYmxhY2sgc3Ryb2tlLWJsYWNrIG9wYWNpdHktODBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcImRhcms6ZmlsbC1yZWQtNjAwIGRhcms6c3Ryb2tlLXJlZC02MDAgZmlsbC1yZWQtNzAwIHN0cm9rZS1yZWQtNzAwXCI7XG4gICAgICB9XG4gICAgfTtcblxuICBsZXQgbGFzdFhQZXJjID0gLTE7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxsaW5lXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcIlwiLCBzZXF1ZW5jZUNsYXNzTmFtZSh7IHNlcXVlbmNlSWR4IH0pKX1cbiAgICAgICAgeDE9e2Ake3N0YXJ0UGVyYyAqIDEwMH0lYH1cbiAgICAgICAgeTE9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICB4Mj17YCR7ZW5kUGVyYyAqIDEwMH0lYH1cbiAgICAgICAgeTI9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICBzdHJva2VXaWR0aD17NX1cbiAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgICB7bWlzbWF0Y2hlcy5tYXAoKGJhc2UpID0+IHtcbiAgICAgICAgY29uc3QgeFBlcmMgPSAoYmFzZS5pbmRleCAvIG1heEVuZCkgKiAxMDA7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoKDEgLyBiYXNlU2VxdWVuY2UubGVuZ3RoKSAqIDEwMCwgMC4wMSk7XG4gICAgICAgIGNvbnN0IGRpZmYgPSB4UGVyYyAtIGxhc3RYUGVyYztcbiAgICAgICAgaWYgKGRpZmYgPCBNSVNNQVRDSF9ESVNUX1BFUkNfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgLy8gRGlzcGxheWluZyBldmVyeSBtaXNtYXRjaCBpcyBub3QgcGFydGljdWxhcmx5IGhlbHBmdWwgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gc2VlIHRoZW0uIEhlcmUgd2UgY2hvb3NlIGEgcmVhc29uYWJsZVxuICAgICAgICAgIC8vIHRocmVzaG9sZCBhbmQgb25seSBkaXNwbGF5IGVsZW1lbnRzIHRoYXQgYXJlIHN1ZmZpY2llbnRseSBmYXIgYXBhcnQuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFhQZXJjID0geFBlcmM7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGdcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhtaXNtYXRjaENsYXNzTmFtZT8uKGJhc2UpIHx8IFwiYmctcmVkLTQwMFwiKX1cbiAgICAgICAgICAgIGtleT17YHNlcXVlbmNlLSR7c2VxdWVuY2VJZHh9LW1pc21hdGNoLSR7YmFzZS5pbmRleH1gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgIHgxPXtgJHt4UGVyYyAtIHdpZHRoIC8gMn0lYH1cbiAgICAgICAgICAgICAgeTE9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICAgICAgICB4Mj17YCR7eFBlcmMgKyB3aWR0aCAvIDJ9JWB9XG4gICAgICAgICAgICAgIHkyPXtgJHtzZXF1ZW5jZUlkeCAqIDEwICsgMTB9YH1cbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezV9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufTtcblxuY29uc3QgTGluZWFyU2VsZWN0aW9uID0gKHtcbiAgc2VsZWN0aW9uLFxuICBzZWxlY3Rpb25SZWYsXG4gIHNldFNlbGVjdGlvbixcbiAgc2VxdWVuY2UsXG4gIHNlbGVjdGlvbkNsYXNzTmFtZSxcbn06IHtcbiAgc2VsZWN0aW9uUmVmOiBSZWFjdC5SZWZPYmplY3Q8U1ZHU1ZHRWxlbWVudD47XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbikgPT4gdm9pZDtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBzZWxlY3Rpb25DbGFzc05hbWU/OiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiBzdHJpbmc7XG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdGFydDogaW50ZXJuYWxTZWxlY3Rpb25TdGFydCxcbiAgICBlbmQ6IGludGVybmFsU2VsZWN0aW9uRW5kLFxuICAgIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24sXG4gIH0gPSB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0KHsgcmVmOiBzZWxlY3Rpb25SZWYgfSk7XG4gIHVzZUVmZmVjdChcbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVTZWxlY3Rpb25VcCgpIHtcbiAgICAgIGlmIChcbiAgICAgICAgc2VsZWN0aW9uUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgaW50ZXJuYWxTZWxlY3Rpb25TdGFydCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvbkVuZFxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHN2Z1dpZHRoID0gc2VsZWN0aW9uUmVmLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgKGludGVybmFsU2VsZWN0aW9uU3RhcnQueCAvIHN2Z1dpZHRoKSAqIHNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAoaW50ZXJuYWxTZWxlY3Rpb25FbmQueCAvIHN2Z1dpZHRoKSAqIHNlcXVlbmNlLmxlbmd0aCxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzaG93IGEgdmVyeSBzbWFsbCBmaXJzdCBzZWxlY3Rpb24gcmVzdWx0IGFzIHN0YXJ0ID09PSBlbmQgYmVjYXVzZSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IHdhbnQgdGhlIGVudGlyZSBzZXF1ZW5jZSB0byBiZSBoaWdobGlnaHRlZCBldmVyeSB0aW1lIHRoZXkgY2xpY2tcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsIHx8IHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0ICsgMSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFNlbGVjdGlvbih7IHN0YXJ0LCBlbmQsIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LCBpbnRlcm5hbFNlbGVjdGlvbkVuZF0sXG4gICk7XG5cbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qIERpc3BsYXkgc2VsZWN0aW9uIGRhdGEgdGhhdCBoYXMgdHJpY2tsZWQgZG93biAqL1xuICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlbGVjdGlvbjtcblxuICAvLyBiYXNpYyBjYXNlXG4gIGxldCBmaXJzdFJlY3RTdGFydCA9IChNYXRoLm1pbihzdGFydCwgZW5kKSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIGxldCBmaXJzdFJlY3RXaWR0aCA9XG4gICAgKGdldFN1YnNlcXVlbmNlTGVuZ3RoKHNlbGVjdGlvbiwgc2VxdWVuY2UubGVuZ3RoKSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIGxldCBzZWNvbmRSZWN0U3RhcnQgPSBudWxsO1xuICBsZXQgc2Vjb25kUmVjdFdpZHRoID0gbnVsbDtcblxuICAvLyBUT0RPOiBhYnN0cmFjdCB0aGlzIGFuZCBsb2dpYyBpbiBMaW5lYXJBbm5vdGF0aW9uIGludG8gaGVscGVyIGZ1bmN0aW9uc1xuICBjb25zdCBzZWxlY3Rpb25TcGFuc1NlYW0gPSBzZWxlY3Rpb24uc3RhcnQgPiBzZWxlY3Rpb24uZW5kO1xuXG4gIC8qIGlmIGRpcmVjdGlvbiBpcyBiYWNrd2FyZCBhbmQgZW5kID4gc3RhcnQgd2UgbmVlZCB0byByZW5kZXIgdHdvIHJlY3RhbmdsZXMgKi9cbiAgaWYgKHNlbGVjdGlvblNwYW5zU2VhbSkge1xuICAgIGZpcnN0UmVjdFN0YXJ0ID0gMDtcbiAgICBmaXJzdFJlY3RXaWR0aCA9IChlbmQgLyBzZXF1ZW5jZS5sZW5ndGgpICogMTAwO1xuICAgIHNlY29uZFJlY3RTdGFydCA9IChzdGFydCAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gICAgc2Vjb25kUmVjdFdpZHRoID0gKChzZXF1ZW5jZS5sZW5ndGggLSBzdGFydCkgLyBzZXF1ZW5jZS5sZW5ndGgpICogMTAwO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8Z1xuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICBcImZpbGwtY3VycmVudCBzdHJva2UtY3VycmVudFwiLFxuICAgICAgICBzZWxlY3Rpb25DbGFzc05hbWU/LihzZWxlY3Rpb24pLFxuICAgICAgKX1cbiAgICA+XG4gICAgICA8cmVjdFxuICAgICAgICB4PXtgJHtmaXJzdFJlY3RTdGFydH0lYH1cbiAgICAgICAgd2lkdGg9e2Ake2ZpcnN0UmVjdFdpZHRofSVgfVxuICAgICAgICB5PXtgMCVgfVxuICAgICAgICBoZWlnaHQ9e2AxMDAlYH1cbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIGZpbGxPcGFjaXR5PXswLjJ9XG4gICAgICAgIHN0cm9rZVdpZHRoPXsxLjV9XG4gICAgICAvPlxuICAgICAge3NlY29uZFJlY3RTdGFydCAmJiBzZWNvbmRSZWN0V2lkdGggJiYgKFxuICAgICAgICA8cmVjdFxuICAgICAgICAgIHg9e2Ake3NlY29uZFJlY3RTdGFydH0lYH1cbiAgICAgICAgICB3aWR0aD17YCR7c2Vjb25kUmVjdFdpZHRofSVgfVxuICAgICAgICAgIHk9e2AwJWB9XG4gICAgICAgICAgaGVpZ2h0PXtgMTAwJWB9XG4gICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgZmlsbE9wYWNpdHk9ezAuMn1cbiAgICAgICAgICBzdHJva2VXaWR0aD17MS41fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICA8L2c+XG4gICk7XG59O1xuIiwiLy8gcGFja2FnZXMvY29yZS9udW1iZXIvc3JjL251bWJlci50c1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIFttaW4sIG1heF0pIHtcbiAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCB2YWx1ZSkpO1xufVxuZXhwb3J0IHtcbiAgY2xhbXBcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9jb3JlL3ByaW1pdGl2ZS9zcmMvcHJpbWl0aXZlLnRzeFxuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnMob3JpZ2luYWxFdmVudEhhbmRsZXIsIG91ckV2ZW50SGFuZGxlciwgeyBjaGVja0ZvckRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlIH0gPSB7fSkge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBvcmlnaW5hbEV2ZW50SGFuZGxlcj8uKGV2ZW50KTtcbiAgICBpZiAoY2hlY2tGb3JEZWZhdWx0UHJldmVudGVkID09PSBmYWxzZSB8fCAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuIG91ckV2ZW50SGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5leHBvcnQge1xuICBjb21wb3NlRXZlbnRIYW5kbGVyc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L2NvbnRleHQvc3JjL2NyZWF0ZUNvbnRleHQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dDIocm9vdENvbXBvbmVudE5hbWUsIGRlZmF1bHRDb250ZXh0KSB7XG4gIGNvbnN0IENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRDb250ZXh0KTtcbiAgY29uc3QgUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5jb250ZXh0IH0gPSBwcm9wcztcbiAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29udGV4dCwgT2JqZWN0LnZhbHVlcyhjb250ZXh0KSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZSwgY2hpbGRyZW4gfSk7XG4gIH07XG4gIFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gcm9vdENvbXBvbmVudE5hbWUgKyBcIlByb3ZpZGVyXCI7XG4gIGZ1bmN0aW9uIHVzZUNvbnRleHQyKGNvbnN1bWVyTmFtZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpO1xuICAgIGlmIChjb250ZXh0KSByZXR1cm4gY29udGV4dDtcbiAgICBpZiAoZGVmYXVsdENvbnRleHQgIT09IHZvaWQgMCkgcmV0dXJuIGRlZmF1bHRDb250ZXh0O1xuICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtjb25zdW1lck5hbWV9XFxgIG11c3QgYmUgdXNlZCB3aXRoaW4gXFxgJHtyb290Q29tcG9uZW50TmFtZX1cXGBgKTtcbiAgfVxuICByZXR1cm4gW1Byb3ZpZGVyLCB1c2VDb250ZXh0Ml07XG59XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0U2NvcGUoc2NvcGVOYW1lLCBjcmVhdGVDb250ZXh0U2NvcGVEZXBzID0gW10pIHtcbiAgbGV0IGRlZmF1bHRDb250ZXh0cyA9IFtdO1xuICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0Myhyb290Q29tcG9uZW50TmFtZSwgZGVmYXVsdENvbnRleHQpIHtcbiAgICBjb25zdCBCYXNlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbnRleHQpO1xuICAgIGNvbnN0IGluZGV4ID0gZGVmYXVsdENvbnRleHRzLmxlbmd0aDtcbiAgICBkZWZhdWx0Q29udGV4dHMgPSBbLi4uZGVmYXVsdENvbnRleHRzLCBkZWZhdWx0Q29udGV4dF07XG4gICAgY29uc3QgUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuLCAuLi5jb250ZXh0IH0gPSBwcm9wcztcbiAgICAgIGNvbnN0IENvbnRleHQgPSBzY29wZT8uW3Njb3BlTmFtZV0/LltpbmRleF0gfHwgQmFzZUNvbnRleHQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gY29udGV4dCwgT2JqZWN0LnZhbHVlcyhjb250ZXh0KSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlLCBjaGlsZHJlbiB9KTtcbiAgICB9O1xuICAgIFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gcm9vdENvbXBvbmVudE5hbWUgKyBcIlByb3ZpZGVyXCI7XG4gICAgZnVuY3Rpb24gdXNlQ29udGV4dDIoY29uc3VtZXJOYW1lLCBzY29wZSkge1xuICAgICAgY29uc3QgQ29udGV4dCA9IHNjb3BlPy5bc2NvcGVOYW1lXT8uW2luZGV4XSB8fCBCYXNlQ29udGV4dDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpO1xuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0O1xuICAgICAgaWYgKGRlZmF1bHRDb250ZXh0ICE9PSB2b2lkIDApIHJldHVybiBkZWZhdWx0Q29udGV4dDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtjb25zdW1lck5hbWV9XFxgIG11c3QgYmUgdXNlZCB3aXRoaW4gXFxgJHtyb290Q29tcG9uZW50TmFtZX1cXGBgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtQcm92aWRlciwgdXNlQ29udGV4dDJdO1xuICB9XG4gIGNvbnN0IGNyZWF0ZVNjb3BlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlQ29udGV4dHMgPSBkZWZhdWx0Q29udGV4dHMubWFwKChkZWZhdWx0Q29udGV4dCkgPT4ge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbnRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VTY29wZShzY29wZSkge1xuICAgICAgY29uc3QgY29udGV4dHMgPSBzY29wZT8uW3Njb3BlTmFtZV0gfHwgc2NvcGVDb250ZXh0cztcbiAgICAgIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICAgICAoKSA9PiAoeyBbYF9fc2NvcGUke3Njb3BlTmFtZX1gXTogeyAuLi5zY29wZSwgW3Njb3BlTmFtZV06IGNvbnRleHRzIH0gfSksXG4gICAgICAgIFtzY29wZSwgY29udGV4dHNdXG4gICAgICApO1xuICAgIH07XG4gIH07XG4gIGNyZWF0ZVNjb3BlLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgcmV0dXJuIFtjcmVhdGVDb250ZXh0MywgY29tcG9zZUNvbnRleHRTY29wZXMoY3JlYXRlU2NvcGUsIC4uLmNyZWF0ZUNvbnRleHRTY29wZURlcHMpXTtcbn1cbmZ1bmN0aW9uIGNvbXBvc2VDb250ZXh0U2NvcGVzKC4uLnNjb3Blcykge1xuICBjb25zdCBiYXNlU2NvcGUgPSBzY29wZXNbMF07XG4gIGlmIChzY29wZXMubGVuZ3RoID09PSAxKSByZXR1cm4gYmFzZVNjb3BlO1xuICBjb25zdCBjcmVhdGVTY29wZSA9ICgpID0+IHtcbiAgICBjb25zdCBzY29wZUhvb2tzID0gc2NvcGVzLm1hcCgoY3JlYXRlU2NvcGUyKSA9PiAoe1xuICAgICAgdXNlU2NvcGU6IGNyZWF0ZVNjb3BlMigpLFxuICAgICAgc2NvcGVOYW1lOiBjcmVhdGVTY29wZTIuc2NvcGVOYW1lXG4gICAgfSkpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1c2VDb21wb3NlZFNjb3BlcyhvdmVycmlkZVNjb3Blcykge1xuICAgICAgY29uc3QgbmV4dFNjb3BlcyA9IHNjb3BlSG9va3MucmVkdWNlKChuZXh0U2NvcGVzMiwgeyB1c2VTY29wZSwgc2NvcGVOYW1lIH0pID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcGVQcm9wcyA9IHVzZVNjb3BlKG92ZXJyaWRlU2NvcGVzKTtcbiAgICAgICAgY29uc3QgY3VycmVudFNjb3BlID0gc2NvcGVQcm9wc1tgX19zY29wZSR7c2NvcGVOYW1lfWBdO1xuICAgICAgICByZXR1cm4geyAuLi5uZXh0U2NvcGVzMiwgLi4uY3VycmVudFNjb3BlIH07XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoeyBbYF9fc2NvcGUke2Jhc2VTY29wZS5zY29wZU5hbWV9YF06IG5leHRTY29wZXMgfSksIFtuZXh0U2NvcGVzXSk7XG4gICAgfTtcbiAgfTtcbiAgY3JlYXRlU2NvcGUuc2NvcGVOYW1lID0gYmFzZVNjb3BlLnNjb3BlTmFtZTtcbiAgcmV0dXJuIGNyZWF0ZVNjb3BlO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlQ29udGV4dDIgYXMgY3JlYXRlQ29udGV4dCxcbiAgY3JlYXRlQ29udGV4dFNjb3BlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvY29tcG9zZS1yZWZzL3NyYy9jb21wb3NlUmVmcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gc2V0UmVmKHJlZiwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiByZWYodmFsdWUpO1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHZvaWQgMCkge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgbGV0IGhhc0NsZWFudXAgPSBmYWxzZTtcbiAgICBjb25zdCBjbGVhbnVwcyA9IHJlZnMubWFwKChyZWYpID0+IHtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSBzZXRSZWYocmVmLCBub2RlKTtcbiAgICAgIGlmICghaGFzQ2xlYW51cCAmJiB0eXBlb2YgY2xlYW51cCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaGFzQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9KTtcbiAgICBpZiAoaGFzQ2xlYW51cCkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGVhbnVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBjbGVhbnVwc1tpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNsZWFudXAgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFJlZihyZWZzW2ldLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlQ29tcG9zZWRSZWZzKC4uLnJlZnMpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGNvbXBvc2VSZWZzKC4uLnJlZnMpLCByZWZzKTtcbn1cbmV4cG9ydCB7XG4gIGNvbXBvc2VSZWZzLFxuICB1c2VDb21wb3NlZFJlZnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9zbG90L3NyYy9zbG90LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjb21wb3NlUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBGcmFnbWVudCBhcyBGcmFnbWVudDIsIGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNsb3QgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnNsb3RQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTtcbiAgY29uc3Qgc2xvdHRhYmxlID0gY2hpbGRyZW5BcnJheS5maW5kKGlzU2xvdHRhYmxlKTtcbiAgaWYgKHNsb3R0YWJsZSkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBzbG90dGFibGUucHJvcHMuY2hpbGRyZW47XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBjaGlsZHJlbkFycmF5Lm1hcCgoY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZCA9PT0gc2xvdHRhYmxlKSB7XG4gICAgICAgIGlmIChSZWFjdC5DaGlsZHJlbi5jb3VudChuZXdFbGVtZW50KSA+IDEpIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KG51bGwpO1xuICAgICAgICByZXR1cm4gUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV3RWxlbWVudCkgPyBuZXdFbGVtZW50LnByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90Q2xvbmUsIHsgLi4uc2xvdFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiwgY2hpbGRyZW46IFJlYWN0LmlzVmFsaWRFbGVtZW50KG5ld0VsZW1lbnQpID8gUmVhY3QuY2xvbmVFbGVtZW50KG5ld0VsZW1lbnQsIHZvaWQgMCwgbmV3Q2hpbGRyZW4pIDogbnVsbCB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90Q2xvbmUsIHsgLi4uc2xvdFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiwgY2hpbGRyZW4gfSk7XG59KTtcblNsb3QuZGlzcGxheU5hbWUgPSBcIlNsb3RcIjtcbnZhciBTbG90Q2xvbmUgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnNsb3RQcm9wcyB9ID0gcHJvcHM7XG4gIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjb25zdCBjaGlsZHJlblJlZiA9IGdldEVsZW1lbnRSZWYoY2hpbGRyZW4pO1xuICAgIGNvbnN0IHByb3BzMiA9IG1lcmdlUHJvcHMoc2xvdFByb3BzLCBjaGlsZHJlbi5wcm9wcyk7XG4gICAgaWYgKGNoaWxkcmVuLnR5cGUgIT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICBwcm9wczIucmVmID0gZm9yd2FyZGVkUmVmID8gY29tcG9zZVJlZnMoZm9yd2FyZGVkUmVmLCBjaGlsZHJlblJlZikgOiBjaGlsZHJlblJlZjtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgcHJvcHMyKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID4gMSA/IFJlYWN0LkNoaWxkcmVuLm9ubHkobnVsbCkgOiBudWxsO1xufSk7XG5TbG90Q2xvbmUuZGlzcGxheU5hbWUgPSBcIlNsb3RDbG9uZVwiO1xudmFyIFNsb3R0YWJsZSA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQyLCB7IGNoaWxkcmVuIH0pO1xufTtcbmZ1bmN0aW9uIGlzU2xvdHRhYmxlKGNoaWxkKSB7XG4gIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgY2hpbGQudHlwZSA9PT0gU2xvdHRhYmxlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhzbG90UHJvcHMsIGNoaWxkUHJvcHMpIHtcbiAgY29uc3Qgb3ZlcnJpZGVQcm9wcyA9IHsgLi4uY2hpbGRQcm9wcyB9O1xuICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIGNoaWxkUHJvcHMpIHtcbiAgICBjb25zdCBzbG90UHJvcFZhbHVlID0gc2xvdFByb3BzW3Byb3BOYW1lXTtcbiAgICBjb25zdCBjaGlsZFByb3BWYWx1ZSA9IGNoaWxkUHJvcHNbcHJvcE5hbWVdO1xuICAgIGNvbnN0IGlzSGFuZGxlciA9IC9eb25bQS1aXS8udGVzdChwcm9wTmFtZSk7XG4gICAgaWYgKGlzSGFuZGxlcikge1xuICAgICAgaWYgKHNsb3RQcm9wVmFsdWUgJiYgY2hpbGRQcm9wVmFsdWUpIHtcbiAgICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGNoaWxkUHJvcFZhbHVlKC4uLmFyZ3MpO1xuICAgICAgICAgIHNsb3RQcm9wVmFsdWUoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHNsb3RQcm9wVmFsdWUpIHtcbiAgICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSBzbG90UHJvcFZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSB7IC4uLnNsb3RQcm9wVmFsdWUsIC4uLmNoaWxkUHJvcFZhbHVlIH07XG4gICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCJjbGFzc05hbWVcIikge1xuICAgICAgb3ZlcnJpZGVQcm9wc1twcm9wTmFtZV0gPSBbc2xvdFByb3BWYWx1ZSwgY2hpbGRQcm9wVmFsdWVdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgLi4uc2xvdFByb3BzLCAuLi5vdmVycmlkZVByb3BzIH07XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UmVmKGVsZW1lbnQpIHtcbiAgbGV0IGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWxlbWVudC5wcm9wcywgXCJyZWZcIik/LmdldDtcbiAgbGV0IG1heVdhcm4gPSBnZXR0ZXIgJiYgXCJpc1JlYWN0V2FybmluZ1wiIGluIGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmc7XG4gIGlmIChtYXlXYXJuKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQucmVmO1xuICB9XG4gIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZWxlbWVudCwgXCJyZWZcIik/LmdldDtcbiAgbWF5V2FybiA9IGdldHRlciAmJiBcImlzUmVhY3RXYXJuaW5nXCIgaW4gZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZztcbiAgaWYgKG1heVdhcm4pIHtcbiAgICByZXR1cm4gZWxlbWVudC5wcm9wcy5yZWY7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucHJvcHMucmVmIHx8IGVsZW1lbnQucmVmO1xufVxudmFyIFJvb3QgPSBTbG90O1xuZXhwb3J0IHtcbiAgUm9vdCxcbiAgU2xvdCxcbiAgU2xvdHRhYmxlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L2NvbGxlY3Rpb24vc3JjL2NvbGxlY3Rpb24udHN4XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0U2NvcGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb24obmFtZSkge1xuICBjb25zdCBQUk9WSURFUl9OQU1FID0gbmFtZSArIFwiQ29sbGVjdGlvblByb3ZpZGVyXCI7XG4gIGNvbnN0IFtjcmVhdGVDb2xsZWN0aW9uQ29udGV4dCwgY3JlYXRlQ29sbGVjdGlvblNjb3BlXSA9IGNyZWF0ZUNvbnRleHRTY29wZShQUk9WSURFUl9OQU1FKTtcbiAgY29uc3QgW0NvbGxlY3Rpb25Qcm92aWRlckltcGwsIHVzZUNvbGxlY3Rpb25Db250ZXh0XSA9IGNyZWF0ZUNvbGxlY3Rpb25Db250ZXh0KFxuICAgIFBST1ZJREVSX05BTUUsXG4gICAgeyBjb2xsZWN0aW9uUmVmOiB7IGN1cnJlbnQ6IG51bGwgfSwgaXRlbU1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9XG4gICk7XG4gIGNvbnN0IENvbGxlY3Rpb25Qcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaXRlbU1hcCA9IFJlYWN0LnVzZVJlZigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKS5jdXJyZW50O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb25Qcm92aWRlckltcGwsIHsgc2NvcGUsIGl0ZW1NYXAsIGNvbGxlY3Rpb25SZWY6IHJlZiwgY2hpbGRyZW4gfSk7XG4gIH07XG4gIENvbGxlY3Rpb25Qcm92aWRlci5kaXNwbGF5TmFtZSA9IFBST1ZJREVSX05BTUU7XG4gIGNvbnN0IENPTExFQ1RJT05fU0xPVF9OQU1FID0gbmFtZSArIFwiQ29sbGVjdGlvblNsb3RcIjtcbiAgY29uc3QgQ29sbGVjdGlvblNsb3QgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAgIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgICBjb25zdCB7IHNjb3BlLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29sbGVjdGlvbkNvbnRleHQoQ09MTEVDVElPTl9TTE9UX05BTUUsIHNjb3BlKTtcbiAgICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRleHQuY29sbGVjdGlvblJlZik7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90LCB7IHJlZjogY29tcG9zZWRSZWZzLCBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICk7XG4gIENvbGxlY3Rpb25TbG90LmRpc3BsYXlOYW1lID0gQ09MTEVDVElPTl9TTE9UX05BTUU7XG4gIGNvbnN0IElURU1fU0xPVF9OQU1FID0gbmFtZSArIFwiQ29sbGVjdGlvbkl0ZW1TbG90XCI7XG4gIGNvbnN0IElURU1fREFUQV9BVFRSID0gXCJkYXRhLXJhZGl4LWNvbGxlY3Rpb24taXRlbVwiO1xuICBjb25zdCBDb2xsZWN0aW9uSXRlbVNsb3QgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAgIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgICBjb25zdCB7IHNjb3BlLCBjaGlsZHJlbiwgLi4uaXRlbURhdGEgfSA9IHByb3BzO1xuICAgICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb2xsZWN0aW9uQ29udGV4dChJVEVNX1NMT1RfTkFNRSwgc2NvcGUpO1xuICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udGV4dC5pdGVtTWFwLnNldChyZWYsIHsgcmVmLCAuLi5pdGVtRGF0YSB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHZvaWQgY29udGV4dC5pdGVtTWFwLmRlbGV0ZShyZWYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTbG90LCB7IC4uLnsgW0lURU1fREFUQV9BVFRSXTogXCJcIiB9LCByZWY6IGNvbXBvc2VkUmVmcywgY2hpbGRyZW4gfSk7XG4gICAgfVxuICApO1xuICBDb2xsZWN0aW9uSXRlbVNsb3QuZGlzcGxheU5hbWUgPSBJVEVNX1NMT1RfTkFNRTtcbiAgZnVuY3Rpb24gdXNlQ29sbGVjdGlvbihzY29wZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb2xsZWN0aW9uQ29udGV4dChuYW1lICsgXCJDb2xsZWN0aW9uQ29uc3VtZXJcIiwgc2NvcGUpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdGlvbk5vZGUgPSBjb250ZXh0LmNvbGxlY3Rpb25SZWYuY3VycmVudDtcbiAgICAgIGlmICghY29sbGVjdGlvbk5vZGUpIHJldHVybiBbXTtcbiAgICAgIGNvbnN0IG9yZGVyZWROb2RlcyA9IEFycmF5LmZyb20oY29sbGVjdGlvbk5vZGUucXVlcnlTZWxlY3RvckFsbChgWyR7SVRFTV9EQVRBX0FUVFJ9XWApKTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShjb250ZXh0Lml0ZW1NYXAudmFsdWVzKCkpO1xuICAgICAgY29uc3Qgb3JkZXJlZEl0ZW1zID0gaXRlbXMuc29ydChcbiAgICAgICAgKGEsIGIpID0+IG9yZGVyZWROb2Rlcy5pbmRleE9mKGEucmVmLmN1cnJlbnQpIC0gb3JkZXJlZE5vZGVzLmluZGV4T2YoYi5yZWYuY3VycmVudClcbiAgICAgICk7XG4gICAgICByZXR1cm4gb3JkZXJlZEl0ZW1zO1xuICAgIH0sIFtjb250ZXh0LmNvbGxlY3Rpb25SZWYsIGNvbnRleHQuaXRlbU1hcF0pO1xuICAgIHJldHVybiBnZXRJdGVtcztcbiAgfVxuICByZXR1cm4gW1xuICAgIHsgUHJvdmlkZXI6IENvbGxlY3Rpb25Qcm92aWRlciwgU2xvdDogQ29sbGVjdGlvblNsb3QsIEl0ZW1TbG90OiBDb2xsZWN0aW9uSXRlbVNsb3QgfSxcbiAgICB1c2VDb2xsZWN0aW9uLFxuICAgIGNyZWF0ZUNvbGxlY3Rpb25TY29wZVxuICBdO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlQ29sbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L2RpcmVjdGlvbi9zcmMvRGlyZWN0aW9uLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBEaXJlY3Rpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xudmFyIERpcmVjdGlvblByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgZGlyLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KERpcmVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRpciwgY2hpbGRyZW4gfSk7XG59O1xuZnVuY3Rpb24gdXNlRGlyZWN0aW9uKGxvY2FsRGlyKSB7XG4gIGNvbnN0IGdsb2JhbERpciA9IFJlYWN0LnVzZUNvbnRleHQoRGlyZWN0aW9uQ29udGV4dCk7XG4gIHJldHVybiBsb2NhbERpciB8fCBnbG9iYWxEaXIgfHwgXCJsdHJcIjtcbn1cbnZhciBQcm92aWRlciA9IERpcmVjdGlvblByb3ZpZGVyO1xuZXhwb3J0IHtcbiAgRGlyZWN0aW9uUHJvdmlkZXIsXG4gIFByb3ZpZGVyLFxuICB1c2VEaXJlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9wcmltaXRpdmUvc3JjL3ByaW1pdGl2ZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgU2xvdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3Qtc2xvdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTk9ERVMgPSBbXG4gIFwiYVwiLFxuICBcImJ1dHRvblwiLFxuICBcImRpdlwiLFxuICBcImZvcm1cIixcbiAgXCJoMlwiLFxuICBcImgzXCIsXG4gIFwiaW1nXCIsXG4gIFwiaW5wdXRcIixcbiAgXCJsYWJlbFwiLFxuICBcImxpXCIsXG4gIFwibmF2XCIsXG4gIFwib2xcIixcbiAgXCJwXCIsXG4gIFwic3BhblwiLFxuICBcInN2Z1wiLFxuICBcInVsXCJcbl07XG52YXIgUHJpbWl0aXZlID0gTk9ERVMucmVkdWNlKChwcmltaXRpdmUsIG5vZGUpID0+IHtcbiAgY29uc3QgTm9kZSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IGFzQ2hpbGQsIC4uLnByaW1pdGl2ZVByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBDb21wID0gYXNDaGlsZCA/IFNsb3QgOiBub2RlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3dbU3ltYm9sLmZvcihcInJhZGl4LXVpXCIpXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENvbXAsIHsgLi4ucHJpbWl0aXZlUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pO1xuICB9KTtcbiAgTm9kZS5kaXNwbGF5TmFtZSA9IGBQcmltaXRpdmUuJHtub2RlfWA7XG4gIHJldHVybiB7IC4uLnByaW1pdGl2ZSwgW25vZGVdOiBOb2RlIH07XG59LCB7fSk7XG5mdW5jdGlvbiBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnQodGFyZ2V0LCBldmVudCkge1xuICBpZiAodGFyZ2V0KSBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpKTtcbn1cbnZhciBSb290ID0gUHJpbWl0aXZlO1xuZXhwb3J0IHtcbiAgUHJpbWl0aXZlLFxuICBSb290LFxuICBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtY2FsbGJhY2stcmVmL3NyYy91c2VDYWxsYmFja1JlZi50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoY2FsbGJhY2spIHtcbiAgY29uc3QgY2FsbGJhY2tSZWYgPSBSZWFjdC51c2VSZWYoY2FsbGJhY2spO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICguLi5hcmdzKSA9PiBjYWxsYmFja1JlZi5jdXJyZW50Py4oLi4uYXJncyksIFtdKTtcbn1cbmV4cG9ydCB7XG4gIHVzZUNhbGxiYWNrUmVmXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLWVzY2FwZS1rZXlkb3duL3NyYy91c2VFc2NhcGVLZXlkb3duLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuZnVuY3Rpb24gdXNlRXNjYXBlS2V5ZG93bihvbkVzY2FwZUtleURvd25Qcm9wLCBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcz8uZG9jdW1lbnQpIHtcbiAgY29uc3Qgb25Fc2NhcGVLZXlEb3duID0gdXNlQ2FsbGJhY2tSZWYob25Fc2NhcGVLZXlEb3duUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICBvbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IG93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93biwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICB9LCBbb25Fc2NhcGVLZXlEb3duLCBvd25lckRvY3VtZW50XSk7XG59XG5leHBvcnQge1xuICB1c2VFc2NhcGVLZXlkb3duXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L2Rpc21pc3NhYmxlLWxheWVyL3NyYy9kaXNtaXNzYWJsZS1sYXllci50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY29tcG9zZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiQHJhZGl4LXVpL3ByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlLCBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnQgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5pbXBvcnQgeyB1c2VFc2NhcGVLZXlkb3duIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtZXNjYXBlLWtleWRvd25cIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIERJU01JU1NBQkxFX0xBWUVSX05BTUUgPSBcIkRpc21pc3NhYmxlTGF5ZXJcIjtcbnZhciBDT05URVhUX1VQREFURSA9IFwiZGlzbWlzc2FibGVMYXllci51cGRhdGVcIjtcbnZhciBQT0lOVEVSX0RPV05fT1VUU0lERSA9IFwiZGlzbWlzc2FibGVMYXllci5wb2ludGVyRG93bk91dHNpZGVcIjtcbnZhciBGT0NVU19PVVRTSURFID0gXCJkaXNtaXNzYWJsZUxheWVyLmZvY3VzT3V0c2lkZVwiO1xudmFyIG9yaWdpbmFsQm9keVBvaW50ZXJFdmVudHM7XG52YXIgRGlzbWlzc2FibGVMYXllckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgbGF5ZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBsYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgYnJhbmNoZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbn0pO1xudmFyIERpc21pc3NhYmxlTGF5ZXIgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cyA9IGZhbHNlLFxuICAgICAgb25Fc2NhcGVLZXlEb3duLFxuICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUsXG4gICAgICBvbkZvY3VzT3V0c2lkZSxcbiAgICAgIG9uSW50ZXJhY3RPdXRzaWRlLFxuICAgICAgb25EaXNtaXNzLFxuICAgICAgLi4ubGF5ZXJQcm9wc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEaXNtaXNzYWJsZUxheWVyQ29udGV4dCk7XG4gICAgY29uc3QgW25vZGUsIHNldE5vZGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IG5vZGU/Lm93bmVyRG9jdW1lbnQgPz8gZ2xvYmFsVGhpcz8uZG9jdW1lbnQ7XG4gICAgY29uc3QgWywgZm9yY2VdID0gUmVhY3QudXNlU3RhdGUoe30pO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlMikgPT4gc2V0Tm9kZShub2RlMikpO1xuICAgIGNvbnN0IGxheWVycyA9IEFycmF5LmZyb20oY29udGV4dC5sYXllcnMpO1xuICAgIGNvbnN0IFtoaWdoZXN0TGF5ZXJXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZF0gPSBbLi4uY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZF0uc2xpY2UoLTEpO1xuICAgIGNvbnN0IGhpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkSW5kZXggPSBsYXllcnMuaW5kZXhPZihoaWdoZXN0TGF5ZXJXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZCk7XG4gICAgY29uc3QgaW5kZXggPSBub2RlID8gbGF5ZXJzLmluZGV4T2Yobm9kZSkgOiAtMTtcbiAgICBjb25zdCBpc0JvZHlQb2ludGVyRXZlbnRzRGlzYWJsZWQgPSBjb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkLnNpemUgPiAwO1xuICAgIGNvbnN0IGlzUG9pbnRlckV2ZW50c0VuYWJsZWQgPSBpbmRleCA+PSBoaWdoZXN0TGF5ZXJXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZEluZGV4O1xuICAgIGNvbnN0IHBvaW50ZXJEb3duT3V0c2lkZSA9IHVzZVBvaW50ZXJEb3duT3V0c2lkZSgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGNvbnN0IGlzUG9pbnRlckRvd25PbkJyYW5jaCA9IFsuLi5jb250ZXh0LmJyYW5jaGVzXS5zb21lKChicmFuY2gpID0+IGJyYW5jaC5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgIGlmICghaXNQb2ludGVyRXZlbnRzRW5hYmxlZCB8fCBpc1BvaW50ZXJEb3duT25CcmFuY2gpIHJldHVybjtcbiAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlPy4oZXZlbnQpO1xuICAgICAgb25JbnRlcmFjdE91dHNpZGU/LihldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIG9uRGlzbWlzcz8uKCk7XG4gICAgfSwgb3duZXJEb2N1bWVudCk7XG4gICAgY29uc3QgZm9jdXNPdXRzaWRlID0gdXNlRm9jdXNPdXRzaWRlKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgaXNGb2N1c0luQnJhbmNoID0gWy4uLmNvbnRleHQuYnJhbmNoZXNdLnNvbWUoKGJyYW5jaCkgPT4gYnJhbmNoLmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgaWYgKGlzRm9jdXNJbkJyYW5jaCkgcmV0dXJuO1xuICAgICAgb25Gb2N1c091dHNpZGU/LihldmVudCk7XG4gICAgICBvbkludGVyYWN0T3V0c2lkZT8uKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgb25EaXNtaXNzPy4oKTtcbiAgICB9LCBvd25lckRvY3VtZW50KTtcbiAgICB1c2VFc2NhcGVLZXlkb3duKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgaXNIaWdoZXN0TGF5ZXIgPSBpbmRleCA9PT0gY29udGV4dC5sYXllcnMuc2l6ZSAtIDE7XG4gICAgICBpZiAoIWlzSGlnaGVzdExheWVyKSByZXR1cm47XG4gICAgICBvbkVzY2FwZUtleURvd24/LihldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgb25EaXNtaXNzKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uRGlzbWlzcygpO1xuICAgICAgfVxuICAgIH0sIG93bmVyRG9jdW1lbnQpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgIGlmIChkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHQubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIG9yaWdpbmFsQm9keVBvaW50ZXJFdmVudHMgPSBvd25lckRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cztcbiAgICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuYWRkKG5vZGUpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5sYXllcnMuYWRkKG5vZGUpO1xuICAgICAgZGlzcGF0Y2hVcGRhdGUoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHMgJiYgY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5zaXplID09PSAxKSB7XG4gICAgICAgICAgb3duZXJEb2N1bWVudC5ib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBvcmlnaW5hbEJvZHlQb2ludGVyRXZlbnRzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtub2RlLCBvd25lckRvY3VtZW50LCBkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHMsIGNvbnRleHRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgIGNvbnRleHQubGF5ZXJzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5kZWxldGUobm9kZSk7XG4gICAgICAgIGRpc3BhdGNoVXBkYXRlKCk7XG4gICAgICB9O1xuICAgIH0sIFtub2RlLCBjb250ZXh0XSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IGZvcmNlKHt9KTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoQ09OVEVYVF9VUERBVEUsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihDT05URVhUX1VQREFURSwgaGFuZGxlVXBkYXRlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuZGl2LFxuICAgICAge1xuICAgICAgICAuLi5sYXllclByb3BzLFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBpc0JvZHlQb2ludGVyRXZlbnRzRGlzYWJsZWQgPyBpc1BvaW50ZXJFdmVudHNFbmFibGVkID8gXCJhdXRvXCIgOiBcIm5vbmVcIiA6IHZvaWQgMCxcbiAgICAgICAgICAuLi5wcm9wcy5zdHlsZVxuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzQ2FwdHVyZTogY29tcG9zZUV2ZW50SGFuZGxlcnMocHJvcHMub25Gb2N1c0NhcHR1cmUsIGZvY3VzT3V0c2lkZS5vbkZvY3VzQ2FwdHVyZSksXG4gICAgICAgIG9uQmx1ckNhcHR1cmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKHByb3BzLm9uQmx1ckNhcHR1cmUsIGZvY3VzT3V0c2lkZS5vbkJsdXJDYXB0dXJlKSxcbiAgICAgICAgb25Qb2ludGVyRG93bkNhcHR1cmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKFxuICAgICAgICAgIHByb3BzLm9uUG9pbnRlckRvd25DYXB0dXJlLFxuICAgICAgICAgIHBvaW50ZXJEb3duT3V0c2lkZS5vblBvaW50ZXJEb3duQ2FwdHVyZVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcbkRpc21pc3NhYmxlTGF5ZXIuZGlzcGxheU5hbWUgPSBESVNNSVNTQUJMRV9MQVlFUl9OQU1FO1xudmFyIEJSQU5DSF9OQU1FID0gXCJEaXNtaXNzYWJsZUxheWVyQnJhbmNoXCI7XG52YXIgRGlzbWlzc2FibGVMYXllckJyYW5jaCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGlzbWlzc2FibGVMYXllckNvbnRleHQpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHJlZik7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICBjb250ZXh0LmJyYW5jaGVzLmFkZChub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRleHQuYnJhbmNoZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtjb250ZXh0LmJyYW5jaGVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgLi4ucHJvcHMsIHJlZjogY29tcG9zZWRSZWZzIH0pO1xufSk7XG5EaXNtaXNzYWJsZUxheWVyQnJhbmNoLmRpc3BsYXlOYW1lID0gQlJBTkNIX05BTUU7XG5mdW5jdGlvbiB1c2VQb2ludGVyRG93bk91dHNpZGUob25Qb2ludGVyRG93bk91dHNpZGUsIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzPy5kb2N1bWVudCkge1xuICBjb25zdCBoYW5kbGVQb2ludGVyRG93bk91dHNpZGUgPSB1c2VDYWxsYmFja1JlZihvblBvaW50ZXJEb3duT3V0c2lkZSk7XG4gIGNvbnN0IGlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGhhbmRsZUNsaWNrUmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgJiYgIWlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGxldCBoYW5kbGVBbmREaXNwYXRjaFBvaW50ZXJEb3duT3V0c2lkZUV2ZW50MiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGhhbmRsZUFuZERpc3BhdGNoQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICBQT0lOVEVSX0RPV05fT1VUU0lERSxcbiAgICAgICAgICAgIGhhbmRsZVBvaW50ZXJEb3duT3V0c2lkZSxcbiAgICAgICAgICAgIGV2ZW50RGV0YWlsLFxuICAgICAgICAgICAgeyBkaXNjcmV0ZTogdHJ1ZSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQgPSBoYW5kbGVBbmREaXNwYXRjaFBvaW50ZXJEb3duT3V0c2lkZUV2ZW50MjtcbiAgICAgICAgY29uc3QgZXZlbnREZXRhaWwgPSB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50IH07XG4gICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCk7XG4gICAgICAgICAgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCA9IGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyO1xuICAgICAgICAgIG93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrUmVmLmN1cnJlbnQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVBbmREaXNwYXRjaFBvaW50ZXJEb3duT3V0c2lkZUV2ZW50MigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGlja1JlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lcklkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgIH0sIDApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW293bmVyRG9jdW1lbnQsIGhhbmRsZVBvaW50ZXJEb3duT3V0c2lkZV0pO1xuICByZXR1cm4ge1xuICAgIC8vIGVuc3VyZXMgd2UgY2hlY2sgUmVhY3QgY29tcG9uZW50IHRyZWUgKG5vdCBqdXN0IERPTSB0cmVlKVxuICAgIG9uUG9pbnRlckRvd25DYXB0dXJlOiAoKSA9PiBpc1BvaW50ZXJJbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUZvY3VzT3V0c2lkZShvbkZvY3VzT3V0c2lkZSwgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXM/LmRvY3VtZW50KSB7XG4gIGNvbnN0IGhhbmRsZUZvY3VzT3V0c2lkZSA9IHVzZUNhbGxiYWNrUmVmKG9uRm9jdXNPdXRzaWRlKTtcbiAgY29uc3QgaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgJiYgIWlzRm9jdXNJbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBldmVudERldGFpbCA9IHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfTtcbiAgICAgICAgaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudChGT0NVU19PVVRTSURFLCBoYW5kbGVGb2N1c091dHNpZGUsIGV2ZW50RGV0YWlsLCB7XG4gICAgICAgICAgZGlzY3JldGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBoYW5kbGVGb2N1cyk7XG4gICAgcmV0dXJuICgpID0+IG93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgaGFuZGxlRm9jdXMpO1xuICB9LCBbb3duZXJEb2N1bWVudCwgaGFuZGxlRm9jdXNPdXRzaWRlXSk7XG4gIHJldHVybiB7XG4gICAgb25Gb2N1c0NhcHR1cmU6ICgpID0+IGlzRm9jdXNJbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IHRydWUsXG4gICAgb25CbHVyQ2FwdHVyZTogKCkgPT4gaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoVXBkYXRlKCkge1xuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChDT05URVhUX1VQREFURSk7XG4gIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudChuYW1lLCBoYW5kbGVyLCBkZXRhaWwsIHsgZGlzY3JldGUgfSkge1xuICBjb25zdCB0YXJnZXQgPSBkZXRhaWwub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbCB9KTtcbiAgaWYgKGhhbmRsZXIpIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgaWYgKGRpc2NyZXRlKSB7XG4gICAgZGlzcGF0Y2hEaXNjcmV0ZUN1c3RvbUV2ZW50KHRhcmdldCwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxudmFyIFJvb3QgPSBEaXNtaXNzYWJsZUxheWVyO1xudmFyIEJyYW5jaCA9IERpc21pc3NhYmxlTGF5ZXJCcmFuY2g7XG5leHBvcnQge1xuICBCcmFuY2gsXG4gIERpc21pc3NhYmxlTGF5ZXIsXG4gIERpc21pc3NhYmxlTGF5ZXJCcmFuY2gsXG4gIFJvb3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvZm9jdXMtZ3VhcmRzL3NyYy9Gb2N1c0d1YXJkcy50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIGNvdW50ID0gMDtcbmZ1bmN0aW9uIEZvY3VzR3VhcmRzKHByb3BzKSB7XG4gIHVzZUZvY3VzR3VhcmRzKCk7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHVzZUZvY3VzR3VhcmRzKCkge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVkZ2VHdWFyZHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtcmFkaXgtZm9jdXMtZ3VhcmRdXCIpO1xuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlZGdlR3VhcmRzWzBdID8/IGNyZWF0ZUZvY3VzR3VhcmQoKSk7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgZWRnZUd1YXJkc1sxXSA/PyBjcmVhdGVGb2N1c0d1YXJkKCkpO1xuICAgIGNvdW50Kys7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtcmFkaXgtZm9jdXMtZ3VhcmRdXCIpLmZvckVhY2goKG5vZGUpID0+IG5vZGUucmVtb3ZlKCkpO1xuICAgICAgfVxuICAgICAgY291bnQtLTtcbiAgICB9O1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb2N1c0d1YXJkKCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1yYWRpeC1mb2N1cy1ndWFyZFwiLCBcIlwiKTtcbiAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gIGVsZW1lbnQuc3R5bGUub3V0bGluZSA9IFwibm9uZVwiO1xuICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIFJvb3QgPSBGb2N1c0d1YXJkcztcbmV4cG9ydCB7XG4gIEZvY3VzR3VhcmRzLFxuICBSb290LFxuICB1c2VGb2N1c0d1YXJkc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9mb2N1cy1zY29wZS9zcmMvZm9jdXMtc2NvcGUudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2tSZWYgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1jYWxsYmFjay1yZWZcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEFVVE9GT0NVU19PTl9NT1VOVCA9IFwiZm9jdXNTY29wZS5hdXRvRm9jdXNPbk1vdW50XCI7XG52YXIgQVVUT0ZPQ1VTX09OX1VOTU9VTlQgPSBcImZvY3VzU2NvcGUuYXV0b0ZvY3VzT25Vbm1vdW50XCI7XG52YXIgRVZFTlRfT1BUSU9OUyA9IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IHRydWUgfTtcbnZhciBGT0NVU19TQ09QRV9OQU1FID0gXCJGb2N1c1Njb3BlXCI7XG52YXIgRm9jdXNTY29wZSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIGxvb3AgPSBmYWxzZSxcbiAgICB0cmFwcGVkID0gZmFsc2UsXG4gICAgb25Nb3VudEF1dG9Gb2N1czogb25Nb3VudEF1dG9Gb2N1c1Byb3AsXG4gICAgb25Vbm1vdW50QXV0b0ZvY3VzOiBvblVubW91bnRBdXRvRm9jdXNQcm9wLFxuICAgIC4uLnNjb3BlUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbY29udGFpbmVyLCBzZXRDb250YWluZXJdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IG9uTW91bnRBdXRvRm9jdXMgPSB1c2VDYWxsYmFja1JlZihvbk1vdW50QXV0b0ZvY3VzUHJvcCk7XG4gIGNvbnN0IG9uVW5tb3VudEF1dG9Gb2N1cyA9IHVzZUNhbGxiYWNrUmVmKG9uVW5tb3VudEF1dG9Gb2N1c1Byb3ApO1xuICBjb25zdCBsYXN0Rm9jdXNlZEVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlKSA9PiBzZXRDb250YWluZXIobm9kZSkpO1xuICBjb25zdCBmb2N1c1Njb3BlID0gUmVhY3QudXNlUmVmKHtcbiAgICBwYXVzZWQ6IGZhbHNlLFxuICAgIHBhdXNlKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgcmVzdW1lKCkge1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH0pLmN1cnJlbnQ7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYXBwZWQpIHtcbiAgICAgIGxldCBoYW5kbGVGb2N1c0luMiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChmb2N1c1Njb3BlLnBhdXNlZCB8fCAhY29udGFpbmVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgbGFzdEZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9jdXMobGFzdEZvY3VzZWRFbGVtZW50UmVmLmN1cnJlbnQsIHsgc2VsZWN0OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBoYW5kbGVGb2N1c091dDIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZm9jdXNTY29wZS5wYXVzZWQgfHwgIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKCFjb250YWluZXIuY29udGFpbnMocmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICBmb2N1cyhsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGhhbmRsZU11dGF0aW9uczIgPSBmdW5jdGlvbihtdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aCA+IDApIGZvY3VzKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlRm9jdXNJbiA9IGhhbmRsZUZvY3VzSW4yLCBoYW5kbGVGb2N1c091dCA9IGhhbmRsZUZvY3VzT3V0MiwgaGFuZGxlTXV0YXRpb25zID0gaGFuZGxlTXV0YXRpb25zMjtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGhhbmRsZUZvY3VzSW4yKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBoYW5kbGVGb2N1c091dDIpO1xuICAgICAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZU11dGF0aW9uczIpO1xuICAgICAgaWYgKGNvbnRhaW5lcikgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lciwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBoYW5kbGVGb2N1c0luMik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBoYW5kbGVGb2N1c091dDIpO1xuICAgICAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbdHJhcHBlZCwgY29udGFpbmVyLCBmb2N1c1Njb3BlLnBhdXNlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGZvY3VzU2NvcGVzU3RhY2suYWRkKGZvY3VzU2NvcGUpO1xuICAgICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGNvbnN0IGhhc0ZvY3VzZWRDYW5kaWRhdGUgPSBjb250YWluZXIuY29udGFpbnMocHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIGlmICghaGFzRm9jdXNlZENhbmRpZGF0ZSkge1xuICAgICAgICBjb25zdCBtb3VudEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEFVVE9GT0NVU19PTl9NT1VOVCwgRVZFTlRfT1BUSU9OUyk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKEFVVE9GT0NVU19PTl9NT1VOVCwgb25Nb3VudEF1dG9Gb2N1cyk7XG4gICAgICAgIGNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG1vdW50RXZlbnQpO1xuICAgICAgICBpZiAoIW1vdW50RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGZvY3VzRmlyc3QocmVtb3ZlTGlua3MoZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcikpLCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgICBmb2N1cyhjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoQVVUT0ZPQ1VTX09OX01PVU5ULCBvbk1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdW5tb3VudEV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEFVVE9GT0NVU19PTl9VTk1PVU5ULCBFVkVOVF9PUFRJT05TKTtcbiAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihBVVRPRk9DVVNfT05fVU5NT1VOVCwgb25Vbm1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgICBjb250YWluZXIuZGlzcGF0Y2hFdmVudCh1bm1vdW50RXZlbnQpO1xuICAgICAgICAgIGlmICghdW5tb3VudEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGZvY3VzKHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA/PyBkb2N1bWVudC5ib2R5LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoQVVUT0ZPQ1VTX09OX1VOTU9VTlQsIG9uVW5tb3VudEF1dG9Gb2N1cyk7XG4gICAgICAgICAgZm9jdXNTY29wZXNTdGFjay5yZW1vdmUoZm9jdXNTY29wZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtjb250YWluZXIsIG9uTW91bnRBdXRvRm9jdXMsIG9uVW5tb3VudEF1dG9Gb2N1cywgZm9jdXNTY29wZV0pO1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWxvb3AgJiYgIXRyYXBwZWQpIHJldHVybjtcbiAgICAgIGlmIChmb2N1c1Njb3BlLnBhdXNlZCkgcmV0dXJuO1xuICAgICAgY29uc3QgaXNUYWJLZXkgPSBldmVudC5rZXkgPT09IFwiVGFiXCIgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleTtcbiAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChpc1RhYktleSAmJiBmb2N1c2VkRWxlbWVudCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIyID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBsYXN0XSA9IGdldFRhYmJhYmxlRWRnZXMoY29udGFpbmVyMik7XG4gICAgICAgIGNvbnN0IGhhc1RhYmJhYmxlRWxlbWVudHNJbnNpZGUgPSBmaXJzdCAmJiBsYXN0O1xuICAgICAgICBpZiAoIWhhc1RhYmJhYmxlRWxlbWVudHNJbnNpZGUpIHtcbiAgICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnQgPT09IGNvbnRhaW5lcjIpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkRWxlbWVudCA9PT0gbGFzdCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChsb29wKSBmb2N1cyhmaXJzdCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiBmb2N1c2VkRWxlbWVudCA9PT0gZmlyc3QpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAobG9vcCkgZm9jdXMobGFzdCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbbG9vcCwgdHJhcHBlZCwgZm9jdXNTY29wZS5wYXVzZWRdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgdGFiSW5kZXg6IC0xLCAuLi5zY29wZVByb3BzLCByZWY6IGNvbXBvc2VkUmVmcywgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duIH0pO1xufSk7XG5Gb2N1c1Njb3BlLmRpc3BsYXlOYW1lID0gRk9DVVNfU0NPUEVfTkFNRTtcbmZ1bmN0aW9uIGZvY3VzRmlyc3QoY2FuZGlkYXRlcywgeyBzZWxlY3QgPSBmYWxzZSB9ID0ge30pIHtcbiAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgIGZvY3VzKGNhbmRpZGF0ZSwgeyBzZWxlY3QgfSk7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCkgcmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUVkZ2VzKGNvbnRhaW5lcikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcik7XG4gIGNvbnN0IGZpcnN0ID0gZmluZFZpc2libGUoY2FuZGlkYXRlcywgY29udGFpbmVyKTtcbiAgY29uc3QgbGFzdCA9IGZpbmRWaXNpYmxlKGNhbmRpZGF0ZXMucmV2ZXJzZSgpLCBjb250YWluZXIpO1xuICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcbn1cbmZ1bmN0aW9uIGdldFRhYmJhYmxlQ2FuZGlkYXRlcyhjb250YWluZXIpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihjb250YWluZXIsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgYWNjZXB0Tm9kZTogKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGlzSGlkZGVuSW5wdXQgPSBub2RlLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBub2RlLnR5cGUgPT09IFwiaGlkZGVuXCI7XG4gICAgICBpZiAobm9kZS5kaXNhYmxlZCB8fCBub2RlLmhpZGRlbiB8fCBpc0hpZGRlbklucHV0KSByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgIHJldHVybiBub2RlLnRhYkluZGV4ID49IDAgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIH1cbiAgfSk7XG4gIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkgbm9kZXMucHVzaCh3YWxrZXIuY3VycmVudE5vZGUpO1xuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBmaW5kVmlzaWJsZShlbGVtZW50cywgY29udGFpbmVyKSB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgIGlmICghaXNIaWRkZW4oZWxlbWVudCwgeyB1cFRvOiBjb250YWluZXIgfSkpIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5mdW5jdGlvbiBpc0hpZGRlbihub2RlLCB7IHVwVG8gfSkge1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSByZXR1cm4gdHJ1ZTtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAodXBUbyAhPT0gdm9pZCAwICYmIG5vZGUgPT09IHVwVG8pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5ID09PSBcIm5vbmVcIikgcmV0dXJuIHRydWU7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NlbGVjdGFibGVJbnB1dChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBcInNlbGVjdFwiIGluIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBmb2N1cyhlbGVtZW50LCB7IHNlbGVjdCA9IGZhbHNlIH0gPSB7fSkge1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmZvY3VzKSB7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBlbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICBpZiAoZWxlbWVudCAhPT0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ICYmIGlzU2VsZWN0YWJsZUlucHV0KGVsZW1lbnQpICYmIHNlbGVjdClcbiAgICAgIGVsZW1lbnQuc2VsZWN0KCk7XG4gIH1cbn1cbnZhciBmb2N1c1Njb3Blc1N0YWNrID0gY3JlYXRlRm9jdXNTY29wZXNTdGFjaygpO1xuZnVuY3Rpb24gY3JlYXRlRm9jdXNTY29wZXNTdGFjaygpIHtcbiAgbGV0IHN0YWNrID0gW107XG4gIHJldHVybiB7XG4gICAgYWRkKGZvY3VzU2NvcGUpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUZvY3VzU2NvcGUgPSBzdGFja1swXTtcbiAgICAgIGlmIChmb2N1c1Njb3BlICE9PSBhY3RpdmVGb2N1c1Njb3BlKSB7XG4gICAgICAgIGFjdGl2ZUZvY3VzU2NvcGU/LnBhdXNlKCk7XG4gICAgICB9XG4gICAgICBzdGFjayA9IGFycmF5UmVtb3ZlKHN0YWNrLCBmb2N1c1Njb3BlKTtcbiAgICAgIHN0YWNrLnVuc2hpZnQoZm9jdXNTY29wZSk7XG4gICAgfSxcbiAgICByZW1vdmUoZm9jdXNTY29wZSkge1xuICAgICAgc3RhY2sgPSBhcnJheVJlbW92ZShzdGFjaywgZm9jdXNTY29wZSk7XG4gICAgICBzdGFja1swXT8ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYXJyYXlSZW1vdmUoYXJyYXksIGl0ZW0pIHtcbiAgY29uc3QgdXBkYXRlZEFycmF5ID0gWy4uLmFycmF5XTtcbiAgY29uc3QgaW5kZXggPSB1cGRhdGVkQXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHVwZGF0ZWRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB1cGRhdGVkQXJyYXk7XG59XG5mdW5jdGlvbiByZW1vdmVMaW5rcyhpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRhZ05hbWUgIT09IFwiQVwiKTtcbn1cbnZhciBSb290ID0gRm9jdXNTY29wZTtcbmV4cG9ydCB7XG4gIEZvY3VzU2NvcGUsXG4gIFJvb3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtbGF5b3V0LWVmZmVjdC9zcmMvdXNlTGF5b3V0RWZmZWN0LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTGF5b3V0RWZmZWN0MiA9IEJvb2xlYW4oZ2xvYmFsVGhpcz8uZG9jdW1lbnQpID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogKCkgPT4ge1xufTtcbmV4cG9ydCB7XG4gIHVzZUxheW91dEVmZmVjdDIgYXMgdXNlTGF5b3V0RWZmZWN0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvaWQvc3JjL2lkLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0XCI7XG52YXIgdXNlUmVhY3RJZCA9IFJlYWN0W1widXNlSWRcIi50b1N0cmluZygpXSB8fCAoKCkgPT4gdm9pZCAwKTtcbnZhciBjb3VudCA9IDA7XG5mdW5jdGlvbiB1c2VJZChkZXRlcm1pbmlzdGljSWQpIHtcbiAgY29uc3QgW2lkLCBzZXRJZF0gPSBSZWFjdC51c2VTdGF0ZSh1c2VSZWFjdElkKCkpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZGV0ZXJtaW5pc3RpY0lkKSBzZXRJZCgocmVhY3RJZCkgPT4gcmVhY3RJZCA/PyBTdHJpbmcoY291bnQrKykpO1xuICB9LCBbZGV0ZXJtaW5pc3RpY0lkXSk7XG4gIHJldHVybiBkZXRlcm1pbmlzdGljSWQgfHwgKGlkID8gYHJhZGl4LSR7aWR9YCA6IFwiXCIpO1xufVxuZXhwb3J0IHtcbiAgdXNlSWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICBsZWZ0OiB4LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5leHBvcnQgeyBhbGlnbm1lbnRzLCBjbGFtcCwgY3JlYXRlQ29vcmRzLCBldmFsdWF0ZSwgZXhwYW5kUGFkZGluZ09iamVjdCwgZmxvb3IsIGdldEFsaWdubWVudCwgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldEF4aXNMZW5ndGgsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlQXhpcywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldFBhZGRpbmdPYmplY3QsIGdldFNpZGUsIGdldFNpZGVBeGlzLCBtYXgsIG1pbiwgcGxhY2VtZW50cywgcmVjdFRvQ2xpZW50UmVjdCwgcm91bmQsIHNpZGVzIH07XG4iLCJpbXBvcnQgeyBnZXRTaWRlQXhpcywgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QXhpc0xlbmd0aCwgZ2V0U2lkZSwgZ2V0QWxpZ25tZW50LCBldmFsdWF0ZSwgZ2V0UGFkZGluZ09iamVjdCwgcmVjdFRvQ2xpZW50UmVjdCwgbWluLCBjbGFtcCwgcGxhY2VtZW50cywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBzaWRlcywgbWF4LCBnZXRPcHBvc2l0ZUF4aXMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuZXhwb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KF9yZWYsIHBsYWNlbWVudCwgcnRsKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzaWRlQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWduTGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IHNpZGVBeGlzID09PSAneSc7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3RzLmZsb2F0aW5nLmhlaWdodFxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaW5pdGlhbFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoaW5pdGlhbFBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZSc7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0LCBmaW5kIHRoZSBjYW5kaWRhdGVzIHRoYXQgZml0IG9uIHRoZSBtYWluQXhpcyBzaWRlIG9mIG92ZXJmbG93LFxuICAgICAgICAvLyB0aGVuIGZpbmQgdGhlIHBsYWNlbWVudCB0aGF0IGZpdHMgdGhlIGJlc3Qgb24gdGhlIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGxldCByZXNldFBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IGQub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGEsIGIpID0+IGEub3ZlcmZsb3dzWzFdIC0gYi5vdmVyZmxvd3NbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyLnBsYWNlbWVudDtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZmFsbGJhY2suXG4gICAgICAgIGlmICghcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbGxiYWNrU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlc3RGaXQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjI7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlcjIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcihkID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaWRlQXhpcyA9IGdldFNpZGVBeGlzKGQucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTaWRlQXhpcyA9PT0gaW5pdGlhbFNpZGVBeGlzIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGJpYXMgdG8gdGhlIGB5YCBzaWRlIGF4aXMgZHVlIHRvIGhvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGluZyBkaXJlY3Rpb25zIGZhdm9yaW5nIGdyZWF0ZXIgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaWRlQXhpcyA9PT0gJ3knO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSkubWFwKGQgPT4gW2QucGxhY2VtZW50LCBkLm92ZXJmbG93cy5maWx0ZXIob3ZlcmZsb3cgPT4gb3ZlcmZsb3cgPiAwKS5yZWR1Y2UoKGFjYywgb3ZlcmZsb3cpID0+IGFjYyArIG92ZXJmbG93LCAwKV0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlcjJbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdoaWRlJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW5PZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzKSB7XG4gIGNvbnN0IG1pblggPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gIGNvbnN0IG1pblkgPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC50b3ApKTtcbiAgY29uc3QgbWF4WCA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gIGNvbnN0IG1heFkgPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RzQnlMaW5lKHJlY3RzKSB7XG4gIGNvbnN0IHNvcnRlZFJlY3RzID0gcmVjdHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IHByZXZSZWN0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRSZWN0c1tpXTtcbiAgICBpZiAoIXByZXZSZWN0IHx8IHJlY3QueSAtIHByZXZSZWN0LnkgPiBwcmV2UmVjdC5oZWlnaHQgLyAyKSB7XG4gICAgICBncm91cHMucHVzaChbcmVjdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdLnB1c2gocmVjdCk7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gcmVjdDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLm1hcChyZWN0ID0+IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KHJlY3QpKSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2lubGluZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBuYXRpdmVDbGllbnRSZWN0cyA9IEFycmF5LmZyb20oKGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpIHx8IFtdKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gZ2V0UmVjdHNCeUxpbmUobmF0aXZlQ2xpZW50UmVjdHMpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChuYXRpdmVDbGllbnRSZWN0cykpO1xuICAgICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZC5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQgJiYgeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHJlY3QgaW4gd2hpY2ggdGhlIHBvaW50IGlzIGZ1bGx5IGluc2lkZS5cbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSB8fCBmYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUubWFpbkF4aXMgfHwgMCxcbiAgICBjcm9zc0F4aXM6IHJhd1ZhbHVlLmNyb3NzQXhpcyB8fCAwLFxuICAgIGFsaWdubWVudEF4aXM6IHJhd1ZhbHVlLmFsaWdubWVudEF4aXNcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJGFycm93O1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxhY2VtZW50IGlzIHRoZSBzYW1lIGFuZCB0aGUgYXJyb3cgY2F1c2VkIGFuIGFsaWdubWVudCBvZmZzZXRcbiAgICAgIC8vIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uaW5nIGNvb3JkaW5hdGVzLlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGlmZkNvb3JkcyxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geSxcbiAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBbbWFpbkF4aXNdOiBjaGVja01haW5BeGlzLFxuICAgICAgICAgICAgW2Nyb3NzQXhpc106IGNoZWNrQ3Jvc3NBeGlzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFsndG9wJywgJ2xlZnQnXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLCBfc3RhdGUkbWlkZGxld2FyZURhdGEyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IG1pbihoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXSwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSBtaW4od2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCk7XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmICgoX3N0YXRlJG1pZGRsZXdhcmVEYXRhID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLmVuYWJsZWQueCkge1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEyID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMi5lbmFibGVkLnkpIHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIiwiZnVuY3Rpb24gaGFzV2luZG93KCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLy8gTW9ja2VkIG5vZGVzIGluIHRlc3RpbmcgZW52aXJvbm1lbnRzIG1heSBub3QgYmUgaW5zdGFuY2VzIG9mIE5vZGUuIEJ5XG4gIC8vIHJldHVybmluZyBgI2RvY3VtZW50YCBhbiBpbmZpbml0ZSBsb29wIHdvbid0IG9jY3VyLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIzMTdcbiAgcmV0dXJuICcjZG9jdW1lbnQnO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsIHx8IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpIHx8IHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTaGFkb3dSb290IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5TaGFkb3dSb290O1xufVxuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFbJ2lubGluZScsICdjb250ZW50cyddLmluY2x1ZGVzKGRpc3BsYXkpO1xufVxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzVG9wTGF5ZXIoZWxlbWVudCkge1xuICByZXR1cm4gWyc6cG9wb3Zlci1vcGVuJywgJzptb2RhbCddLnNvbWUoc2VsZWN0b3IgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnRPckNzcykge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBpc0VsZW1lbnQoZWxlbWVudE9yQ3NzKSA/IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudE9yQ3NzKSA6IGVsZW1lbnRPckNzcztcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXRyYW5zZm9ybXMtMi8jaW5kaXZpZHVhbC10cmFuc2Zvcm1zXG4gIHJldHVybiBbJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3BlcnNwZWN0aXZlJ10uc29tZSh2YWx1ZSA9PiBjc3NbdmFsdWVdID8gY3NzW3ZhbHVlXSAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IChjc3MuY29udGFpbmVyVHlwZSA/IGNzcy5jb250YWluZXJUeXBlICE9PSAnbm9ybWFsJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IFsndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ10uc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXS5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzVG9wTGF5ZXIoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxYLFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QsIHRyYXZlcnNlSWZyYW1lcykge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDI7XG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cbiAgaWYgKHRyYXZlcnNlSWZyYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhdmVyc2VJZnJhbWVzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgY29uc3QgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KHdpbik7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIGZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhmcmFtZUVsZW1lbnQpIDogW10pO1xuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChzY3JvbGxhYmxlQW5jZXN0b3IsIGdldE92ZXJmbG93QW5jZXN0b3JzKHNjcm9sbGFibGVBbmNlc3RvciwgW10sIHRyYXZlcnNlSWZyYW1lcykpO1xufVxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KHdpbikge1xuICByZXR1cm4gd2luLnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yod2luLnBhcmVudCkgPyB3aW4uZnJhbWVFbGVtZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldEZyYW1lRWxlbWVudCwgZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IsIGdldE5vZGVOYW1lLCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgZ2V0V2luZG93LCBpc0NvbnRhaW5pbmdCbG9jaywgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzTm9kZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGlzU2hhZG93Um9vdCwgaXNUYWJsZUVsZW1lbnQsIGlzVG9wTGF5ZXIsIGlzV2ViS2l0IH07XG4iLCJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBkZXRlY3RPdmVyZmxvdyBhcyBkZXRlY3RPdmVyZmxvdyQxLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBzaGlmdCBhcyBzaGlmdCQxLCBmbGlwIGFzIGZsaXAkMSwgc2l6ZSBhcyBzaXplJDEsIGhpZGUgYXMgaGlkZSQxLCBhcnJvdyBhcyBhcnJvdyQxLCBpbmxpbmUgYXMgaW5saW5lJDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5pbXBvcnQgeyByb3VuZCwgY3JlYXRlQ29vcmRzLCBtYXgsIG1pbiwgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNIVE1MRWxlbWVudCwgaXNFbGVtZW50LCBnZXRXaW5kb3csIGlzV2ViS2l0LCBnZXRGcmFtZUVsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldERvY3VtZW50RWxlbWVudCwgaXNUb3BMYXllciwgZ2V0Tm9kZU5hbWUsIGlzT3ZlcmZsb3dFbGVtZW50LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBpc0NvbnRhaW5pbmdCbG9jaywgaXNUYWJsZUVsZW1lbnQsIGdldENvbnRhaW5pbmdCbG9jayB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuZXhwb3J0IHsgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcblxuZnVuY3Rpb24gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRXaW4gPSB3aW47XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRXaW4gPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSk7XG4gICAgICBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbn1cblxuLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuLy8gaW5jb3JyZWN0IGZvciBSVEwuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQsIHJlY3QpIHtcbiAgY29uc3QgbGVmdFNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbiAgaWYgKCFyZWN0KSB7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBsZWZ0U2Nyb2xsO1xuICB9XG4gIHJldHVybiByZWN0LmxlZnQgKyBsZWZ0U2Nyb2xsO1xufVxuXG5mdW5jdGlvbiBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCBpZ25vcmVTY3JvbGxiYXJYKSB7XG4gIGlmIChpZ25vcmVTY3JvbGxiYXJYID09PSB2b2lkIDApIHtcbiAgICBpZ25vcmVTY3JvbGxiYXJYID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHRtbFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHggPSBodG1sUmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSAoaWdub3JlU2Nyb2xsYmFyWCA/IDAgOlxuICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhci5cbiAgZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQsIGh0bWxSZWN0KSk7XG4gIGNvbnN0IHkgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHRvcExheWVyID0gZWxlbWVudHMgPyBpc1RvcExheWVyKGVsZW1lbnRzLmZsb2F0aW5nKSA6IGZhbHNlO1xuICBpZiAob2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudEVsZW1lbnQgfHwgdG9wTGF5ZXIgJiYgaXNGaXhlZCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgdHJ1ZSkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZS54LFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZS55LFxuICAgIHg6IHJlY3QueCAqIHNjYWxlLnggLSBzY3JvbGwuc2Nyb2xsTGVmdCAqIHNjYWxlLnggKyBvZmZzZXRzLnggKyBodG1sT2Zmc2V0LngsXG4gICAgeTogcmVjdC55ICogc2NhbGUueSAtIHNjcm9sbC5zY3JvbGxUb3AgKiBzY2FsZS55ICsgb2Zmc2V0cy55ICsgaHRtbE9mZnNldC55XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5nZXRDbGllbnRSZWN0cygpKTtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIHRoZSBpbm5lciBjbGllbnQgcmVjdCwgc3VidHJhY3Rpbmcgc2Nyb2xsYmFycyBpZiBwcmVzZW50LlxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJlY3QgPSBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpO1xuICB9IGVsc2UgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgeDogY2xpcHBpbmdBbmNlc3Rvci54IC0gdmlzdWFsT2Zmc2V0cy54LFxuICAgICAgeTogY2xpcHBpbmdBbmNlc3Rvci55IC0gdmlzdWFsT2Zmc2V0cy55LFxuICAgICAgd2lkdGg6IGNsaXBwaW5nQW5jZXN0b3Iud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaXBwaW5nQW5jZXN0b3IuaGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChyZWN0KTtcbn1cbmZ1bmN0aW9uIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBzdG9wTm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKHBhcmVudE5vZGUgPT09IHN0b3BOb2RlIHx8ICFpc0VsZW1lbnQocGFyZW50Tm9kZSkgfHwgaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpLnBvc2l0aW9uID09PSAnZml4ZWQnIHx8IGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihwYXJlbnROb2RlLCBzdG9wTm9kZSk7XG59XG5cbi8vIEEgXCJjbGlwcGluZyBhbmNlc3RvclwiIGlzIGFuIGBvdmVyZmxvd2AgZWxlbWVudCB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgY2hpbGQgZWxlbWVudHMuIFRoaXMgcmV0dXJucyBhbGwgY2xpcHBpbmcgYW5jZXN0b3JzXG4vLyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCB1cCB0aGUgdHJlZS5cbmZ1bmN0aW9uIGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCBjYWNoZSkge1xuICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZS5nZXQoZWxlbWVudCk7XG4gIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9XG4gIGxldCByZXN1bHQgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50LCBbXSwgZmFsc2UpLmZpbHRlcihlbCA9PiBpc0VsZW1lbnQoZWwpICYmIGdldE5vZGVOYW1lKGVsKSAhPT0gJ2JvZHknKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnO1xuICBsZXQgY3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/IGdldFBhcmVudE5vZGUoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHdoaWxlIChpc0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSXNDb250YWluaW5nID0gaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpO1xuICAgIGlmICghY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzaG91bGREcm9wQ3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiAhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgOiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgISFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSAmJiBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5jbHVkZXMoY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUucG9zaXRpb24pIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIGN1cnJlbnROb2RlKTtcbiAgICBpZiAoc2hvdWxkRHJvcEN1cnJlbnROb2RlKSB7XG4gICAgICAvLyBEcm9wIG5vbi1jb250YWluaW5nIGJsb2Nrcy5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoYW5jZXN0b3IgPT4gYW5jZXN0b3IgIT09IGN1cnJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVjb3JkIGxhc3QgY29udGFpbmluZyBibG9jayBmb3IgbmV4dCBpdGVyYXRpb24uXG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgY2FjaGUuc2V0KGVsZW1lbnQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIGFuY2VzdG9ycy5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudCxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdBbmNlc3RvcnMnID8gaXNUb3BMYXllcihlbGVtZW50KSA/IFtdIDogZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIHRoaXMuX2MpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBbLi4uZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nQW5jZXN0b3IgPSBjbGlwcGluZ0FuY2VzdG9yc1swXTtcbiAgY29uc3QgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdBbmNlc3RvcnMucmVkdWNlKChhY2NSZWN0LCBjbGlwcGluZ0FuY2VzdG9yKSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcCxcbiAgICB4OiBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICB5OiBjbGlwcGluZ1JlY3QudG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAvLyBJZiB0aGUgPGJvZHk+IHNjcm9sbGJhciBhcHBlYXJzIG9uIHRoZSBsZWZ0IChlLmcuIFJUTCBzeXN0ZW1zKS4gVXNlXG4gICAgICAvLyBGaXJlZm94IHdpdGggbGF5b3V0LnNjcm9sbGJhci5zaWRlID0gMyBpbiBhYm91dDpjb25maWcgdG8gdGVzdCB0aGlzLlxuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLnggLSBodG1sT2Zmc2V0Lng7XG4gIGNvbnN0IHkgPSByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnkgLSBodG1sT2Zmc2V0Lnk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAvLyBGaXJlZm94IHJldHVybnMgdGhlIDxodG1sPiBlbGVtZW50IGFzIHRoZSBvZmZzZXRQYXJlbnQgaWYgaXQncyBub24tc3RhdGljLFxuICAvLyB3aGlsZSBDaHJvbWUgYW5kIFNhZmFyaSByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LiBUaGUgPGJvZHk+IGVsZW1lbnQgbXVzdFxuICAvLyBiZSB1c2VkIHRvIHBlcmZvcm0gdGhlIGNvcnJlY3QgY2FsY3VsYXRpb25zIGV2ZW4gaWYgdGhlIDxodG1sPiBlbGVtZW50IGlzXG4gIC8vIG5vbi1zdGF0aWMuXG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZmxvYXRpbmdEaW1lbnNpb25zLmhlaWdodFxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuZnVuY3Rpb24gcmVjdHNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLndpZHRoID09PSBiLndpZHRoICYmIGEuaGVpZ2h0ID09PSBiLmhlaWdodDtcbn1cblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgKF9pbyA9IGlvKSA9PSBudWxsIHx8IF9pby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW47XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBjbGlwcGVkLCB0aGUgcmF0aW8gaXMgMC4gVGhyb3R0bGUgdGhlIHJlZnJlc2hcbiAgICAgICAgICAvLyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgdXBkYXRlcy5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZnJlc2goZmFsc2UsIDFlLTcpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhdGlvID09PSAxICYmICFyZWN0c0FyZUVxdWFsKGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpIHtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gdGhvdWdoIHRoZSByYXRpbyBpcyByZXBvcnRlZCBhcyAxLCB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBpcyBub3QgYWN0dWFsbHkgZnVsbHkgd2l0aGluIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlcidzIHJvb3RcbiAgICAgICAgLy8gYXJlYSBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gdW5kZXIgcGVyZm9ybWFuY2UgY29uc3RyYWludHMuIFRoaXMgbWF5XG4gICAgICAgIC8vIGJlIGEgYnVnIGluIHRoZSBicm93c2VyJ3MgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24uIFRvXG4gICAgICAgIC8vIHdvcmsgYXJvdW5kIHRoaXMsIHdlIGNvbXBhcmUgdGhlIGVsZW1lbnQncyBib3VuZGluZyByZWN0IG5vdyB3aXRoXG4gICAgICAgIC8vIHdoYXQgaXQgd2FzIGF0IHRoZSB0aW1lIHdlIGNyZWF0ZWQgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLiBJZiB0aGV5XG4gICAgICAgIC8vIGFyZSBub3QgZXF1YWwgdGhlbiB0aGUgZWxlbWVudCBtb3ZlZCwgc28gd2UgcmVmcmVzaC5cbiAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBtb3VudGVkIG9uIHRoZSBET00gb3JcbiAqIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTSBvciBoaWRkZW4gZnJvbSB0aGUgc2NyZWVuLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gdW53cmFwRWxlbWVudChyZWZlcmVuY2UpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4ocmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSksIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQgW2ZpcnN0RW50cnldID0gX3JlZjtcbiAgICAgIGlmIChmaXJzdEVudHJ5ICYmIGZpcnN0RW50cnkudGFyZ2V0ID09PSByZWZlcmVuY2VFbCAmJiByZXNpemVPYnNlcnZlcikge1xuICAgICAgICAvLyBQcmV2ZW50IHVwZGF0ZSBsb29wcyB3aGVuIHVzaW5nIHRoZSBgc2l6ZWAgbWlkZGxld2FyZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzQwXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgICAgKF9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgIXJlY3RzQXJlRXF1YWwocHJldlJlZlJlY3QsIG5leHRSZWZSZWN0KSkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICAgIHByZXZSZWZSZWN0ID0gbmV4dFJlZlJlY3Q7XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZUxvb3ApO1xuICB9XG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfcmVzaXplT2JzZXJ2ZXIyO1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSk7XG4gICAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICAgIH0pO1xuICAgIGNsZWFudXBJbyA9PSBudWxsIHx8IGNsZWFudXBJbygpO1xuICAgIChfcmVzaXplT2JzZXJ2ZXIyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyMi5kaXNjb25uZWN0KCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuY29uc3QgZGV0ZWN0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyQxO1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBvZmZzZXQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBhdXRvUGxhY2VtZW50JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IHNoaWZ0JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZmxpcCQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBzaXplJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gaGlkZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IGFycm93JDE7XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGlubGluZSQxO1xuXG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gbGltaXRTaGlmdCQxO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpID0+IHtcbiAgLy8gVGhpcyBjYWNoZXMgdGhlIGV4cGVuc2l2ZSBgZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzYCBmdW5jdGlvbiBzbyB0aGF0XG4gIC8vIG11bHRpcGxlIGxpZmVjeWNsZSByZXNldHMgcmUtdXNlIHRoZSBzYW1lIHJlc3VsdC4gSXQgb25seSBsaXZlcyBmb3IgYVxuICAvLyBzaW5nbGUgY2FsbC4gSWYgb3RoZXIgZnVuY3Rpb25zIGJlY29tZSBleHBlbnNpdmUsIHdlIGNhbiBhZGQgdGhlbSBhcyB3ZWxsLlxuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICBwbGF0Zm9ybSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHBsYXRmb3JtV2l0aENhY2hlID0ge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMucGxhdGZvcm0sXG4gICAgX2M6IGNhY2hlXG4gIH07XG4gIHJldHVybiBjb21wdXRlUG9zaXRpb24kMShyZWZlcmVuY2UsIGZsb2F0aW5nLCB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucyxcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm1XaXRoQ2FjaGVcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9O1xuIiwiaW1wb3J0IHsgY29tcHV0ZVBvc2l0aW9uLCBhcnJvdyBhcyBhcnJvdyQyLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBmbGlwIGFzIGZsaXAkMSwgc2l6ZSBhcyBzaXplJDEsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBoaWRlIGFzIGhpZGUkMSwgaW5saW5lIGFzIGlubGluZSQxIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5leHBvcnQgeyBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgcGxhdGZvcm0gfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLy8gRm9yayBvZiBgZmFzdC1kZWVwLWVxdWFsYCB0aGF0IG9ubHkgZG9lcyB0aGUgY29tcGFyaXNvbnMgd2UgbmVlZCBhbmQgY29tcGFyZXNcbi8vIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCBsZW5ndGg7XG4gIGxldCBpO1xuICBsZXQga2V5cztcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG5mdW5jdGlvbiBnZXREUFIoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCB3aW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeURQUihlbGVtZW50LCB2YWx1ZSkge1xuICBjb25zdCBkcHIgPSBnZXREUFIoZWxlbWVudCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZHByKSAvIGRwcjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogZXh0ZXJuYWxSZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZzogZXh0ZXJuYWxGbG9hdGluZ1xuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm0gPSB0cnVlLFxuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkLFxuICAgIG9wZW5cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RyYXRlZ3ksXG4gICAgcGxhY2VtZW50LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fSxcbiAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBbbGF0ZXN0TWlkZGxld2FyZSwgc2V0TGF0ZXN0TWlkZGxld2FyZV0gPSBSZWFjdC51c2VTdGF0ZShtaWRkbGV3YXJlKTtcbiAgaWYgKCFkZWVwRXF1YWwobGF0ZXN0TWlkZGxld2FyZSwgbWlkZGxld2FyZSkpIHtcbiAgICBzZXRMYXRlc3RNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICB9XG4gIGNvbnN0IFtfcmVmZXJlbmNlLCBfc2V0UmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbX2Zsb2F0aW5nLCBfc2V0RmxvYXRpbmddID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSByZWZlcmVuY2VSZWYuY3VycmVudCkge1xuICAgICAgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0RmxvYXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgZmxvYXRpbmdSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0RmxvYXRpbmcobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gZXh0ZXJuYWxSZWZlcmVuY2UgfHwgX3JlZmVyZW5jZTtcbiAgY29uc3QgZmxvYXRpbmdFbCA9IGV4dGVybmFsRmxvYXRpbmcgfHwgX2Zsb2F0aW5nO1xuICBjb25zdCByZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZsb2F0aW5nUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKGRhdGEpO1xuICBjb25zdCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCA9IHdoaWxlRWxlbWVudHNNb3VudGVkICE9IG51bGw7XG4gIGNvbnN0IHdoaWxlRWxlbWVudHNNb3VudGVkUmVmID0gdXNlTGF0ZXN0UmVmKHdoaWxlRWxlbWVudHNNb3VudGVkKTtcbiAgY29uc3QgcGxhdGZvcm1SZWYgPSB1c2VMYXRlc3RSZWYocGxhdGZvcm0pO1xuICBjb25zdCBvcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCB1cGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWZlcmVuY2VSZWYuY3VycmVudCB8fCAhZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhdGVzdE1pZGRsZXdhcmVcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybVJlZi5jdXJyZW50KSB7XG4gICAgICBjb25maWcucGxhdGZvcm0gPSBwbGF0Zm9ybVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBjb21wdXRlUG9zaXRpb24ocmVmZXJlbmNlUmVmLmN1cnJlbnQsIGZsb2F0aW5nUmVmLmN1cnJlbnQsIGNvbmZpZykudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZ1bGxEYXRhID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICAvLyBUaGUgZmxvYXRpbmcgZWxlbWVudCdzIHBvc2l0aW9uIG1heSBiZSByZWNvbXB1dGVkIHdoaWxlIGl0J3MgY2xvc2VkXG4gICAgICAgIC8vIGJ1dCBzdGlsbCBtb3VudGVkIChzdWNoIGFzIHdoZW4gdHJhbnNpdGlvbmluZyBvdXQpLiBUbyBlbnN1cmVcbiAgICAgICAgLy8gYGlzUG9zaXRpb25lZGAgd2lsbCBiZSBgZmFsc2VgIGluaXRpYWxseSBvbiB0aGUgbmV4dCBvcGVuLCBhdm9pZFxuICAgICAgICAvLyBzZXR0aW5nIGl0IHRvIGB0cnVlYCB3aGVuIGBvcGVuID09PSBmYWxzZWAgKG11c3QgYmUgc3BlY2lmaWVkKS5cbiAgICAgICAgaXNQb3NpdGlvbmVkOiBvcGVuUmVmLmN1cnJlbnQgIT09IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50ICYmICFkZWVwRXF1YWwoZGF0YVJlZi5jdXJyZW50LCBmdWxsRGF0YSkpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50ID0gZnVsbERhdGE7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgc2V0RGF0YShmdWxsRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbbGF0ZXN0TWlkZGxld2FyZSwgcGxhY2VtZW50LCBzdHJhdGVneSwgcGxhdGZvcm1SZWYsIG9wZW5SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuID09PSBmYWxzZSAmJiBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkKSB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgICBzZXREYXRhKGRhdGEgPT4gKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocmVmZXJlbmNlRWwpIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gcmVmZXJlbmNlRWw7XG4gICAgaWYgKGZsb2F0aW5nRWwpIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBmbG9hdGluZ0VsO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gd2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudChyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZF0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlUmVmLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ1JlZixcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0RmxvYXRpbmdcbiAgfSksIFtzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlRWwsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nRWxcbiAgfSksIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbF0pO1xuICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgY29uc3QgeCA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCk7XG4gICAgY29uc3QgeSA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiLFxuICAgICAgICAuLi4oZ2V0RFBSKGVsZW1lbnRzLmZsb2F0aW5nKSA+PSAxLjUgJiYge1xuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeVxuICAgIH07XG4gIH0sIFtzdHJhdGVneSwgdHJhbnNmb3JtLCBlbGVtZW50cy5mbG9hdGluZywgZGF0YS54LCBkYXRhLnldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5kYXRhLFxuICAgIHVwZGF0ZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nU3R5bGVzXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgZmxvYXRpbmdTdHlsZXNdKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93JDEgPSBvcHRpb25zID0+IHtcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYWRkaW5nXG4gICAgICB9ID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zKHN0YXRlKSA6IG9wdGlvbnM7XG4gICAgICBpZiAoZWxlbWVudCAmJiBpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMih7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5vZmZzZXQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4ubGltaXRTaGlmdCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5mbGlwJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaXplJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmF1dG9QbGFjZW1lbnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaGlkZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaW5saW5lJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5hcnJvdyQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplLCB1c2VGbG9hdGluZyB9O1xuIiwiLy8gcGFja2FnZXMvcmVhY3QvYXJyb3cvc3JjL2Fycm93LnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTkFNRSA9IFwiQXJyb3dcIjtcbnZhciBBcnJvdyA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgd2lkdGggPSAxMCwgaGVpZ2h0ID0gNSwgLi4uYXJyb3dQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFByaW1pdGl2ZS5zdmcsXG4gICAge1xuICAgICAgLi4uYXJyb3dQcm9wcyxcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB2aWV3Qm94OiBcIjAgMCAzMCAxMFwiLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsXG4gICAgICBjaGlsZHJlbjogcHJvcHMuYXNDaGlsZCA/IGNoaWxkcmVuIDogLyogQF9fUFVSRV9fICovIGpzeChcInBvbHlnb25cIiwgeyBwb2ludHM6IFwiMCwwIDMwLDAgMTUsMTBcIiB9KVxuICAgIH1cbiAgKTtcbn0pO1xuQXJyb3cuZGlzcGxheU5hbWUgPSBOQU1FO1xudmFyIFJvb3QgPSBBcnJvdztcbmV4cG9ydCB7XG4gIEFycm93LFxuICBSb290XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLXNpemUvc3JjL3VzZVNpemUudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbmZ1bmN0aW9uIHVzZVNpemUoZWxlbWVudCkge1xuICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSBSZWFjdC51c2VTdGF0ZSh2b2lkIDApO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBzZXRTaXplKHsgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgfSk7XG4gICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgbGV0IGhlaWdodDtcbiAgICAgICAgaWYgKFwiYm9yZGVyQm94U2l6ZVwiIGluIGVudHJ5KSB7XG4gICAgICAgICAgY29uc3QgYm9yZGVyU2l6ZUVudHJ5ID0gZW50cnlbXCJib3JkZXJCb3hTaXplXCJdO1xuICAgICAgICAgIGNvbnN0IGJvcmRlclNpemUgPSBBcnJheS5pc0FycmF5KGJvcmRlclNpemVFbnRyeSkgPyBib3JkZXJTaXplRW50cnlbMF0gOiBib3JkZXJTaXplRW50cnk7XG4gICAgICAgICAgd2lkdGggPSBib3JkZXJTaXplW1wiaW5saW5lU2l6ZVwiXTtcbiAgICAgICAgICBoZWlnaHQgPSBib3JkZXJTaXplW1wiYmxvY2tTaXplXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzZXRTaXplKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgIH0pO1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTaXplKHZvaWQgMCk7XG4gICAgfVxuICB9LCBbZWxlbWVudF0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydCB7XG4gIHVzZVNpemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvcG9wcGVyL3NyYy9wb3BwZXIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIHVzZUZsb2F0aW5nLFxuICBhdXRvVXBkYXRlLFxuICBvZmZzZXQsXG4gIHNoaWZ0LFxuICBsaW1pdFNoaWZ0LFxuICBoaWRlLFxuICBhcnJvdyBhcyBmbG9hdGluZ1VJYXJyb3csXG4gIGZsaXAsXG4gIHNpemVcbn0gZnJvbSBcIkBmbG9hdGluZy11aS9yZWFjdC1kb21cIjtcbmltcG9ydCAqIGFzIEFycm93UHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtYXJyb3dcIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0U2NvcGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlU2l6ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLXNpemVcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNJREVfT1BUSU9OUyA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbnZhciBBTElHTl9PUFRJT05TID0gW1wic3RhcnRcIiwgXCJjZW50ZXJcIiwgXCJlbmRcIl07XG52YXIgUE9QUEVSX05BTUUgPSBcIlBvcHBlclwiO1xudmFyIFtjcmVhdGVQb3BwZXJDb250ZXh0LCBjcmVhdGVQb3BwZXJTY29wZV0gPSBjcmVhdGVDb250ZXh0U2NvcGUoUE9QUEVSX05BTUUpO1xudmFyIFtQb3BwZXJQcm92aWRlciwgdXNlUG9wcGVyQ29udGV4dF0gPSBjcmVhdGVQb3BwZXJDb250ZXh0KFBPUFBFUl9OQU1FKTtcbnZhciBQb3BwZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlUG9wcGVyLCBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIGNvbnN0IFthbmNob3IsIHNldEFuY2hvcl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUG9wcGVyUHJvdmlkZXIsIHsgc2NvcGU6IF9fc2NvcGVQb3BwZXIsIGFuY2hvciwgb25BbmNob3JDaGFuZ2U6IHNldEFuY2hvciwgY2hpbGRyZW4gfSk7XG59O1xuUG9wcGVyLmRpc3BsYXlOYW1lID0gUE9QUEVSX05BTUU7XG52YXIgQU5DSE9SX05BTUUgPSBcIlBvcHBlckFuY2hvclwiO1xudmFyIFBvcHBlckFuY2hvciA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlUG9wcGVyLCB2aXJ0dWFsUmVmLCAuLi5hbmNob3JQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVBvcHBlckNvbnRleHQoQU5DSE9SX05BTUUsIF9fc2NvcGVQb3BwZXIpO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCByZWYpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb250ZXh0Lm9uQW5jaG9yQ2hhbmdlKHZpcnR1YWxSZWY/LmN1cnJlbnQgfHwgcmVmLmN1cnJlbnQpO1xuICAgIH0pO1xuICAgIHJldHVybiB2aXJ0dWFsUmVmID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyAuLi5hbmNob3JQcm9wcywgcmVmOiBjb21wb3NlZFJlZnMgfSk7XG4gIH1cbik7XG5Qb3BwZXJBbmNob3IuZGlzcGxheU5hbWUgPSBBTkNIT1JfTkFNRTtcbnZhciBDT05URU5UX05BTUUgPSBcIlBvcHBlckNvbnRlbnRcIjtcbnZhciBbUG9wcGVyQ29udGVudFByb3ZpZGVyLCB1c2VDb250ZW50Q29udGV4dF0gPSBjcmVhdGVQb3BwZXJDb250ZXh0KENPTlRFTlRfTkFNRSk7XG52YXIgUG9wcGVyQ29udGVudCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX19zY29wZVBvcHBlcixcbiAgICAgIHNpZGUgPSBcImJvdHRvbVwiLFxuICAgICAgc2lkZU9mZnNldCA9IDAsXG4gICAgICBhbGlnbiA9IFwiY2VudGVyXCIsXG4gICAgICBhbGlnbk9mZnNldCA9IDAsXG4gICAgICBhcnJvd1BhZGRpbmcgPSAwLFxuICAgICAgYXZvaWRDb2xsaXNpb25zID0gdHJ1ZSxcbiAgICAgIGNvbGxpc2lvbkJvdW5kYXJ5ID0gW10sXG4gICAgICBjb2xsaXNpb25QYWRkaW5nOiBjb2xsaXNpb25QYWRkaW5nUHJvcCA9IDAsXG4gICAgICBzdGlja3kgPSBcInBhcnRpYWxcIixcbiAgICAgIGhpZGVXaGVuRGV0YWNoZWQgPSBmYWxzZSxcbiAgICAgIHVwZGF0ZVBvc2l0aW9uU3RyYXRlZ3kgPSBcIm9wdGltaXplZFwiLFxuICAgICAgb25QbGFjZWQsXG4gICAgICAuLi5jb250ZW50UHJvcHNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVBvcHBlckNvbnRleHQoQ09OVEVOVF9OQU1FLCBfX3Njb3BlUG9wcGVyKTtcbiAgICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCAobm9kZSkgPT4gc2V0Q29udGVudChub2RlKSk7XG4gICAgY29uc3QgW2Fycm93LCBzZXRBcnJvd10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBhcnJvd1NpemUgPSB1c2VTaXplKGFycm93KTtcbiAgICBjb25zdCBhcnJvd1dpZHRoID0gYXJyb3dTaXplPy53aWR0aCA/PyAwO1xuICAgIGNvbnN0IGFycm93SGVpZ2h0ID0gYXJyb3dTaXplPy5oZWlnaHQgPz8gMDtcbiAgICBjb25zdCBkZXNpcmVkUGxhY2VtZW50ID0gc2lkZSArIChhbGlnbiAhPT0gXCJjZW50ZXJcIiA/IFwiLVwiICsgYWxpZ24gOiBcIlwiKTtcbiAgICBjb25zdCBjb2xsaXNpb25QYWRkaW5nID0gdHlwZW9mIGNvbGxpc2lvblBhZGRpbmdQcm9wID09PSBcIm51bWJlclwiID8gY29sbGlzaW9uUGFkZGluZ1Byb3AgOiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgLi4uY29sbGlzaW9uUGFkZGluZ1Byb3AgfTtcbiAgICBjb25zdCBib3VuZGFyeSA9IEFycmF5LmlzQXJyYXkoY29sbGlzaW9uQm91bmRhcnkpID8gY29sbGlzaW9uQm91bmRhcnkgOiBbY29sbGlzaW9uQm91bmRhcnldO1xuICAgIGNvbnN0IGhhc0V4cGxpY2l0Qm91bmRhcmllcyA9IGJvdW5kYXJ5Lmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zID0ge1xuICAgICAgcGFkZGluZzogY29sbGlzaW9uUGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeS5maWx0ZXIoaXNOb3ROdWxsKSxcbiAgICAgIC8vIHdpdGggYHN0cmF0ZWd5OiAnZml4ZWQnYCwgdGhpcyBpcyB0aGUgb25seSB3YXkgdG8gZ2V0IGl0IHRvIHJlc3BlY3QgYm91bmRhcmllc1xuICAgICAgYWx0Qm91bmRhcnk6IGhhc0V4cGxpY2l0Qm91bmRhcmllc1xuICAgIH07XG4gICAgY29uc3QgeyByZWZzLCBmbG9hdGluZ1N0eWxlcywgcGxhY2VtZW50LCBpc1Bvc2l0aW9uZWQsIG1pZGRsZXdhcmVEYXRhIH0gPSB1c2VGbG9hdGluZyh7XG4gICAgICAvLyBkZWZhdWx0IHRvIGBmaXhlZGAgc3RyYXRlZ3kgc28gdXNlcnMgZG9uJ3QgaGF2ZSB0byBwaWNrIGFuZCB3ZSBhbHNvIGF2b2lkIGZvY3VzIHNjcm9sbCBpc3N1ZXNcbiAgICAgIHN0cmF0ZWd5OiBcImZpeGVkXCIsXG4gICAgICBwbGFjZW1lbnQ6IGRlc2lyZWRQbGFjZW1lbnQsXG4gICAgICB3aGlsZUVsZW1lbnRzTW91bnRlZDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGF1dG9VcGRhdGUoLi4uYXJncywge1xuICAgICAgICAgIGFuaW1hdGlvbkZyYW1lOiB1cGRhdGVQb3NpdGlvblN0cmF0ZWd5ID09PSBcImFsd2F5c1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICAgIH0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IGNvbnRleHQuYW5jaG9yXG4gICAgICB9LFxuICAgICAgbWlkZGxld2FyZTogW1xuICAgICAgICBvZmZzZXQoeyBtYWluQXhpczogc2lkZU9mZnNldCArIGFycm93SGVpZ2h0LCBhbGlnbm1lbnRBeGlzOiBhbGlnbk9mZnNldCB9KSxcbiAgICAgICAgYXZvaWRDb2xsaXNpb25zICYmIHNoaWZ0KHtcbiAgICAgICAgICBtYWluQXhpczogdHJ1ZSxcbiAgICAgICAgICBjcm9zc0F4aXM6IGZhbHNlLFxuICAgICAgICAgIGxpbWl0ZXI6IHN0aWNreSA9PT0gXCJwYXJ0aWFsXCIgPyBsaW1pdFNoaWZ0KCkgOiB2b2lkIDAsXG4gICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICAgIH0pLFxuICAgICAgICBhdm9pZENvbGxpc2lvbnMgJiYgZmxpcCh7IC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyB9KSxcbiAgICAgICAgc2l6ZSh7XG4gICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgIGFwcGx5OiAoeyBlbGVtZW50cywgcmVjdHMsIGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aDogYW5jaG9yV2lkdGgsIGhlaWdodDogYW5jaG9ySGVpZ2h0IH0gPSByZWN0cy5yZWZlcmVuY2U7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50U3R5bGUgPSBlbGVtZW50cy5mbG9hdGluZy5zdHlsZTtcbiAgICAgICAgICAgIGNvbnRlbnRTdHlsZS5zZXRQcm9wZXJ0eShcIi0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS13aWR0aFwiLCBgJHthdmFpbGFibGVXaWR0aH1weGApO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLWhlaWdodFwiLCBgJHthdmFpbGFibGVIZWlnaHR9cHhgKTtcbiAgICAgICAgICAgIGNvbnRlbnRTdHlsZS5zZXRQcm9wZXJ0eShcIi0tcmFkaXgtcG9wcGVyLWFuY2hvci13aWR0aFwiLCBgJHthbmNob3JXaWR0aH1weGApO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYW5jaG9yLWhlaWdodFwiLCBgJHthbmNob3JIZWlnaHR9cHhgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBhcnJvdyAmJiBmbG9hdGluZ1VJYXJyb3coeyBlbGVtZW50OiBhcnJvdywgcGFkZGluZzogYXJyb3dQYWRkaW5nIH0pLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4oeyBhcnJvd1dpZHRoLCBhcnJvd0hlaWdodCB9KSxcbiAgICAgICAgaGlkZVdoZW5EZXRhY2hlZCAmJiBoaWRlKHsgc3RyYXRlZ3k6IFwicmVmZXJlbmNlSGlkZGVuXCIsIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyB9KVxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IFtwbGFjZWRTaWRlLCBwbGFjZWRBbGlnbl0gPSBnZXRTaWRlQW5kQWxpZ25Gcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgaGFuZGxlUGxhY2VkID0gdXNlQ2FsbGJhY2tSZWYob25QbGFjZWQpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaXNQb3NpdGlvbmVkKSB7XG4gICAgICAgIGhhbmRsZVBsYWNlZD8uKCk7XG4gICAgICB9XG4gICAgfSwgW2lzUG9zaXRpb25lZCwgaGFuZGxlUGxhY2VkXSk7XG4gICAgY29uc3QgYXJyb3dYID0gbWlkZGxld2FyZURhdGEuYXJyb3c/Lng7XG4gICAgY29uc3QgYXJyb3dZID0gbWlkZGxld2FyZURhdGEuYXJyb3c/Lnk7XG4gICAgY29uc3QgY2Fubm90Q2VudGVyQXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8uY2VudGVyT2Zmc2V0ICE9PSAwO1xuICAgIGNvbnN0IFtjb250ZW50WkluZGV4LCBzZXRDb250ZW50WkluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZW50KSBzZXRDb250ZW50WkluZGV4KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRlbnQpLnpJbmRleCk7XG4gICAgfSwgW2NvbnRlbnRdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogcmVmcy5zZXRGbG9hdGluZyxcbiAgICAgICAgXCJkYXRhLXJhZGl4LXBvcHBlci1jb250ZW50LXdyYXBwZXJcIjogXCJcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAuLi5mbG9hdGluZ1N0eWxlcyxcbiAgICAgICAgICB0cmFuc2Zvcm06IGlzUG9zaXRpb25lZCA/IGZsb2F0aW5nU3R5bGVzLnRyYW5zZm9ybSA6IFwidHJhbnNsYXRlKDAsIC0yMDAlKVwiLFxuICAgICAgICAgIC8vIGtlZXAgb2ZmIHRoZSBwYWdlIHdoZW4gbWVhc3VyaW5nXG4gICAgICAgICAgbWluV2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgICB6SW5kZXg6IGNvbnRlbnRaSW5kZXgsXG4gICAgICAgICAgW1wiLS1yYWRpeC1wb3BwZXItdHJhbnNmb3JtLW9yaWdpblwiXTogW1xuICAgICAgICAgICAgbWlkZGxld2FyZURhdGEudHJhbnNmb3JtT3JpZ2luPy54LFxuICAgICAgICAgICAgbWlkZGxld2FyZURhdGEudHJhbnNmb3JtT3JpZ2luPy55XG4gICAgICAgICAgXS5qb2luKFwiIFwiKSxcbiAgICAgICAgICAvLyBoaWRlIHRoZSBjb250ZW50IGlmIHVzaW5nIHRoZSBoaWRlIG1pZGRsZXdhcmUgYW5kIHNob3VsZCBiZSBoaWRkZW5cbiAgICAgICAgICAvLyBzZXQgdmlzaWJpbGl0eSB0byBoaWRkZW4gYW5kIGRpc2FibGUgcG9pbnRlciBldmVudHMgc28gdGhlIFVJIGJlaGF2ZXNcbiAgICAgICAgICAvLyBhcyBpZiB0aGUgUG9wcGVyQ29udGVudCBpc24ndCB0aGVyZSBhdCBhbGxcbiAgICAgICAgICAuLi5taWRkbGV3YXJlRGF0YS5oaWRlPy5yZWZlcmVuY2VIaWRkZW4gJiYge1xuICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkaXI6IHByb3BzLmRpcixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgUG9wcGVyQ29udGVudFByb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNjb3BlOiBfX3Njb3BlUG9wcGVyLFxuICAgICAgICAgICAgcGxhY2VkU2lkZSxcbiAgICAgICAgICAgIG9uQXJyb3dDaGFuZ2U6IHNldEFycm93LFxuICAgICAgICAgICAgYXJyb3dYLFxuICAgICAgICAgICAgYXJyb3dZLFxuICAgICAgICAgICAgc2hvdWxkSGlkZUFycm93OiBjYW5ub3RDZW50ZXJBcnJvdyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICBQcmltaXRpdmUuZGl2LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJkYXRhLXNpZGVcIjogcGxhY2VkU2lkZSxcbiAgICAgICAgICAgICAgICBcImRhdGEtYWxpZ25cIjogcGxhY2VkQWxpZ24sXG4gICAgICAgICAgICAgICAgLi4uY29udGVudFByb3BzLFxuICAgICAgICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgUG9wcGVyQ29udGVudCBoYXNuJ3QgYmVlbiBwbGFjZWQgeWV0IChub3QgYWxsIG1lYXN1cmVtZW50cyBkb25lKVxuICAgICAgICAgICAgICAgICAgLy8gd2UgcHJldmVudCBhbmltYXRpb25zIHNvIHRoYXQgdXNlcnMncyBhbmltYXRpb24gZG9uJ3Qga2ljayBpbiB0b28gZWFybHkgcmVmZXJyaW5nIHdyb25nIHNpZGVzXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb246ICFpc1Bvc2l0aW9uZWQgPyBcIm5vbmVcIiA6IHZvaWQgMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5Qb3BwZXJDb250ZW50LmRpc3BsYXlOYW1lID0gQ09OVEVOVF9OQU1FO1xudmFyIEFSUk9XX05BTUUgPSBcIlBvcHBlckFycm93XCI7XG52YXIgT1BQT1NJVEVfU0lERSA9IHtcbiAgdG9wOiBcImJvdHRvbVwiLFxuICByaWdodDogXCJsZWZ0XCIsXG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgbGVmdDogXCJyaWdodFwiXG59O1xudmFyIFBvcHBlckFycm93ID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBQb3BwZXJBcnJvdzIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7IF9fc2NvcGVQb3BwZXIsIC4uLmFycm93UHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZUNvbnRlbnRDb250ZXh0KEFSUk9XX05BTUUsIF9fc2NvcGVQb3BwZXIpO1xuICBjb25zdCBiYXNlU2lkZSA9IE9QUE9TSVRFX1NJREVbY29udGVudENvbnRleHQucGxhY2VkU2lkZV07XG4gIHJldHVybiAoXG4gICAgLy8gd2UgaGF2ZSB0byB1c2UgYW4gZXh0cmEgd3JhcHBlciBiZWNhdXNlIGBSZXNpemVPYnNlcnZlcmAgKHVzZWQgYnkgYHVzZVNpemVgKVxuICAgIC8vIGRvZXNuJ3QgcmVwb3J0IHNpemUgYXMgd2UnZCBleHBlY3Qgb24gU1ZHIGVsZW1lbnRzLlxuICAgIC8vIGl0IHJlcG9ydHMgdGhlaXIgYm91bmRpbmcgYm94IHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBsYXJnZXN0IHBhdGggaW5zaWRlIHRoZSBTVkcuXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFwic3BhblwiLFxuICAgICAge1xuICAgICAgICByZWY6IGNvbnRlbnRDb250ZXh0Lm9uQXJyb3dDaGFuZ2UsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICBsZWZ0OiBjb250ZW50Q29udGV4dC5hcnJvd1gsXG4gICAgICAgICAgdG9wOiBjb250ZW50Q29udGV4dC5hcnJvd1ksXG4gICAgICAgICAgW2Jhc2VTaWRlXTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IHtcbiAgICAgICAgICAgIHRvcDogXCJcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjAgMFwiLFxuICAgICAgICAgICAgYm90dG9tOiBcImNlbnRlciAwXCIsXG4gICAgICAgICAgICBsZWZ0OiBcIjEwMCUgMFwiXG4gICAgICAgICAgfVtjb250ZW50Q29udGV4dC5wbGFjZWRTaWRlXSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgICAgIHRvcDogXCJ0cmFuc2xhdGVZKDEwMCUpXCIsXG4gICAgICAgICAgICByaWdodDogXCJ0cmFuc2xhdGVZKDUwJSkgcm90YXRlKDkwZGVnKSB0cmFuc2xhdGVYKC01MCUpXCIsXG4gICAgICAgICAgICBib3R0b206IGByb3RhdGUoMTgwZGVnKWAsXG4gICAgICAgICAgICBsZWZ0OiBcInRyYW5zbGF0ZVkoNTAlKSByb3RhdGUoLTkwZGVnKSB0cmFuc2xhdGVYKDUwJSlcIlxuICAgICAgICAgIH1bY29udGVudENvbnRleHQucGxhY2VkU2lkZV0sXG4gICAgICAgICAgdmlzaWJpbGl0eTogY29udGVudENvbnRleHQuc2hvdWxkSGlkZUFycm93ID8gXCJoaWRkZW5cIiA6IHZvaWQgMFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICBBcnJvd1ByaW1pdGl2ZS5Sb290LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmFycm93UHJvcHMsXG4gICAgICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIC4uLmFycm93UHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgIC8vIGVuc3VyZXMgdGhlIGVsZW1lbnQgY2FuIGJlIG1lYXN1cmVkIGNvcnJlY3RseSAobW9zdGx5IGZvciBpZiBTVkcpXG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIClcbiAgKTtcbn0pO1xuUG9wcGVyQXJyb3cuZGlzcGxheU5hbWUgPSBBUlJPV19OQU1FO1xuZnVuY3Rpb24gaXNOb3ROdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbDtcbn1cbnZhciB0cmFuc2Zvcm1PcmlnaW4gPSAob3B0aW9ucykgPT4gKHtcbiAgbmFtZTogXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgb3B0aW9ucyxcbiAgZm4oZGF0YSkge1xuICAgIGNvbnN0IHsgcGxhY2VtZW50LCByZWN0cywgbWlkZGxld2FyZURhdGEgfSA9IGRhdGE7XG4gICAgY29uc3QgY2Fubm90Q2VudGVyQXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8uY2VudGVyT2Zmc2V0ICE9PSAwO1xuICAgIGNvbnN0IGlzQXJyb3dIaWRkZW4gPSBjYW5ub3RDZW50ZXJBcnJvdztcbiAgICBjb25zdCBhcnJvd1dpZHRoID0gaXNBcnJvd0hpZGRlbiA/IDAgOiBvcHRpb25zLmFycm93V2lkdGg7XG4gICAgY29uc3QgYXJyb3dIZWlnaHQgPSBpc0Fycm93SGlkZGVuID8gMCA6IG9wdGlvbnMuYXJyb3dIZWlnaHQ7XG4gICAgY29uc3QgW3BsYWNlZFNpZGUsIHBsYWNlZEFsaWduXSA9IGdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBub0Fycm93QWxpZ24gPSB7IHN0YXJ0OiBcIjAlXCIsIGNlbnRlcjogXCI1MCVcIiwgZW5kOiBcIjEwMCVcIiB9W3BsYWNlZEFsaWduXTtcbiAgICBjb25zdCBhcnJvd1hDZW50ZXIgPSAobWlkZGxld2FyZURhdGEuYXJyb3c/LnggPz8gMCkgKyBhcnJvd1dpZHRoIC8gMjtcbiAgICBjb25zdCBhcnJvd1lDZW50ZXIgPSAobWlkZGxld2FyZURhdGEuYXJyb3c/LnkgPz8gMCkgKyBhcnJvd0hlaWdodCAvIDI7XG4gICAgbGV0IHggPSBcIlwiO1xuICAgIGxldCB5ID0gXCJcIjtcbiAgICBpZiAocGxhY2VkU2lkZSA9PT0gXCJib3R0b21cIikge1xuICAgICAgeCA9IGlzQXJyb3dIaWRkZW4gPyBub0Fycm93QWxpZ24gOiBgJHthcnJvd1hDZW50ZXJ9cHhgO1xuICAgICAgeSA9IGAkey1hcnJvd0hlaWdodH1weGA7XG4gICAgfSBlbHNlIGlmIChwbGFjZWRTaWRlID09PSBcInRvcFwiKSB7XG4gICAgICB4ID0gaXNBcnJvd0hpZGRlbiA/IG5vQXJyb3dBbGlnbiA6IGAke2Fycm93WENlbnRlcn1weGA7XG4gICAgICB5ID0gYCR7cmVjdHMuZmxvYXRpbmcuaGVpZ2h0ICsgYXJyb3dIZWlnaHR9cHhgO1xuICAgIH0gZWxzZSBpZiAocGxhY2VkU2lkZSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICB4ID0gYCR7LWFycm93SGVpZ2h0fXB4YDtcbiAgICAgIHkgPSBpc0Fycm93SGlkZGVuID8gbm9BcnJvd0FsaWduIDogYCR7YXJyb3dZQ2VudGVyfXB4YDtcbiAgICB9IGVsc2UgaWYgKHBsYWNlZFNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICB4ID0gYCR7cmVjdHMuZmxvYXRpbmcud2lkdGggKyBhcnJvd0hlaWdodH1weGA7XG4gICAgICB5ID0gaXNBcnJvd0hpZGRlbiA/IG5vQXJyb3dBbGlnbiA6IGAke2Fycm93WUNlbnRlcn1weGA7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IHsgeCwgeSB9IH07XG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0U2lkZUFuZEFsaWduRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgY29uc3QgW3NpZGUsIGFsaWduID0gXCJjZW50ZXJcIl0gPSBwbGFjZW1lbnQuc3BsaXQoXCItXCIpO1xuICByZXR1cm4gW3NpZGUsIGFsaWduXTtcbn1cbnZhciBSb290MiA9IFBvcHBlcjtcbnZhciBBbmNob3IgPSBQb3BwZXJBbmNob3I7XG52YXIgQ29udGVudCA9IFBvcHBlckNvbnRlbnQ7XG52YXIgQXJyb3cgPSBQb3BwZXJBcnJvdztcbmV4cG9ydCB7XG4gIEFMSUdOX09QVElPTlMsXG4gIEFuY2hvcixcbiAgQXJyb3csXG4gIENvbnRlbnQsXG4gIFBvcHBlcixcbiAgUG9wcGVyQW5jaG9yLFxuICBQb3BwZXJBcnJvdyxcbiAgUG9wcGVyQ29udGVudCxcbiAgUm9vdDIgYXMgUm9vdCxcbiAgU0lERV9PUFRJT05TLFxuICBjcmVhdGVQb3BwZXJTY29wZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9wb3J0YWwvc3JjL3BvcnRhbC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBQT1JUQUxfTkFNRSA9IFwiUG9ydGFsXCI7XG52YXIgUG9ydGFsID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7IGNvbnRhaW5lcjogY29udGFpbmVyUHJvcCwgLi4ucG9ydGFsUHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiBzZXRNb3VudGVkKHRydWUpLCBbXSk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclByb3AgfHwgbW91bnRlZCAmJiBnbG9iYWxUaGlzPy5kb2N1bWVudD8uYm9keTtcbiAgcmV0dXJuIGNvbnRhaW5lciA/IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCgvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgLi4ucG9ydGFsUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pLCBjb250YWluZXIpIDogbnVsbDtcbn0pO1xuUG9ydGFsLmRpc3BsYXlOYW1lID0gUE9SVEFMX05BTUU7XG52YXIgUm9vdCA9IFBvcnRhbDtcbmV4cG9ydCB7XG4gIFBvcnRhbCxcbiAgUm9vdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3VzZS1jb250cm9sbGFibGUtc3RhdGUvc3JjL3VzZUNvbnRyb2xsYWJsZVN0YXRlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuZnVuY3Rpb24gdXNlQ29udHJvbGxhYmxlU3RhdGUoe1xuICBwcm9wLFxuICBkZWZhdWx0UHJvcCxcbiAgb25DaGFuZ2UgPSAoKSA9PiB7XG4gIH1cbn0pIHtcbiAgY29uc3QgW3VuY29udHJvbGxlZFByb3AsIHNldFVuY29udHJvbGxlZFByb3BdID0gdXNlVW5jb250cm9sbGVkU3RhdGUoeyBkZWZhdWx0UHJvcCwgb25DaGFuZ2UgfSk7XG4gIGNvbnN0IGlzQ29udHJvbGxlZCA9IHByb3AgIT09IHZvaWQgMDtcbiAgY29uc3QgdmFsdWUgPSBpc0NvbnRyb2xsZWQgPyBwcm9wIDogdW5jb250cm9sbGVkUHJvcDtcbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2tSZWYob25DaGFuZ2UpO1xuICBjb25zdCBzZXRWYWx1ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChuZXh0VmFsdWUpID0+IHtcbiAgICAgIGlmIChpc0NvbnRyb2xsZWQpIHtcbiAgICAgICAgY29uc3Qgc2V0dGVyID0gbmV4dFZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSB0eXBlb2YgbmV4dFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBzZXR0ZXIocHJvcCkgOiBuZXh0VmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZTIgIT09IHByb3ApIGhhbmRsZUNoYW5nZSh2YWx1ZTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VW5jb250cm9sbGVkUHJvcChuZXh0VmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2lzQ29udHJvbGxlZCwgcHJvcCwgc2V0VW5jb250cm9sbGVkUHJvcCwgaGFuZGxlQ2hhbmdlXVxuICApO1xuICByZXR1cm4gW3ZhbHVlLCBzZXRWYWx1ZV07XG59XG5mdW5jdGlvbiB1c2VVbmNvbnRyb2xsZWRTdGF0ZSh7XG4gIGRlZmF1bHRQcm9wLFxuICBvbkNoYW5nZVxufSkge1xuICBjb25zdCB1bmNvbnRyb2xsZWRTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGRlZmF1bHRQcm9wKTtcbiAgY29uc3QgW3ZhbHVlXSA9IHVuY29udHJvbGxlZFN0YXRlO1xuICBjb25zdCBwcmV2VmFsdWVSZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFja1JlZihvbkNoYW5nZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZXZWYWx1ZVJlZi5jdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgaGFuZGxlQ2hhbmdlKHZhbHVlKTtcbiAgICAgIHByZXZWYWx1ZVJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICB9LCBbdmFsdWUsIHByZXZWYWx1ZVJlZiwgaGFuZGxlQ2hhbmdlXSk7XG4gIHJldHVybiB1bmNvbnRyb2xsZWRTdGF0ZTtcbn1cbmV4cG9ydCB7XG4gIHVzZUNvbnRyb2xsYWJsZVN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLXByZXZpb3VzL3NyYy91c2VQcmV2aW91cy50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHsgdmFsdWUsIHByZXZpb3VzOiB2YWx1ZSB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudC52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHJlZi5jdXJyZW50LnByZXZpb3VzID0gcmVmLmN1cnJlbnQudmFsdWU7XG4gICAgICByZWYuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQucHJldmlvdXM7XG4gIH0sIFt2YWx1ZV0pO1xufVxuZXhwb3J0IHtcbiAgdXNlUHJldmlvdXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC92aXN1YWxseS1oaWRkZW4vc3JjL3Zpc3VhbGx5LWhpZGRlbi50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE5BTUUgPSBcIlZpc3VhbGx5SGlkZGVuXCI7XG52YXIgVmlzdWFsbHlIaWRkZW4gPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgUHJpbWl0aXZlLnNwYW4sXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vc2Nzcy9taXhpbnMvX3Zpc3VhbGx5LWhpZGRlbi5zY3NzXG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgbWFyZ2luOiAtMSxcbiAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICBjbGlwOiBcInJlY3QoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuVmlzdWFsbHlIaWRkZW4uZGlzcGxheU5hbWUgPSBOQU1FO1xudmFyIFJvb3QgPSBWaXN1YWxseUhpZGRlbjtcbmV4cG9ydCB7XG4gIFJvb3QsXG4gIFZpc3VhbGx5SGlkZGVuXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGdldERlZmF1bHRQYXJlbnQgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNhbXBsZVRhcmdldCA9IEFycmF5LmlzQXJyYXkob3JpZ2luYWxUYXJnZXQpID8gb3JpZ2luYWxUYXJnZXRbMF0gOiBvcmlnaW5hbFRhcmdldDtcbiAgICByZXR1cm4gc2FtcGxlVGFyZ2V0Lm93bmVyRG9jdW1lbnQuYm9keTtcbn07XG52YXIgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgdW5jb250cm9sbGVkTm9kZXMgPSBuZXcgV2Vha01hcCgpO1xudmFyIG1hcmtlck1hcCA9IHt9O1xudmFyIGxvY2tDb3VudCA9IDA7XG52YXIgdW53cmFwSG9zdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUuaG9zdCB8fCB1bndyYXBIb3N0KG5vZGUucGFyZW50Tm9kZSkpO1xufTtcbnZhciBjb3JyZWN0VGFyZ2V0cyA9IGZ1bmN0aW9uIChwYXJlbnQsIHRhcmdldHMpIHtcbiAgICByZXR1cm4gdGFyZ2V0c1xuICAgICAgICAubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JyZWN0ZWRUYXJnZXQgPSB1bndyYXBIb3N0KHRhcmdldCk7XG4gICAgICAgIGlmIChjb3JyZWN0ZWRUYXJnZXQgJiYgcGFyZW50LmNvbnRhaW5zKGNvcnJlY3RlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3JyZWN0ZWRUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcignYXJpYS1oaWRkZW4nLCB0YXJnZXQsICdpbiBub3QgY29udGFpbmVkIGluc2lkZScsIHBhcmVudCwgJy4gRG9pbmcgbm90aGluZycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBCb29sZWFuKHgpOyB9KTtcbn07XG4vKipcbiAqIE1hcmtzIGV2ZXJ5dGhpbmcgZXhjZXB0IGdpdmVuIG5vZGUob3Igbm9kZXMpIGFzIGFyaWEtaGlkZGVuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBFbGVtZW50W119IG9yaWdpbmFsVGFyZ2V0IC0gZWxlbWVudHMgdG8ga2VlcCBvbiB0aGUgcGFnZVxuICogQHBhcmFtIFtwYXJlbnROb2RlXSAtIHRvcCBlbGVtZW50LCBkZWZhdWx0cyB0byBkb2N1bWVudC5ib2R5XG4gKiBAcGFyYW0ge1N0cmluZ30gW21hcmtlck5hbWVdIC0gYSBzcGVjaWFsIGF0dHJpYnV0ZSB0byBtYXJrIGV2ZXJ5IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29udHJvbEF0dHJpYnV0ZV0gLSBodG1sIEF0dHJpYnV0ZSB0byBjb250cm9sXG4gKiBAcmV0dXJuIHtVbmRvfSB1bmRvIGNvbW1hbmRcbiAqL1xudmFyIGFwcGx5QXR0cmlidXRlVG9PdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUsIGNvbnRyb2xBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IGNvcnJlY3RUYXJnZXRzKHBhcmVudE5vZGUsIEFycmF5LmlzQXJyYXkob3JpZ2luYWxUYXJnZXQpID8gb3JpZ2luYWxUYXJnZXQgOiBbb3JpZ2luYWxUYXJnZXRdKTtcbiAgICBpZiAoIW1hcmtlck1hcFttYXJrZXJOYW1lXSkge1xuICAgICAgICBtYXJrZXJNYXBbbWFya2VyTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICB2YXIgbWFya2VyQ291bnRlciA9IG1hcmtlck1hcFttYXJrZXJOYW1lXTtcbiAgICB2YXIgaGlkZGVuTm9kZXMgPSBbXTtcbiAgICB2YXIgZWxlbWVudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGVsZW1lbnRzVG9TdG9wID0gbmV3IFNldCh0YXJnZXRzKTtcbiAgICB2YXIga2VlcCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoIWVsIHx8IGVsZW1lbnRzVG9LZWVwLmhhcyhlbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50c1RvS2VlcC5hZGQoZWwpO1xuICAgICAgICBrZWVwKGVsLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgdGFyZ2V0cy5mb3JFYWNoKGtlZXApO1xuICAgIHZhciBkZWVwID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBlbGVtZW50c1RvU3RvcC5oYXMocGFyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzVG9LZWVwLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgIGRlZXAobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeUhpZGRlbiA9IGF0dHIgIT09IG51bGwgJiYgYXR0ciAhPT0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyTWFwLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJNYXAuc2V0KG5vZGUsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJWYWx1ZSA9PT0gMSAmJiBhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmNvbnRyb2xsZWROb2Rlcy5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlclZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShtYXJrZXJOYW1lLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeUhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSwgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhcmlhLWhpZGRlbjogY2Fubm90IG9wZXJhdGUgb24gJywgbm9kZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGRlZXAocGFyZW50Tm9kZSk7XG4gICAgZWxlbWVudHNUb0tlZXAuY2xlYXIoKTtcbiAgICBsb2NrQ291bnQrKztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRkZW5Ob2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgY291bnRlclZhbHVlID0gY291bnRlck1hcC5nZXQobm9kZSkgLSAxO1xuICAgICAgICAgICAgdmFyIG1hcmtlclZhbHVlID0gbWFya2VyQ291bnRlci5nZXQobm9kZSkgLSAxO1xuICAgICAgICAgICAgY291bnRlck1hcC5zZXQobm9kZSwgY291bnRlclZhbHVlKTtcbiAgICAgICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgICAgIGlmICghY291bnRlclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmNvbnRyb2xsZWROb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuY29udHJvbGxlZE5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWFya2VyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShtYXJrZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxvY2tDb3VudC0tO1xuICAgICAgICBpZiAoIWxvY2tDb3VudCkge1xuICAgICAgICAgICAgLy8gY2xlYXJcbiAgICAgICAgICAgIGNvdW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICB1bmNvbnRyb2xsZWROb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBtYXJrZXJNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBNYXJrcyBldmVyeXRoaW5nIGV4Y2VwdCBnaXZlbiBub2RlKG9yIG5vZGVzKSBhcyBhcmlhLWhpZGRlblxuICogQHBhcmFtIHtFbGVtZW50IHwgRWxlbWVudFtdfSBvcmlnaW5hbFRhcmdldCAtIGVsZW1lbnRzIHRvIGtlZXAgb24gdGhlIHBhZ2VcbiAqIEBwYXJhbSBbcGFyZW50Tm9kZV0gLSB0b3AgZWxlbWVudCwgZGVmYXVsdHMgdG8gZG9jdW1lbnQuYm9keVxuICogQHBhcmFtIHtTdHJpbmd9IFttYXJrZXJOYW1lXSAtIGEgc3BlY2lhbCBhdHRyaWJ1dGUgdG8gbWFyayBldmVyeSBub2RlXG4gKiBAcmV0dXJuIHtVbmRvfSB1bmRvIGNvbW1hbmRcbiAqL1xuZXhwb3J0IHZhciBoaWRlT3RoZXJzID0gZnVuY3Rpb24gKG9yaWdpbmFsVGFyZ2V0LCBwYXJlbnROb2RlLCBtYXJrZXJOYW1lKSB7XG4gICAgaWYgKG1hcmtlck5hbWUgPT09IHZvaWQgMCkgeyBtYXJrZXJOYW1lID0gJ2RhdGEtYXJpYS1oaWRkZW4nOyB9XG4gICAgdmFyIHRhcmdldHMgPSBBcnJheS5mcm9tKEFycmF5LmlzQXJyYXkob3JpZ2luYWxUYXJnZXQpID8gb3JpZ2luYWxUYXJnZXQgOiBbb3JpZ2luYWxUYXJnZXRdKTtcbiAgICB2YXIgYWN0aXZlUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgZ2V0RGVmYXVsdFBhcmVudChvcmlnaW5hbFRhcmdldCk7XG4gICAgaWYgKCFhY3RpdmVQYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIH1cbiAgICAvLyB3ZSBzaG91bGQgbm90IGhpZGUgYXJpYUxpdmUgZWxlbWVudHMgLSBodHRwczovL2dpdGh1Yi5jb20vdGhlS2FzaGV5L2FyaWEtaGlkZGVuL2lzc3Vlcy8xMFxuICAgIHRhcmdldHMucHVzaC5hcHBseSh0YXJnZXRzLCBBcnJheS5mcm9tKGFjdGl2ZVBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2FyaWEtbGl2ZV0nKSkpO1xuICAgIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKHRhcmdldHMsIGFjdGl2ZVBhcmVudE5vZGUsIG1hcmtlck5hbWUsICdhcmlhLWhpZGRlbicpO1xufTtcbi8qKlxuICogTWFya3MgZXZlcnl0aGluZyBleGNlcHQgZ2l2ZW4gbm9kZShvciBub2RlcykgYXMgaW5lcnRcbiAqIEBwYXJhbSB7RWxlbWVudCB8IEVsZW1lbnRbXX0gb3JpZ2luYWxUYXJnZXQgLSBlbGVtZW50cyB0byBrZWVwIG9uIHRoZSBwYWdlXG4gKiBAcGFyYW0gW3BhcmVudE5vZGVdIC0gdG9wIGVsZW1lbnQsIGRlZmF1bHRzIHRvIGRvY3VtZW50LmJvZHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWFya2VyTmFtZV0gLSBhIHNwZWNpYWwgYXR0cmlidXRlIHRvIG1hcmsgZXZlcnkgbm9kZVxuICogQHJldHVybiB7VW5kb30gdW5kbyBjb21tYW5kXG4gKi9cbmV4cG9ydCB2YXIgaW5lcnRPdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpIHtcbiAgICBpZiAobWFya2VyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcmtlck5hbWUgPSAnZGF0YS1pbmVydC1lZCc7IH1cbiAgICB2YXIgYWN0aXZlUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgZ2V0RGVmYXVsdFBhcmVudChvcmlnaW5hbFRhcmdldCk7XG4gICAgaWYgKCFhY3RpdmVQYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHlBdHRyaWJ1dGVUb090aGVycyhvcmlnaW5hbFRhcmdldCwgYWN0aXZlUGFyZW50Tm9kZSwgbWFya2VyTmFtZSwgJ2luZXJ0Jyk7XG59O1xuLyoqXG4gKiBAcmV0dXJucyBpZiBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgaW5lcnRcbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0luZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIEhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKTtcbn07XG4vKipcbiAqIEF1dG9tYXRpYyBmdW5jdGlvbiB0byBcInN1cHByZXNzXCIgRE9NIGVsZW1lbnRzIC0gX2hpZGVfIG9yIF9pbmVydF8gaW4gdGhlIGJlc3QgcG9zc2libGUgd2F5XG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBFbGVtZW50W119IG9yaWdpbmFsVGFyZ2V0IC0gZWxlbWVudHMgdG8ga2VlcCBvbiB0aGUgcGFnZVxuICogQHBhcmFtIFtwYXJlbnROb2RlXSAtIHRvcCBlbGVtZW50LCBkZWZhdWx0cyB0byBkb2N1bWVudC5ib2R5XG4gKiBAcGFyYW0ge1N0cmluZ30gW21hcmtlck5hbWVdIC0gYSBzcGVjaWFsIGF0dHJpYnV0ZSB0byBtYXJrIGV2ZXJ5IG5vZGVcbiAqIEByZXR1cm4ge1VuZG99IHVuZG8gY29tbWFuZFxuICovXG5leHBvcnQgdmFyIHN1cHByZXNzT3RoZXJzID0gZnVuY3Rpb24gKG9yaWdpbmFsVGFyZ2V0LCBwYXJlbnROb2RlLCBtYXJrZXJOYW1lKSB7XG4gICAgaWYgKG1hcmtlck5hbWUgPT09IHZvaWQgMCkgeyBtYXJrZXJOYW1lID0gJ2RhdGEtc3VwcHJlc3NlZCc7IH1cbiAgICByZXR1cm4gKHN1cHBvcnRzSW5lcnQoKSA/IGluZXJ0T3RoZXJzIDogaGlkZU90aGVycykob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpO1xufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcbiAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG52YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGFyID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICByZXR1cm4gYXI7XG4gIH07XG4gIHJldHVybiBvd25LZXlzKG8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICBpZiAoYXN5bmMpIGlubmVyID0gZGlzcG9zZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkgeyB0cnkgeyBpbm5lci5jYWxsKHRoaXMpOyB9IGNhdGNoIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSB9O1xuICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gIH1cbiAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xuICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgfVxuICB2YXIgciwgcyA9IDA7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKHIgPSBlbnYuc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghci5hc3luYyAmJiBzID09PSAxKSByZXR1cm4gcyA9IDAsIGVudi5zdGFjay5wdXNoKHIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xuICAgICAgICBpZiAoci5kaXNwb3NlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHIuZGlzcG9zZS5jYWxsKHIudmFsdWUpO1xuICAgICAgICAgIGlmIChyLmFzeW5jKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzIHw9IDE7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA9PT0gMSkgcmV0dXJuIGVudi5oYXNFcnJvciA/IFByb21pc2UucmVqZWN0KGVudi5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uKHBhdGgsIHByZXNlcnZlSnN4KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLlxcLj9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLih0c3gpJHwoKD86XFwuZCk/KSgoPzpcXC5bXi4vXSs/KT8pXFwuKFtjbV0/KXRzJC9pLCBmdW5jdGlvbiAobSwgdHN4LCBkLCBleHQsIGNtKSB7XG4gICAgICAgICAgcmV0dXJuIHRzeCA/IHByZXNlcnZlSnN4ID8gXCIuanN4XCIgOiBcIi5qc1wiIDogZCAmJiAoIWV4dCB8fCAhY20pID8gbSA6IChkICsgZXh0ICsgXCIuXCIgKyBjbS50b0xvd2VyQ2FzZSgpICsgXCJqc1wiKTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19lc0RlY29yYXRlLFxuICBfX3J1bkluaXRpYWxpemVycyxcbiAgX19wcm9wS2V5LFxuICBfX3NldEZ1bmN0aW9uTmFtZSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG4gIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uLFxufTtcbiIsImV4cG9ydCB2YXIgemVyb1JpZ2h0Q2xhc3NOYW1lID0gJ3JpZ2h0LXNjcm9sbC1iYXItcG9zaXRpb24nO1xuZXhwb3J0IHZhciBmdWxsV2lkdGhDbGFzc05hbWUgPSAnd2lkdGgtYmVmb3JlLXNjcm9sbC1iYXInO1xuZXhwb3J0IHZhciBub1Njcm9sbGJhcnNDbGFzc05hbWUgPSAnd2l0aC1zY3JvbGwtYmFycy1oaWRkZW4nO1xuLyoqXG4gKiBOYW1lIG9mIGEgQ1NTIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlIGFtb3VudCBvZiBcImhpZGRlblwiIHNjcm9sbGJhclxuICogISBtaWdodCBiZSB1bmRlZmluZWQgISB1c2Ugd2lsbCBmYWxsYmFjayFcbiAqL1xuZXhwb3J0IHZhciByZW1vdmVkQmFyU2l6ZVZhcmlhYmxlID0gJy0tcmVtb3ZlZC1ib2R5LXNjcm9sbC1iYXItc2l6ZSc7XG4iLCIvKipcbiAqIEFzc2lnbnMgYSB2YWx1ZSBmb3IgYSBnaXZlbiByZWYsIG5vIG1hdHRlciBvZiB0aGUgcmVmIGZvcm1hdFxuICogQHBhcmFtIHtSZWZPYmplY3R9IHJlZiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gb3IgcmVmIG9iamVjdFxuICogQHBhcmFtIHZhbHVlIC0gYSBuZXcgdmFsdWVcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvdXNlLWNhbGxiYWNrLXJlZiNhc3NpZ25yZWZcbiAqIEBleGFtcGxlXG4gKiBjb25zdCByZWZPYmplY3QgPSB1c2VSZWYoKTtcbiAqIGNvbnN0IHJlZkZuID0gKHJlZikgPT4gey4uLi59XG4gKlxuICogYXNzaWduUmVmKHJlZk9iamVjdCwgXCJyZWZWYWx1ZVwiKTtcbiAqIGFzc2lnblJlZihyZWZGbiwgXCJyZWZWYWx1ZVwiKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnblJlZihyZWYsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG4iLCJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogY3JlYXRlcyBhIE11dGFibGVSZWYgd2l0aCByZWYgY2hhbmdlIGNhbGxiYWNrXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIC0gaW5pdGlhbCByZWYgdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gYSBjYWxsYmFjayB0byBydW4gd2hlbiB2YWx1ZSBjaGFuZ2VzXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlZiA9IHVzZUNhbGxiYWNrUmVmKDAsIChuZXdWYWx1ZSwgb2xkVmFsdWUpID0+IGNvbnNvbGUubG9nKG9sZFZhbHVlLCAnLT4nLCBuZXdWYWx1ZSk7XG4gKiByZWYuY3VycmVudCA9IDE7XG4gKiAvLyBwcmludHMgMCAtPiAxXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlcmVmXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvdXNlLWNhbGxiYWNrLXJlZiN1c2VjYWxsYmFja3JlZi0tLXRvLXJlcGxhY2UtcmVhY3R1c2VyZWZcbiAqIEByZXR1cm5zIHtNdXRhYmxlUmVmT2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoaW5pdGlhbFZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZWYgPSB1c2VTdGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAvLyB2YWx1ZVxuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlLFxuICAgICAgICAvLyBsYXN0IGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgLy8gXCJtZW1vaXplZFwiIHB1YmxpYyBpbnRlcmZhY2VcbiAgICAgICAgZmFjYWRlOiB7XG4gICAgICAgICAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmLnZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBjdXJyZW50KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZWYuY2FsbGJhY2sodmFsdWUsIGxhc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7IH0pWzBdO1xuICAgIC8vIHVwZGF0ZSBjYWxsYmFja1xuICAgIHJlZi5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiByZWYuZmFjYWRlO1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduUmVmIH0gZnJvbSAnLi9hc3NpZ25SZWYnO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2tSZWYgfSBmcm9tICcuL3VzZVJlZic7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIGN1cnJlbnRWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBNZXJnZXMgdHdvIG9yIG1vcmUgcmVmcyB0b2dldGhlciBwcm92aWRpbmcgYSBzaW5nbGUgaW50ZXJmYWNlIHRvIHNldCB0aGVpciB2YWx1ZVxuICogQHBhcmFtIHtSZWZPYmplY3R8UmVmfSByZWZzXG4gKiBAcmV0dXJucyB7TXV0YWJsZVJlZk9iamVjdH0gLSBhIG5ldyByZWYsIHdoaWNoIHRyYW5zbGF0ZXMgYWxsIGNoYW5nZXMgdG8ge3JlZnN9XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VSZWZzfSBhIHZlcnNpb24gd2l0aG91dCBidWl0LWluIG1lbW9pemF0aW9uXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvdXNlLWNhbGxiYWNrLXJlZiN1c2VtZXJnZXJlZnNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gKiAgIGNvbnN0IG93blJlZiA9IHVzZVJlZigpO1xuICogICBjb25zdCBkb21SZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgb3duUmVmXSk7IC8vIPCfkYggbWVyZ2UgdG9nZXRoZXJcbiAqICAgcmV0dXJuIDxkaXYgcmVmPXtkb21SZWZ9Pi4uLjwvZGl2PlxuICogfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VSZWZzKHJlZnMsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciBjYWxsYmFja1JlZiA9IHVzZUNhbGxiYWNrUmVmKGRlZmF1bHRWYWx1ZSB8fCBudWxsLCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBhc3NpZ25SZWYocmVmLCBuZXdWYWx1ZSk7IH0pO1xuICAgIH0pO1xuICAgIC8vIGhhbmRsZSByZWZzIGNoYW5nZXMgLSBhZGRlZCBvciByZW1vdmVkXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGN1cnJlbnRWYWx1ZXMuZ2V0KGNhbGxiYWNrUmVmKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJldlJlZnNfMSA9IG5ldyBTZXQob2xkVmFsdWUpO1xuICAgICAgICAgICAgdmFyIG5leHRSZWZzXzEgPSBuZXcgU2V0KHJlZnMpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfMSA9IGNhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBwcmV2UmVmc18xLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFJlZnNfMS5oYXMocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25SZWYocmVmLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRSZWZzXzEuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2UmVmc18xLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnblJlZihyZWYsIGN1cnJlbnRfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFZhbHVlcy5zZXQoY2FsbGJhY2tSZWYsIHJlZnMpO1xuICAgIH0sIFtyZWZzXSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrUmVmO1xufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmZ1bmN0aW9uIEl0b0koYSkge1xuICAgIHJldHVybiBhO1xufVxuZnVuY3Rpb24gaW5uZXJDcmVhdGVNZWRpdW0oZGVmYXVsdHMsIG1pZGRsZXdhcmUpIHtcbiAgICBpZiAobWlkZGxld2FyZSA9PT0gdm9pZCAwKSB7IG1pZGRsZXdhcmUgPSBJdG9JOyB9XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciBhc3NpZ25lZCA9IGZhbHNlO1xuICAgIHZhciBtZWRpdW0gPSB7XG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhc3NpZ25lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2lkZWNhcjogY291bGQgbm90IGByZWFkYCBmcm9tIGFuIGBhc3NpZ25lZGAgbWVkaXVtLiBgcmVhZGAgY291bGQgYmUgdXNlZCBvbmx5IHdpdGggYHVzZU1lZGl1bWAuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgICB9LFxuICAgICAgICB1c2VNZWRpdW06IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1pZGRsZXdhcmUoZGF0YSwgYXNzaWduZWQpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IGl0ZW07IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXNzaWduU3luY01lZGl1bTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBhc3NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjYnMgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgY2JzLmZvckVhY2goY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0ge1xuICAgICAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uICh4KSB7IHJldHVybiBjYih4KTsgfSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1ZmZlcjsgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFzc2lnbk1lZGl1bTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBhc3NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ1F1ZXVlID0gW107XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjYnMgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgY2JzLmZvckVhY2goY2IpO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleGVjdXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNicyA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBjYnMuZm9yRWFjaChjYik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGN5Y2xlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihleGVjdXRlUXVldWUpOyB9O1xuICAgICAgICAgICAgY3ljbGUoKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHtcbiAgICAgICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUXVldWUucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgY3ljbGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUXVldWUgPSBwZW5kaW5nUXVldWUuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gbWVkaXVtO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lZGl1bShkZWZhdWx0cywgbWlkZGxld2FyZSkge1xuICAgIGlmIChtaWRkbGV3YXJlID09PSB2b2lkIDApIHsgbWlkZGxld2FyZSA9IEl0b0k7IH1cbiAgICByZXR1cm4gaW5uZXJDcmVhdGVNZWRpdW0oZGVmYXVsdHMsIG1pZGRsZXdhcmUpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaWRlY2FyTWVkaXVtKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBtZWRpdW0gPSBpbm5lckNyZWF0ZU1lZGl1bShudWxsKTtcbiAgICBtZWRpdW0ub3B0aW9ucyA9IF9fYXNzaWduKHsgYXN5bmM6IHRydWUsIHNzcjogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG1lZGl1bTtcbn1cbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbnZhciBTaWRlQ2FyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNpZGVDYXIgPSBfYS5zaWRlQ2FyLCByZXN0ID0gX19yZXN0KF9hLCBbXCJzaWRlQ2FyXCJdKTtcbiAgICBpZiAoIXNpZGVDYXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWRlY2FyOiBwbGVhc2UgcHJvdmlkZSBgc2lkZUNhcmAgcHJvcGVydHkgdG8gaW1wb3J0IHRoZSByaWdodCBjYXInKTtcbiAgICB9XG4gICAgdmFyIFRhcmdldCA9IHNpZGVDYXIucmVhZCgpO1xuICAgIGlmICghVGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2lkZWNhciBtZWRpdW0gbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRhcmdldCwgX19hc3NpZ24oe30sIHJlc3QpKTtcbn07XG5TaWRlQ2FyLmlzU2lkZUNhckV4cG9ydCA9IHRydWU7XG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0U2lkZWNhcihtZWRpdW0sIGV4cG9ydGVkKSB7XG4gICAgbWVkaXVtLnVzZU1lZGl1bShleHBvcnRlZCk7XG4gICAgcmV0dXJuIFNpZGVDYXI7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVTaWRlY2FyTWVkaXVtIH0gZnJvbSAndXNlLXNpZGVjYXInO1xuZXhwb3J0IHZhciBlZmZlY3RDYXIgPSBjcmVhdGVTaWRlY2FyTWVkaXVtKCk7XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmdWxsV2lkdGhDbGFzc05hbWUsIHplcm9SaWdodENsYXNzTmFtZSB9IGZyb20gJ3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyL2NvbnN0YW50cyc7XG5pbXBvcnQgeyB1c2VNZXJnZVJlZnMgfSBmcm9tICd1c2UtY2FsbGJhY2stcmVmJztcbmltcG9ydCB7IGVmZmVjdENhciB9IGZyb20gJy4vbWVkaXVtJztcbnZhciBub3RoaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbn07XG4vKipcbiAqIFJlbW92ZXMgc2Nyb2xsYmFyIGZyb20gdGhlIHBhZ2UgYW5kIGNvbnRhaW4gdGhlIHNjcm9sbCB3aXRoaW4gdGhlIExvY2tcbiAqL1xudmFyIFJlbW92ZVNjcm9sbCA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCBwYXJlbnRSZWYpIHtcbiAgICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgb25TY3JvbGxDYXB0dXJlOiBub3RoaW5nLFxuICAgICAgICBvbldoZWVsQ2FwdHVyZTogbm90aGluZyxcbiAgICAgICAgb25Ub3VjaE1vdmVDYXB0dXJlOiBub3RoaW5nLFxuICAgIH0pLCBjYWxsYmFja3MgPSBfYVswXSwgc2V0Q2FsbGJhY2tzID0gX2FbMV07XG4gICAgdmFyIGZvcndhcmRQcm9wcyA9IHByb3BzLmZvcndhcmRQcm9wcywgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiwgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCByZW1vdmVTY3JvbGxCYXIgPSBwcm9wcy5yZW1vdmVTY3JvbGxCYXIsIGVuYWJsZWQgPSBwcm9wcy5lbmFibGVkLCBzaGFyZHMgPSBwcm9wcy5zaGFyZHMsIHNpZGVDYXIgPSBwcm9wcy5zaWRlQ2FyLCBub0lzb2xhdGlvbiA9IHByb3BzLm5vSXNvbGF0aW9uLCBpbmVydCA9IHByb3BzLmluZXJ0LCBhbGxvd1BpbmNoWm9vbSA9IHByb3BzLmFsbG93UGluY2hab29tLCBfYiA9IHByb3BzLmFzLCBDb250YWluZXIgPSBfYiA9PT0gdm9pZCAwID8gJ2RpdicgOiBfYiwgZ2FwTW9kZSA9IHByb3BzLmdhcE1vZGUsIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcImZvcndhcmRQcm9wc1wiLCBcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwicmVtb3ZlU2Nyb2xsQmFyXCIsIFwiZW5hYmxlZFwiLCBcInNoYXJkc1wiLCBcInNpZGVDYXJcIiwgXCJub0lzb2xhdGlvblwiLCBcImluZXJ0XCIsIFwiYWxsb3dQaW5jaFpvb21cIiwgXCJhc1wiLCBcImdhcE1vZGVcIl0pO1xuICAgIHZhciBTaWRlQ2FyID0gc2lkZUNhcjtcbiAgICB2YXIgY29udGFpbmVyUmVmID0gdXNlTWVyZ2VSZWZzKFtyZWYsIHBhcmVudFJlZl0pO1xuICAgIHZhciBjb250YWluZXJQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN0KSwgY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGVuYWJsZWQgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lkZUNhciwgeyBzaWRlQ2FyOiBlZmZlY3RDYXIsIHJlbW92ZVNjcm9sbEJhcjogcmVtb3ZlU2Nyb2xsQmFyLCBzaGFyZHM6IHNoYXJkcywgbm9Jc29sYXRpb246IG5vSXNvbGF0aW9uLCBpbmVydDogaW5lcnQsIHNldENhbGxiYWNrczogc2V0Q2FsbGJhY2tzLCBhbGxvd1BpbmNoWm9vbTogISFhbGxvd1BpbmNoWm9vbSwgbG9ja1JlZjogcmVmLCBnYXBNb2RlOiBnYXBNb2RlIH0pKSxcbiAgICAgICAgZm9yd2FyZFByb3BzID8gKFJlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbnRhaW5lclByb3BzKSwgeyByZWY6IGNvbnRhaW5lclJlZiB9KSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCBfX2Fzc2lnbih7fSwgY29udGFpbmVyUHJvcHMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHJlZjogY29udGFpbmVyUmVmIH0pLCBjaGlsZHJlbikpKSk7XG59KTtcblJlbW92ZVNjcm9sbC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICByZW1vdmVTY3JvbGxCYXI6IHRydWUsXG4gICAgaW5lcnQ6IGZhbHNlLFxufTtcblJlbW92ZVNjcm9sbC5jbGFzc05hbWVzID0ge1xuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoQ2xhc3NOYW1lLFxuICAgIHplcm9SaWdodDogemVyb1JpZ2h0Q2xhc3NOYW1lLFxufTtcbmV4cG9ydCB7IFJlbW92ZVNjcm9sbCB9O1xuIiwidmFyIGN1cnJlbnROb25jZTtcbmV4cG9ydCB2YXIgc2V0Tm9uY2UgPSBmdW5jdGlvbiAobm9uY2UpIHtcbiAgICBjdXJyZW50Tm9uY2UgPSBub25jZTtcbn07XG5leHBvcnQgdmFyIGdldE5vbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50Tm9uY2UpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb25jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbiIsImltcG9ydCB7IGdldE5vbmNlIH0gZnJvbSAnZ2V0LW5vbmNlJztcbmZ1bmN0aW9uIG1ha2VTdHlsZVRhZygpIHtcbiAgICBpZiAoIWRvY3VtZW50KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICB0YWcudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgdGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5mdW5jdGlvbiBpbmplY3RTdHlsZXModGFnLCBjc3MpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHRhZy5zdHlsZVNoZWV0KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZVRhZyh0YWcpIHtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG59XG5leHBvcnQgdmFyIHN0eWxlc2hlZXRTaW5nbGV0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBzdHlsZXNoZWV0ID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgoc3R5bGVzaGVldCA9IG1ha2VTdHlsZVRhZygpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmplY3RTdHlsZXMoc3R5bGVzaGVldCwgc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRTdHlsZVRhZyhzdHlsZXNoZWV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgaWYgKCFjb3VudGVyICYmIHN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LnBhcmVudE5vZGUgJiYgc3R5bGVzaGVldC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59O1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3R5bGVzaGVldFNpbmdsZXRvbiB9IGZyb20gJy4vc2luZ2xldG9uJztcbi8qKlxuICogY3JlYXRlcyBhIGhvb2sgdG8gY29udHJvbCBzdHlsZSBzaW5nbGV0b25cbiAqIEBzZWUge0BsaW5rIHN0eWxlU2luZ2xldG9ufSBmb3IgYSBzYWZlciBjb21wb25lbnQgdmVyc2lvblxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgdXNlU3R5bGUgPSBzdHlsZUhvb2tTaW5nbGV0b24oKTtcbiAqIC8vL1xuICogdXNlU3R5bGUoJ2JvZHkgeyBvdmVyZmxvdzogaGlkZGVufScpO1xuICovXG5leHBvcnQgdmFyIHN0eWxlSG9va1NpbmdsZXRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2hlZXQgPSBzdHlsZXNoZWV0U2luZ2xldG9uKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHlsZXMsIGlzRHluYW1pYykge1xuICAgICAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2hlZXQuYWRkKHN0eWxlcyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNoZWV0LnJlbW92ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW3N0eWxlcyAmJiBpc0R5bmFtaWNdKTtcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IHN0eWxlSG9va1NpbmdsZXRvbiB9IGZyb20gJy4vaG9vayc7XG4vKipcbiAqIGNyZWF0ZSBhIENvbXBvbmVudCB0byBhZGQgc3R5bGVzIG9uIGRlbWFuZFxuICogLSBzdHlsZXMgYXJlIGFkZGVkIHdoZW4gZmlyc3QgaW5zdGFuY2UgaXMgbW91bnRlZFxuICogLSBzdHlsZXMgYXJlIHJlbW92ZWQgd2hlbiB0aGUgbGFzdCBpbnN0YW5jZSBpcyB1bm1vdW50ZWRcbiAqIC0gY2hhbmdpbmcgc3R5bGVzIGluIHJ1bnRpbWUgZG9lcyBub3RoaW5nIHVubGVzcyBkeW5hbWljIGlzIHNldC4gQnV0IHdpdGggbXVsdGlwbGUgY29tcG9uZW50cyB0aGF0IGNhbiBsZWFkIHRvIHRoZSB1bmRlZmluZWQgYmVoYXZpb3JcbiAqL1xuZXhwb3J0IHZhciBzdHlsZVNpbmdsZXRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlU3R5bGUgPSBzdHlsZUhvb2tTaW5nbGV0b24oKTtcbiAgICB2YXIgU2hlZXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IF9hLnN0eWxlcywgZHluYW1pYyA9IF9hLmR5bmFtaWM7XG4gICAgICAgIHVzZVN0eWxlKHN0eWxlcywgZHluYW1pYyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFNoZWV0O1xufTtcbiIsImV4cG9ydCB2YXIgemVyb0dhcCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBnYXA6IDAsXG59O1xudmFyIHBhcnNlID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHBhcnNlSW50KHggfHwgJycsIDEwKSB8fCAwOyB9O1xudmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uIChnYXBNb2RlKSB7XG4gICAgdmFyIGNzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gICAgdmFyIGxlZnQgPSBjc1tnYXBNb2RlID09PSAncGFkZGluZycgPyAncGFkZGluZ0xlZnQnIDogJ21hcmdpbkxlZnQnXTtcbiAgICB2YXIgdG9wID0gY3NbZ2FwTW9kZSA9PT0gJ3BhZGRpbmcnID8gJ3BhZGRpbmdUb3AnIDogJ21hcmdpblRvcCddO1xuICAgIHZhciByaWdodCA9IGNzW2dhcE1vZGUgPT09ICdwYWRkaW5nJyA/ICdwYWRkaW5nUmlnaHQnIDogJ21hcmdpblJpZ2h0J107XG4gICAgcmV0dXJuIFtwYXJzZShsZWZ0KSwgcGFyc2UodG9wKSwgcGFyc2UocmlnaHQpXTtcbn07XG5leHBvcnQgdmFyIGdldEdhcFdpZHRoID0gZnVuY3Rpb24gKGdhcE1vZGUpIHtcbiAgICBpZiAoZ2FwTW9kZSA9PT0gdm9pZCAwKSB7IGdhcE1vZGUgPSAnbWFyZ2luJzsgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gemVyb0dhcDtcbiAgICB9XG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXQoZ2FwTW9kZSk7XG4gICAgdmFyIGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogb2Zmc2V0c1swXSxcbiAgICAgICAgdG9wOiBvZmZzZXRzWzFdLFxuICAgICAgICByaWdodDogb2Zmc2V0c1syXSxcbiAgICAgICAgZ2FwOiBNYXRoLm1heCgwLCB3aW5kb3dXaWR0aCAtIGRvY3VtZW50V2lkdGggKyBvZmZzZXRzWzJdIC0gb2Zmc2V0c1swXSksXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdHlsZVNpbmdsZXRvbiB9IGZyb20gJ3JlYWN0LXN0eWxlLXNpbmdsZXRvbic7XG5pbXBvcnQgeyBmdWxsV2lkdGhDbGFzc05hbWUsIHplcm9SaWdodENsYXNzTmFtZSwgbm9TY3JvbGxiYXJzQ2xhc3NOYW1lLCByZW1vdmVkQmFyU2l6ZVZhcmlhYmxlIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0R2FwV2lkdGggfSBmcm9tICcuL3V0aWxzJztcbnZhciBTdHlsZSA9IHN0eWxlU2luZ2xldG9uKCk7XG5leHBvcnQgdmFyIGxvY2tBdHRyaWJ1dGUgPSAnZGF0YS1zY3JvbGwtbG9ja2VkJztcbi8vIGltcG9ydGFudCB0aXAgLSBvbmNlIHdlIG1lYXN1cmUgc2Nyb2xsQmFyIHdpZHRoIGFuZCByZW1vdmUgdGhlbVxuLy8gd2UgY291bGQgbm90IHJlcGVhdCB0aGlzIG9wZXJhdGlvblxuLy8gdGh1cyB3ZSBhcmUgdXNpbmcgc3R5bGUtc2luZ2xldG9uIC0gb25seSB0aGUgZmlyc3QgXCJ5ZXQgY29ycmVjdFwiIHN0eWxlIHdpbGwgYmUgYXBwbGllZC5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiAoX2EsIGFsbG93UmVsYXRpdmUsIGdhcE1vZGUsIGltcG9ydGFudCkge1xuICAgIHZhciBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBnYXAgPSBfYS5nYXA7XG4gICAgaWYgKGdhcE1vZGUgPT09IHZvaWQgMCkgeyBnYXBNb2RlID0gJ21hcmdpbic7IH1cbiAgICByZXR1cm4gXCJcXG4gIC5cIi5jb25jYXQobm9TY3JvbGxiYXJzQ2xhc3NOYW1lLCBcIiB7XFxuICAgb3ZlcmZsb3c6IGhpZGRlbiBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICAgcGFkZGluZy1yaWdodDogXCIpLmNvbmNhdChnYXAsIFwicHggXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgYm9keVtcIikuY29uY2F0KGxvY2tBdHRyaWJ1dGUsIFwiXSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW4gXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgICBvdmVyc2Nyb2xsLWJlaGF2aW9yOiBjb250YWluO1xcbiAgICBcIikuY29uY2F0KFtcbiAgICAgICAgYWxsb3dSZWxhdGl2ZSAmJiBcInBvc2l0aW9uOiByZWxhdGl2ZSBcIi5jb25jYXQoaW1wb3J0YW50LCBcIjtcIiksXG4gICAgICAgIGdhcE1vZGUgPT09ICdtYXJnaW4nICYmXG4gICAgICAgICAgICBcIlxcbiAgICBwYWRkaW5nLWxlZnQ6IFwiLmNvbmNhdChsZWZ0LCBcInB4O1xcbiAgICBwYWRkaW5nLXRvcDogXCIpLmNvbmNhdCh0b3AsIFwicHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IFwiKS5jb25jYXQocmlnaHQsIFwicHg7XFxuICAgIG1hcmdpbi1sZWZ0OjA7XFxuICAgIG1hcmdpbi10b3A6MDtcXG4gICAgbWFyZ2luLXJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICAgIFwiKSxcbiAgICAgICAgZ2FwTW9kZSA9PT0gJ3BhZGRpbmcnICYmIFwicGFkZGluZy1yaWdodDogXCIuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XCIpLFxuICAgIF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbignJyksIFwiXFxuICB9XFxuICBcXG4gIC5cIikuY29uY2F0KHplcm9SaWdodENsYXNzTmFtZSwgXCIge1xcbiAgICByaWdodDogXCIpLmNvbmNhdChnYXAsIFwicHggXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgXFxuICAuXCIpLmNvbmNhdChmdWxsV2lkdGhDbGFzc05hbWUsIFwiIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICB9XFxuICBcXG4gIC5cIikuY29uY2F0KHplcm9SaWdodENsYXNzTmFtZSwgXCIgLlwiKS5jb25jYXQoemVyb1JpZ2h0Q2xhc3NOYW1lLCBcIiB7XFxuICAgIHJpZ2h0OiAwIFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gIH1cXG4gIFxcbiAgLlwiKS5jb25jYXQoZnVsbFdpZHRoQ2xhc3NOYW1lLCBcIiAuXCIpLmNvbmNhdChmdWxsV2lkdGhDbGFzc05hbWUsIFwiIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwIFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gIH1cXG4gIFxcbiAgYm9keVtcIikuY29uY2F0KGxvY2tBdHRyaWJ1dGUsIFwiXSB7XFxuICAgIFwiKS5jb25jYXQocmVtb3ZlZEJhclNpemVWYXJpYWJsZSwgXCI6IFwiKS5jb25jYXQoZ2FwLCBcInB4O1xcbiAgfVxcblwiKTtcbn07XG52YXIgZ2V0Q3VycmVudFVzZUNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBwYXJzZUludChkb2N1bWVudC5ib2R5LmdldEF0dHJpYnV0ZShsb2NrQXR0cmlidXRlKSB8fCAnMCcsIDEwKTtcbiAgICByZXR1cm4gaXNGaW5pdGUoY291bnRlcikgPyBjb3VudGVyIDogMDtcbn07XG5leHBvcnQgdmFyIHVzZUxvY2tBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUobG9ja0F0dHJpYnV0ZSwgKGdldEN1cnJlbnRVc2VDb3VudGVyKCkgKyAxKS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdDb3VudGVyID0gZ2V0Q3VycmVudFVzZUNvdW50ZXIoKSAtIDE7XG4gICAgICAgICAgICBpZiAobmV3Q291bnRlciA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUobG9ja0F0dHJpYnV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShsb2NrQXR0cmlidXRlLCBuZXdDb3VudGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbn07XG4vKipcbiAqIFJlbW92ZXMgcGFnZSBzY3JvbGxiYXIgYW5kIGJsb2NrcyBwYWdlIHNjcm9sbCB3aGVuIG1vdW50ZWRcbiAqL1xuZXhwb3J0IHZhciBSZW1vdmVTY3JvbGxCYXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbm9SZWxhdGl2ZSA9IF9hLm5vUmVsYXRpdmUsIG5vSW1wb3J0YW50ID0gX2Eubm9JbXBvcnRhbnQsIF9iID0gX2EuZ2FwTW9kZSwgZ2FwTW9kZSA9IF9iID09PSB2b2lkIDAgPyAnbWFyZ2luJyA6IF9iO1xuICAgIHVzZUxvY2tBdHRyaWJ1dGUoKTtcbiAgICAvKlxuICAgICBnYXAgd2lsbCBiZSBtZWFzdXJlZCBvbiBldmVyeSBjb21wb25lbnQgbW91bnRcbiAgICAgaG93ZXZlciBpdCB3aWxsIGJlIHVzZWQgb25seSBieSB0aGUgXCJmaXJzdFwiIGludm9jYXRpb25cbiAgICAgZHVlIHRvIHNpbmdsZXRvbiBuYXR1cmUgb2YgPFN0eWxlXG4gICAgICovXG4gICAgdmFyIGdhcCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0R2FwV2lkdGgoZ2FwTW9kZSk7IH0sIFtnYXBNb2RlXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3R5bGUsIHsgc3R5bGVzOiBnZXRTdHlsZXMoZ2FwLCAhbm9SZWxhdGl2ZSwgZ2FwTW9kZSwgIW5vSW1wb3J0YW50ID8gJyFpbXBvcnRhbnQnIDogJycpIH0pO1xufTtcbiIsInZhciBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IHZhciBub25QYXNzaXZlID0gcGFzc2l2ZVN1cHBvcnRlZCA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IGZhbHNlO1xuIiwidmFyIGFsd2F5c0NvbnRhaW5zU2Nyb2xsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyB0ZXh0YXJlYSB3aWxsIGFsd2F5cyBfY29udGFpbl8gc2Nyb2xsIGluc2lkZSBzZWxmLiBJdCBvbmx5IGNhbiBiZSBoaWRkZW5cbiAgICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnO1xufTtcbnZhciBlbGVtZW50Q2FuQmVTY3JvbGxlZCA9IGZ1bmN0aW9uIChub2RlLCBvdmVyZmxvdykge1xuICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICByZXR1cm4gKFxuICAgIC8vIG5vdC1ub3Qtc2Nyb2xsYWJsZVxuICAgIHN0eWxlc1tvdmVyZmxvd10gIT09ICdoaWRkZW4nICYmXG4gICAgICAgIC8vIGNvbnRhaW5zIHNjcm9sbCBpbnNpZGUgc2VsZlxuICAgICAgICAhKHN0eWxlcy5vdmVyZmxvd1kgPT09IHN0eWxlcy5vdmVyZmxvd1ggJiYgIWFsd2F5c0NvbnRhaW5zU2Nyb2xsKG5vZGUpICYmIHN0eWxlc1tvdmVyZmxvd10gPT09ICd2aXNpYmxlJykpO1xufTtcbnZhciBlbGVtZW50Q291bGRCZVZTY3JvbGxlZCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBlbGVtZW50Q2FuQmVTY3JvbGxlZChub2RlLCAnb3ZlcmZsb3dZJyk7IH07XG52YXIgZWxlbWVudENvdWxkQmVIU2Nyb2xsZWQgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZWxlbWVudENhbkJlU2Nyb2xsZWQobm9kZSwgJ292ZXJmbG93WCcpOyB9O1xuZXhwb3J0IHZhciBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZCA9IGZ1bmN0aW9uIChheGlzLCBub2RlKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIGRvIHtcbiAgICAgICAgLy8gU2tpcCBvdmVyIHNoYWRvdyByb290XG4gICAgICAgIGlmICh0eXBlb2YgU2hhZG93Um9vdCAhPT0gJ3VuZGVmaW5lZCcgJiYgY3VycmVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzU2Nyb2xsYWJsZSA9IGVsZW1lbnRDb3VsZEJlU2Nyb2xsZWQoYXhpcywgY3VycmVudCk7XG4gICAgICAgIGlmIChpc1Njcm9sbGFibGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFNjcm9sbFZhcmlhYmxlcyhheGlzLCBjdXJyZW50KSwgc2Nyb2xsSGVpZ2h0ID0gX2FbMV0sIGNsaWVudEhlaWdodCA9IF9hWzJdO1xuICAgICAgICAgICAgaWYgKHNjcm9sbEhlaWdodCA+IGNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfSB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBvd25lckRvY3VtZW50LmJvZHkpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG52YXIgZ2V0VlNjcm9sbFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzY3JvbGxUb3AgPSBfYS5zY3JvbGxUb3AsIHNjcm9sbEhlaWdodCA9IF9hLnNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0ID0gX2EuY2xpZW50SGVpZ2h0O1xuICAgIHJldHVybiBbXG4gICAgICAgIHNjcm9sbFRvcCxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBjbGllbnRIZWlnaHQsXG4gICAgXTtcbn07XG52YXIgZ2V0SFNjcm9sbFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gX2Euc2Nyb2xsTGVmdCwgc2Nyb2xsV2lkdGggPSBfYS5zY3JvbGxXaWR0aCwgY2xpZW50V2lkdGggPSBfYS5jbGllbnRXaWR0aDtcbiAgICByZXR1cm4gW1xuICAgICAgICBzY3JvbGxMZWZ0LFxuICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgY2xpZW50V2lkdGgsXG4gICAgXTtcbn07XG52YXIgZWxlbWVudENvdWxkQmVTY3JvbGxlZCA9IGZ1bmN0aW9uIChheGlzLCBub2RlKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd2JyA/IGVsZW1lbnRDb3VsZEJlVlNjcm9sbGVkKG5vZGUpIDogZWxlbWVudENvdWxkQmVIU2Nyb2xsZWQobm9kZSk7XG59O1xudmFyIGdldFNjcm9sbFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChheGlzLCBub2RlKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09ICd2JyA/IGdldFZTY3JvbGxWYXJpYWJsZXMobm9kZSkgOiBnZXRIU2Nyb2xsVmFyaWFibGVzKG5vZGUpO1xufTtcbnZhciBnZXREaXJlY3Rpb25GYWN0b3IgPSBmdW5jdGlvbiAoYXhpcywgZGlyZWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQncyBkaXJlY3Rpb24gaXMgcnRsIChyaWdodC10by1sZWZ0KSwgdGhlbiBzY3JvbGxMZWZ0IGlzIDAgd2hlbiB0aGUgc2Nyb2xsYmFyIGlzIGF0IGl0cyByaWdodG1vc3QgcG9zaXRpb24sXG4gICAgICogYW5kIHRoZW4gaW5jcmVhc2luZ2x5IG5lZ2F0aXZlIGFzIHlvdSBzY3JvbGwgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2Nyb2xsTGVmdFxuICAgICAqL1xuICAgIHJldHVybiBheGlzID09PSAnaCcgJiYgZGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcbn07XG5leHBvcnQgdmFyIGhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uIChheGlzLCBlbmRUYXJnZXQsIGV2ZW50LCBzb3VyY2VEZWx0YSwgbm9PdmVyc2Nyb2xsKSB7XG4gICAgdmFyIGRpcmVjdGlvbkZhY3RvciA9IGdldERpcmVjdGlvbkZhY3RvcihheGlzLCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbmRUYXJnZXQpLmRpcmVjdGlvbik7XG4gICAgdmFyIGRlbHRhID0gZGlyZWN0aW9uRmFjdG9yICogc291cmNlRGVsdGE7XG4gICAgLy8gZmluZCBzY3JvbGxhYmxlIHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIHRhcmdldEluTG9jayA9IGVuZFRhcmdldC5jb250YWlucyh0YXJnZXQpO1xuICAgIHZhciBzaG91bGRDYW5jZWxTY3JvbGwgPSBmYWxzZTtcbiAgICB2YXIgaXNEZWx0YVBvc2l0aXZlID0gZGVsdGEgPiAwO1xuICAgIHZhciBhdmFpbGFibGVTY3JvbGwgPSAwO1xuICAgIHZhciBhdmFpbGFibGVTY3JvbGxUb3AgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0U2Nyb2xsVmFyaWFibGVzKGF4aXMsIHRhcmdldCksIHBvc2l0aW9uID0gX2FbMF0sIHNjcm9sbF8xID0gX2FbMV0sIGNhcGFjaXR5ID0gX2FbMl07XG4gICAgICAgIHZhciBlbGVtZW50U2Nyb2xsID0gc2Nyb2xsXzEgLSBjYXBhY2l0eSAtIGRpcmVjdGlvbkZhY3RvciAqIHBvc2l0aW9uO1xuICAgICAgICBpZiAocG9zaXRpb24gfHwgZWxlbWVudFNjcm9sbCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRDb3VsZEJlU2Nyb2xsZWQoYXhpcywgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVNjcm9sbCArPSBlbGVtZW50U2Nyb2xsO1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVNjcm9sbFRvcCArPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKFxuICAgIC8vIHBvcnRhbGVkIGNvbnRlbnRcbiAgICAoIXRhcmdldEluTG9jayAmJiB0YXJnZXQgIT09IGRvY3VtZW50LmJvZHkpIHx8XG4gICAgICAgIC8vIHNlbGYgY29udGVudFxuICAgICAgICAodGFyZ2V0SW5Mb2NrICYmIChlbmRUYXJnZXQuY29udGFpbnModGFyZ2V0KSB8fCBlbmRUYXJnZXQgPT09IHRhcmdldCkpKTtcbiAgICAvLyBoYW5kbGUgZXBzaWxvbiBhcm91bmQgMCAobm9uIHN0YW5kYXJkIHpvb20gbGV2ZWxzKVxuICAgIGlmIChpc0RlbHRhUG9zaXRpdmUgJiZcbiAgICAgICAgKChub092ZXJzY3JvbGwgJiYgTWF0aC5hYnMoYXZhaWxhYmxlU2Nyb2xsKSA8IDEpIHx8ICghbm9PdmVyc2Nyb2xsICYmIGRlbHRhID4gYXZhaWxhYmxlU2Nyb2xsKSkpIHtcbiAgICAgICAgc2hvdWxkQ2FuY2VsU2Nyb2xsID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRGVsdGFQb3NpdGl2ZSAmJlxuICAgICAgICAoKG5vT3ZlcnNjcm9sbCAmJiBNYXRoLmFicyhhdmFpbGFibGVTY3JvbGxUb3ApIDwgMSkgfHwgKCFub092ZXJzY3JvbGwgJiYgLWRlbHRhID4gYXZhaWxhYmxlU2Nyb2xsVG9wKSkpIHtcbiAgICAgICAgc2hvdWxkQ2FuY2VsU2Nyb2xsID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZENhbmNlbFNjcm9sbDtcbn07XG4iLCJpbXBvcnQgeyBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSZW1vdmVTY3JvbGxCYXIgfSBmcm9tICdyZWFjdC1yZW1vdmUtc2Nyb2xsLWJhcic7XG5pbXBvcnQgeyBzdHlsZVNpbmdsZXRvbiB9IGZyb20gJ3JlYWN0LXN0eWxlLXNpbmdsZXRvbic7XG5pbXBvcnQgeyBub25QYXNzaXZlIH0gZnJvbSAnLi9hZ2dyZXNpdmVDYXB0dXJlJztcbmltcG9ydCB7IGhhbmRsZVNjcm9sbCwgbG9jYXRpb25Db3VsZEJlU2Nyb2xsZWQgfSBmcm9tICcuL2hhbmRsZVNjcm9sbCc7XG5leHBvcnQgdmFyIGdldFRvdWNoWFkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NoYW5nZWRUb3VjaGVzJyBpbiBldmVudCA/IFtldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXSA6IFswLCAwXTtcbn07XG5leHBvcnQgdmFyIGdldERlbHRhWFkgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIFtldmVudC5kZWx0YVgsIGV2ZW50LmRlbHRhWV07IH07XG52YXIgZXh0cmFjdFJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gcmVmICYmICdjdXJyZW50JyBpbiByZWYgPyByZWYuY3VycmVudCA6IHJlZjtcbn07XG52YXIgZGVsdGFDb21wYXJlID0gZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHhbMF0gPT09IHlbMF0gJiYgeFsxXSA9PT0geVsxXTsgfTtcbnZhciBnZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiBcIlxcbiAgLmJsb2NrLWludGVyYWN0aXZpdHktXCIuY29uY2F0KGlkLCBcIiB7cG9pbnRlci1ldmVudHM6IG5vbmU7fVxcbiAgLmFsbG93LWludGVyYWN0aXZpdHktXCIpLmNvbmNhdChpZCwgXCIge3BvaW50ZXItZXZlbnRzOiBhbGw7fVxcblwiKTsgfTtcbnZhciBpZENvdW50ZXIgPSAwO1xudmFyIGxvY2tTdGFjayA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIFJlbW92ZVNjcm9sbFNpZGVDYXIocHJvcHMpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudFF1ZXVlID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgICB2YXIgdG91Y2hTdGFydFJlZiA9IFJlYWN0LnVzZVJlZihbMCwgMF0pO1xuICAgIHZhciBhY3RpdmVBeGlzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgdmFyIGlkID0gUmVhY3QudXNlU3RhdGUoaWRDb3VudGVyKyspWzBdO1xuICAgIHZhciBTdHlsZSA9IFJlYWN0LnVzZVN0YXRlKHN0eWxlU2luZ2xldG9uKVswXTtcbiAgICB2YXIgbGFzdFByb3BzID0gUmVhY3QudXNlUmVmKHByb3BzKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBsYXN0UHJvcHMuY3VycmVudCA9IHByb3BzO1xuICAgIH0sIFtwcm9wc10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9wcy5pbmVydCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgIHZhciBhbGxvd18xID0gX19zcHJlYWRBcnJheShbcHJvcHMubG9ja1JlZi5jdXJyZW50XSwgKHByb3BzLnNoYXJkcyB8fCBbXSkubWFwKGV4dHJhY3RSZWYpLCB0cnVlKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICBhbGxvd18xLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKFwiYWxsb3ctaW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImJsb2NrLWludGVyYWN0aXZpdHktXCIuY29uY2F0KGlkKSk7XG4gICAgICAgICAgICAgICAgYWxsb3dfMS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShcImFsbG93LWludGVyYWN0aXZpdHktXCIuY29uY2F0KGlkKSk7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfSwgW3Byb3BzLmluZXJ0LCBwcm9wcy5sb2NrUmVmLmN1cnJlbnQsIHByb3BzLnNoYXJkc10pO1xuICAgIHZhciBzaG91bGRDYW5jZWxFdmVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgcGFyZW50KSB7XG4gICAgICAgIGlmICgoJ3RvdWNoZXMnIGluIGV2ZW50ICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAyKSB8fCAoZXZlbnQudHlwZSA9PT0gJ3doZWVsJyAmJiBldmVudC5jdHJsS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuICFsYXN0UHJvcHMuY3VycmVudC5hbGxvd1BpbmNoWm9vbTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG91Y2ggPSBnZXRUb3VjaFhZKGV2ZW50KTtcbiAgICAgICAgdmFyIHRvdWNoU3RhcnQgPSB0b3VjaFN0YXJ0UmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBkZWx0YVggPSAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IHRvdWNoU3RhcnRbMF0gLSB0b3VjaFswXTtcbiAgICAgICAgdmFyIGRlbHRhWSA9ICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogdG91Y2hTdGFydFsxXSAtIHRvdWNoWzFdO1xuICAgICAgICB2YXIgY3VycmVudEF4aXM7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHZhciBtb3ZlRGlyZWN0aW9uID0gTWF0aC5hYnMoZGVsdGFYKSA+IE1hdGguYWJzKGRlbHRhWSkgPyAnaCcgOiAndic7XG4gICAgICAgIC8vIGFsbG93IGhvcml6b250YWwgdG91Y2ggbW92ZSBvbiBSYW5nZSBpbnB1dHMuIFRoZXkgd2lsbCBub3QgY2F1c2UgYW55IHNjcm9sbFxuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGV2ZW50ICYmIG1vdmVEaXJlY3Rpb24gPT09ICdoJyAmJiB0YXJnZXQudHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uID0gbG9jYXRpb25Db3VsZEJlU2Nyb2xsZWQobW92ZURpcmVjdGlvbiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuQmVTY3JvbGxlZEluTWFpbkRpcmVjdGlvbikge1xuICAgICAgICAgICAgY3VycmVudEF4aXMgPSBtb3ZlRGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEF4aXMgPSBtb3ZlRGlyZWN0aW9uID09PSAndicgPyAnaCcgOiAndic7XG4gICAgICAgICAgICBjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uID0gbG9jYXRpb25Db3VsZEJlU2Nyb2xsZWQobW92ZURpcmVjdGlvbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIG90aGVyIGF4aXMgbWlnaHQgYmUgbm90IHNjcm9sbGFibGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFjdGl2ZUF4aXMuY3VycmVudCAmJiAnY2hhbmdlZFRvdWNoZXMnIGluIGV2ZW50ICYmIChkZWx0YVggfHwgZGVsdGFZKSkge1xuICAgICAgICAgICAgYWN0aXZlQXhpcy5jdXJyZW50ID0gY3VycmVudEF4aXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50QXhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbmNlbGluZ0F4aXMgPSBhY3RpdmVBeGlzLmN1cnJlbnQgfHwgY3VycmVudEF4aXM7XG4gICAgICAgIHJldHVybiBoYW5kbGVTY3JvbGwoY2FuY2VsaW5nQXhpcywgcGFyZW50LCBldmVudCwgY2FuY2VsaW5nQXhpcyA9PT0gJ2gnID8gZGVsdGFYIDogZGVsdGFZLCB0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNob3VsZFByZXZlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoX2V2ZW50KSB7XG4gICAgICAgIHZhciBldmVudCA9IF9ldmVudDtcbiAgICAgICAgaWYgKCFsb2NrU3RhY2subGVuZ3RoIHx8IGxvY2tTdGFja1tsb2NrU3RhY2subGVuZ3RoIC0gMV0gIT09IFN0eWxlKSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIGxhc3QgYWN0aXZlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbHRhID0gJ2RlbHRhWScgaW4gZXZlbnQgPyBnZXREZWx0YVhZKGV2ZW50KSA6IGdldFRvdWNoWFkoZXZlbnQpO1xuICAgICAgICB2YXIgc291cmNlRXZlbnQgPSBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubmFtZSA9PT0gZXZlbnQudHlwZSAmJiAoZS50YXJnZXQgPT09IGV2ZW50LnRhcmdldCB8fCBldmVudC50YXJnZXQgPT09IGUuc2hhZG93UGFyZW50KSAmJiBkZWx0YUNvbXBhcmUoZS5kZWx0YSwgZGVsdGEpOyB9KVswXTtcbiAgICAgICAgLy8gc2VsZiBldmVudCwgYW5kIHNob3VsZCBiZSBjYW5jZWxlZFxuICAgICAgICBpZiAoc291cmNlRXZlbnQgJiYgc291cmNlRXZlbnQuc2hvdWxkKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3V0c2lkZSBvciBzaGFyZCBldmVudFxuICAgICAgICBpZiAoIXNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgc2hhcmROb2RlcyA9IChsYXN0UHJvcHMuY3VycmVudC5zaGFyZHMgfHwgW10pXG4gICAgICAgICAgICAgICAgLm1hcChleHRyYWN0UmVmKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7IH0pO1xuICAgICAgICAgICAgdmFyIHNob3VsZFN0b3AgPSBzaGFyZE5vZGVzLmxlbmd0aCA+IDAgPyBzaG91bGRDYW5jZWxFdmVudChldmVudCwgc2hhcmROb2Rlc1swXSkgOiAhbGFzdFByb3BzLmN1cnJlbnQubm9Jc29sYXRpb247XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RvcCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHZhciBzaG91bGRDYW5jZWwgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobmFtZSwgZGVsdGEsIHRhcmdldCwgc2hvdWxkKSB7XG4gICAgICAgIHZhciBldmVudCA9IHsgbmFtZTogbmFtZSwgZGVsdGE6IGRlbHRhLCB0YXJnZXQ6IHRhcmdldCwgc2hvdWxkOiBzaG91bGQsIHNoYWRvd1BhcmVudDogZ2V0T3V0ZXJtb3N0U2hhZG93UGFyZW50KHRhcmdldCkgfTtcbiAgICAgICAgc2hvdWxkUHJldmVudFF1ZXVlLmN1cnJlbnQucHVzaChldmVudCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2hvdWxkUHJldmVudFF1ZXVlLmN1cnJlbnQgPSBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgIT09IGV2ZW50OyB9KTtcbiAgICAgICAgfSwgMSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxUb3VjaFN0YXJ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRvdWNoU3RhcnRSZWYuY3VycmVudCA9IGdldFRvdWNoWFkoZXZlbnQpO1xuICAgICAgICBhY3RpdmVBeGlzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxXaGVlbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzaG91bGRDYW5jZWwoZXZlbnQudHlwZSwgZ2V0RGVsdGFYWShldmVudCksIGV2ZW50LnRhcmdldCwgc2hvdWxkQ2FuY2VsRXZlbnQoZXZlbnQsIHByb3BzLmxvY2tSZWYuY3VycmVudCkpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2Nyb2xsVG91Y2hNb3ZlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNob3VsZENhbmNlbChldmVudC50eXBlLCBnZXRUb3VjaFhZKGV2ZW50KSwgZXZlbnQudGFyZ2V0LCBzaG91bGRDYW5jZWxFdmVudChldmVudCwgcHJvcHMubG9ja1JlZi5jdXJyZW50KSk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvY2tTdGFjay5wdXNoKFN0eWxlKTtcbiAgICAgICAgcHJvcHMuc2V0Q2FsbGJhY2tzKHtcbiAgICAgICAgICAgIG9uU2Nyb2xsQ2FwdHVyZTogc2Nyb2xsV2hlZWwsXG4gICAgICAgICAgICBvbldoZWVsQ2FwdHVyZTogc2Nyb2xsV2hlZWwsXG4gICAgICAgICAgICBvblRvdWNoTW92ZUNhcHR1cmU6IHNjcm9sbFRvdWNoTW92ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHNob3VsZFByZXZlbnQsIG5vblBhc3NpdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2Nyb2xsVG91Y2hTdGFydCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NrU3RhY2sgPSBsb2NrU3RhY2suZmlsdGVyKGZ1bmN0aW9uIChpbnN0KSB7IHJldHVybiBpbnN0ICE9PSBTdHlsZTsgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHNob3VsZFByZXZlbnQsIG5vblBhc3NpdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgc2Nyb2xsVG91Y2hTdGFydCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciByZW1vdmVTY3JvbGxCYXIgPSBwcm9wcy5yZW1vdmVTY3JvbGxCYXIsIGluZXJ0ID0gcHJvcHMuaW5lcnQ7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBpbmVydCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3R5bGUsIHsgc3R5bGVzOiBnZW5lcmF0ZVN0eWxlKGlkKSB9KSA6IG51bGwsXG4gICAgICAgIHJlbW92ZVNjcm9sbEJhciA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtb3ZlU2Nyb2xsQmFyLCB7IGdhcE1vZGU6IHByb3BzLmdhcE1vZGUgfSkgOiBudWxsKSk7XG59XG5mdW5jdGlvbiBnZXRPdXRlcm1vc3RTaGFkb3dQYXJlbnQobm9kZSkge1xuICAgIHZhciBzaGFkb3dQYXJlbnQgPSBudWxsO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgc2hhZG93UGFyZW50ID0gbm9kZS5ob3N0O1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93UGFyZW50O1xufVxuIiwiaW1wb3J0IHsgZXhwb3J0U2lkZWNhciB9IGZyb20gJ3VzZS1zaWRlY2FyJztcbmltcG9ydCB7IFJlbW92ZVNjcm9sbFNpZGVDYXIgfSBmcm9tICcuL1NpZGVFZmZlY3QnO1xuaW1wb3J0IHsgZWZmZWN0Q2FyIH0gZnJvbSAnLi9tZWRpdW0nO1xuZXhwb3J0IGRlZmF1bHQgZXhwb3J0U2lkZWNhcihlZmZlY3RDYXIsIFJlbW92ZVNjcm9sbFNpZGVDYXIpO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlbW92ZVNjcm9sbCB9IGZyb20gJy4vVUknO1xuaW1wb3J0IFNpZGVDYXIgZnJvbSAnLi9zaWRlY2FyJztcbnZhciBSZWFjdFJlbW92ZVNjcm9sbCA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlbW92ZVNjcm9sbCwgX19hc3NpZ24oe30sIHByb3BzLCB7IHJlZjogcmVmLCBzaWRlQ2FyOiBTaWRlQ2FyIH0pKSk7IH0pO1xuUmVhY3RSZW1vdmVTY3JvbGwuY2xhc3NOYW1lcyA9IFJlbW92ZVNjcm9sbC5jbGFzc05hbWVzO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3RSZW1vdmVTY3JvbGw7XG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3Qvc2VsZWN0L3NyYy9zZWxlY3QudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSBcIkByYWRpeC11aS9udW1iZXJcIjtcbmltcG9ydCB7IGNvbXBvc2VFdmVudEhhbmRsZXJzIH0gZnJvbSBcIkByYWRpeC11aS9wcmltaXRpdmVcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbGxlY3Rpb24gfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbGxlY3Rpb25cIjtcbmltcG9ydCB7IHVzZUNvbXBvc2VkUmVmcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzXCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0U2NvcGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7IHVzZURpcmVjdGlvbiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtZGlyZWN0aW9uXCI7XG5pbXBvcnQgeyBEaXNtaXNzYWJsZUxheWVyIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1kaXNtaXNzYWJsZS1sYXllclwiO1xuaW1wb3J0IHsgdXNlRm9jdXNHdWFyZHMgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWZvY3VzLWd1YXJkc1wiO1xuaW1wb3J0IHsgRm9jdXNTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtZm9jdXMtc2NvcGVcIjtcbmltcG9ydCB7IHVzZUlkIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1pZFwiO1xuaW1wb3J0ICogYXMgUG9wcGVyUHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcG9wcGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVQb3BwZXJTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcG9wcGVyXCI7XG5pbXBvcnQgeyBQb3J0YWwgYXMgUG9ydGFsUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wb3J0YWxcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuaW1wb3J0IHsgdXNlQ29udHJvbGxhYmxlU3RhdGUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1jb250cm9sbGFibGUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZVByZXZpb3VzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtcHJldmlvdXNcIjtcbmltcG9ydCB7IFZpc3VhbGx5SGlkZGVuIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC12aXN1YWxseS1oaWRkZW5cIjtcbmltcG9ydCB7IGhpZGVPdGhlcnMgfSBmcm9tIFwiYXJpYS1oaWRkZW5cIjtcbmltcG9ydCB7IFJlbW92ZVNjcm9sbCB9IGZyb20gXCJyZWFjdC1yZW1vdmUtc2Nyb2xsXCI7XG5pbXBvcnQgeyBGcmFnbWVudCwganN4LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgT1BFTl9LRVlTID0gW1wiIFwiLCBcIkVudGVyXCIsIFwiQXJyb3dVcFwiLCBcIkFycm93RG93blwiXTtcbnZhciBTRUxFQ1RJT05fS0VZUyA9IFtcIiBcIiwgXCJFbnRlclwiXTtcbnZhciBTRUxFQ1RfTkFNRSA9IFwiU2VsZWN0XCI7XG52YXIgW0NvbGxlY3Rpb24sIHVzZUNvbGxlY3Rpb24sIGNyZWF0ZUNvbGxlY3Rpb25TY29wZV0gPSBjcmVhdGVDb2xsZWN0aW9uKFNFTEVDVF9OQU1FKTtcbnZhciBbY3JlYXRlU2VsZWN0Q29udGV4dCwgY3JlYXRlU2VsZWN0U2NvcGVdID0gY3JlYXRlQ29udGV4dFNjb3BlKFNFTEVDVF9OQU1FLCBbXG4gIGNyZWF0ZUNvbGxlY3Rpb25TY29wZSxcbiAgY3JlYXRlUG9wcGVyU2NvcGVcbl0pO1xudmFyIHVzZVBvcHBlclNjb3BlID0gY3JlYXRlUG9wcGVyU2NvcGUoKTtcbnZhciBbU2VsZWN0UHJvdmlkZXIsIHVzZVNlbGVjdENvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChTRUxFQ1RfTkFNRSk7XG52YXIgW1NlbGVjdE5hdGl2ZU9wdGlvbnNQcm92aWRlciwgdXNlU2VsZWN0TmF0aXZlT3B0aW9uc0NvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChTRUxFQ1RfTkFNRSk7XG52YXIgU2VsZWN0ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBfX3Njb3BlU2VsZWN0LFxuICAgIGNoaWxkcmVuLFxuICAgIG9wZW46IG9wZW5Qcm9wLFxuICAgIGRlZmF1bHRPcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICB2YWx1ZTogdmFsdWVQcm9wLFxuICAgIGRlZmF1bHRWYWx1ZSxcbiAgICBvblZhbHVlQ2hhbmdlLFxuICAgIGRpcixcbiAgICBuYW1lLFxuICAgIGF1dG9Db21wbGV0ZSxcbiAgICBkaXNhYmxlZCxcbiAgICByZXF1aXJlZCxcbiAgICBmb3JtXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgW3RyaWdnZXIsIHNldFRyaWdnZXJdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFt2YWx1ZU5vZGUsIHNldFZhbHVlTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3ZhbHVlTm9kZUhhc0NoaWxkcmVuLCBzZXRWYWx1ZU5vZGVIYXNDaGlsZHJlbl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IHVzZURpcmVjdGlvbihkaXIpO1xuICBjb25zdCBbb3BlbiA9IGZhbHNlLCBzZXRPcGVuXSA9IHVzZUNvbnRyb2xsYWJsZVN0YXRlKHtcbiAgICBwcm9wOiBvcGVuUHJvcCxcbiAgICBkZWZhdWx0UHJvcDogZGVmYXVsdE9wZW4sXG4gICAgb25DaGFuZ2U6IG9uT3BlbkNoYW5nZVxuICB9KTtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VDb250cm9sbGFibGVTdGF0ZSh7XG4gICAgcHJvcDogdmFsdWVQcm9wLFxuICAgIGRlZmF1bHRQcm9wOiBkZWZhdWx0VmFsdWUsXG4gICAgb25DaGFuZ2U6IG9uVmFsdWVDaGFuZ2VcbiAgfSk7XG4gIGNvbnN0IHRyaWdnZXJQb2ludGVyRG93blBvc1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNGb3JtQ29udHJvbCA9IHRyaWdnZXIgPyBmb3JtIHx8ICEhdHJpZ2dlci5jbG9zZXN0KFwiZm9ybVwiKSA6IHRydWU7XG4gIGNvbnN0IFtuYXRpdmVPcHRpb25zU2V0LCBzZXROYXRpdmVPcHRpb25zU2V0XSA9IFJlYWN0LnVzZVN0YXRlKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICBjb25zdCBuYXRpdmVTZWxlY3RLZXkgPSBBcnJheS5mcm9tKG5hdGl2ZU9wdGlvbnNTZXQpLm1hcCgob3B0aW9uKSA9PiBvcHRpb24ucHJvcHMudmFsdWUpLmpvaW4oXCI7XCIpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQb3BwZXJQcmltaXRpdmUuUm9vdCwgeyAuLi5wb3BwZXJTY29wZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIFNlbGVjdFByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHJlcXVpcmVkLFxuICAgICAgc2NvcGU6IF9fc2NvcGVTZWxlY3QsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgb25UcmlnZ2VyQ2hhbmdlOiBzZXRUcmlnZ2VyLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgb25WYWx1ZU5vZGVDaGFuZ2U6IHNldFZhbHVlTm9kZSxcbiAgICAgIHZhbHVlTm9kZUhhc0NoaWxkcmVuLFxuICAgICAgb25WYWx1ZU5vZGVIYXNDaGlsZHJlbkNoYW5nZTogc2V0VmFsdWVOb2RlSGFzQ2hpbGRyZW4sXG4gICAgICBjb250ZW50SWQ6IHVzZUlkKCksXG4gICAgICB2YWx1ZSxcbiAgICAgIG9uVmFsdWVDaGFuZ2U6IHNldFZhbHVlLFxuICAgICAgb3BlbixcbiAgICAgIG9uT3BlbkNoYW5nZTogc2V0T3BlbixcbiAgICAgIGRpcjogZGlyZWN0aW9uLFxuICAgICAgdHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb24uUHJvdmlkZXIsIHsgc2NvcGU6IF9fc2NvcGVTZWxlY3QsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIFNlbGVjdE5hdGl2ZU9wdGlvbnNQcm92aWRlcixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogcHJvcHMuX19zY29wZVNlbGVjdCxcbiAgICAgICAgICAgIG9uTmF0aXZlT3B0aW9uQWRkOiBSZWFjdC51c2VDYWxsYmFjaygob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgIHNldE5hdGl2ZU9wdGlvbnNTZXQoKHByZXYpID0+IG5ldyBTZXQocHJldikuYWRkKG9wdGlvbikpO1xuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgb25OYXRpdmVPcHRpb25SZW1vdmU6IFJlYWN0LnVzZUNhbGxiYWNrKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgc2V0TmF0aXZlT3B0aW9uc1NldCgocHJldikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNTZXQgPSBuZXcgU2V0KHByZXYpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnNTZXQuZGVsZXRlKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnNTZXQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICB9XG4gICAgICAgICkgfSksXG4gICAgICAgIGlzRm9ybUNvbnRyb2wgPyAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICBCdWJibGVTZWxlY3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYXV0b0NvbXBsZXRlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBvbkNoYW5nZTogKGV2ZW50KSA9PiBzZXRWYWx1ZShldmVudC50YXJnZXQudmFsdWUpLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgdmFsdWUgPT09IHZvaWQgMCA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJvcHRpb25cIiwgeyB2YWx1ZTogXCJcIiB9KSA6IG51bGwsXG4gICAgICAgICAgICAgIEFycmF5LmZyb20obmF0aXZlT3B0aW9uc1NldClcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdGl2ZVNlbGVjdEtleVxuICAgICAgICApIDogbnVsbFxuICAgICAgXVxuICAgIH1cbiAgKSB9KTtcbn07XG5TZWxlY3QuZGlzcGxheU5hbWUgPSBTRUxFQ1RfTkFNRTtcbnZhciBUUklHR0VSX05BTUUgPSBcIlNlbGVjdFRyaWdnZXJcIjtcbnZhciBTZWxlY3RUcmlnZ2VyID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIGRpc2FibGVkID0gZmFsc2UsIC4uLnRyaWdnZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChUUklHR0VSX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBjb250ZXh0LmRpc2FibGVkIHx8IGRpc2FibGVkO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRleHQub25UcmlnZ2VyQ2hhbmdlKTtcbiAgICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoXCJ0b3VjaFwiKTtcbiAgICBjb25zdCBbc2VhcmNoUmVmLCBoYW5kbGVUeXBlYWhlYWRTZWFyY2gsIHJlc2V0VHlwZWFoZWFkXSA9IHVzZVR5cGVhaGVhZFNlYXJjaCgoc2VhcmNoKSA9PiB7XG4gICAgICBjb25zdCBlbmFibGVkSXRlbXMgPSBnZXRJdGVtcygpLmZpbHRlcigoaXRlbSkgPT4gIWl0ZW0uZGlzYWJsZWQpO1xuICAgICAgY29uc3QgY3VycmVudEl0ZW0gPSBlbmFibGVkSXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS52YWx1ZSA9PT0gY29udGV4dC52YWx1ZSk7XG4gICAgICBjb25zdCBuZXh0SXRlbSA9IGZpbmROZXh0SXRlbShlbmFibGVkSXRlbXMsIHNlYXJjaCwgY3VycmVudEl0ZW0pO1xuICAgICAgaWYgKG5leHRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dC5vblZhbHVlQ2hhbmdlKG5leHRJdGVtLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVPcGVuID0gKHBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgaWYgKCFpc0Rpc2FibGVkKSB7XG4gICAgICAgIGNvbnRleHQub25PcGVuQ2hhbmdlKHRydWUpO1xuICAgICAgICByZXNldFR5cGVhaGVhZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50ZXJFdmVudCkge1xuICAgICAgICBjb250ZXh0LnRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIHg6IE1hdGgucm91bmQocG9pbnRlckV2ZW50LnBhZ2VYKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHBvaW50ZXJFdmVudC5wYWdlWSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFBvcHBlclByaW1pdGl2ZS5BbmNob3IsIHsgYXNDaGlsZDogdHJ1ZSwgLi4ucG9wcGVyU2NvcGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgUHJpbWl0aXZlLmJ1dHRvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgcm9sZTogXCJjb21ib2JveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogY29udGV4dC5jb250ZW50SWQsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBjb250ZXh0Lm9wZW4sXG4gICAgICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBjb250ZXh0LnJlcXVpcmVkLFxuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibm9uZVwiLFxuICAgICAgICBkaXI6IGNvbnRleHQuZGlyLFxuICAgICAgICBcImRhdGEtc3RhdGVcIjogY29udGV4dC5vcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwiLFxuICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgXCJkYXRhLWRpc2FibGVkXCI6IGlzRGlzYWJsZWQgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICBcImRhdGEtcGxhY2Vob2xkZXJcIjogc2hvdWxkU2hvd1BsYWNlaG9sZGVyKGNvbnRleHQudmFsdWUpID8gXCJcIiA6IHZvaWQgMCxcbiAgICAgICAgLi4udHJpZ2dlclByb3BzLFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgb25DbGljazogY29tcG9zZUV2ZW50SGFuZGxlcnModHJpZ2dlclByb3BzLm9uQ2xpY2ssIChldmVudCkgPT4ge1xuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCAhPT0gXCJtb3VzZVwiKSB7XG4gICAgICAgICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvblBvaW50ZXJEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyh0cmlnZ2VyUHJvcHMub25Qb2ludGVyRG93biwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICBpZiAodGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiBldmVudC5jdHJsS2V5ID09PSBmYWxzZSAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgb25LZXlEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyh0cmlnZ2VyUHJvcHMub25LZXlEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBpc1R5cGluZ0FoZWFkID0gc2VhcmNoUmVmLmN1cnJlbnQgIT09IFwiXCI7XG4gICAgICAgICAgY29uc3QgaXNNb2RpZmllcktleSA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG4gICAgICAgICAgaWYgKCFpc01vZGlmaWVyS2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT09IDEpIGhhbmRsZVR5cGVhaGVhZFNlYXJjaChldmVudC5rZXkpO1xuICAgICAgICAgIGlmIChpc1R5cGluZ0FoZWFkICYmIGV2ZW50LmtleSA9PT0gXCIgXCIpIHJldHVybjtcbiAgICAgICAgICBpZiAoT1BFTl9LRVlTLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIGhhbmRsZU9wZW4oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICkgfSk7XG4gIH1cbik7XG5TZWxlY3RUcmlnZ2VyLmRpc3BsYXlOYW1lID0gVFJJR0dFUl9OQU1FO1xudmFyIFZBTFVFX05BTUUgPSBcIlNlbGVjdFZhbHVlXCI7XG52YXIgU2VsZWN0VmFsdWUgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgY2xhc3NOYW1lLCBzdHlsZSwgY2hpbGRyZW4sIHBsYWNlaG9sZGVyID0gXCJcIiwgLi4udmFsdWVQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoVkFMVUVfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgeyBvblZhbHVlTm9kZUhhc0NoaWxkcmVuQ2hhbmdlIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gY2hpbGRyZW4gIT09IHZvaWQgMDtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCBjb250ZXh0Lm9uVmFsdWVOb2RlQ2hhbmdlKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgb25WYWx1ZU5vZGVIYXNDaGlsZHJlbkNoYW5nZShoYXNDaGlsZHJlbik7XG4gICAgfSwgW29uVmFsdWVOb2RlSGFzQ2hpbGRyZW5DaGFuZ2UsIGhhc0NoaWxkcmVuXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuc3BhbixcbiAgICAgIHtcbiAgICAgICAgLi4udmFsdWVQcm9wcyxcbiAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgIHN0eWxlOiB7IHBvaW50ZXJFdmVudHM6IFwibm9uZVwiIH0sXG4gICAgICAgIGNoaWxkcmVuOiBzaG91bGRTaG93UGxhY2Vob2xkZXIoY29udGV4dC52YWx1ZSkgPyAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBwbGFjZWhvbGRlciB9KSA6IGNoaWxkcmVuXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblNlbGVjdFZhbHVlLmRpc3BsYXlOYW1lID0gVkFMVUVfTkFNRTtcbnZhciBJQ09OX05BTUUgPSBcIlNlbGVjdEljb25cIjtcbnZhciBTZWxlY3RJY29uID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIGNoaWxkcmVuLCAuLi5pY29uUHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5zcGFuLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgLi4uaWNvblByb3BzLCByZWY6IGZvcndhcmRlZFJlZiwgY2hpbGRyZW46IGNoaWxkcmVuIHx8IFwiXFx1MjVCQ1wiIH0pO1xuICB9XG4pO1xuU2VsZWN0SWNvbi5kaXNwbGF5TmFtZSA9IElDT05fTkFNRTtcbnZhciBQT1JUQUxfTkFNRSA9IFwiU2VsZWN0UG9ydGFsXCI7XG52YXIgU2VsZWN0UG9ydGFsID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhbFByaW1pdGl2ZSwgeyBhc0NoaWxkOiB0cnVlLCAuLi5wcm9wcyB9KTtcbn07XG5TZWxlY3RQb3J0YWwuZGlzcGxheU5hbWUgPSBQT1JUQUxfTkFNRTtcbnZhciBDT05URU5UX05BTUUgPSBcIlNlbGVjdENvbnRlbnRcIjtcbnZhciBTZWxlY3RDb250ZW50ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChDT05URU5UX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IFtmcmFnbWVudCwgc2V0RnJhZ21lbnRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgc2V0RnJhZ21lbnQobmV3IERvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgfSwgW10pO1xuICAgIGlmICghY29udGV4dC5vcGVuKSB7XG4gICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnQ7XG4gICAgICByZXR1cm4gZnJhZyA/IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RDb250ZW50UHJvdmlkZXIsIHsgc2NvcGU6IHByb3BzLl9fc2NvcGVTZWxlY3QsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb24uU2xvdCwgeyBzY29wZTogcHJvcHMuX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW4gfSkgfSkgfSksXG4gICAgICAgIGZyYWdcbiAgICAgICkgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RDb250ZW50SW1wbCwgeyAuLi5wcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSk7XG4gIH1cbik7XG5TZWxlY3RDb250ZW50LmRpc3BsYXlOYW1lID0gQ09OVEVOVF9OQU1FO1xudmFyIENPTlRFTlRfTUFSR0lOID0gMTA7XG52YXIgW1NlbGVjdENvbnRlbnRQcm92aWRlciwgdXNlU2VsZWN0Q29udGVudENvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChDT05URU5UX05BTUUpO1xudmFyIENPTlRFTlRfSU1QTF9OQU1FID0gXCJTZWxlY3RDb250ZW50SW1wbFwiO1xudmFyIFNlbGVjdENvbnRlbnRJbXBsID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBfX3Njb3BlU2VsZWN0LFxuICAgICAgcG9zaXRpb24gPSBcIml0ZW0tYWxpZ25lZFwiLFxuICAgICAgb25DbG9zZUF1dG9Gb2N1cyxcbiAgICAgIG9uRXNjYXBlS2V5RG93bixcbiAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlLFxuICAgICAgLy9cbiAgICAgIC8vIFBvcHBlckNvbnRlbnQgcHJvcHNcbiAgICAgIHNpZGUsXG4gICAgICBzaWRlT2Zmc2V0LFxuICAgICAgYWxpZ24sXG4gICAgICBhbGlnbk9mZnNldCxcbiAgICAgIGFycm93UGFkZGluZyxcbiAgICAgIGNvbGxpc2lvbkJvdW5kYXJ5LFxuICAgICAgY29sbGlzaW9uUGFkZGluZyxcbiAgICAgIHN0aWNreSxcbiAgICAgIGhpZGVXaGVuRGV0YWNoZWQsXG4gICAgICBhdm9pZENvbGxpc2lvbnMsXG4gICAgICAvL1xuICAgICAgLi4uY29udGVudFByb3BzXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgW2NvbnRlbnQsIHNldENvbnRlbnRdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3ZpZXdwb3J0LCBzZXRWaWV3cG9ydF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCAobm9kZSkgPT4gc2V0Q29udGVudChub2RlKSk7XG4gICAgY29uc3QgW3NlbGVjdGVkSXRlbSwgc2V0U2VsZWN0ZWRJdGVtXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtzZWxlY3RlZEl0ZW1UZXh0LCBzZXRTZWxlY3RlZEl0ZW1UZXh0XSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSB1c2VDb2xsZWN0aW9uKF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IFtpc1Bvc2l0aW9uZWQsIHNldElzUG9zaXRpb25lZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZW50KSByZXR1cm4gaGlkZU90aGVycyhjb250ZW50KTtcbiAgICB9LCBbY29udGVudF0pO1xuICAgIHVzZUZvY3VzR3VhcmRzKCk7XG4gICAgY29uc3QgZm9jdXNGaXJzdCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKGNhbmRpZGF0ZXMpID0+IHtcbiAgICAgICAgY29uc3QgW2ZpcnN0SXRlbSwgLi4ucmVzdEl0ZW1zXSA9IGdldEl0ZW1zKCkubWFwKChpdGVtKSA9PiBpdGVtLnJlZi5jdXJyZW50KTtcbiAgICAgICAgY29uc3QgW2xhc3RJdGVtXSA9IHJlc3RJdGVtcy5zbGljZSgtMSk7XG4gICAgICAgIGNvbnN0IFBSRVZJT1VTTFlfRk9DVVNFRF9FTEVNRU5UID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT09IFBSRVZJT1VTTFlfRk9DVVNFRF9FTEVNRU5UKSByZXR1cm47XG4gICAgICAgICAgY2FuZGlkYXRlPy5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcIm5lYXJlc3RcIiB9KTtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBmaXJzdEl0ZW0gJiYgdmlld3BvcnQpIHZpZXdwb3J0LnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gbGFzdEl0ZW0gJiYgdmlld3BvcnQpIHZpZXdwb3J0LnNjcm9sbFRvcCA9IHZpZXdwb3J0LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICBjYW5kaWRhdGU/LmZvY3VzKCk7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IFBSRVZJT1VTTFlfRk9DVVNFRF9FTEVNRU5UKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbZ2V0SXRlbXMsIHZpZXdwb3J0XVxuICAgICk7XG4gICAgY29uc3QgZm9jdXNTZWxlY3RlZEl0ZW0gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgICgpID0+IGZvY3VzRmlyc3QoW3NlbGVjdGVkSXRlbSwgY29udGVudF0pLFxuICAgICAgW2ZvY3VzRmlyc3QsIHNlbGVjdGVkSXRlbSwgY29udGVudF1cbiAgICApO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaXNQb3NpdGlvbmVkKSB7XG4gICAgICAgIGZvY3VzU2VsZWN0ZWRJdGVtKCk7XG4gICAgICB9XG4gICAgfSwgW2lzUG9zaXRpb25lZCwgZm9jdXNTZWxlY3RlZEl0ZW1dKTtcbiAgICBjb25zdCB7IG9uT3BlbkNoYW5nZSwgdHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmIH0gPSBjb250ZXh0O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBsZXQgcG9pbnRlck1vdmVEZWx0YSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBjb25zdCBoYW5kbGVQb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgIHBvaW50ZXJNb3ZlRGVsdGEgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLmFicyhNYXRoLnJvdW5kKGV2ZW50LnBhZ2VYKSAtICh0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudD8ueCA/PyAwKSksXG4gICAgICAgICAgICB5OiBNYXRoLmFicyhNYXRoLnJvdW5kKGV2ZW50LnBhZ2VZKSAtICh0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudD8ueSA/PyAwKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVQb2ludGVyVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAocG9pbnRlck1vdmVEZWx0YS54IDw9IDEwICYmIHBvaW50ZXJNb3ZlRGVsdGEueSA8PSAxMCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFjb250ZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBoYW5kbGVQb2ludGVyVXAsIHsgY2FwdHVyZTogdHJ1ZSwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBoYW5kbGVQb2ludGVyVXAsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBbY29udGVudCwgb25PcGVuQ2hhbmdlLCB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWZdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgY2xvc2UgPSAoKSA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNsb3NlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNsb3NlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBjbG9zZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGNsb3NlKTtcbiAgICAgIH07XG4gICAgfSwgW29uT3BlbkNoYW5nZV0pO1xuICAgIGNvbnN0IFtzZWFyY2hSZWYsIGhhbmRsZVR5cGVhaGVhZFNlYXJjaF0gPSB1c2VUeXBlYWhlYWRTZWFyY2goKHNlYXJjaCkgPT4ge1xuICAgICAgY29uc3QgZW5hYmxlZEl0ZW1zID0gZ2V0SXRlbXMoKS5maWx0ZXIoKGl0ZW0pID0+ICFpdGVtLmRpc2FibGVkKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJdGVtID0gZW5hYmxlZEl0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0ucmVmLmN1cnJlbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgY29uc3QgbmV4dEl0ZW0gPSBmaW5kTmV4dEl0ZW0oZW5hYmxlZEl0ZW1zLCBzZWFyY2gsIGN1cnJlbnRJdGVtKTtcbiAgICAgIGlmIChuZXh0SXRlbSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG5leHRJdGVtLnJlZi5jdXJyZW50LmZvY3VzKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGl0ZW1SZWZDYWxsYmFjayA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKG5vZGUsIHZhbHVlLCBkaXNhYmxlZCkgPT4ge1xuICAgICAgICBjb25zdCBpc0ZpcnN0VmFsaWRJdGVtID0gIWZpcnN0VmFsaWRJdGVtRm91bmRSZWYuY3VycmVudCAmJiAhZGlzYWJsZWQ7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWRJdGVtID0gY29udGV4dC52YWx1ZSAhPT0gdm9pZCAwICYmIGNvbnRleHQudmFsdWUgPT09IHZhbHVlO1xuICAgICAgICBpZiAoaXNTZWxlY3RlZEl0ZW0gfHwgaXNGaXJzdFZhbGlkSXRlbSkge1xuICAgICAgICAgIHNldFNlbGVjdGVkSXRlbShub2RlKTtcbiAgICAgICAgICBpZiAoaXNGaXJzdFZhbGlkSXRlbSkgZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtjb250ZXh0LnZhbHVlXVxuICAgICk7XG4gICAgY29uc3QgaGFuZGxlSXRlbUxlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gY29udGVudD8uZm9jdXMoKSwgW2NvbnRlbnRdKTtcbiAgICBjb25zdCBpdGVtVGV4dFJlZkNhbGxiYWNrID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAobm9kZSwgdmFsdWUsIGRpc2FibGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RWYWxpZEl0ZW0gPSAhZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZi5jdXJyZW50ICYmICFkaXNhYmxlZDtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZEl0ZW0gPSBjb250ZXh0LnZhbHVlICE9PSB2b2lkIDAgJiYgY29udGV4dC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkSXRlbSB8fCBpc0ZpcnN0VmFsaWRJdGVtKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRJdGVtVGV4dChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtjb250ZXh0LnZhbHVlXVxuICAgICk7XG4gICAgY29uc3QgU2VsZWN0UG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gXCJwb3BwZXJcIiA/IFNlbGVjdFBvcHBlclBvc2l0aW9uIDogU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvbjtcbiAgICBjb25zdCBwb3BwZXJDb250ZW50UHJvcHMgPSBTZWxlY3RQb3NpdGlvbiA9PT0gU2VsZWN0UG9wcGVyUG9zaXRpb24gPyB7XG4gICAgICBzaWRlLFxuICAgICAgc2lkZU9mZnNldCxcbiAgICAgIGFsaWduLFxuICAgICAgYWxpZ25PZmZzZXQsXG4gICAgICBhcnJvd1BhZGRpbmcsXG4gICAgICBjb2xsaXNpb25Cb3VuZGFyeSxcbiAgICAgIGNvbGxpc2lvblBhZGRpbmcsXG4gICAgICBzdGlja3ksXG4gICAgICBoaWRlV2hlbkRldGFjaGVkLFxuICAgICAgYXZvaWRDb2xsaXNpb25zXG4gICAgfSA6IHt9O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgU2VsZWN0Q29udGVudFByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIG9uVmlld3BvcnRDaGFuZ2U6IHNldFZpZXdwb3J0LFxuICAgICAgICBpdGVtUmVmQ2FsbGJhY2ssXG4gICAgICAgIHNlbGVjdGVkSXRlbSxcbiAgICAgICAgb25JdGVtTGVhdmU6IGhhbmRsZUl0ZW1MZWF2ZSxcbiAgICAgICAgaXRlbVRleHRSZWZDYWxsYmFjayxcbiAgICAgICAgZm9jdXNTZWxlY3RlZEl0ZW0sXG4gICAgICAgIHNlbGVjdGVkSXRlbVRleHQsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBpc1Bvc2l0aW9uZWQsXG4gICAgICAgIHNlYXJjaFJlZixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUmVtb3ZlU2Nyb2xsLCB7IGFzOiBTbG90LCBhbGxvd1BpbmNoWm9vbTogdHJ1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgRm9jdXNTY29wZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhc0NoaWxkOiB0cnVlLFxuICAgICAgICAgICAgdHJhcHBlZDogY29udGV4dC5vcGVuLFxuICAgICAgICAgICAgb25Nb3VudEF1dG9Gb2N1czogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Vbm1vdW50QXV0b0ZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbkNsb3NlQXV0b0ZvY3VzLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgY29udGV4dC50cmlnZ2VyPy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICBEaXNtaXNzYWJsZUxheWVyLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXNDaGlsZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlT3V0c2lkZVBvaW50ZXJFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgb25Fc2NhcGVLZXlEb3duLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckRvd25PdXRzaWRlLFxuICAgICAgICAgICAgICAgIG9uRm9jdXNPdXRzaWRlOiAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgICAgICAgb25EaXNtaXNzOiAoKSA9PiBjb250ZXh0Lm9uT3BlbkNoYW5nZShmYWxzZSksXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgICAgICBTZWxlY3RQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJsaXN0Ym94XCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb250ZXh0LmNvbnRlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXN0YXRlXCI6IGNvbnRleHQub3BlbiA/IFwib3BlblwiIDogXCJjbG9zZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZGlyOiBjb250ZXh0LmRpcixcbiAgICAgICAgICAgICAgICAgICAgb25Db250ZXh0TWVudTogKGV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBvcHBlckNvbnRlbnRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgb25QbGFjZWQ6ICgpID0+IHNldElzUG9zaXRpb25lZCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gZmxleCBsYXlvdXQgc28gd2UgY2FuIHBsYWNlIHRoZSBzY3JvbGwgYnV0dG9ucyBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIG91dGxpbmUgYnkgZGVmYXVsdCBhcyB0aGUgY29udGVudCBNQVkgZ2V0IGZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMuc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyhjb250ZW50UHJvcHMub25LZXlEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc01vZGlmaWVyS2V5ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNb2RpZmllcktleSAmJiBldmVudC5rZXkubGVuZ3RoID09PSAxKSBoYW5kbGVUeXBlYWhlYWRTZWFyY2goZXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoW1wiQXJyb3dVcFwiLCBcIkFycm93RG93blwiLCBcIkhvbWVcIiwgXCJFbmRcIl0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBnZXRJdGVtcygpLmZpbHRlcigoaXRlbSkgPT4gIWl0ZW0uZGlzYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZU5vZGVzID0gaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLnJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbXCJBcnJvd1VwXCIsIFwiRW5kXCJdLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlTm9kZXMgPSBjYW5kaWRhdGVOb2Rlcy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChbXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCJdLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGNhbmRpZGF0ZU5vZGVzLmluZGV4T2YoY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVOb2RlcyA9IGNhbmRpZGF0ZU5vZGVzLnNsaWNlKGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBmb2N1c0ZpcnN0KGNhbmRpZGF0ZU5vZGVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICkgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuU2VsZWN0Q29udGVudEltcGwuZGlzcGxheU5hbWUgPSBDT05URU5UX0lNUExfTkFNRTtcbnZhciBJVEVNX0FMSUdORURfUE9TSVRJT05fTkFNRSA9IFwiU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvblwiO1xudmFyIFNlbGVjdEl0ZW1BbGlnbmVkUG9zaXRpb24gPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgb25QbGFjZWQsIC4uLnBvcHBlclByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoQ09OVEVOVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChDT05URU5UX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBbY29udGVudFdyYXBwZXIsIHNldENvbnRlbnRXcmFwcGVyXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgKG5vZGUpID0+IHNldENvbnRlbnQobm9kZSkpO1xuICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IHNob3VsZEV4cGFuZE9uU2Nyb2xsUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qgc2hvdWxkUmVwb3NpdGlvblJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgeyB2aWV3cG9ydCwgc2VsZWN0ZWRJdGVtLCBzZWxlY3RlZEl0ZW1UZXh0LCBmb2N1c1NlbGVjdGVkSXRlbSB9ID0gY29udGVudENvbnRleHQ7XG4gIGNvbnN0IHBvc2l0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChjb250ZXh0LnRyaWdnZXIgJiYgY29udGV4dC52YWx1ZU5vZGUgJiYgY29udGVudFdyYXBwZXIgJiYgY29udGVudCAmJiB2aWV3cG9ydCAmJiBzZWxlY3RlZEl0ZW0gJiYgc2VsZWN0ZWRJdGVtVGV4dCkge1xuICAgICAgY29uc3QgdHJpZ2dlclJlY3QgPSBjb250ZXh0LnRyaWdnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250ZW50UmVjdCA9IGNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB2YWx1ZU5vZGVSZWN0ID0gY29udGV4dC52YWx1ZU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBpdGVtVGV4dFJlY3QgPSBzZWxlY3RlZEl0ZW1UZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKGNvbnRleHQuZGlyICE9PSBcInJ0bFwiKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1UZXh0T2Zmc2V0ID0gaXRlbVRleHRSZWN0LmxlZnQgLSBjb250ZW50UmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCBsZWZ0ID0gdmFsdWVOb2RlUmVjdC5sZWZ0IC0gaXRlbVRleHRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxlZnREZWx0YSA9IHRyaWdnZXJSZWN0LmxlZnQgLSBsZWZ0O1xuICAgICAgICBjb25zdCBtaW5Db250ZW50V2lkdGggPSB0cmlnZ2VyUmVjdC53aWR0aCArIGxlZnREZWx0YTtcbiAgICAgICAgY29uc3QgY29udGVudFdpZHRoID0gTWF0aC5tYXgobWluQ29udGVudFdpZHRoLCBjb250ZW50UmVjdC53aWR0aCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0RWRnZSA9IHdpbmRvdy5pbm5lcldpZHRoIC0gQ09OVEVOVF9NQVJHSU47XG4gICAgICAgIGNvbnN0IGNsYW1wZWRMZWZ0ID0gY2xhbXAobGVmdCwgW1xuICAgICAgICAgIENPTlRFTlRfTUFSR0lOLFxuICAgICAgICAgIC8vIFByZXZlbnRzIHRoZSBjb250ZW50IGZyb20gZ29pbmcgb2ZmIHRoZSBzdGFydGluZyBlZGdlIG9mIHRoZVxuICAgICAgICAgIC8vIHZpZXdwb3J0LiBJdCBtYXkgc3RpbGwgZ28gb2ZmIHRoZSBlbmRpbmcgZWRnZSwgYnV0IHRoaXMgY2FuIGJlXG4gICAgICAgICAgLy8gY29udHJvbGxlZCBieSB0aGUgdXNlciBzaW5jZSB0aGV5IG1heSB3YW50IHRvIG1hbmFnZSBvdmVyZmxvdyBpbiBhXG4gICAgICAgICAgLy8gc3BlY2lmaWMgd2F5LlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWRpeC11aS9wcmltaXRpdmVzL2lzc3Vlcy8yMDQ5XG4gICAgICAgICAgTWF0aC5tYXgoQ09OVEVOVF9NQVJHSU4sIHJpZ2h0RWRnZSAtIGNvbnRlbnRXaWR0aClcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1pbldpZHRoID0gbWluQ29udGVudFdpZHRoICsgXCJweFwiO1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5sZWZ0ID0gY2xhbXBlZExlZnQgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtVGV4dE9mZnNldCA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gaXRlbVRleHRSZWN0LnJpZ2h0O1xuICAgICAgICBjb25zdCByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gdmFsdWVOb2RlUmVjdC5yaWdodCAtIGl0ZW1UZXh0T2Zmc2V0O1xuICAgICAgICBjb25zdCByaWdodERlbHRhID0gd2luZG93LmlubmVyV2lkdGggLSB0cmlnZ2VyUmVjdC5yaWdodCAtIHJpZ2h0O1xuICAgICAgICBjb25zdCBtaW5Db250ZW50V2lkdGggPSB0cmlnZ2VyUmVjdC53aWR0aCArIHJpZ2h0RGVsdGE7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IE1hdGgubWF4KG1pbkNvbnRlbnRXaWR0aCwgY29udGVudFJlY3Qud2lkdGgpO1xuICAgICAgICBjb25zdCBsZWZ0RWRnZSA9IHdpbmRvdy5pbm5lcldpZHRoIC0gQ09OVEVOVF9NQVJHSU47XG4gICAgICAgIGNvbnN0IGNsYW1wZWRSaWdodCA9IGNsYW1wKHJpZ2h0LCBbXG4gICAgICAgICAgQ09OVEVOVF9NQVJHSU4sXG4gICAgICAgICAgTWF0aC5tYXgoQ09OVEVOVF9NQVJHSU4sIGxlZnRFZGdlIC0gY29udGVudFdpZHRoKVxuICAgICAgICBdKTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUubWluV2lkdGggPSBtaW5Db250ZW50V2lkdGggKyBcInB4XCI7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLnJpZ2h0ID0gY2xhbXBlZFJpZ2h0ICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBnZXRJdGVtcygpO1xuICAgICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gQ09OVEVOVF9NQVJHSU4gKiAyO1xuICAgICAgY29uc3QgaXRlbXNIZWlnaHQgPSB2aWV3cG9ydC5zY3JvbGxIZWlnaHQ7XG4gICAgICBjb25zdCBjb250ZW50U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudCk7XG4gICAgICBjb25zdCBjb250ZW50Qm9yZGVyVG9wV2lkdGggPSBwYXJzZUludChjb250ZW50U3R5bGVzLmJvcmRlclRvcFdpZHRoLCAxMCk7XG4gICAgICBjb25zdCBjb250ZW50UGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbnRlbnRTdHlsZXMucGFkZGluZ1RvcCwgMTApO1xuICAgICAgY29uc3QgY29udGVudEJvcmRlckJvdHRvbVdpZHRoID0gcGFyc2VJbnQoY29udGVudFN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCwgMTApO1xuICAgICAgY29uc3QgY29udGVudFBhZGRpbmdCb3R0b20gPSBwYXJzZUludChjb250ZW50U3R5bGVzLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICAgIGNvbnN0IGZ1bGxDb250ZW50SGVpZ2h0ID0gY29udGVudEJvcmRlclRvcFdpZHRoICsgY29udGVudFBhZGRpbmdUb3AgKyBpdGVtc0hlaWdodCArIGNvbnRlbnRQYWRkaW5nQm90dG9tICsgY29udGVudEJvcmRlckJvdHRvbVdpZHRoO1xuICAgICAgY29uc3QgbWluQ29udGVudEhlaWdodCA9IE1hdGgubWluKHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQgKiA1LCBmdWxsQ29udGVudEhlaWdodCk7XG4gICAgICBjb25zdCB2aWV3cG9ydFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0UGFkZGluZ1RvcCA9IHBhcnNlSW50KHZpZXdwb3J0U3R5bGVzLnBhZGRpbmdUb3AsIDEwKTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0UGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHZpZXdwb3J0U3R5bGVzLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICAgIGNvbnN0IHRvcEVkZ2VUb1RyaWdnZXJNaWRkbGUgPSB0cmlnZ2VyUmVjdC50b3AgKyB0cmlnZ2VyUmVjdC5oZWlnaHQgLyAyIC0gQ09OVEVOVF9NQVJHSU47XG4gICAgICBjb25zdCB0cmlnZ2VyTWlkZGxlVG9Cb3R0b21FZGdlID0gYXZhaWxhYmxlSGVpZ2h0IC0gdG9wRWRnZVRvVHJpZ2dlck1pZGRsZTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkSXRlbUhhbGZIZWlnaHQgPSBzZWxlY3RlZEl0ZW0ub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGl0ZW1PZmZzZXRNaWRkbGUgPSBzZWxlY3RlZEl0ZW0ub2Zmc2V0VG9wICsgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodDtcbiAgICAgIGNvbnN0IGNvbnRlbnRUb3BUb0l0ZW1NaWRkbGUgPSBjb250ZW50Qm9yZGVyVG9wV2lkdGggKyBjb250ZW50UGFkZGluZ1RvcCArIGl0ZW1PZmZzZXRNaWRkbGU7XG4gICAgICBjb25zdCBpdGVtTWlkZGxlVG9Db250ZW50Qm90dG9tID0gZnVsbENvbnRlbnRIZWlnaHQgLSBjb250ZW50VG9wVG9JdGVtTWlkZGxlO1xuICAgICAgY29uc3Qgd2lsbEFsaWduV2l0aG91dFRvcE92ZXJmbG93ID0gY29udGVudFRvcFRvSXRlbU1pZGRsZSA8PSB0b3BFZGdlVG9UcmlnZ2VyTWlkZGxlO1xuICAgICAgaWYgKHdpbGxBbGlnbldpdGhvdXRUb3BPdmVyZmxvdykge1xuICAgICAgICBjb25zdCBpc0xhc3RJdGVtID0gaXRlbXMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZEl0ZW0gPT09IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnJlZi5jdXJyZW50O1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgICAgICBjb25zdCB2aWV3cG9ydE9mZnNldEJvdHRvbSA9IGNvbnRlbnQuY2xpZW50SGVpZ2h0IC0gdmlld3BvcnQub2Zmc2V0VG9wIC0gdmlld3BvcnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBjbGFtcGVkVHJpZ2dlck1pZGRsZVRvQm90dG9tRWRnZSA9IE1hdGgubWF4KFxuICAgICAgICAgIHRyaWdnZXJNaWRkbGVUb0JvdHRvbUVkZ2UsXG4gICAgICAgICAgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodCArIC8vIHZpZXdwb3J0IG1pZ2h0IGhhdmUgcGFkZGluZyBib3R0b20sIGluY2x1ZGUgaXQgdG8gYXZvaWQgYSBzY3JvbGxhYmxlIHZpZXdwb3J0XG4gICAgICAgICAgKGlzTGFzdEl0ZW0gPyB2aWV3cG9ydFBhZGRpbmdCb3R0b20gOiAwKSArIHZpZXdwb3J0T2Zmc2V0Qm90dG9tICsgY29udGVudEJvcmRlckJvdHRvbVdpZHRoXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNvbnRlbnRUb3BUb0l0ZW1NaWRkbGUgKyBjbGFtcGVkVHJpZ2dlck1pZGRsZVRvQm90dG9tRWRnZTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdEl0ZW0gPSBpdGVtcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSXRlbSA9PT0gaXRlbXNbMF0ucmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnN0IGNsYW1wZWRUb3BFZGdlVG9UcmlnZ2VyTWlkZGxlID0gTWF0aC5tYXgoXG4gICAgICAgICAgdG9wRWRnZVRvVHJpZ2dlck1pZGRsZSxcbiAgICAgICAgICBjb250ZW50Qm9yZGVyVG9wV2lkdGggKyB2aWV3cG9ydC5vZmZzZXRUb3AgKyAvLyB2aWV3cG9ydCBtaWdodCBoYXZlIHBhZGRpbmcgdG9wLCBpbmNsdWRlIGl0IHRvIGF2b2lkIGEgc2Nyb2xsYWJsZSB2aWV3cG9ydFxuICAgICAgICAgIChpc0ZpcnN0SXRlbSA/IHZpZXdwb3J0UGFkZGluZ1RvcCA6IDApICsgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBjbGFtcGVkVG9wRWRnZVRvVHJpZ2dlck1pZGRsZSArIGl0ZW1NaWRkbGVUb0NvbnRlbnRCb3R0b207XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgdmlld3BvcnQuc2Nyb2xsVG9wID0gY29udGVudFRvcFRvSXRlbU1pZGRsZSAtIHRvcEVkZ2VUb1RyaWdnZXJNaWRkbGUgKyB2aWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgICB9XG4gICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5tYXJnaW4gPSBgJHtDT05URU5UX01BUkdJTn1weCAwYDtcbiAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1pbkhlaWdodCA9IG1pbkNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5tYXhIZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQgKyBcInB4XCI7XG4gICAgICBvblBsYWNlZD8uKCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYuY3VycmVudCA9IHRydWUpO1xuICAgIH1cbiAgfSwgW1xuICAgIGdldEl0ZW1zLFxuICAgIGNvbnRleHQudHJpZ2dlcixcbiAgICBjb250ZXh0LnZhbHVlTm9kZSxcbiAgICBjb250ZW50V3JhcHBlcixcbiAgICBjb250ZW50LFxuICAgIHZpZXdwb3J0LFxuICAgIHNlbGVjdGVkSXRlbSxcbiAgICBzZWxlY3RlZEl0ZW1UZXh0LFxuICAgIGNvbnRleHQuZGlyLFxuICAgIG9uUGxhY2VkXG4gIF0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4gcG9zaXRpb24oKSwgW3Bvc2l0aW9uXSk7XG4gIGNvbnN0IFtjb250ZW50WkluZGV4LCBzZXRDb250ZW50WkluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnQpIHNldENvbnRlbnRaSW5kZXgod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudCkuekluZGV4KTtcbiAgfSwgW2NvbnRlbnRdKTtcbiAgY29uc3QgaGFuZGxlU2Nyb2xsQnV0dG9uQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlICYmIHNob3VsZFJlcG9zaXRpb25SZWYuY3VycmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBwb3NpdGlvbigpO1xuICAgICAgICBmb2N1c1NlbGVjdGVkSXRlbT8uKCk7XG4gICAgICAgIHNob3VsZFJlcG9zaXRpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3Bvc2l0aW9uLCBmb2N1c1NlbGVjdGVkSXRlbV1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgU2VsZWN0Vmlld3BvcnRQcm92aWRlcixcbiAgICB7XG4gICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgIGNvbnRlbnRXcmFwcGVyLFxuICAgICAgc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYsXG4gICAgICBvblNjcm9sbEJ1dHRvbkNoYW5nZTogaGFuZGxlU2Nyb2xsQnV0dG9uQ2hhbmdlLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IHNldENvbnRlbnRXcmFwcGVyLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICAgICAgekluZGV4OiBjb250ZW50WkluZGV4XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLnBvcHBlclByb3BzLFxuICAgICAgICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCB0aGUgaGVpZ2h0IG9mIHRoZSBjb250ZW50LCBpdCBpbmNsdWRlcyBib3JkZXJzLiBJZiB3ZSB3ZXJlIHRvIHNldFxuICAgICAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgd2l0aG91dCBoYXZpbmcgYGJveFNpemluZzogJ2JvcmRlci1ib3gnYCBpdCB3b3VsZCBiZSB0b28gYmlnLlxuICAgICAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhlIGNvbnRlbnQgZG9lc24ndCBnZXQgdGFsbGVyIHRoYW4gdGhlIHdyYXBwZXJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIC4uLnBvcHBlclByb3BzLnN0eWxlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gICk7XG59KTtcblNlbGVjdEl0ZW1BbGlnbmVkUG9zaXRpb24uZGlzcGxheU5hbWUgPSBJVEVNX0FMSUdORURfUE9TSVRJT05fTkFNRTtcbnZhciBQT1BQRVJfUE9TSVRJT05fTkFNRSA9IFwiU2VsZWN0UG9wcGVyUG9zaXRpb25cIjtcbnZhciBTZWxlY3RQb3BwZXJQb3NpdGlvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgYWxpZ24gPSBcInN0YXJ0XCIsXG4gICAgY29sbGlzaW9uUGFkZGluZyA9IENPTlRFTlRfTUFSR0lOLFxuICAgIC4uLnBvcHBlclByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcG9wcGVyU2NvcGUgPSB1c2VQb3BwZXJTY29wZShfX3Njb3BlU2VsZWN0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgUG9wcGVyUHJpbWl0aXZlLkNvbnRlbnQsXG4gICAge1xuICAgICAgLi4ucG9wcGVyU2NvcGUsXG4gICAgICAuLi5wb3BwZXJQcm9wcyxcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgYWxpZ24sXG4gICAgICBjb2xsaXNpb25QYWRkaW5nLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLy8gRW5zdXJlIGJvcmRlci1ib3ggZm9yIGZsb2F0aW5nLXVpIGNhbGN1bGF0aW9uc1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICAuLi5wb3BwZXJQcm9wcy5zdHlsZSxcbiAgICAgICAgLy8gcmUtbmFtZXNwYWNlIGV4cG9zZWQgY29udGVudCBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICAuLi57XG4gICAgICAgICAgXCItLXJhZGl4LXNlbGVjdC1jb250ZW50LXRyYW5zZm9ybS1vcmlnaW5cIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItdHJhbnNmb3JtLW9yaWdpbilcIixcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LWNvbnRlbnQtYXZhaWxhYmxlLXdpZHRoXCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS13aWR0aClcIixcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LWNvbnRlbnQtYXZhaWxhYmxlLWhlaWdodFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hdmFpbGFibGUtaGVpZ2h0KVwiLFxuICAgICAgICAgIFwiLS1yYWRpeC1zZWxlY3QtdHJpZ2dlci13aWR0aFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hbmNob3Itd2lkdGgpXCIsXG4gICAgICAgICAgXCItLXJhZGl4LXNlbGVjdC10cmlnZ2VyLWhlaWdodFwiOiBcInZhcigtLXJhZGl4LXBvcHBlci1hbmNob3ItaGVpZ2h0KVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59KTtcblNlbGVjdFBvcHBlclBvc2l0aW9uLmRpc3BsYXlOYW1lID0gUE9QUEVSX1BPU0lUSU9OX05BTUU7XG52YXIgW1NlbGVjdFZpZXdwb3J0UHJvdmlkZXIsIHVzZVNlbGVjdFZpZXdwb3J0Q29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSwge30pO1xudmFyIFZJRVdQT1JUX05BTUUgPSBcIlNlbGVjdFZpZXdwb3J0XCI7XG52YXIgU2VsZWN0Vmlld3BvcnQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgbm9uY2UsIC4uLnZpZXdwb3J0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoVklFV1BPUlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3Qgdmlld3BvcnRDb250ZXh0ID0gdXNlU2VsZWN0Vmlld3BvcnRDb250ZXh0KFZJRVdQT1JUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRlbnRDb250ZXh0Lm9uVmlld3BvcnRDaGFuZ2UpO1xuICAgIGNvbnN0IHByZXZTY3JvbGxUb3BSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgX19odG1sOiBgW2RhdGEtcmFkaXgtc2VsZWN0LXZpZXdwb3J0XXtzY3JvbGxiYXItd2lkdGg6bm9uZTstbXMtb3ZlcmZsb3ctc3R5bGU6bm9uZTstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDt9W2RhdGEtcmFkaXgtc2VsZWN0LXZpZXdwb3J0XTo6LXdlYmtpdC1zY3JvbGxiYXJ7ZGlzcGxheTpub25lfWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vbmNlXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KENvbGxlY3Rpb24uU2xvdCwgeyBzY29wZTogX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgIHtcbiAgICAgICAgICBcImRhdGEtcmFkaXgtc2VsZWN0LXZpZXdwb3J0XCI6IFwiXCIsXG4gICAgICAgICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICAgICAgICAuLi52aWV3cG9ydFByb3BzLFxuICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgcG9zaXRpb246ICdyZWxhdGl2ZScgaGVyZSBvbiB0aGUgYHZpZXdwb3J0YCBzbyB0aGF0IHdoZW4gd2UgY2FsbFxuICAgICAgICAgICAgLy8gYHNlbGVjdGVkSXRlbS5vZmZzZXRUb3BgIGluIGNhbGN1bGF0aW9ucywgdGhlIG9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgIC8vIChpbmRlcGVuZGVudCBvZiB0aGUgc2Nyb2xsVXBCdXR0b24pLlxuICAgICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAvLyBWaWV3cG9ydCBzaG91bGQgb25seSBiZSBzY3JvbGxhYmxlIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAvLyBUaGlzIHdvbid0IHdvcmsgaW4gdmVydGljYWwgd3JpdGluZyBtb2Rlcywgc28gd2UnbGwgbmVlZCB0b1xuICAgICAgICAgICAgLy8gcmV2aXNpdCB0aGlzIGlmL3doZW4gdGhhdCBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vYmxvZy92ZXJ0aWNhbC1mb3JtLWNvbnRyb2xzXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW4gYXV0b1wiLFxuICAgICAgICAgICAgLi4udmlld3BvcnRQcm9wcy5zdHlsZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TY3JvbGw6IGNvbXBvc2VFdmVudEhhbmRsZXJzKHZpZXdwb3J0UHJvcHMub25TY3JvbGwsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgeyBjb250ZW50V3JhcHBlciwgc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYgfSA9IHZpZXdwb3J0Q29udGV4dDtcbiAgICAgICAgICAgIGlmIChzaG91bGRFeHBhbmRPblNjcm9sbFJlZj8uY3VycmVudCAmJiBjb250ZW50V3JhcHBlcikge1xuICAgICAgICAgICAgICBjb25zdCBzY3JvbGxlZEJ5ID0gTWF0aC5hYnMocHJldlNjcm9sbFRvcFJlZi5jdXJyZW50IC0gdmlld3BvcnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgaWYgKHNjcm9sbGVkQnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gQ09OVEVOVF9NQVJHSU4gKiAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzc01pbkhlaWdodCA9IHBhcnNlRmxvYXQoY29udGVudFdyYXBwZXIuc3R5bGUubWluSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjc3NIZWlnaHQgPSBwYXJzZUZsb2F0KGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkhlaWdodCA9IE1hdGgubWF4KGNzc01pbkhlaWdodCwgY3NzSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkhlaWdodCA8IGF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEhlaWdodCA9IHByZXZIZWlnaHQgKyBzY3JvbGxlZEJ5O1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2xhbXBlZE5leHRIZWlnaHQgPSBNYXRoLm1pbihhdmFpbGFibGVIZWlnaHQsIG5leHRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0RGlmZiA9IG5leHRIZWlnaHQgLSBjbGFtcGVkTmV4dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGNsYW1wZWROZXh0SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRXcmFwcGVyLnN0eWxlLmJvdHRvbSA9PT0gXCIwcHhcIikge1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5zY3JvbGxUb3AgPSBoZWlnaHREaWZmID4gMCA/IGhlaWdodERpZmYgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IHZpZXdwb3J0LnNjcm9sbFRvcDtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICApIH0pXG4gICAgXSB9KTtcbiAgfVxuKTtcblNlbGVjdFZpZXdwb3J0LmRpc3BsYXlOYW1lID0gVklFV1BPUlRfTkFNRTtcbnZhciBHUk9VUF9OQU1FID0gXCJTZWxlY3RHcm91cFwiO1xudmFyIFtTZWxlY3RHcm91cENvbnRleHRQcm92aWRlciwgdXNlU2VsZWN0R3JvdXBDb250ZXh0XSA9IGNyZWF0ZVNlbGVjdENvbnRleHQoR1JPVVBfTkFNRSk7XG52YXIgU2VsZWN0R3JvdXAgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgLi4uZ3JvdXBQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgZ3JvdXBJZCA9IHVzZUlkKCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU2VsZWN0R3JvdXBDb250ZXh0UHJvdmlkZXIsIHsgc2NvcGU6IF9fc2NvcGVTZWxlY3QsIGlkOiBncm91cElkLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IHJvbGU6IFwiZ3JvdXBcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogZ3JvdXBJZCwgLi4uZ3JvdXBQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSkgfSk7XG4gIH1cbik7XG5TZWxlY3RHcm91cC5kaXNwbGF5TmFtZSA9IEdST1VQX05BTUU7XG52YXIgTEFCRUxfTkFNRSA9IFwiU2VsZWN0TGFiZWxcIjtcbnZhciBTZWxlY3RMYWJlbCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5sYWJlbFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBncm91cENvbnRleHQgPSB1c2VTZWxlY3RHcm91cENvbnRleHQoTEFCRUxfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyBpZDogZ3JvdXBDb250ZXh0LmlkLCAuLi5sYWJlbFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KTtcbiAgfVxuKTtcblNlbGVjdExhYmVsLmRpc3BsYXlOYW1lID0gTEFCRUxfTkFNRTtcbnZhciBJVEVNX05BTUUgPSBcIlNlbGVjdEl0ZW1cIjtcbnZhciBbU2VsZWN0SXRlbUNvbnRleHRQcm92aWRlciwgdXNlU2VsZWN0SXRlbUNvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChJVEVNX05BTUUpO1xudmFyIFNlbGVjdEl0ZW0gPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICB0ZXh0VmFsdWU6IHRleHRWYWx1ZVByb3AsXG4gICAgICAuLi5pdGVtUHJvcHNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoSVRFTV9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZVNlbGVjdENvbnRlbnRDb250ZXh0KElURU1fTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgaXNTZWxlY3RlZCA9IGNvbnRleHQudmFsdWUgPT09IHZhbHVlO1xuICAgIGNvbnN0IFt0ZXh0VmFsdWUsIHNldFRleHRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSh0ZXh0VmFsdWVQcm9wID8/IFwiXCIpO1xuICAgIGNvbnN0IFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKFxuICAgICAgZm9yd2FyZGVkUmVmLFxuICAgICAgKG5vZGUpID0+IGNvbnRlbnRDb250ZXh0Lml0ZW1SZWZDYWxsYmFjaz8uKG5vZGUsIHZhbHVlLCBkaXNhYmxlZClcbiAgICApO1xuICAgIGNvbnN0IHRleHRJZCA9IHVzZUlkKCk7XG4gICAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoXCJ0b3VjaFwiKTtcbiAgICBjb25zdCBoYW5kbGVTZWxlY3QgPSAoKSA9PiB7XG4gICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgIGNvbnRleHQub25WYWx1ZUNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRleHQub25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkEgPFNlbGVjdC5JdGVtIC8+IG11c3QgaGF2ZSBhIHZhbHVlIHByb3AgdGhhdCBpcyBub3QgYW4gZW1wdHkgc3RyaW5nLiBUaGlzIGlzIGJlY2F1c2UgdGhlIFNlbGVjdCB2YWx1ZSBjYW4gYmUgc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgc2VsZWN0aW9uIGFuZCBzaG93IHRoZSBwbGFjZWhvbGRlci5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBTZWxlY3RJdGVtQ29udGV4dFByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICB0ZXh0SWQsXG4gICAgICAgIGlzU2VsZWN0ZWQsXG4gICAgICAgIG9uSXRlbVRleHRDaGFuZ2U6IFJlYWN0LnVzZUNhbGxiYWNrKChub2RlKSA9PiB7XG4gICAgICAgICAgc2V0VGV4dFZhbHVlKChwcmV2VGV4dFZhbHVlKSA9PiBwcmV2VGV4dFZhbHVlIHx8IChub2RlPy50ZXh0Q29udGVudCA/PyBcIlwiKS50cmltKCkpO1xuICAgICAgICB9LCBbXSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIENvbGxlY3Rpb24uSXRlbVNsb3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2NvcGU6IF9fc2NvcGVTZWxlY3QsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgdGV4dFZhbHVlLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb2xlOiBcIm9wdGlvblwiLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRleHRJZCxcbiAgICAgICAgICAgICAgICBcImRhdGEtaGlnaGxpZ2h0ZWRcIjogaXNGb2N1c2VkID8gXCJcIiA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogaXNTZWxlY3RlZCAmJiBpc0ZvY3VzZWQsXG4gICAgICAgICAgICAgICAgXCJkYXRhLXN0YXRlXCI6IGlzU2VsZWN0ZWQgPyBcImNoZWNrZWRcIiA6IFwidW5jaGVja2VkXCIsXG4gICAgICAgICAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IGRpc2FibGVkIHx8IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHRhYkluZGV4OiBkaXNhYmxlZCA/IHZvaWQgMCA6IC0xLFxuICAgICAgICAgICAgICAgIC4uLml0ZW1Qcm9wcyxcbiAgICAgICAgICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Gb2N1cywgKCkgPT4gc2V0SXNGb2N1c2VkKHRydWUpKSxcbiAgICAgICAgICAgICAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vbkJsdXIsICgpID0+IHNldElzRm9jdXNlZChmYWxzZSkpLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vbkNsaWNrLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCAhPT0gXCJtb3VzZVwiKSBoYW5kbGVTZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvblBvaW50ZXJVcDogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uUG9pbnRlclVwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gXCJtb3VzZVwiKSBoYW5kbGVTZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvblBvaW50ZXJEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyRG93biwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb25Qb2ludGVyTW92ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uUG9pbnRlck1vdmUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRDb250ZXh0Lm9uSXRlbUxlYXZlPy4oKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckxlYXZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyTGVhdmUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudENvbnRleHQub25JdGVtTGVhdmU/LigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uS2V5RG93biwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpc1R5cGluZ0FoZWFkID0gY29udGVudENvbnRleHQuc2VhcmNoUmVmPy5jdXJyZW50ICE9PSBcIlwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVHlwaW5nQWhlYWQgJiYgZXZlbnQua2V5ID09PSBcIiBcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgaWYgKFNFTEVDVElPTl9LRVlTLmluY2x1ZGVzKGV2ZW50LmtleSkpIGhhbmRsZVNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5TZWxlY3RJdGVtLmRpc3BsYXlOYW1lID0gSVRFTV9OQU1FO1xudmFyIElURU1fVEVYVF9OQU1FID0gXCJTZWxlY3RJdGVtVGV4dFwiO1xudmFyIFNlbGVjdEl0ZW1UZXh0ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIGNsYXNzTmFtZSwgc3R5bGUsIC4uLml0ZW1UZXh0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZVNlbGVjdENvbnRlbnRDb250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBpdGVtQ29udGV4dCA9IHVzZVNlbGVjdEl0ZW1Db250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBuYXRpdmVPcHRpb25zQ29udGV4dCA9IHVzZVNlbGVjdE5hdGl2ZU9wdGlvbnNDb250ZXh0KElURU1fVEVYVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBbaXRlbVRleHROb2RlLCBzZXRJdGVtVGV4dE5vZGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKFxuICAgICAgZm9yd2FyZGVkUmVmLFxuICAgICAgKG5vZGUpID0+IHNldEl0ZW1UZXh0Tm9kZShub2RlKSxcbiAgICAgIGl0ZW1Db250ZXh0Lm9uSXRlbVRleHRDaGFuZ2UsXG4gICAgICAobm9kZSkgPT4gY29udGVudENvbnRleHQuaXRlbVRleHRSZWZDYWxsYmFjaz8uKG5vZGUsIGl0ZW1Db250ZXh0LnZhbHVlLCBpdGVtQ29udGV4dC5kaXNhYmxlZClcbiAgICApO1xuICAgIGNvbnN0IHRleHRDb250ZW50ID0gaXRlbVRleHROb2RlPy50ZXh0Q29udGVudDtcbiAgICBjb25zdCBuYXRpdmVPcHRpb24gPSBSZWFjdC51c2VNZW1vKFxuICAgICAgKCkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcIm9wdGlvblwiLCB7IHZhbHVlOiBpdGVtQ29udGV4dC52YWx1ZSwgZGlzYWJsZWQ6IGl0ZW1Db250ZXh0LmRpc2FibGVkLCBjaGlsZHJlbjogdGV4dENvbnRlbnQgfSwgaXRlbUNvbnRleHQudmFsdWUpLFxuICAgICAgW2l0ZW1Db250ZXh0LmRpc2FibGVkLCBpdGVtQ29udGV4dC52YWx1ZSwgdGV4dENvbnRlbnRdXG4gICAgKTtcbiAgICBjb25zdCB7IG9uTmF0aXZlT3B0aW9uQWRkLCBvbk5hdGl2ZU9wdGlvblJlbW92ZSB9ID0gbmF0aXZlT3B0aW9uc0NvbnRleHQ7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTmF0aXZlT3B0aW9uQWRkKG5hdGl2ZU9wdGlvbik7XG4gICAgICByZXR1cm4gKCkgPT4gb25OYXRpdmVPcHRpb25SZW1vdmUobmF0aXZlT3B0aW9uKTtcbiAgICB9LCBbb25OYXRpdmVPcHRpb25BZGQsIG9uTmF0aXZlT3B0aW9uUmVtb3ZlLCBuYXRpdmVPcHRpb25dKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLnNwYW4sIHsgaWQ6IGl0ZW1Db250ZXh0LnRleHRJZCwgLi4uaXRlbVRleHRQcm9wcywgcmVmOiBjb21wb3NlZFJlZnMgfSksXG4gICAgICBpdGVtQ29udGV4dC5pc1NlbGVjdGVkICYmIGNvbnRleHQudmFsdWVOb2RlICYmICFjb250ZXh0LnZhbHVlTm9kZUhhc0NoaWxkcmVuID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKGl0ZW1UZXh0UHJvcHMuY2hpbGRyZW4sIGNvbnRleHQudmFsdWVOb2RlKSA6IG51bGxcbiAgICBdIH0pO1xuICB9XG4pO1xuU2VsZWN0SXRlbVRleHQuZGlzcGxheU5hbWUgPSBJVEVNX1RFWFRfTkFNRTtcbnZhciBJVEVNX0lORElDQVRPUl9OQU1FID0gXCJTZWxlY3RJdGVtSW5kaWNhdG9yXCI7XG52YXIgU2VsZWN0SXRlbUluZGljYXRvciA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5pdGVtSW5kaWNhdG9yUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGl0ZW1Db250ZXh0ID0gdXNlU2VsZWN0SXRlbUNvbnRleHQoSVRFTV9JTkRJQ0FUT1JfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgcmV0dXJuIGl0ZW1Db250ZXh0LmlzU2VsZWN0ZWQgPyAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5zcGFuLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgLi4uaXRlbUluZGljYXRvclByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KSA6IG51bGw7XG4gIH1cbik7XG5TZWxlY3RJdGVtSW5kaWNhdG9yLmRpc3BsYXlOYW1lID0gSVRFTV9JTkRJQ0FUT1JfTkFNRTtcbnZhciBTQ1JPTExfVVBfQlVUVE9OX05BTUUgPSBcIlNlbGVjdFNjcm9sbFVwQnV0dG9uXCI7XG52YXIgU2VsZWN0U2Nyb2xsVXBCdXR0b24gPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoU0NST0xMX1VQX0JVVFRPTl9OQU1FLCBwcm9wcy5fX3Njb3BlU2VsZWN0KTtcbiAgY29uc3Qgdmlld3BvcnRDb250ZXh0ID0gdXNlU2VsZWN0Vmlld3BvcnRDb250ZXh0KFNDUk9MTF9VUF9CVVRUT05fTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IFtjYW5TY3JvbGxVcCwgc2V0Q2FuU2Nyb2xsVXBdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCB2aWV3cG9ydENvbnRleHQub25TY3JvbGxCdXR0b25DaGFuZ2UpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjb250ZW50Q29udGV4dC52aWV3cG9ydCAmJiBjb250ZW50Q29udGV4dC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGxldCBoYW5kbGVTY3JvbGwyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGNhblNjcm9sbFVwMiA9IHZpZXdwb3J0LnNjcm9sbFRvcCA+IDA7XG4gICAgICAgIHNldENhblNjcm9sbFVwKGNhblNjcm9sbFVwMik7XG4gICAgICB9O1xuICAgICAgdmFyIGhhbmRsZVNjcm9sbCA9IGhhbmRsZVNjcm9sbDI7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGNvbnRlbnRDb250ZXh0LnZpZXdwb3J0O1xuICAgICAgaGFuZGxlU2Nyb2xsMigpO1xuICAgICAgdmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwyKTtcbiAgICAgIHJldHVybiAoKSA9PiB2aWV3cG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbDIpO1xuICAgIH1cbiAgfSwgW2NvbnRlbnRDb250ZXh0LnZpZXdwb3J0LCBjb250ZW50Q29udGV4dC5pc1Bvc2l0aW9uZWRdKTtcbiAgcmV0dXJuIGNhblNjcm9sbFVwID8gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTZWxlY3RTY3JvbGxCdXR0b25JbXBsLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICBvbkF1dG9TY3JvbGw6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyB2aWV3cG9ydCwgc2VsZWN0ZWRJdGVtIH0gPSBjb250ZW50Q29udGV4dDtcbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgIHZpZXdwb3J0LnNjcm9sbFRvcCA9IHZpZXdwb3J0LnNjcm9sbFRvcCAtIHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsO1xufSk7XG5TZWxlY3RTY3JvbGxVcEJ1dHRvbi5kaXNwbGF5TmFtZSA9IFNDUk9MTF9VUF9CVVRUT05fTkFNRTtcbnZhciBTQ1JPTExfRE9XTl9CVVRUT05fTkFNRSA9IFwiU2VsZWN0U2Nyb2xsRG93bkJ1dHRvblwiO1xudmFyIFNlbGVjdFNjcm9sbERvd25CdXR0b24gPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoU0NST0xMX0RPV05fQlVUVE9OX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCB2aWV3cG9ydENvbnRleHQgPSB1c2VTZWxlY3RWaWV3cG9ydENvbnRleHQoU0NST0xMX0RPV05fQlVUVE9OX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBbY2FuU2Nyb2xsRG93biwgc2V0Q2FuU2Nyb2xsRG93bl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHZpZXdwb3J0Q29udGV4dC5vblNjcm9sbEJ1dHRvbkNoYW5nZSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnRDb250ZXh0LnZpZXdwb3J0ICYmIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZCkge1xuICAgICAgbGV0IGhhbmRsZVNjcm9sbDIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdmlld3BvcnQuc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBjYW5TY3JvbGxEb3duMiA9IE1hdGguY2VpbCh2aWV3cG9ydC5zY3JvbGxUb3ApIDwgbWF4U2Nyb2xsO1xuICAgICAgICBzZXRDYW5TY3JvbGxEb3duKGNhblNjcm9sbERvd24yKTtcbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlU2Nyb2xsID0gaGFuZGxlU2Nyb2xsMjtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gY29udGVudENvbnRleHQudmlld3BvcnQ7XG4gICAgICBoYW5kbGVTY3JvbGwyKCk7XG4gICAgICB2aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbDIpO1xuICAgICAgcmV0dXJuICgpID0+IHZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsMik7XG4gICAgfVxuICB9LCBbY29udGVudENvbnRleHQudmlld3BvcnQsIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZF0pO1xuICByZXR1cm4gY2FuU2Nyb2xsRG93biA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgU2VsZWN0U2Nyb2xsQnV0dG9uSW1wbCxcbiAgICB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgb25BdXRvU2Nyb2xsOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdmlld3BvcnQsIHNlbGVjdGVkSXRlbSB9ID0gY29udGVudENvbnRleHQ7XG4gICAgICAgIGlmICh2aWV3cG9ydCAmJiBzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICB2aWV3cG9ydC5zY3JvbGxUb3AgPSB2aWV3cG9ydC5zY3JvbGxUb3AgKyBzZWxlY3RlZEl0ZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApIDogbnVsbDtcbn0pO1xuU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbi5kaXNwbGF5TmFtZSA9IFNDUk9MTF9ET1dOX0JVVFRPTl9OQU1FO1xudmFyIFNlbGVjdFNjcm9sbEJ1dHRvbkltcGwgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgb25BdXRvU2Nyb2xsLCAuLi5zY3JvbGxJbmRpY2F0b3JQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoXCJTZWxlY3RTY3JvbGxCdXR0b25cIiwgX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IGF1dG9TY3JvbGxUaW1lclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZ2V0SXRlbXMgPSB1c2VDb2xsZWN0aW9uKF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBjbGVhckF1dG9TY3JvbGxUaW1lciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50KTtcbiAgICAgIGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJBdXRvU2Nyb2xsVGltZXIoKTtcbiAgfSwgW2NsZWFyQXV0b1Njcm9sbFRpbWVyXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEl0ZW1zKCkuZmluZCgoaXRlbSkgPT4gaXRlbS5yZWYuY3VycmVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgYWN0aXZlSXRlbT8ucmVmLmN1cnJlbnQ/LnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwibmVhcmVzdFwiIH0pO1xuICB9LCBbZ2V0SXRlbXNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgUHJpbWl0aXZlLmRpdixcbiAgICB7XG4gICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICAuLi5zY3JvbGxJbmRpY2F0b3JQcm9wcyxcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgc3R5bGU6IHsgZmxleFNocmluazogMCwgLi4uc2Nyb2xsSW5kaWNhdG9yUHJvcHMuc3R5bGUgfSxcbiAgICAgIG9uUG9pbnRlckRvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKHNjcm9sbEluZGljYXRvclByb3BzLm9uUG9pbnRlckRvd24sICgpID0+IHtcbiAgICAgICAgaWYgKGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwob25BdXRvU2Nyb2xsLCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgb25Qb2ludGVyTW92ZTogY29tcG9zZUV2ZW50SGFuZGxlcnMoc2Nyb2xsSW5kaWNhdG9yUHJvcHMub25Qb2ludGVyTW92ZSwgKCkgPT4ge1xuICAgICAgICBjb250ZW50Q29udGV4dC5vbkl0ZW1MZWF2ZT8uKCk7XG4gICAgICAgIGlmIChhdXRvU2Nyb2xsVGltZXJSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID0gd2luZG93LnNldEludGVydmFsKG9uQXV0b1Njcm9sbCwgNTApO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIG9uUG9pbnRlckxlYXZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhzY3JvbGxJbmRpY2F0b3JQcm9wcy5vblBvaW50ZXJMZWF2ZSwgKCkgPT4ge1xuICAgICAgICBjbGVhckF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgfSlcbiAgICB9XG4gICk7XG59KTtcbnZhciBTRVBBUkFUT1JfTkFNRSA9IFwiU2VsZWN0U2VwYXJhdG9yXCI7XG52YXIgU2VsZWN0U2VwYXJhdG9yID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLnNlcGFyYXRvclByb3BzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgLi4uc2VwYXJhdG9yUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pO1xuICB9XG4pO1xuU2VsZWN0U2VwYXJhdG9yLmRpc3BsYXlOYW1lID0gU0VQQVJBVE9SX05BTUU7XG52YXIgQVJST1dfTkFNRSA9IFwiU2VsZWN0QXJyb3dcIjtcbnZhciBTZWxlY3RBcnJvdyA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5hcnJvd1Byb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KEFSUk9XX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoQVJST1dfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgcmV0dXJuIGNvbnRleHQub3BlbiAmJiBjb250ZW50Q29udGV4dC5wb3NpdGlvbiA9PT0gXCJwb3BwZXJcIiA/IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9wcGVyUHJpbWl0aXZlLkFycm93LCB7IC4uLnBvcHBlclNjb3BlLCAuLi5hcnJvd1Byb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KSA6IG51bGw7XG4gIH1cbik7XG5TZWxlY3RBcnJvdy5kaXNwbGF5TmFtZSA9IEFSUk9XX05BTUU7XG5mdW5jdGlvbiBzaG91bGRTaG93UGxhY2Vob2xkZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB2b2lkIDA7XG59XG52YXIgQnViYmxlU2VsZWN0ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IHZhbHVlLCAuLi5zZWxlY3RQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHJlZik7XG4gICAgY29uc3QgcHJldlZhbHVlID0gdXNlUHJldmlvdXModmFsdWUpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3QgPSByZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHNlbGVjdFByb3RvID0gd2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICBzZWxlY3RQcm90byxcbiAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICApO1xuICAgICAgY29uc3Qgc2V0VmFsdWUgPSBkZXNjcmlwdG9yLnNldDtcbiAgICAgIGlmIChwcmV2VmFsdWUgIT09IHZhbHVlICYmIHNldFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KFwiY2hhbmdlXCIsIHsgYnViYmxlczogdHJ1ZSB9KTtcbiAgICAgICAgc2V0VmFsdWUuY2FsbChzZWxlY3QsIHZhbHVlKTtcbiAgICAgICAgc2VsZWN0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIFtwcmV2VmFsdWUsIHZhbHVlXSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVmlzdWFsbHlIaWRkZW4sIHsgYXNDaGlsZDogdHJ1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzZWxlY3RcIiwgeyAuLi5zZWxlY3RQcm9wcywgcmVmOiBjb21wb3NlZFJlZnMsIGRlZmF1bHRWYWx1ZTogdmFsdWUgfSkgfSk7XG4gIH1cbik7XG5CdWJibGVTZWxlY3QuZGlzcGxheU5hbWUgPSBcIkJ1YmJsZVNlbGVjdFwiO1xuZnVuY3Rpb24gdXNlVHlwZWFoZWFkU2VhcmNoKG9uU2VhcmNoQ2hhbmdlKSB7XG4gIGNvbnN0IGhhbmRsZVNlYXJjaENoYW5nZSA9IHVzZUNhbGxiYWNrUmVmKG9uU2VhcmNoQ2hhbmdlKTtcbiAgY29uc3Qgc2VhcmNoUmVmID0gUmVhY3QudXNlUmVmKFwiXCIpO1xuICBjb25zdCB0aW1lclJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3QgaGFuZGxlVHlwZWFoZWFkU2VhcmNoID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGtleSkgPT4ge1xuICAgICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUmVmLmN1cnJlbnQgKyBrZXk7XG4gICAgICBoYW5kbGVTZWFyY2hDaGFuZ2Uoc2VhcmNoKTtcbiAgICAgIChmdW5jdGlvbiB1cGRhdGVTZWFyY2godmFsdWUpIHtcbiAgICAgICAgc2VhcmNoUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lclJlZi5jdXJyZW50KTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBcIlwiKSB0aW1lclJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdXBkYXRlU2VhcmNoKFwiXCIpLCAxZTMpO1xuICAgICAgfSkoc2VhcmNoKTtcbiAgICB9LFxuICAgIFtoYW5kbGVTZWFyY2hDaGFuZ2VdXG4gICk7XG4gIGNvbnN0IHJlc2V0VHlwZWFoZWFkID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNlYXJjaFJlZi5jdXJyZW50ID0gXCJcIjtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyUmVmLmN1cnJlbnQpO1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXJSZWYuY3VycmVudCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtzZWFyY2hSZWYsIGhhbmRsZVR5cGVhaGVhZFNlYXJjaCwgcmVzZXRUeXBlYWhlYWRdO1xufVxuZnVuY3Rpb24gZmluZE5leHRJdGVtKGl0ZW1zLCBzZWFyY2gsIGN1cnJlbnRJdGVtKSB7XG4gIGNvbnN0IGlzUmVwZWF0ZWQgPSBzZWFyY2gubGVuZ3RoID4gMSAmJiBBcnJheS5mcm9tKHNlYXJjaCkuZXZlcnkoKGNoYXIpID0+IGNoYXIgPT09IHNlYXJjaFswXSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRTZWFyY2ggPSBpc1JlcGVhdGVkID8gc2VhcmNoWzBdIDogc2VhcmNoO1xuICBjb25zdCBjdXJyZW50SXRlbUluZGV4ID0gY3VycmVudEl0ZW0gPyBpdGVtcy5pbmRleE9mKGN1cnJlbnRJdGVtKSA6IC0xO1xuICBsZXQgd3JhcHBlZEl0ZW1zID0gd3JhcEFycmF5KGl0ZW1zLCBNYXRoLm1heChjdXJyZW50SXRlbUluZGV4LCAwKSk7XG4gIGNvbnN0IGV4Y2x1ZGVDdXJyZW50SXRlbSA9IG5vcm1hbGl6ZWRTZWFyY2gubGVuZ3RoID09PSAxO1xuICBpZiAoZXhjbHVkZUN1cnJlbnRJdGVtKSB3cmFwcGVkSXRlbXMgPSB3cmFwcGVkSXRlbXMuZmlsdGVyKCh2KSA9PiB2ICE9PSBjdXJyZW50SXRlbSk7XG4gIGNvbnN0IG5leHRJdGVtID0gd3JhcHBlZEl0ZW1zLmZpbmQoXG4gICAgKGl0ZW0pID0+IGl0ZW0udGV4dFZhbHVlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChub3JtYWxpemVkU2VhcmNoLnRvTG93ZXJDYXNlKCkpXG4gICk7XG4gIHJldHVybiBuZXh0SXRlbSAhPT0gY3VycmVudEl0ZW0gPyBuZXh0SXRlbSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHdyYXBBcnJheShhcnJheSwgc3RhcnRJbmRleCkge1xuICByZXR1cm4gYXJyYXkubWFwKChfLCBpbmRleCkgPT4gYXJyYXlbKHN0YXJ0SW5kZXggKyBpbmRleCkgJSBhcnJheS5sZW5ndGhdKTtcbn1cbnZhciBSb290MiA9IFNlbGVjdDtcbnZhciBUcmlnZ2VyID0gU2VsZWN0VHJpZ2dlcjtcbnZhciBWYWx1ZSA9IFNlbGVjdFZhbHVlO1xudmFyIEljb24gPSBTZWxlY3RJY29uO1xudmFyIFBvcnRhbCA9IFNlbGVjdFBvcnRhbDtcbnZhciBDb250ZW50MiA9IFNlbGVjdENvbnRlbnQ7XG52YXIgVmlld3BvcnQgPSBTZWxlY3RWaWV3cG9ydDtcbnZhciBHcm91cCA9IFNlbGVjdEdyb3VwO1xudmFyIExhYmVsID0gU2VsZWN0TGFiZWw7XG52YXIgSXRlbSA9IFNlbGVjdEl0ZW07XG52YXIgSXRlbVRleHQgPSBTZWxlY3RJdGVtVGV4dDtcbnZhciBJdGVtSW5kaWNhdG9yID0gU2VsZWN0SXRlbUluZGljYXRvcjtcbnZhciBTY3JvbGxVcEJ1dHRvbiA9IFNlbGVjdFNjcm9sbFVwQnV0dG9uO1xudmFyIFNjcm9sbERvd25CdXR0b24gPSBTZWxlY3RTY3JvbGxEb3duQnV0dG9uO1xudmFyIFNlcGFyYXRvciA9IFNlbGVjdFNlcGFyYXRvcjtcbnZhciBBcnJvdzIgPSBTZWxlY3RBcnJvdztcbmV4cG9ydCB7XG4gIEFycm93MiBhcyBBcnJvdyxcbiAgQ29udGVudDIgYXMgQ29udGVudCxcbiAgR3JvdXAsXG4gIEljb24sXG4gIEl0ZW0sXG4gIEl0ZW1JbmRpY2F0b3IsXG4gIEl0ZW1UZXh0LFxuICBMYWJlbCxcbiAgUG9ydGFsLFxuICBSb290MiBhcyBSb290LFxuICBTY3JvbGxEb3duQnV0dG9uLFxuICBTY3JvbGxVcEJ1dHRvbixcbiAgU2VsZWN0LFxuICBTZWxlY3RBcnJvdyxcbiAgU2VsZWN0Q29udGVudCxcbiAgU2VsZWN0R3JvdXAsXG4gIFNlbGVjdEljb24sXG4gIFNlbGVjdEl0ZW0sXG4gIFNlbGVjdEl0ZW1JbmRpY2F0b3IsXG4gIFNlbGVjdEl0ZW1UZXh0LFxuICBTZWxlY3RMYWJlbCxcbiAgU2VsZWN0UG9ydGFsLFxuICBTZWxlY3RTY3JvbGxEb3duQnV0dG9uLFxuICBTZWxlY3RTY3JvbGxVcEJ1dHRvbixcbiAgU2VsZWN0U2VwYXJhdG9yLFxuICBTZWxlY3RUcmlnZ2VyLFxuICBTZWxlY3RWYWx1ZSxcbiAgU2VsZWN0Vmlld3BvcnQsXG4gIFNlcGFyYXRvcixcbiAgVHJpZ2dlcixcbiAgVmFsdWUsXG4gIFZpZXdwb3J0LFxuICBjcmVhdGVTZWxlY3RTY29wZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5jb25zdCB0b0tlYmFiQ2FzZSA9IChzdHJpbmcpID0+IHN0cmluZy5yZXBsYWNlKC8oW2EtejAtOV0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG5jb25zdCBtZXJnZUNsYXNzZXMgPSAoLi4uY2xhc3NlcykgPT4gY2xhc3Nlcy5maWx0ZXIoKGNsYXNzTmFtZSwgaW5kZXgsIGFycmF5KSA9PiB7XG4gIHJldHVybiBCb29sZWFuKGNsYXNzTmFtZSkgJiYgY2xhc3NOYW1lLnRyaW0oKSAhPT0gXCJcIiAmJiBhcnJheS5pbmRleE9mKGNsYXNzTmFtZSkgPT09IGluZGV4O1xufSkuam9pbihcIiBcIikudHJpbSgpO1xuXG5leHBvcnQgeyBtZXJnZUNsYXNzZXMsIHRvS2ViYWJDYXNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7XG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHdpZHRoOiAyNCxcbiAgaGVpZ2h0OiAyNCxcbiAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxufTtcblxuZXhwb3J0IHsgZGVmYXVsdEF0dHJpYnV0ZXMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdEF0dHJpYnV0ZXMuanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IHsgZm9yd2FyZFJlZiwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IG1lcmdlQ2xhc3NlcyB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy5qcyc7XG5cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBzaXplID0gMjQsXG4gICAgc3Ryb2tlV2lkdGggPSAyLFxuICAgIGFic29sdXRlU3Ryb2tlV2lkdGgsXG4gICAgY2xhc3NOYW1lID0gXCJcIixcbiAgICBjaGlsZHJlbixcbiAgICBpY29uTm9kZSxcbiAgICAuLi5yZXN0XG4gIH0sIHJlZikgPT4ge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgXCJzdmdcIixcbiAgICAgIHtcbiAgICAgICAgcmVmLFxuICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlcyxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGggPyBOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQgLyBOdW1iZXIoc2l6ZSkgOiBzdHJva2VXaWR0aCxcbiAgICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoXCJsdWNpZGVcIiwgY2xhc3NOYW1lKSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgLi4uaWNvbk5vZGUubWFwKChbdGFnLCBhdHRyc10pID0+IGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykpLFxuICAgICAgICAuLi5BcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogW2NoaWxkcmVuXVxuICAgICAgXVxuICAgICk7XG4gIH1cbik7XG5cbmV4cG9ydCB7IEljb24gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbi5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSB9IGZyb20gJy4vc2hhcmVkL3NyYy91dGlscy5qcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uanMnO1xuXG5jb25zdCBjcmVhdGVMdWNpZGVJY29uID0gKGljb25OYW1lLCBpY29uTm9kZSkgPT4ge1xuICBjb25zdCBDb21wb25lbnQgPSBmb3J3YXJkUmVmKFxuICAgICh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiBjcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAgIHJlZixcbiAgICAgIGljb25Ob2RlLFxuICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoYGx1Y2lkZS0ke3RvS2ViYWJDYXNlKGljb25OYW1lKX1gLCBjbGFzc05hbWUpLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICApO1xuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBgJHtpY29uTmFtZX1gO1xuICByZXR1cm4gQ29tcG9uZW50O1xufTtcblxuZXhwb3J0IHsgY3JlYXRlTHVjaWRlSWNvbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVMdWNpZGVJY29uLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDaGVjayA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDaGVja1wiLCBbW1wicGF0aFwiLCB7IGQ6IFwiTTIwIDYgOSAxN2wtNS01XCIsIGtleTogXCIxZ21mMmNcIiB9XV0pO1xuXG5leHBvcnQgeyBDaGVjayBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVjay5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgQ2hldnJvbkRvd24gPSBjcmVhdGVMdWNpZGVJY29uKFwiQ2hldnJvbkRvd25cIiwgW1xuICBbXCJwYXRoXCIsIHsgZDogXCJtNiA5IDYgNiA2LTZcIiwga2V5OiBcInFydW5zbFwiIH1dXG5dKTtcblxuZXhwb3J0IHsgQ2hldnJvbkRvd24gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hldnJvbi1kb3duLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDaGV2cm9uVXAgPSBjcmVhdGVMdWNpZGVJY29uKFwiQ2hldnJvblVwXCIsIFtbXCJwYXRoXCIsIHsgZDogXCJtMTggMTUtNi02LTYgNlwiLCBrZXk6IFwiMTUzdWR6XCIgfV1dKTtcblxuZXhwb3J0IHsgQ2hldnJvblVwIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZXZyb24tdXAuanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IENvcHkgPSBjcmVhdGVMdWNpZGVJY29uKFwiQ29weVwiLCBbXG4gIFtcInJlY3RcIiwgeyB3aWR0aDogXCIxNFwiLCBoZWlnaHQ6IFwiMTRcIiwgeDogXCI4XCIsIHk6IFwiOFwiLCByeDogXCIyXCIsIHJ5OiBcIjJcIiwga2V5OiBcIjE3anllYVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNNCAxNmMtMS4xIDAtMi0uOS0yLTJWNGMwLTEuMS45LTIgMi0yaDEwYzEuMSAwIDIgLjkgMiAyXCIsIGtleTogXCJ6aXg5dWZcIiB9XVxuXSk7XG5cbmV4cG9ydCB7IENvcHkgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29weS5qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFNlbGVjdFByaW1pdGl2ZSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNlbGVjdFwiO1xuaW1wb3J0IHsgQ2hlY2ssIENoZXZyb25Eb3duLCBDaGV2cm9uVXAgfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XG5pbXBvcnQgeyBjbiB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcblxuY29uc3QgU2VsZWN0ID0gU2VsZWN0UHJpbWl0aXZlLlJvb3Q7XG5cbmNvbnN0IFNlbGVjdEdyb3VwID0gU2VsZWN0UHJpbWl0aXZlLkdyb3VwO1xuXG5jb25zdCBTZWxlY3RWYWx1ZSA9IFNlbGVjdFByaW1pdGl2ZS5WYWx1ZTtcblxuY29uc3QgU2VsZWN0VHJpZ2dlciA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuVHJpZ2dlcj5cbj4oKHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuVHJpZ2dlclxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICBcInJpbmctb2Zmc2V0LWJhY2tncm91bmQgZm9jdXM6cmluZy1yaW5nIGZsZXggaC00IHctZnVsbCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHdoaXRlc3BhY2Utbm93cmFwIHJvdW5kZWQtbWQgYmctdHJhbnNwYXJlbnQgcHgtMyBweS0yIHRleHQteHMgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMSBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6b3BhY2l0eS01MCBbJj5zcGFuXTpsaW5lLWNsYW1wLTFcIixcbiAgICAgIFwiZGFyazpwbGFjZWhvbGRlci10ZXh0LXppbmMtNjAwIHRleHQtYmxhY2sgcGxhY2Vob2xkZXI6dGV4dC1ub2lyLTQwMCBkYXJrOnRleHQtd2hpdGVcIixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICApfVxuICAgIHsuLi5wcm9wc31cbiAgPlxuICAgIHtjaGlsZHJlbn1cbiAgICA8U2VsZWN0UHJpbWl0aXZlLkljb24gYXNDaGlsZD5cbiAgICAgIDxDaGV2cm9uRG93biBjbGFzc05hbWU9XCJtbC0xIGgtNCB3LTQgdGV4dC1ibGFjayBvcGFjaXR5LTUwIGRhcms6dGV4dC13aGl0ZVwiIC8+XG4gICAgPC9TZWxlY3RQcmltaXRpdmUuSWNvbj5cbiAgPC9TZWxlY3RQcmltaXRpdmUuVHJpZ2dlcj5cbikpO1xuU2VsZWN0VHJpZ2dlci5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RTY3JvbGxVcEJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5TY3JvbGxVcEJ1dHRvbj4sXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uPlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uXG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwiZmxleCBjdXJzb3ItZGVmYXVsdCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcHktMVwiLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICA+XG4gICAgPENoZXZyb25VcCBjbGFzc05hbWU9XCJoLTQgdy00XCIgLz5cbiAgPC9TZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24+XG4pKTtcblNlbGVjdFNjcm9sbFVwQnV0dG9uLmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RTY3JvbGxEb3duQnV0dG9uID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b24+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5TY3JvbGxEb3duQnV0dG9uPlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b25cbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgXCJmbGV4IGN1cnNvci1kZWZhdWx0IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBweS0xXCIsXG4gICAgICBjbGFzc05hbWUsXG4gICAgKX1cbiAgICB7Li4ucHJvcHN9XG4gID5cbiAgICA8Q2hldnJvbkRvd24gY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+XG4gIDwvU2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b24+XG4pKTtcblNlbGVjdFNjcm9sbERvd25CdXR0b24uZGlzcGxheU5hbWUgPVxuICBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbi5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0Q29udGVudCA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5Db250ZW50PixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuQ29udGVudD5cbj4oKHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgcG9zaXRpb24gPSBcInBvcHBlclwiLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5Qb3J0YWw+XG4gICAgPFNlbGVjdFByaW1pdGl2ZS5Db250ZW50XG4gICAgICByZWY9e3JlZn1cbiAgICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICAgIFwiZGF0YS1bc3RhdGU9b3Blbl06YW5pbWF0ZS1pbiBkYXRhLVtzdGF0ZT1jbG9zZWRdOmFuaW1hdGUtb3V0IGRhdGEtW3N0YXRlPWNsb3NlZF06ZmFkZS1vdXQtMCBkYXRhLVtzdGF0ZT1vcGVuXTpmYWRlLWluLTAgZGF0YS1bc3RhdGU9Y2xvc2VkXTp6b29tLW91dC05NSBkYXRhLVtzdGF0ZT1vcGVuXTp6b29tLWluLTk1IGRhdGEtW3NpZGU9Ym90dG9tXTpzbGlkZS1pbi1mcm9tLXRvcC0yIGRhdGEtW3NpZGU9bGVmdF06c2xpZGUtaW4tZnJvbS1yaWdodC0yIGRhdGEtW3NpZGU9cmlnaHRdOnNsaWRlLWluLWZyb20tbGVmdC0yIGRhdGEtW3NpZGU9dG9wXTpzbGlkZS1pbi1mcm9tLWJvdHRvbS0yIHJlbGF0aXZlIHotNTAgbWF4LWgtOTYgbWluLXctWzhyZW1dIG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLW1kIGJvcmRlciBzaGFkb3ctbWRcIixcbiAgICAgICAgcG9zaXRpb24gPT09IFwicG9wcGVyXCIgJiZcbiAgICAgICAgICBcImRhdGEtW3NpZGU9Ym90dG9tXTp0cmFuc2xhdGUteS0xIGRhdGEtW3NpZGU9bGVmdF06LXRyYW5zbGF0ZS14LTEgZGF0YS1bc2lkZT1yaWdodF06dHJhbnNsYXRlLXgtMSBkYXRhLVtzaWRlPXRvcF06LXRyYW5zbGF0ZS15LTFcIixcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICAgIHBvc2l0aW9uPXtwb3NpdGlvbn1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICA8U2VsZWN0U2Nyb2xsVXBCdXR0b24gLz5cbiAgICAgIDxTZWxlY3RQcmltaXRpdmUuVmlld3BvcnRcbiAgICAgICAgY2xhc3NOYW1lPXtjbihcbiAgICAgICAgICBcInAtMVwiLFxuICAgICAgICAgIHBvc2l0aW9uID09PSBcInBvcHBlclwiICYmXG4gICAgICAgICAgICBcImgtW3ZhcigtLXJhZGl4LXNlbGVjdC10cmlnZ2VyLWhlaWdodCldIHctZnVsbCBtaW4tdy1bdmFyKC0tcmFkaXgtc2VsZWN0LXRyaWdnZXItd2lkdGgpXVwiLFxuICAgICAgICApfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1NlbGVjdFByaW1pdGl2ZS5WaWV3cG9ydD5cbiAgICAgIDxTZWxlY3RTY3JvbGxEb3duQnV0dG9uIC8+XG4gICAgPC9TZWxlY3RQcmltaXRpdmUuQ29udGVudD5cbiAgPC9TZWxlY3RQcmltaXRpdmUuUG9ydGFsPlxuKSk7XG5TZWxlY3RDb250ZW50LmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLkNvbnRlbnQuZGlzcGxheU5hbWU7XG5cbmNvbnN0IFNlbGVjdExhYmVsID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLkxhYmVsPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuTGFiZWw+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuTGFiZWxcbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFwicHgtMiBweS0xLjUgdGV4dC1zbSBmb250LXNlbWlib2xkXCIsIGNsYXNzTmFtZSl9XG4gICAgey4uLnByb3BzfVxuICAvPlxuKSk7XG5TZWxlY3RMYWJlbC5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5MYWJlbC5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0SXRlbSA9IFJlYWN0LmZvcndhcmRSZWY8XG4gIFJlYWN0LkVsZW1lbnRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5JdGVtPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuSXRlbT5cbj4oKHsgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuSXRlbVxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICBcInJlbGF0aXZlIGZsZXggdy1mdWxsIGN1cnNvci1kZWZhdWx0IHNlbGVjdC1ub25lIGl0ZW1zLWNlbnRlciByb3VuZGVkLXNtIHB5LTEuNSBwbC0yIHByLTggdGV4dC1zbSBvdXRsaW5lLW5vbmUgZGF0YS1bZGlzYWJsZWRdOnBvaW50ZXItZXZlbnRzLW5vbmUgZGF0YS1bZGlzYWJsZWRdOm9wYWNpdHktNTBcIixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICApfVxuICAgIHsuLi5wcm9wc31cbiAgPlxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImFic29sdXRlIHJpZ2h0LTIgZmxleCBoLTMuNSB3LTMuNSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgIDxTZWxlY3RQcmltaXRpdmUuSXRlbUluZGljYXRvcj5cbiAgICAgICAgPENoZWNrIGNsYXNzTmFtZT1cImgtNCB3LTRcIiAvPlxuICAgICAgPC9TZWxlY3RQcmltaXRpdmUuSXRlbUluZGljYXRvcj5cbiAgICA8L3NwYW4+XG4gICAgPFNlbGVjdFByaW1pdGl2ZS5JdGVtVGV4dD57Y2hpbGRyZW59PC9TZWxlY3RQcmltaXRpdmUuSXRlbVRleHQ+XG4gIDwvU2VsZWN0UHJpbWl0aXZlLkl0ZW0+XG4pKTtcblNlbGVjdEl0ZW0uZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuSXRlbS5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0U2VwYXJhdG9yID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNlcGFyYXRvcj4sXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNlcGFyYXRvcj5cbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5TZXBhcmF0b3JcbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFwiYmctbXV0ZWQgLW14LTEgbXktMSBoLXB4XCIsIGNsYXNzTmFtZSl9XG4gICAgey4uLnByb3BzfVxuICAvPlxuKSk7XG5TZWxlY3RTZXBhcmF0b3IuZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yLmRpc3BsYXlOYW1lO1xuXG5leHBvcnQge1xuICBTZWxlY3QsXG4gIFNlbGVjdEdyb3VwLFxuICBTZWxlY3RWYWx1ZSxcbiAgU2VsZWN0VHJpZ2dlcixcbiAgU2VsZWN0Q29udGVudCxcbiAgU2VsZWN0TGFiZWwsXG4gIFNlbGVjdEl0ZW0sXG4gIFNlbGVjdFNlcGFyYXRvcixcbiAgU2VsZWN0U2Nyb2xsVXBCdXR0b24sXG4gIFNlbGVjdFNjcm9sbERvd25CdXR0b24sXG59O1xuIiwiaW1wb3J0IHsgY24gfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyBDaGVja0ljb24sIENvcHlJY29uIH0gZnJvbSBcImx1Y2lkZS1yZWFjdFwiO1xuaW1wb3J0IHsgUmVhY3ROb2RlLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgQ29weUJ1dHRvbiA9ICh7XG4gIGxhYmVsLFxuICBidXR0b25DbGFzc05hbWUsXG4gIGxvZ29DbGFzc05hbWUsXG4gIHRleHRUb0NvcHksXG4gIGRpc2FibGVkLFxufToge1xuICBsYWJlbDogUmVhY3ROb2RlO1xuICB0ZXh0VG9Db3B5OiAoKSA9PiBzdHJpbmc7XG4gIGJ1dHRvbkNsYXNzTmFtZT86IHN0cmluZztcbiAgbG9nb0NsYXNzTmFtZT86IHN0cmluZztcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xufSkgPT4ge1xuICBjb25zdCBbbG9nbywgc2V0TG9nb10gPSB1c2VTdGF0ZTxSZWFjdE5vZGU+KFxuICAgIDxDb3B5SWNvbiBjbGFzc05hbWU9e2NuKFwiaC0zIHctM1wiLCBsb2dvQ2xhc3NOYW1lKX0gLz4sXG4gICk7XG4gIGNvbnN0IFtpbnRlcm5hbExhYmVsLCBzZXRJbnRlcm5hbExhYmVsXSA9IHVzZVN0YXRlPFJlYWN0Tm9kZT4obGFiZWwpO1xuICBjb25zdCBvbkNsaXBib2FyZENvcHkgPSAoKSA9PiB7XG4gICAgc2V0TG9nbyg8Q2hlY2tJY29uIGNsYXNzTmFtZT17Y24oXCJoLTMgdy0zXCIsIGxvZ29DbGFzc05hbWUpfSAvPik7XG4gICAgc2V0SW50ZXJuYWxMYWJlbChcIkNvcGllZCFcIik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRMb2dvKDxDb3B5SWNvbiBjbGFzc05hbWU9e2NuKFwiaC0zIHctM1wiLCBsb2dvQ2xhc3NOYW1lKX0gLz4pO1xuICAgICAgc2V0SW50ZXJuYWxMYWJlbChsYWJlbCk7XG4gICAgfSwgMTAwMCk7XG4gIH07XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgYXJpYS1sYWJlbD1cIkNvcHkgdG8gY2xpcGJvYXJkXCJcbiAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICAgIFwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkIGRpc2FibGVkOnRleHQtbm9pci00MDAgZGFyazp0ZXh0LW5vaXItMTAwIGRhcms6ZGlzYWJsZWQ6dGV4dC16aW5jLTYwMFwiLFxuICAgICAgICBidXR0b25DbGFzc05hbWUsXG4gICAgICApfVxuICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dFRvQ29weSgpO1xuICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcbiAgICAgICAgb25DbGlwYm9hcmRDb3B5KCk7XG4gICAgICB9fVxuICAgID5cbiAgICAgIHtsb2dvfVxuICAgICAge2ludGVybmFsTGFiZWx9XG4gICAgPC9idXR0b24+XG4gICk7XG59O1xuIiwiaW1wb3J0IHtcbiAgYmFzZUluU2VsZWN0aW9uLFxuICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcCxcbn0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHtcbiAgQW5ub3RhdGVkQmFzZSxcbiAgQW5ub3RhdGlvbixcbiAgQXJpYWRuZVNlbGVjdGlvbixcbiAgU3RhY2tlZEFubm90YXRpb24sXG59IGZyb20gXCIuLi90eXBlc1wiO1xuXG5pbXBvcnQge1xuICBTZWxlY3QsXG4gIFNlbGVjdENvbnRlbnQsXG4gIFNlbGVjdEl0ZW0sXG4gIFNlbGVjdFZhbHVlLFxuICBTZWxlY3RUcmlnZ2VyLFxufSBmcm9tIFwiQHVpL3NlbGVjdFwiO1xuaW1wb3J0IHsgQ29weUJ1dHRvbiB9IGZyb20gXCJAdWkvY29weS1idXR0b25cIjtcblxuZXhwb3J0IGNvbnN0IFNlcXVlbmNlVmlld2VyID0gKHtcbiAgc2VxdWVuY2VzLFxuICBhbm5vdGF0aW9ucyxcbiAgc2VsZWN0aW9uLFxuICBzZXRTZWxlY3Rpb24sXG4gIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgY2hhckNsYXNzTmFtZSxcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxuICBoaWRlTWV0YWRhdGFCYXIsXG4gIG5vVmFsaWRhdGUsXG59OiB7XG4gIHNlcXVlbmNlczogc3RyaW5nW107XG4gIGFubm90YXRpb25zOiBBbm5vdGF0aW9uW107XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIGNvbnRhaW5lckNsYXNzTmFtZT86IHN0cmluZztcbiAgY2hhckNsYXNzTmFtZTogKHtcbiAgICBiYXNlLFxuICAgIHNlcXVlbmNlSWR4LFxuICB9OiB7XG4gICAgYmFzZTogQW5ub3RhdGVkQmFzZTtcbiAgICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICB9KSA9PiBzdHJpbmc7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IHN0cmluZztcbiAgaGlkZU1ldGFkYXRhQmFyPzogYm9vbGVhbjtcbiAgbm9WYWxpZGF0ZT86IGJvb2xlYW47XG59KSA9PiB7XG4gIGNvbnN0IFtob3ZlcmVkUG9zaXRpb24sIHNldEhvdmVyZWRQb3NpdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3NlcUlkeFRvQ29weSwgc2V0U2VxSWR4VG9Db3B5XSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gIGNvbnN0IFthY3RpdmVBbm5vdGF0aW9uLCBzZXRBY3RpdmVBbm5vdGF0aW9uXSA9IHVzZVN0YXRlPEFubm90YXRpb24gfCBudWxsPihcbiAgICBudWxsLFxuICApO1xuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSB1c2VNZW1vKFxuICAgIGZ1bmN0aW9uIG1lbW9pemUoKSB7XG4gICAgICByZXR1cm4gc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcChcbiAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgIE1hdGgubWF4KC4uLnNlcXVlbmNlcy5tYXAoKHNlcSkgPT4gc2VxLmxlbmd0aCkpLFxuICAgICAgKTtcbiAgICB9LFxuICAgIFthbm5vdGF0aW9uc10sXG4gICk7XG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlcyA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZXMubWFwKChzZXF1ZW5jZSkgPT5cbiAgICAgICAgZ2V0QW5ub3RhdGVkU2VxdWVuY2UoeyBzZXF1ZW5jZSwgc3RhY2tlZEFubm90YXRpb25zLCBub1ZhbGlkYXRlIH0pLFxuICAgICAgKTtcbiAgICB9LFxuICAgIFtzZXF1ZW5jZXMsIHN0YWNrZWRBbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgbWVtb2l6ZWRTZXFDb250ZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxTZXFDb250ZW50XG4gICAgICAgIGFubm90YXRlZFNlcXVlbmNlcz17YW5ub3RhdGVkU2VxdWVuY2VzfVxuICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgc2V0U2VsZWN0aW9uPXtzZXRTZWxlY3Rpb259XG4gICAgICAgIHNldEhvdmVyZWRQb3NpdGlvbj17c2V0SG92ZXJlZFBvc2l0aW9ufVxuICAgICAgICBzZXRBY3RpdmVBbm5vdGF0aW9uPXtzZXRBY3RpdmVBbm5vdGF0aW9ufVxuICAgICAgICBzdGFja2VkQW5ub3RhdGlvbnM9e3N0YWNrZWRBbm5vdGF0aW9uc31cbiAgICAgICAgY2hhckNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZX1cbiAgICAgICAgc2VsZWN0aW9uQ2xhc3NOYW1lPXtzZWxlY3Rpb25DbGFzc05hbWV9XG4gICAgICAvPlxuICAgICk7XG4gIH0sIFthbm5vdGF0ZWRTZXF1ZW5jZXMsIHNlbGVjdGlvbiwgc3RhY2tlZEFubm90YXRpb25zXSk7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwicmVsYXRpdmUgaXNvbGF0ZSBmbGV4IGZsZXgtd3JhcFwiLFxuICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgICAgKX1cbiAgICAgID5cbiAgICAgICAgICA8U2VxTWV0YWRhdGFCYXJcbiAgICAgICAgICAgIGhvdmVyZWRQb3NpdGlvbj17aG92ZXJlZFBvc2l0aW9ufVxuICAgICAgICAgICAgYWN0aXZlQW5ub3RhdGlvbj17YWN0aXZlQW5ub3RhdGlvbn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcInN0aWNreSBpbnNldC14LTAgdG9wLTAgei1bM10gdy1mdWxsIHB4LTIgcHktMSBiYWNrZHJvcC1ibHVyLW1kXCIsIGhpZGVNZXRhZGF0YUJhciA/ICdoaWRkZW4nIDogJycpfVxuICAgICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2VzPXthbm5vdGF0ZWRTZXF1ZW5jZXN9XG4gICAgICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjaGFyQ2xhc3NOYW1lfVxuICAgICAgICAgICAgc2VxSWR4VG9Db3B5PXtzZXFJZHhUb0NvcHl9XG4gICAgICAgICAgICBzZXRTZXFJZHhUb0NvcHk9e3NldFNlcUlkeFRvQ29weX1cbiAgICAgICAgICAgIHNlbGVjdGlvbj17c2VsZWN0aW9ufVxuICAgICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXdyYXAgcHgtMlwiPnttZW1vaXplZFNlcUNvbnRlbnR9PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn07XG5leHBvcnQgY29uc3QgU2VxQ29udGVudCA9ICh7XG4gIGFubm90YXRlZFNlcXVlbmNlcyxcbiAgc2VsZWN0aW9uLFxuICBzZXRTZWxlY3Rpb24sXG4gIHNldEhvdmVyZWRQb3NpdGlvbixcbiAgc2V0QWN0aXZlQW5ub3RhdGlvbixcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBjaGFyQ2xhc3NOYW1lLFxuICBzZWxlY3Rpb25DbGFzc05hbWUsXG59OiB7XG4gIGFubm90YXRlZFNlcXVlbmNlczogQW5ub3RhdGVkQmFzZVtdW107XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIHNldFNlbGVjdGlvbjogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEhvdmVyZWRQb3NpdGlvbjogKHBvc2l0aW9uOiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRBY3RpdmVBbm5vdGF0aW9uOiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbiB8IG51bGwpID0+IHZvaWQ7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogU3RhY2tlZEFubm90YXRpb25bXTtcbiAgY2hhckNsYXNzTmFtZTogKHtcbiAgICBiYXNlLFxuICAgIHNlcXVlbmNlSWR4LFxuICB9OiB7XG4gICAgYmFzZTogQW5ub3RhdGVkQmFzZTtcbiAgICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICB9KSA9PiBzdHJpbmc7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3QgbW91c2VEb3duID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaW5kaWNlc0NsYXNzTmFtZSA9ICh7XG4gICAgYmFzZSxcbiAgICBzZXF1ZW5jZUlkeCxcbiAgfToge1xuICAgIGJhc2U6IEFubm90YXRlZEJhc2U7XG4gICAgc2VxdWVuY2VJZHg6IG51bWJlcjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGlzTm90Rmlyc3RTZXEgPSBzZXF1ZW5jZUlkeCAhPT0gMDtcbiAgICBjb25zdCBpc05vdE11bHRpcGxlT2ZUZW4gPSBiYXNlLmluZGV4ICUgMTAgIT09IDA7XG5cbiAgICBpZiAoaXNOb3RGaXJzdFNlcSB8fCBpc05vdE11bHRpcGxlT2ZUZW4pIHtcbiAgICAgIHJldHVybiBcIm9wYWNpdHktMFwiO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcyhcbiAgICAgIFwidGV4dC14cyB6LTFcIixcbiAgICAgIC8vIGRvbid0IGFsbG93IHNlbGVjdGlvbiBvZiBpbmRpY2VzXG4gICAgICBcImRhcms6Z3JvdXAtaG92ZXI6dGV4dC1ub2lyLTMwMCBncm91cC1ob3Zlcjp0ZXh0LW5vaXItODAwXCIsXG4gICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICBiYXNlSW5kZXg6IGJhc2UuaW5kZXgsXG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgc2VxdWVuY2VMZW5ndGg6IGFubm90YXRlZFNlcXVlbmNlc1tzZXF1ZW5jZUlkeF0ubGVuZ3RoLFxuICAgICAgfSlcbiAgICAgICAgPyBcInRleHQtYnJhbmQtNzAwIGRhcms6dGV4dC1icmFuZC0zMDBcIlxuICAgICAgICA6IFwidGV4dC1ub2lyLTQwMCBkYXJrOnRleHQtbm9pci02MDBcIixcbiAgICApO1xuICB9O1xuICBjb25zdCBoYW5kbGVNb3VzZVVwID0gKCkgPT4ge1xuICAgIG1vdXNlRG93bi5jdXJyZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIGFkZE1vdXNlVXBMaXN0ZW5lcigpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAoKSA9PiB7XG4gICAgICBoYW5kbGVNb3VzZVVwKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZU1vdXNlVXBMaXN0ZW5lcigpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgICAgaGFuZGxlTW91c2VVcCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXNbMF0ubWFwKCh7IGluZGV4OiBiYXNlSWR4IH0pID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgIFwicmVsYXRpdmUgbXQtNCBmbGV4IGZsZXgtY29sIGp1c3RpZnktYmV0d2VlblwiLFxuICAgICAgICAgICAgICBcImdyb3VwIGhvdmVyOmJnLW5vaXItMjAwIGRhcms6aG92ZXI6Ymctbm9pci02MDBcIixcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBrZXk9e2BiYXNlLSR7YmFzZUlkeH1gfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKFxuICAgICAgICAgICAgICAoc2VxdWVuY2U6IEFubm90YXRlZEJhc2VbXSwgc2VxdWVuY2VJZHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gc2VxdWVuY2UuZmluZChcbiAgICAgICAgICAgICAgICAgIChiYXNlOiBBbm5vdGF0ZWRCYXNlKSA9PiBiYXNlLmluZGV4ID09PSBiYXNlSWR4LFxuICAgICAgICAgICAgICAgICkgfHwgeyBiYXNlOiBcIiBcIiwgYW5ub3RhdGlvbnM6IFtdLCBpbmRleDogYmFzZUlkeCB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAga2V5PXtgc2VxdWVuY2UtJHtzZXF1ZW5jZUlkeH0tYmFzZS0ke2Jhc2VJZHh9YH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwid2hpdGVzcGFjZS1wcmUgdGV4dC1jZW50ZXJcIil9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHNldEhvdmVyZWRQb3NpdGlvbihiYXNlLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBtb3VzZSBpcyBkb3duLCB1cGRhdGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlRG93bi5jdXJyZW50ICYmIHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGJhc2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0SG92ZXJlZFBvc2l0aW9uKG51bGwpfVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlRG93bj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGJhc2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGJhc2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiZm9yd2FyZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlVXA9e2hhbmRsZU1vdXNlVXB9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxDaGFyQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgY2hhcj17YHwgJHtiYXNlLmluZGV4fWB9XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXg9e2Jhc2VJZHh9XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWJzb2x1dGUgLXRvcC00IGxlZnQtMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJncm91cC1ob3Zlcjp0ZXh0LWJyYW5kLTIwMCBib3JkZXItYiBib3JkZXItbm9pci02MDAgZ3JvdXAtaG92ZXI6Ym9yZGVyLW5vaXItMzAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8Q2hhckNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgIGNoYXI9e2Jhc2UuYmFzZX1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRleD17YmFzZUlkeH1cbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlSW5kZXg6IGJhc2VJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VMZW5ndGg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2VzW3NlcXVlbmNlSWR4XS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlLmJhc2UgIT09IFwiIFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8U2VxdWVuY2VBbm5vdGF0aW9uXG4gICAgICAgICAgICAgIGFubm90YXRpb25zPXtzdGFja2VkQW5ub3RhdGlvbnN9XG4gICAgICAgICAgICAgIGluZGV4PXtiYXNlSWR4fVxuICAgICAgICAgICAgICBtYXhBbm5vdGF0aW9uU3RhY2s9e01hdGgubWF4KFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoLi4uc3RhY2tlZEFubm90YXRpb25zLm1hcCgoYW5uKSA9PiBhbm4uc3RhY2spKSxcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgc2V0SG92ZXJlZFBvc2l0aW9uPXtzZXRIb3ZlcmVkUG9zaXRpb259XG4gICAgICAgICAgICAgIHNldEFjdGl2ZUFubm90YXRpb249e3NldEFjdGl2ZUFubm90YXRpb259XG4gICAgICAgICAgICAgIG1heFNlcXVlbmNlTGVuZ3RoPXtNYXRoLm1heChcbiAgICAgICAgICAgICAgICAuLi5hbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKChzZXEpID0+IHNlcS5sZW5ndGgpLFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNlcU1ldGFkYXRhQmFyID0gKHtcbiAgaG92ZXJlZFBvc2l0aW9uLFxuICBhY3RpdmVBbm5vdGF0aW9uLFxuICBhbm5vdGF0ZWRTZXF1ZW5jZXMsXG4gIGNoYXJDbGFzc05hbWUsXG4gIHNlcUlkeFRvQ29weSxcbiAgc2V0U2VxSWR4VG9Db3B5LFxuICBzZWxlY3Rpb24sXG4gIGNsYXNzTmFtZSxcbn06IHtcbiAgaG92ZXJlZFBvc2l0aW9uOiBudW1iZXIgfCBudWxsO1xuICBhY3RpdmVBbm5vdGF0aW9uOiBBbm5vdGF0aW9uIHwgbnVsbDtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgYW5ub3RhdGVkU2VxdWVuY2VzOiBBbm5vdGF0ZWRCYXNlW11bXTtcbiAgc2VxSWR4VG9Db3B5OiBudW1iZXI7XG4gIHNldFNlcUlkeFRvQ29weTogKGlkeDogbnVtYmVyKSA9PiB2b2lkO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBhbm5vdGF0aW9uRGlzcGxheSA9IGFjdGl2ZUFubm90YXRpb24gPyAoXG4gICAgPHNwYW5cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgXCJmbGV4IGdhcC0xIHJvdW5kZWQtZnVsbCBweC0yIHB5LXB4IHRleHQteHMgIW9wYWNpdHktMTAwXCIsXG4gICAgICAgIFwibWwtYXV0b1wiLFxuICAgICAgICBhY3RpdmVBbm5vdGF0aW9uLmNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmxleCBnYXAtMVwiPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJvcGFjaXR5LTcwXCI+TGFiZWw6IDwvcD5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwiXCI+e2FjdGl2ZUFubm90YXRpb24udGV4dH08L3A+XG4gICAgICA8L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGV4IGdhcC0xXCI+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cIm9wYWNpdHktNzBcIj5UeXBlOiA8L3A+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cIlwiPnthY3RpdmVBbm5vdGF0aW9uLnR5cGV9PC9wPlxuICAgICAgPC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmxleCBnYXAtMVwiPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJvcGFjaXR5LTcwXCI+RGlyZWN0aW9uOiA8L3A+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cIlwiPnthY3RpdmVBbm5vdGF0aW9uLmRpcmVjdGlvbn08L3A+XG4gICAgICA8L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGV4IGdhcC0xXCI+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cIm9wYWNpdHktNzBcIj5mcm9tPC9wPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJcIj5cbiAgICAgICAgICB7YWN0aXZlQW5ub3RhdGlvbi5zdGFydH0gLSB7YWN0aXZlQW5ub3RhdGlvbi5lbmR9XG4gICAgICAgIDwvcD5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gICkgOiBudWxsO1xuICBjb25zdCBwb3NpdGlvbkRpc3BsYXkgPSAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwibWluLXctMTYgdGV4dC14cyB0ZXh0LWJsYWNrIGRhcms6dGV4dC13aGl0ZVwiPlxuICAgICAgUG9zOiB7aG92ZXJlZFBvc2l0aW9uID8/IDB9XG4gICAgPC9zcGFuPlxuICApO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgXCJmbGV4IGgtOCBpdGVtcy1jZW50ZXIgZ2FwLTEgcHktMSB0ZXh0LXhzXCIsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgPlxuICAgICAge3Bvc2l0aW9uRGlzcGxheX1cbiAgICAgIDxDb3B5RGlzcGxheVxuICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZXM9e2Fubm90YXRlZFNlcXVlbmNlc31cbiAgICAgICAgY2hhckNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZX1cbiAgICAgICAgc2VxSWR4VG9Db3B5PXtzZXFJZHhUb0NvcHl9XG4gICAgICAgIHNldFNlcUlkeFRvQ29weT17c2V0U2VxSWR4VG9Db3B5fVxuICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgIC8+XG4gICAgICB7YW5ub3RhdGlvbkRpc3BsYXl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgU2VxdWVuY2VBbm5vdGF0aW9uID0gKHtcbiAgYW5ub3RhdGlvbnMsXG4gIG1heEFubm90YXRpb25TdGFjayxcbiAgaW5kZXgsXG4gIHNldEhvdmVyZWRQb3NpdGlvbixcbiAgc2V0QWN0aXZlQW5ub3RhdGlvbixcbiAgbWF4U2VxdWVuY2VMZW5ndGgsXG59OiB7XG4gIGFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xuICBtYXhBbm5vdGF0aW9uU3RhY2s6IG51bWJlcjtcbiAgc2V0SG92ZXJlZFBvc2l0aW9uOiAocG9zaXRpb246IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEFjdGl2ZUFubm90YXRpb246IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgbWF4U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbn0pID0+IHtcbiAgY29uc3Qgb3JkZXJlZEFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuc29ydCgoYSwgYikgPT4gYS5zdGFjayAtIGIuc3RhY2spO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cIiBcIlxuICAgICAga2V5PXtgYW5ub3RhdGlvbi0ke2luZGV4fWB9XG4gICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHNldEhvdmVyZWRQb3NpdGlvbihpbmRleCl9XG4gICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHNldEhvdmVyZWRQb3NpdGlvbihudWxsKX1cbiAgICA+XG4gICAgICB7Wy4uLkFycmF5KG1heEFubm90YXRpb25TdGFjaykua2V5cygpXS5tYXAoKGkpID0+IHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IG9yZGVyZWRBbm5vdGF0aW9uc1xuICAgICAgICAgIC5maWx0ZXIoKGFubikgPT5cbiAgICAgICAgICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgICAgICAgIGJhc2VJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogYW5uLFxuICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG4gICAgICAgICAgLmZpbmQoKGFubikgPT4gYW5uLnN0YWNrID09PSBpKTtcbiAgICAgICAgaWYgKGFubm90YXRpb24pIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgYmFzZUluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uOiBhbm5vdGF0aW9uLFxuICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleT17YGFubm90YXRpb24tJHtpbmRleH0tJHtpfWB9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcImgtMyBib3JkZXItYi0yIGJvcmRlci1ub2lyLTEwMCBvcGFjaXR5LTEwIFwifVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBrZXk9e2Bhbm5vdGF0aW9uLSR7aW5kZXh9LSR7aX1gfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgXCJncm91cC9hbm5vdGF0aW9uIGgtMyBib3JkZXItYmxhY2sgZ3JvdXAtaG92ZXIvYW5ub3RhdGlvbjpib3JkZXJcIixcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT5cbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLm9uQ2xpY2s/Lih7XG4gICAgICAgICAgICAgICAgICBzdGFydDogYW5ub3RhdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgIGVuZDogYW5ub3RhdGlvbi5lbmQsXG4gICAgICAgICAgICAgICAgICBkaWVjdGlvbjogYW5ub3RhdGlvbi5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHNldEFjdGl2ZUFubm90YXRpb24oYW5ub3RhdGlvbil9XG4gICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0QWN0aXZlQW5ub3RhdGlvbihudWxsKX1cbiAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17YHBsYWNlaG9sZGVyLSR7aW5kZXh9LSR7aX1gfSBjbGFzc05hbWU9e1wiaC0zXCJ9IC8+O1xuICAgICAgICB9XG4gICAgICB9KX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmludGVyZmFjZSBDaGFyUHJvcHMge1xuICBjaGFyOiBzdHJpbmc7XG4gIGluZGV4OiBudW1iZXI7XG4gIGNoYXJDbGFzc05hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IENoYXJDb21wb25lbnQgPSAoeyBjaGFyLCBjaGFyQ2xhc3NOYW1lIH06IENoYXJQcm9wcykgPT4ge1xuICAvLyBkb24ndCBhbGxvdyBzZWxlY3Rpb24gb2YgY2hhcnNcbiAgY29uc3Qgc2hhcmVkQ2xhc3NOYW1lID0gXCJmb250LW1vbm8gc2VsZWN0LW5vbmVcIjtcbiAgaWYgKGNoYXIgPT09IFwiIFwiKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHNoYXJlZENsYXNzTmFtZSwgY2hhckNsYXNzTmFtZSwgXCJvcGFjaXR5LTIwXCIpfT5cbiAgICAgICAgLlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHNoYXJlZENsYXNzTmFtZSwgY2hhckNsYXNzTmFtZSwgXCJtci1weFwiKX0+XG4gICAgICB7Y2hhcn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb3B5RGlzcGxheSA9ICh7XG4gIHNlcUlkeFRvQ29weSxcbiAgc2V0U2VxSWR4VG9Db3B5LFxuICBhbm5vdGF0ZWRTZXF1ZW5jZXMsXG4gIGNoYXJDbGFzc05hbWUsXG4gIHNlbGVjdGlvbixcbn06IHtcbiAgc2VxSWR4VG9Db3B5OiBudW1iZXI7XG4gIHNldFNlcUlkeFRvQ29weTogKGlkeDogbnVtYmVyKSA9PiB2b2lkO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZXM6IEFubm90YXRlZEJhc2VbXVtdO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBnZXRTdHJpbmdUb0NvcHkgPSAoKSA9PiB7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VxID0gYW5ub3RhdGVkU2VxdWVuY2VzW3NlcUlkeFRvQ29weV07XG4gICAgY29uc3Qgc3RyaW5nVG9Db3B5ID0gc2VxXG4gICAgICAuZmlsdGVyKChiYXNlKSA9PlxuICAgICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICAgIGJhc2VJbmRleDogYmFzZS5pbmRleCxcbiAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbixcbiAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2VzW3NlcUlkeFRvQ29weV0ubGVuZ3RoLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICAgIC5tYXAoKGJhc2UpID0+IGJhc2UuYmFzZSlcbiAgICAgIC5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzdHJpbmdUb0NvcHk7XG4gIH07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBtb3VudENvcHlIYW5kbGVyKCkge1xuICAgIGNvbnN0IGNvcHlIYW5kbGVyID0gKGU6IENsaXBib2FyZEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdHJpbmdUb0NvcHkgPSBnZXRTdHJpbmdUb0NvcHkoKTtcbiAgICAgIGlmICghc3RyaW5nVG9Db3B5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YShcInRleHQvcGxhaW5cIiwgc3RyaW5nVG9Db3B5KTtcbiAgICAgIGFsZXJ0KFwiQ29waWVkIHRvIGNsaXBib2FyZCFcIik7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCBjb3B5SGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnRDb3B5SGFuZGxlcigpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIGNvcHlIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGV4XCI+XG4gICAgICA8U2VsZWN0XG4gICAgICAgIHZhbHVlPXtzZXFJZHhUb0NvcHkudG9TdHJpbmcoKX1cbiAgICAgICAgb25WYWx1ZUNoYW5nZT17KHZhbHVlKSA9PiBzZXRTZXFJZHhUb0NvcHkocGFyc2VJbnQodmFsdWUpKX1cbiAgICAgID5cbiAgICAgICAgPFNlbGVjdFRyaWdnZXIgY2xhc3NOYW1lPVwidy1maXRcIj5cbiAgICAgICAgICA8U2VsZWN0VmFsdWVcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgIGJhc2U6IHsgYmFzZTogXCJBXCIsIGFubm90YXRpb25zOiBbXSwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgc2VxdWVuY2VJZHg6IHNlcUlkeFRvQ29weSxcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIFNlcXVlbmNlIHtzZXFJZHhUb0NvcHkgKyAxfVxuICAgICAgICAgIDwvU2VsZWN0VmFsdWU+XG4gICAgICAgIDwvU2VsZWN0VHJpZ2dlcj5cbiAgICAgICAgPFNlbGVjdENvbnRlbnQgY2xhc3NOYW1lPVwiYmctd2hpdGUgZGFyazpiZy1ibGFja1wiPlxuICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKChfLCBpZHgpID0+IChcbiAgICAgICAgICAgIDxTZWxlY3RJdGVtXG4gICAgICAgICAgICAgIGtleT17YHNlcXVlbmNlLSR7aWR4fWB9XG4gICAgICAgICAgICAgIHZhbHVlPXtpZHgudG9TdHJpbmcoKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjaGFyQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgICBiYXNlOiB7IGJhc2U6IFwiQVwiLCBhbm5vdGF0aW9uczogW10sIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgc2VxdWVuY2VJZHg6IGlkeCxcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFNlcXVlbmNlIHtpZHggKyAxfXtcIiBcIn1cbiAgICAgICAgICAgIDwvU2VsZWN0SXRlbT5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9TZWxlY3RDb250ZW50PlxuICAgICAgPC9TZWxlY3Q+XG4gICAgICA8Q29weUJ1dHRvblxuICAgICAgICB0ZXh0VG9Db3B5PXsoKSA9PiBnZXRTdHJpbmdUb0NvcHkoKSA/PyBcIlwifVxuICAgICAgICBsYWJlbD17XCJcIn1cbiAgICAgICAgZGlzYWJsZWQ9eyFzZWxlY3Rpb259XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBBbm5vdGF0ZWRCYXNlLCBBbm5vdGF0ZWRTZXF1ZW5jZSB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IFJlZmVyZW5jZVRpY2tzID0gKHtcbiAgc2VxdWVuY2UsXG4gIGNsYXNzTmFtZSxcbn06IHtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJvdmVyZmxvdy1oaWRkZW50ZXh0LXdoaXRlIGZsZXhcIiwgY2xhc3NOYW1lKX0+XG4gICAgICB7c2VxdWVuY2UubWFwKChudWNsOiBBbm5vdGF0ZWRCYXNlLCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc2hvd1RpY2tzID0gbnVjbC5iYXNlICE9PSBcIi1cIiAmJiAobnVjbC5pbmRleCArIDEpICUgMTAgPT09IDA7IC8vIHdlIGRvbid0IHdhbnQgdG8gc2hvdyB0aWNrcyBmb3IgZ2Fwc1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlIGZsZXggaC0xMiBmbGV4LWNvbCBpdGVtcy1lbmQganVzdGlmeS1lbmRcIlxuICAgICAgICAgICAga2V5PXtgYmFzZS0ke2l9LWluZGV4LXdyYXBwZXJgfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgIFwiZm9udC1tb25vIFwiLFxuICAgICAgICAgICAgICAgIFwiYWJzb2x1dGUgYm90dG9tLTAgbGVmdC0wIHJpZ2h0LTBcIixcblxuICAgICAgICAgICAgICAgIHNob3dUaWNrcyA/IFwib3BhY2l0eS0xMDBcIiA6IFwib3BhY2l0eS0wXCIsXG4gICAgICAgICAgICAgICAgbnVjbC5iYXNlID09PSBcIkdcIiAmJiBcInRleHQtcmVkLTUwMFwiLFxuICAgICAgICAgICAgICAgIG51Y2wuYmFzZSA9PT0gXCJBXCIgJiYgXCJ0ZXh0LXllbGxvdy01MDBcIixcbiAgICAgICAgICAgICAgICBudWNsLmJhc2UgPT09IFwiVFwiICYmIFwidGV4dC1ncmVlbi01MDBcIixcbiAgICAgICAgICAgICAgICBudWNsLmJhc2UgPT09IFwiQ1wiICYmIFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzXCI+IHtudWNsLmluZGV4ICsgMX08L3A+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm14LWF1dG8gdGV4dC14c1wiPnw8L3A+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJtci1weCBmb250LW1vbm8gb3BhY2l0eS0wXCIpfT5cbiAgICAgICAgICAgICAge251Y2wuYmFzZX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbInJlcXVpcmUkJDAiLCJSZWFjdCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJqc3hSdW50aW1lTW9kdWxlIiwicmVxdWlyZSQkMSIsIm9mZnNldCIsImluZGV4Iiwic2l6ZSIsInV0aWwiLCJvYmplY3RVdGlsIiwiZXJyb3JVdGlsIiwiZXJyb3JNYXAiLCJjdHgiLCJtaW4iLCJtYXgiLCJyZXN1bHQiLCJpc3N1ZXMiLCJlbGVtZW50cyIsInByb2Nlc3NlZCIsInIiLCJfYSIsIl9iIiwiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwianN4IiwianN4cyIsInN0YXJ0IiwiZW5kIiwibWlzbWF0Y2hDbGFzc05hbWUiLCJGcmFnbWVudCIsImNsYW1wIiwiRnJhZ21lbnQyIiwiY3JlYXRlQ29sbGVjdGlvblNjb3BlIiwidXNlQ29sbGVjdGlvbiIsIk5vZGUiLCJ1c2VDYWxsYmFja1JlZiIsImNvdW50IiwidXNlTGF5b3V0RWZmZWN0IiwiY29tcHV0ZVBvc2l0aW9uIiwicGxhdGZvcm0iLCJhcnJvdyIsImZsaXAiLCJzaWRlcyIsInNpZGUiLCJwbGFjZW1lbnQiLCJvdmVyZmxvdyIsImhpZGUiLCJzaGlmdCIsIngiLCJ5IiwibGltaXRTaGlmdCIsImdldENvbXB1dGVkU3R5bGUiLCJvZmZzZXQkMSIsInNoaWZ0JDEiLCJmbGlwJDEiLCJzaXplJDEiLCJoaWRlJDEiLCJhcnJvdyQxIiwibGltaXRTaGlmdCQxIiwiZGF0YSIsIk5BTUUiLCJBcnJvdyIsIkNPTlRFTlRfTkFNRSIsImZsb2F0aW5nVUlhcnJvdyIsIkFSUk9XX05BTUUiLCJBcnJvd1ByaW1pdGl2ZS5Sb290IiwiUm9vdDIiLCJQT1JUQUxfTkFNRSIsIlBvcnRhbCIsIlJlYWN0RE9NIiwiX19hc3NpZ24iLCJjYnMiLCJTaWRlQ2FyIiwiU3R5bGUiLCJTZWxlY3QiLCJQb3BwZXJQcmltaXRpdmUuUm9vdCIsIlNlbGVjdFRyaWdnZXIiLCJQb3BwZXJQcmltaXRpdmUuQW5jaG9yIiwiU2VsZWN0VmFsdWUiLCJQb3J0YWxQcmltaXRpdmUiLCJTZWxlY3RDb250ZW50IiwiZm9jdXNGaXJzdCIsIlJlbW92ZVNjcm9sbCIsIlBvcHBlclByaW1pdGl2ZS5Db250ZW50IiwiU2VsZWN0TGFiZWwiLCJTZWxlY3RJdGVtIiwiU2VsZWN0U2Nyb2xsVXBCdXR0b24iLCJTZWxlY3RTY3JvbGxEb3duQnV0dG9uIiwiU2VsZWN0U2VwYXJhdG9yIiwiUG9wcGVyUHJpbWl0aXZlLkFycm93IiwiSWNvbiIsIlNlbGVjdFByaW1pdGl2ZS5Sb290IiwiU2VsZWN0UHJpbWl0aXZlLlZhbHVlIiwiU2VsZWN0UHJpbWl0aXZlLlRyaWdnZXIiLCJTZWxlY3RQcmltaXRpdmUuSWNvbiIsIlNlbGVjdFByaW1pdGl2ZS5TY3JvbGxVcEJ1dHRvbiIsIlNlbGVjdFByaW1pdGl2ZS5TY3JvbGxEb3duQnV0dG9uIiwiU2VsZWN0UHJpbWl0aXZlLlBvcnRhbCIsIlNlbGVjdFByaW1pdGl2ZS5Db250ZW50IiwiU2VsZWN0UHJpbWl0aXZlLlZpZXdwb3J0IiwiU2VsZWN0UHJpbWl0aXZlLkxhYmVsIiwiU2VsZWN0UHJpbWl0aXZlLkl0ZW0iLCJTZWxlY3RQcmltaXRpdmUuSXRlbUluZGljYXRvciIsIlNlbGVjdFByaW1pdGl2ZS5JdGVtVGV4dCIsIlNlbGVjdFByaW1pdGl2ZS5TZXBhcmF0b3IiLCJDb3B5SWNvbiIsIkNoZWNrSWNvbiIsImJhc2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTYSxNQUFJLElBQUVBLGdCQUFpQixJQUFFLE9BQU8sSUFBSSxlQUFlLEdBQUUsSUFBRSxPQUFPLElBQUksZ0JBQWdCLEdBQUUsSUFBRSxPQUFPLFVBQVUsZ0JBQWUsSUFBRSxFQUFFLG1EQUFtRCxtQkFBa0IsSUFBRSxFQUFDLEtBQUksTUFBRyxLQUFJLE1BQUcsUUFBTyxNQUFHLFVBQVMsS0FBRTtBQUNsUCxXQUFTLEVBQUUsR0FBRSxHQUFFLEdBQUU7QUFBQyxRQUFJLEdBQUUsSUFBRSxDQUFFLEdBQUMsSUFBRSxNQUFLLElBQUU7QUFBSyxlQUFTLE1BQUksSUFBRSxLQUFHO0FBQUcsZUFBUyxFQUFFLFFBQU0sSUFBRSxLQUFHLEVBQUU7QUFBSyxlQUFTLEVBQUUsUUFBTSxJQUFFLEVBQUU7QUFBSyxTQUFJLEtBQUssRUFBRSxHQUFFLEtBQUssR0FBRSxDQUFDLEtBQUcsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxNQUFJLEVBQUUsQ0FBQyxJQUFFLEVBQUUsQ0FBQztBQUFHLFFBQUcsS0FBRyxFQUFFLGFBQWEsTUFBSSxLQUFLLElBQUUsRUFBRSxjQUFhLEVBQUUsWUFBUyxFQUFFLENBQUMs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Q0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsVUFBVTtBQUFBLEVBQ3JFO0FBQUEsRUFDSSxJQUFJLFVBQVU7QUFDVixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLEVBQ2xFO0FBQUEsRUFDSSxJQUFJLFFBQVE7QUFDUixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsS0FBSztBQUFBLEVBQ2hFO0FBQUEsRUFDSSxJQUFJLFVBQVU7QUFDVixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLEVBQ2xFO0FBQUEsRUFDSSxJQUFJLFNBQVM7QUFDVCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEVBQ2pFO0FBQUEsRUFDSSxJQUFJLFdBQVc7QUFDWCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsUUFBUTtBQUFBLEVBQ25FO0FBQUEsRUFDSSxJQUFJLFNBQVM7QUFDVCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEVBQ2pFO0FBQUEsRUFDSSxJQUFJLFVBQVU7QUFDVixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLEVBQ2xFO0FBQUEsRUFDSSxJQUFJLFNBQVM7QUFDVCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEVBQ2pFO0FBQUEsRUFDSSxJQUFJLE9BQU87QUFDUCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxH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QixFQUNILENBQUE7QUFBQSxRQUFBO0FBQUEsTUFBQTtBQUFBLElBQ0Y7QUFBQSxJQUNBRCxrQ0FBQTtBQUFBLE1BQUM7QUFBQSxNQUFBO0FBQUEsUUFDQyxZQUFZLE1BQU0sZ0JBQUEsS0FBcUI7QUFBQSxRQUN2QyxPQUFPO0FBQUEsUUFDUCxVQUFVLENBQUM7QUFBQSxNQUFBO0FBQUEsSUFBQTtBQUFBLEVBQ2IsR0FDRjtBQUVKO0FDMWhCTyxNQUFNLGlCQUFpQixDQUFDO0FBQUEsRUFDN0I7QUFBQSxFQUNBO0FBQ0YsTUFHTTtBQUVGLFNBQUFBLGtDQUFBLElBQUMsT0FBSSxFQUFBLFdBQVcsV0FBVyxrQ0FBa0MsU0FBUyxHQUNuRSxVQUFTLFNBQUEsSUFBSSxDQUFDLE1BQXFCLE1BQWM7QUFDaEQsVUFBTSxZQUFZLEtBQUssU0FBUyxRQUFRLEtBQUssUUFBUSxLQUFLLE9BQU87QUFFL0QsV0FBQUMsa0NBQUE7QUFBQSxNQUFDO0FBQUEsTUFBQTtBQUFBLFFBQ0MsV0FBVTtBQUFBLFFBR1YsVUFBQTtBQUFBLFVBQUFBLGtDQUFBO0FBQUEsWUFBQztBQUFBLFlBQUE7QUFBQSxjQUNDLFdBQVc7QUFBQSxnQkFDVDtBQUFBLGdCQUNBO0FBQUEsZ0JBRUEsWUFBWSxnQkFBZ0I7QUFBQSxnQkFDNUIsS0FBSyxTQUFTLE9BQU87QUFBQSxnQkFDckIsS0FBSyxTQUFTLE9BQU87QUFBQSxnQkFDckIsS0FBSyxTQUFTLE9BQU87QUFBQSxnQkFDckIsS0FBSyxTQUFTLE9BQU87QUFBQSxjQUN2QjtBQUFBLGNBRUEsVUFBQTtBQUFBLGdCQUFDQSxrQ0FBQUEsS0FBQSxLQUFBLEVBQUUsV0FBVSxXQUFVLFVBQUE7QUFBQSxrQkFBQTtBQUFBLGtCQUFFLEtBQUssUUFBUTtBQUFBLGdCQUFBLEdBQUU7QUFBQSxnQkFDdkNELGtDQUFBLElBQUEsS0FBQSxFQUFFLFdBQVUsbUJBQWtCLFVBQUMsSUFBQSxDQUFBO0FBQUEsY0FBQTtBQUFBLFlBQUE7QUFBQSxVQUNsQztBQUFBLGdEQUVDLE9BQUksRUFBQSxXQUFXLFdBQVcsMkJBQTJCLEdBQ25ELGVBQUssS0FDUixDQUFBO0FBQUEsUUFBQTtBQUFBLE1BQUE7QUFBQSxNQXBCSyxRQUFRLENBQUM7QUFBQSxJQXFCaEI7QUFBQSxFQUVILENBQUEsR0FDSDtBQUVKOyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiw0LDUsNiwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NV19
