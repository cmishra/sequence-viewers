import * as React from "react";
import React__default, { useRef, useState, useCallback, useEffect, Fragment, useMemo, useLayoutEffect, forwardRef, createElement } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default from "react-dom";
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = React__default;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self) ;
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
if (process.env.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
const genArc = ({
  center,
  innerRadius,
  largeArc,
  length,
  offset: offset2,
  outerRadius,
  seqLength
}) => {
  const leftBottom = findCoor({
    index: offset2,
    radius: innerRadius,
    center,
    seqLength
  });
  const leftTop = findCoor({
    index: offset2,
    radius: outerRadius,
    center,
    seqLength
  });
  const rightBottom = findCoor({
    index: length + offset2,
    radius: innerRadius,
    center,
    seqLength
  });
  const rightTop = findCoor({
    index: length + offset2,
    radius: outerRadius,
    center,
    seqLength
  });
  const sFlagF = 1;
  const sFlagR = 0;
  const lArc = largeArc ? 1 : 0;
  return `M ${rightBottom.x} ${rightBottom.y}
      A ${innerRadius} ${innerRadius}, 0, ${lArc}, ${sFlagR}, ${leftBottom.x} ${leftBottom.y}
      L ${leftBottom.x} ${leftBottom.y}
      L ${leftTop.x} ${leftTop.y}
      A ${outerRadius} ${outerRadius}, 0, ${lArc}, ${sFlagF}, ${rightTop.x} ${rightTop.y}
      Z`;
};
const findCoor = ({
  index: index2,
  radius,
  center,
  seqLength
}) => {
  const lengthPerc = index2 / seqLength;
  const lengthPercCentered = lengthPerc - 0.25;
  const radians = lengthPercCentered * Math.PI * 2;
  const xAdjust = Math.cos(radians) * radius;
  const yAdjust = Math.sin(radians) * radius;
  return {
    x: center.x + xAdjust,
    y: center.y + yAdjust
  };
};
const findAngleFromCoor = ({
  coor,
  center
}) => {
  const x = coor.x - center.x;
  const y = coor.y - center.y;
  let radians = Math.atan2(y, x);
  if (radians < 0) {
    radians = radians + Math.PI * 2;
  }
  return radians * (180 / Math.PI);
};
const findIndexFromAngle = ({
  angle,
  seqLength
}) => {
  let effectiveAngle = angle.degrees + 90;
  if (effectiveAngle < 0) {
    effectiveAngle = 360 + effectiveAngle;
  }
  effectiveAngle = effectiveAngle % 360;
  const arcPerc = effectiveAngle / 360;
  const rawBaseIdx = arcPerc * seqLength;
  return Math.round(rawBaseIdx < 0 ? seqLength + rawBaseIdx : rawBaseIdx);
};
const clampSlice = ({
  slice,
  firstIdx,
  lastIdx
}) => {
  if (!slice) {
    return null;
  }
  let { start, end } = slice;
  const outOfBoundsBefore = start < firstIdx && end < firstIdx;
  const outOfBoundsAfter = start > lastIdx && end > lastIdx;
  if (outOfBoundsBefore || outOfBoundsAfter) {
    return null;
  }
  if (start >= end) {
    start = Math.min(start, lastIdx);
    end = Math.max(end, firstIdx);
  } else {
    end = Math.min(end, lastIdx);
    start = Math.max(start, firstIdx);
  }
  return {
    start,
    end,
    direction: slice.direction
  };
};
var months = [
  "JAN",
  "FEB",
  "MAR",
  "APR",
  "MAY",
  "JUN",
  "JUL",
  "AUG",
  "SEP",
  "OCT",
  "NOV",
  "DEC"
];
const MONTHS = months;
function genbankToJson(sequence) {
  if (typeof sequence !== "string") {
    throw new TypeError("input must be a string");
  }
  let resultsArray = [];
  let result;
  let currentFeatureNote;
  let genbankAnnotationKey = {
    // Contains in order: locus name, sequence length, molecule type (e.g. DNA), genbank division (see 1-18 below), modification date
    // locus definition has changed with time, use accession number for a unique identifier
    LOCUS_TAG: "LOCUS",
    DEFINITION_TAG: "DEFINITION",
    // Accession tag
    // Example: Z78533
    ACCESSION_TAG: "ACCESSION",
    // The version tag contains 2 informations
    // The accession number with a revision
    // The GI (GenInfo Identifier), a ncbi sequential number
    // Example: Z78533.1  GI:2765658
    // Unicity garanteed with respect to sequence. If 1 nucleotide changes, the version is different.
    VERSION_TAG: "VERSION",
    KEYWORDS_TAG: "KEYWORDS",
    // SEGMENT_TAG:"SEGMENT"
    // Source is free text
    SOURCE_TAG: "SOURCE",
    ORGANISM_TAG: "ORGANISM",
    REFERENCE_TAG: "REFERENCE",
    FEATURES_TAG: "FEATURES",
    // CONTIG_TAG: "CONTIG"
    ORIGIN_TAG: "ORIGIN",
    END_SEQUENCE_TAG: "//"
  };
  let lines = sequence.split(/\r?\n/);
  let fieldName;
  let subFieldType;
  let featureLocationIndentation;
  let lastLineWasFeaturesTag;
  let lastLineWasLocation;
  let hasFoundLocus = false;
  for (let line of lines) {
    if (line === null) break;
    let lineFieldName = getLineFieldName(line);
    let val = getLineVal(line);
    let isSubKey = isSubKeyword(line);
    let isKey = isKeyword(line);
    if (lineFieldName === genbankAnnotationKey.END_SEQUENCE_TAG || isKey) {
      fieldName = lineFieldName;
      subFieldType = null;
    } else if (isSubKey) {
      subFieldType = lineFieldName;
    }
    if (line.trim() === "" || lineFieldName === ";") {
      continue;
    }
    if (!hasFoundLocus && fieldName !== genbankAnnotationKey.LOCUS_TAG) {
      break;
    }
    switch (fieldName) {
      case genbankAnnotationKey.LOCUS_TAG:
        hasFoundLocus = true;
        parseLocus(line);
        break;
      case genbankAnnotationKey.FEATURES_TAG:
        parseFeatures(line, lineFieldName, val);
        break;
      case genbankAnnotationKey.ORIGIN_TAG:
        parseOrigin(line, lineFieldName);
        break;
      case genbankAnnotationKey.DEFINITION_TAG:
      case genbankAnnotationKey.ACCESSION_TAG:
      case genbankAnnotationKey.VERSION_TAG:
      case genbankAnnotationKey.KEYWORDS_TAG:
        parseMultiLineField(fieldName, line, fieldName.toLowerCase());
        break;
      case genbankAnnotationKey.SOURCE_TAG:
        if (subFieldType === genbankAnnotationKey.ORGANISM_TAG) {
          parseMultiLineField(subFieldType, line, "organism");
        } else {
          parseMultiLineField(lineFieldName, line, "source");
        }
        break;
      case genbankAnnotationKey.REFERENCE_TAG:
        if (lineFieldName === genbankAnnotationKey.REFERENCE_TAG) {
          const ref = result.references || [];
          result.references = ref;
          ref.push({});
        }
        parseReference(line, subFieldType);
        break;
      case genbankAnnotationKey.END_SEQUENCE_TAG:
        endSeq();
        break;
    }
  }
  if (resultsArray[resultsArray.length - 1] !== result) {
    endSeq();
  }
  return resultsArray;
  function endSeq() {
    postProcessCurSeq();
    resultsArray.push(result);
  }
  function getCurrentFeature() {
    return result.features[result.features.length - 1];
  }
  function postProcessCurSeq() {
    if (result && result.features) {
      for (let i = 0; i < result.features.length; i++) {
        result.features[i] = postProcessGenbankFeature(result.features[i]);
      }
    }
  }
  function parseOrigin(line, key) {
    if (key !== genbankAnnotationKey.ORIGIN_TAG) {
      let newLine = line.replace(/[\s]*[0-9]*/g, "");
      result.sequence += newLine;
    }
  }
  function parseLocus(line) {
    result = {
      features: [],
      name: "Untitled sequence",
      sequence: "",
      references: []
    };
    line = removeFieldName(genbankAnnotationKey.LOCUS_TAG, line);
    const m = line.match(
      /^([^\s]+)\s+(\d+)\s+bp\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*([^\s]+)?$/
    );
    let locusName = m[1];
    let size2 = +m[2];
    let moleculeType = m[3];
    let circular = m[4] === "circular";
    const seq = result;
    let dateStr = "";
    if (!m[6]) {
      dateStr = m[5];
    } else {
      seq.genbankDivision = m[5];
      dateStr = m[6];
    }
    seq.circular = circular;
    seq.moleculeType = moleculeType;
    const dateMatch = dateStr.match(/^(\d{2})-(.{3})-(\d{4})$/);
    const date = /* @__PURE__ */ new Date();
    date.setFullYear(+dateMatch[3]);
    date.setUTCMonth(MONTHS.indexOf(dateMatch[2].toUpperCase()));
    date.setDate(+dateMatch[1]);
    date.setUTCHours(12);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    seq.date = date.toISOString();
    seq.name = locusName;
    seq.size = size2;
  }
  function removeFieldName(fName, line) {
    line = line.replace(/^\s*/, "");
    if (line.indexOf(fName) === 0) {
      line = line.replace(fName, "");
    }
    return line.trim();
  }
  function parseReference(line, subType) {
    const refs = result.references;
    let lastRef = refs[refs.length - 1];
    if (!subType) {
      parseMultiLineField(
        genbankAnnotationKey.REFERENCE_TAG,
        line,
        "description",
        lastRef
      );
    } else {
      parseMultiLineField(subType, line, subType.toLowerCase(), lastRef);
    }
  }
  function parseFeatures(line, key, val) {
    let strand;
    if (key === genbankAnnotationKey.FEATURES_TAG) {
      lastLineWasFeaturesTag = true;
      return;
    }
    if (lastLineWasFeaturesTag) {
      featureLocationIndentation = getLengthOfWhiteSpaceBeforeStartOfLetters(
        line
      );
      lastLineWasFeaturesTag = false;
    }
    if (isFeatureLineRunon(line, featureLocationIndentation)) {
      if (lastLineWasLocation) {
        parseFeatureLocation(line.trim());
        lastLineWasLocation = true;
      } else {
        if (currentFeatureNote) {
          currentFeatureNote[currentFeatureNote.length - 1] += line.trim().replace(/"/g, "");
        }
        lastLineWasLocation = false;
      }
    } else {
      if (isNote(line)) {
        if (getCurrentFeature()) {
          parseFeatureNote(line);
          lastLineWasLocation = false;
        }
      } else {
        if (val.match(/complement/g)) {
          strand = -1;
        } else {
          strand = 1;
        }
        newFeature();
        let feat = getCurrentFeature();
        feat.type = key;
        feat.strand = strand;
        parseFeatureLocation(val);
        lastLineWasLocation = true;
      }
    }
  }
  function newFeature() {
    result.features.push({
      notes: {}
    });
  }
  function isNote(line) {
    let qual = false;
    if (line.trim().charAt(0).match(/\//)) {
      qual = true;
    } else if (line.match(/^[\s]*\/[\w]+=[\S]+/)) {
      qual = true;
    }
    return qual;
  }
  function parseFeatureLocation(locStr) {
    locStr = locStr.trim();
    let locArr = [];
    locStr.replace(/(\d+)/g, function(string, match) {
      locArr.push(match);
    });
    let feat = getCurrentFeature();
    feat.start = +locArr[0];
    feat.end = locArr[1] === void 0 ? +locArr[0] : +locArr[1];
  }
  function parseFeatureNote(line) {
    let newLine, lineArr;
    newLine = line.trim();
    newLine = newLine.replace(/^\/|"$/g, "");
    lineArr = newLine.split(/="|=/);
    let val = lineArr[1];
    if (val) {
      val = val.replace(/\\/g, " ");
      if (line.match(/="/g)) {
        val = val.replace(/".*/g, "");
      } else if (val.match(/^\d+$/g)) {
        val = +val;
      }
    }
    let key = lineArr[0];
    let currentNotes = getCurrentFeature().notes;
    if (currentNotes[key]) {
      currentNotes[key].push(val);
    } else {
      currentNotes[key] = [val];
    }
    currentFeatureNote = currentNotes[key];
  }
  function getLineFieldName(line) {
    let arr;
    line = line.trim();
    arr = line.split(/[\s]+/);
    return arr[0];
  }
  function parseMultiLineField(fName, line, resultKey, r) {
    r = r || result;
    let fieldValue = removeFieldName(fName, line);
    r[resultKey] = r[resultKey] ? `${r[resultKey]} ` : "";
    r[resultKey] += fieldValue;
  }
  function getLineVal(line) {
    let arr;
    if (line.indexOf("=") < 0) {
      line = line.replace(/^[\s]*[\S]+[\s]+|[\s]+$/, "");
      line = line.trim();
      return line;
    } else {
      arr = line.split(/=/);
      return arr[1];
    }
  }
  function isKeyword(line) {
    let isKey = false;
    if (line.substr(0, 10).match(/^[\S]+/)) {
      isKey = true;
    }
    return isKey;
  }
  function isSubKeyword(line) {
    let isSubKey = false;
    if (line.substr(0, 10).match(/^[\s]+[\S]+/)) {
      isSubKey = true;
    }
    return isSubKey;
  }
  function postProcessGenbankFeature(feat) {
    if (feat.notes.label) {
      feat.name = feat.notes.label[0];
    } else if (feat.notes.gene) {
      feat.name = feat.notes.gene[0];
    } else if (feat.notes.ApEinfo_label) {
      feat.name = feat.notes.ApEinfo_label[0];
    } else if (feat.notes.name) {
      feat.name = feat.notes.name[0];
    } else if (feat.notes.organism) {
      feat.name = feat.notes.organism[0];
    } else if (feat.notes.locus_tag) {
      feat.name = feat.notes.locus_tag[0];
    } else if (feat.notes.note) {
      feat.name = feat.notes.note[0];
    } else {
      feat.name = "Untitled Feature";
    }
    feat.name = typeof feat.name === "string" ? feat.name : String(feat.name);
    return feat;
  }
}
function isFeatureLineRunon(line, featureLocationIndentation) {
  let indentationOfLine = getLengthOfWhiteSpaceBeforeStartOfLetters(line);
  if (featureLocationIndentation === indentationOfLine) {
    return false;
  }
  let trimmed = line.trim();
  if (trimmed.charAt(0).match(/\//)) {
    return false;
  }
  return true;
}
function getLengthOfWhiteSpaceBeforeStartOfLetters(string) {
  let match = /^\s*/.exec(string);
  if (match !== null) {
    return match[0].length;
  } else {
    return 0;
  }
}
var src = genbankToJson;
const genbankParser = /* @__PURE__ */ getDefaultExportFromCjs(src);
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const coorSchema = z.object({
  x: z.number(),
  y: z.number()
});
const angleSchema = z.object({
  degrees: z.number(),
  center: coorSchema
});
const annotationTypeSchema = z.union([
  z.literal("CDS"),
  z.literal("enhancer"),
  z.literal("intron"),
  z.literal("misc_feature"),
  z.literal("polyA_signal"),
  z.literal("promoter"),
  z.literal("protein_bind"),
  z.literal("rep_origin"),
  z.literal("LTR"),
  z.string()
]);
const annotationSchema = z.object({
  type: annotationTypeSchema,
  direction: z.union([z.literal("forward"), z.literal("reverse")]),
  start: z.number(),
  end: z.number(),
  className: z.string().optional(),
  text: z.string(),
  onClick: z.function().args(z.any()).optional()
  // circular reference
});
const stackedAnnotationSchema = annotationSchema.extend({
  stack: z.number()
});
const nuclSchema = z.union([
  z.literal("A"),
  z.literal("C"),
  z.literal("G"),
  z.literal("T")
]);
const aaSchema = z.union([
  // Add all your amino acids literals here
  z.literal("A"),
  z.literal("C"),
  z.literal("D"),
  z.literal("E"),
  z.literal("F"),
  z.literal("G"),
  z.literal("H"),
  z.literal("I"),
  z.literal("K"),
  z.literal("L"),
  z.literal("M"),
  z.literal("N"),
  z.literal("P"),
  z.literal("Q"),
  z.literal("R"),
  z.literal("S"),
  z.literal("T"),
  z.literal("V"),
  z.literal("W"),
  z.literal("Y")
]);
const GapSchema = z.literal("-");
const StopSchema = z.literal("*");
const SpaceSchema = z.literal(" ");
const UnknownSchema = z.literal("?");
const annotatedBaseSchema = z.object({
  base: z.string().length(1),
  annotations: z.array(stackedAnnotationSchema),
  index: z.number()
});
const annotatedSequenceSchema = z.array(annotatedBaseSchema);
const ariadneSelectionSchema = z.object({
  start: z.number(),
  end: z.number(),
  direction: z.union([z.literal("forward"), z.literal("reverse")])
});
const GenbankFeatureSchema = z.object({
  name: z.string().min(1),
  start: z.number(),
  end: z.number(),
  strand: z.union([z.literal(1), z.literal(-1)]),
  type: annotationTypeSchema,
  notes: z.record(z.array(z.string())).optional()
});
const genbankToAnnotatedSequence = ({
  genbank,
  annotationOnClick
}) => {
  const features = genbank.features.map((feature) => {
    return GenbankFeatureSchema.parse(feature);
  });
  const annotations = genbankFeaturesToAnnotations({
    features,
    annotationOnClick
  });
  const stackedAnnotations = stackAnnsByType(annotations);
  const { successes, failures } = safeAnythingToAnnotatedSequences({
    payload: genbank.sequence,
    payloadType: "raw",
    annotations: stackedAnnotations
  });
  if (failures.length > 0) {
    throw new Error(`Failed to parse genbank: ${failures[0]}`);
  }
  if (successes.length !== 1 || successes[0].sequences.length !== 1) {
    throw new Error(`Expected exactly one annotated sequence`);
  }
  return {
    annotatedSequence: annotatedSequenceSchema.parse(successes[0].sequences[0]),
    annotations
  };
};
const genbankFeaturesToAnnotations = ({
  features,
  annotationOnClick
}) => {
  return features.map((feature) => {
    const [start, end] = [feature.start, feature.end];
    return {
      type: feature.type,
      start,
      end,
      label: feature.type,
      text: feature.name,
      direction: feature.strand === 1 ? "forward" : "reverse",
      className: getClassNameFromFeatureType(feature.type),
      onClick: annotationOnClick
    };
  });
};
function getClassNameFromFeatureType(annType) {
  const common = "cursor-pointer opacity-60 group-hover:opacity-100 !text-xs hover:opacity-100 pointer-events-all text-white text-clip overflow-hidden whitespace-nowrap";
  const classNameMap = zipArrays(
    [
      "CDS",
      "enhancer",
      "intron",
      "misc_feature",
      "polyA_signal",
      "promoter",
      "protein_bind",
      "rep_origin",
      "LTR",
      "source",
      "insertion"
    ],
    [
      "bg-red-600 fill-red-600 stroke-red-600",
      "bg-blue-600 fill-blue-600 stroke-blue-600",
      "bg-green-600 fill-green-600 stroke-green-600",
      "bg-yellow-600 fill-yellow-600 stroke-yellow-600",
      "bg-orange-600 fill-orange-600 stroke-orange-600",
      "bg-purple-600 fill-purple-600 stroke-purple-600",
      "bg-sky-600 fill-sky-600 stroke-sky-600",
      "bg-teal-600 fill-teal-600 stroke-teal-600",
      "bg-gray-600 fill-gray-600 stroke-gray-600",
      "bg-pink-600 fill-pink-600 stroke-pink-600"
    ]
  );
  if (annType in classNameMap) {
    return `${common} ${classNameMap[annType]}`;
  }
  return common;
}
const zipArrays = (keys, values) => {
  return Object.fromEntries(
    keys.map((key, i) => {
      const val = values[i];
      return [key, val];
    })
  );
};
const parseGenbank = (genbankString) => {
  const result = genbankParser(genbankString);
  return result;
};
const getComplement = (sequence) => {
  const complement = {
    A: "T",
    T: "A",
    C: "G",
    G: "C",
    N: "N"
  };
  return sequence.split("").map((base) => {
    if (base in complement) {
      return complement[base];
    } else {
      return "?";
    }
  }).join("");
};
const getAnnotatedSequence = ({
  sequence,
  stackedAnnotations,
  noValidate
}) => {
  const mapFn = (base, idx) => {
    const annotationsForBase = stackedAnnotations.filter((annotation) => {
      if (annotation.start > annotation.end) {
        const isBetweenAnnotationStartAndEndofSequence = idx >= annotation.start && idx <= sequence.length;
        const isBetweenStartOfSequenceAndAnnotationEnd = idx >= 0 && idx <= annotation.end;
        return isBetweenAnnotationStartAndEndofSequence || isBetweenStartOfSequenceAndAnnotationEnd;
      } else {
        return idx >= annotation.start && idx <= annotation.end;
      }
    });
    return {
      base,
      index: idx,
      annotations: annotationsForBase,
      complement: getComplement(base)
    };
  };
  const raw = sequence.split("").map(mapFn).filter((x) => x.base !== " ");
  const annotatedSequence = annotatedSequenceSchema.safeParse(raw);
  if (noValidate) {
    if (annotatedSequence.success === false) {
      console.warn(annotatedSequence.error);
    }
    return raw;
  }
  if (annotatedSequence.success === false) {
    throw new Error(annotatedSequence.error.message);
  }
  return annotatedSequence.data;
};
const stackElements = (elements) => {
  if (elements.length === 0) {
    return [];
  }
  const last = (arr) => arr[arr.length - 1];
  const first = (arr) => arr[0];
  const maxIndex = elements.map((e) => e.end).reduce((a, b) => Math.max(a, b));
  const stack = [];
  elements.forEach((a) => {
    const insertIndex = stack.findIndex((elems) => {
      if (a.end === a.start) {
        return -1;
      }
      if (last(elems).end <= last(elems).start) {
        return last(elems).end + maxIndex <= a.start;
      }
      if (a.end > a.start) {
        return last(elems).end <= a.start;
      }
      return last(elems).end < a.start && a.end < first(elems).start;
    });
    if (insertIndex > -1) {
      stack[insertIndex].push(a);
    } else {
      stack.push([a]);
    }
  });
  return stack.map((row) => row.sort((a, b) => a.start - b.start));
};
const getStackedAnnotations = (annotations) => {
  const stackedAnnotations = stackElements(annotations);
  return stackedAnnotations.map((row, idx) => row.map((annotation) => ({ ...annotation, stack: idx }))).flat();
};
const baseInSelection = ({
  baseIndex,
  selection,
  sequenceLength
}) => {
  if (!selection) {
    return false;
  }
  const { start, end } = selection;
  if (start === end) {
    return baseIndex === start;
  }
  if (start < end) {
    return inRange(baseIndex, start, end);
  } else {
    return inRange(baseIndex, start, sequenceLength) || inRange(baseIndex, 0, end);
  }
};
const inRange = (value, min2, max2) => {
  return value >= min2 && value <= max2;
};
const getSubsequenceLength = ({ start, end }, sequenceLength) => {
  if (start < end) {
    return end - start;
  } else {
    return sequenceLength - start + end;
  }
};
const anythingToAnnotatedSequences = ({
  payload,
  payloadType,
  annotations,
  annotationOnClick
}) => {
  const { successes, failures } = safeAnythingToAnnotatedSequences({
    payload,
    payloadType,
    annotations,
    annotationOnClick
  });
  if (failures.length > 0) {
    const failString = failures.map((f) => f.error).join("\n");
    throw new Error(`Parse failures: ${failString}`);
  }
  const sequences = successes.map((s) => s.sequences).flat();
  const newAnnotations = successes.map((s) => s.annotations).flat();
  const stackedAnnotations = getStackedAnnotations(newAnnotations);
  return { sequences, stackedAnnotations };
};
const safeAnythingToAnnotatedSequences = ({
  payload,
  payloadType,
  annotations,
  annotationOnClick
}) => {
  const successes = [];
  const failures = [];
  switch (payloadType) {
    case "raw": {
      try {
        const sequences = [
          stringToAnnotatedSequence({
            sequence: payload,
            annotations: annotations ?? []
          })
        ];
        successes.push({
          source: {
            payload,
            annotations,
            annotationOnClick,
            payloadType
          },
          sequences,
          annotations: annotations ?? []
        });
      } catch (e) {
        failures.push({
          source: {
            payload,
            annotations,
            annotationOnClick,
            payloadType
          },
          error: `Failed to parse raw sequence: ${e}`
        });
      }
      break;
    }
    case "parsed-genbank":
    case "genbank": {
      const parsed = payloadType === "parsed-genbank" ? [payload] : genbankParser(payload);
      parsed.forEach((genbank) => {
        try {
          const sequence = genbankToAnnotatedSequence({
            genbank,
            annotationOnClick
          }).annotatedSequence;
          successes.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            sequences: [sequence],
            annotations: []
          });
        } catch (e) {
          failures.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            error: `Failed to parse genbank: ${e}`
          });
        }
      });
      break;
    }
    case "fasta": {
      let records;
      if (payloadType === "fasta") {
        records = parseFasta(payload);
      } else {
        records = parseFastq(payload);
      }
      records.forEach((record) => {
        try {
          const res = safeAnythingToAnnotatedSequences({
            payload: record.sequence,
            payloadType: "raw"
          });
          failures.push(...res.failures);
          successes.push(...res.successes);
        } catch (e) {
          failures.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            error: `Failed to parse ${payloadType}: ${e}`
          });
        }
      });
      break;
    }
    default: {
      failures.push({
        source: {
          payload,
          annotations,
          annotationOnClick,
          payloadType
        },
        error: `Unknown payload type: ${payloadType}`
      });
      break;
    }
  }
  return {
    successes,
    failures
  };
};
const stringToAnnotatedSequence = ({
  sequence,
  annotations
}) => {
  const stackedAnnotations = getStackedAnnotations(annotations ?? []);
  const annotatedSequence = getAnnotatedSequence({
    sequence,
    stackedAnnotations
  });
  return annotatedSequence;
};
const annotationsHaveOverlap = (a1, a2, maxLen) => {
  if (baseInSelection({
    baseIndex: a1.start,
    selection: a2,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a1.end,
    selection: a2,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a2.start,
    selection: a1,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a2.end,
    selection: a1,
    sequenceLength: maxLen
  })) {
    return true;
  }
  return false;
};
const stackAnnotationsNoOverlap = (annotations, maxLen) => {
  const annotationsByStack = [];
  annotations.map((annotation) => {
    let curStack = 0;
    while (true) {
      const stackAnns = annotationsByStack[curStack];
      if (!stackAnns) {
        annotationsByStack[curStack] = [annotation];
        return;
      }
      let overlap = false;
      for (const stackedAnn of stackAnns) {
        if (annotationsHaveOverlap(annotation, stackedAnn, maxLen)) {
          overlap = true;
          break;
        }
      }
      if (overlap) {
        curStack += 1;
      } else {
        annotationsByStack[curStack].push(annotation);
        return;
      }
    }
  });
  const stackedAnnotations = [];
  annotationsByStack.forEach((stackedAnns, index2) => {
    stackedAnns.forEach((annotation) => {
      stackedAnnotations.push({
        ...annotation,
        stack: index2
      });
    });
  });
  return stackedAnnotations;
};
const stackAnnsByType = (annotations) => {
  const annotationMap = annotations.reduce(
    (acc, annotation) => {
      if (acc[annotation.type] === void 0) {
        acc[annotation.type] = [];
      }
      acc[annotation.type].push(annotation);
      return acc;
    },
    {}
  );
  const stacks = Object.values(annotationMap).map((stack, stackIdx) => {
    return stack.map((annotation) => {
      const res = {
        ...annotation,
        stack: stackIdx
      };
      return res;
    });
  }).flat();
  return stacks;
};
function parseFastq(data) {
  const lines = data.trim().split("\n");
  const records = [];
  for (let i = 0; i < lines.length; i += 4) {
    const record = {
      id: lines[i].substring(1),
      sequence: lines[i + 1],
      optionalId: lines[i + 2].substring(1),
      quality: lines[i + 3]
    };
    records.push(record);
  }
  return records;
}
function parseFasta(data) {
  const lines = data.trim().split("\n");
  const records = [];
  for (let i = 0; i < lines.length; i += 2) {
    const record = {
      id: lines[i].substring(1),
      sequence: lines[i + 1]
    };
    records.push(record);
  }
  return records;
}
const useStateRef = (initialValue) => {
  const ref = useRef(initialValue);
  const [state, internalSetState] = useState(initialValue);
  const setState = useCallback((value) => {
    ref.current = value;
    internalSetState(value);
  }, []);
  return [state, setState, ref];
};
const useLinearSelectionRect = ({
  ref,
  onMouseUp,
  onMouseDown,
  onMouseMove
}) => {
  const [start, setStart, startRef] = useStateRef(null);
  const [end, setEnd, endRef] = useStateRef(null);
  const [direction, setDirection] = useState("forward");
  const active = useRef(false);
  const _onMouseDown = (e) => {
    var _a;
    const { clientX, clientY } = e;
    const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
      left: 0,
      top: 0
    };
    const x = clientX - left;
    const y = clientY - top;
    active.current = true;
    setStart({ x, y });
    setEnd({ x, y });
    onMouseDown == null ? void 0 : onMouseDown({ start: { x, y } });
  };
  const _onMouseUp = () => {
    active.current = false;
    if (startRef.current && endRef.current) {
      onMouseUp == null ? void 0 : onMouseUp({ start: startRef.current, end: endRef.current });
    } else {
      console.error("start or end is null when mouseup");
    }
  };
  const _onMouseMove = (e) => {
    var _a, _b;
    if (active.current) {
      const { clientX, clientY } = e;
      const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
        left: 0,
        top: 0
      };
      const x = clientX - left;
      const y = clientY - top;
      const { startX } = {
        startX: (_b = startRef.current) == null ? void 0 : _b.x
      };
      if (startX && startX > x) {
        setDirection("reverse");
      } else {
        setDirection("forward");
      }
      setEnd({ x, y });
      if (startRef.current && endRef.current) {
        onMouseMove == null ? void 0 : onMouseMove({ start: startRef.current, end: endRef.current });
      } else {
        console.error("start is null when mousemove");
      }
    }
  };
  useEffect(() => {
    const node = ref == null ? void 0 : ref.current;
    if (node) {
      node.addEventListener("mousedown", _onMouseDown);
      node.addEventListener("mousemove", _onMouseMove);
    }
    if (window) {
      window.addEventListener("mouseup", _onMouseUp);
    }
    return () => {
      node == null ? void 0 : node.removeEventListener("mousedown", _onMouseDown);
      node == null ? void 0 : node.removeEventListener("mousemove", _onMouseMove);
      window == null ? void 0 : window.removeEventListener("mouseup", _onMouseUp);
    };
  }, [ref]);
  return { start, end, direction };
};
const useCircularSelectionRect = (ref) => {
  const [start, setStart, startRef] = useStateRef(null);
  const [end, setEnd] = useStateRef(null);
  const [direction, setDirection] = useState(null);
  const ANGLE_DELTA_THRESHOLD_IN_DEGREES = 2;
  const active = useRef(false);
  const onMouseDown = (e) => {
    if (ref.current) {
      console.debug("resetting start and end");
      setStart(null);
      setEnd(null);
      setDirection(null);
      active.current = true;
      const { clientX, clientY } = e;
      const { left, top, width, height } = ref.current.getBoundingClientRect();
      const x = clientX - left;
      const y = clientY - top;
      const center = { x: width / 2, y: height / 2 };
      const startAngle = findAngleFromCoor({ coor: { x, y }, center });
      setStart({
        degrees: startAngle,
        center
      });
    }
  };
  const onMouseUp = () => {
    active.current = false;
    setDirection(null);
  };
  const onMouseMove = (e) => {
    if (active.current && ref.current) {
      const { clientX, clientY } = e;
      const { left, top, width, height } = ref.current.getBoundingClientRect();
      const x = clientX - left;
      const y = clientY - top;
      const center = { x: width / 2, y: height / 2 };
      if (Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) < 0.4 * (width / 2)) {
        console.debug("within 0.5 radius of center, not updating selection");
        return;
      }
      const endAngle = findAngleFromCoor({ coor: { x, y }, center });
      if (startRef.current) {
        const startAngle = startRef.current.degrees;
        const endAngleIsNearStartAngle = inRange(
          endAngle,
          startAngle - ANGLE_DELTA_THRESHOLD_IN_DEGREES,
          startAngle + ANGLE_DELTA_THRESHOLD_IN_DEGREES
        );
        if (endAngleIsNearStartAngle) {
          setDirection(null);
        }
      }
      setEnd({
        degrees: endAngle,
        center
      });
    }
  };
  useEffect(
    function determineDirection() {
      if (start && end && direction === null) {
        const startAngle = start.degrees;
        const endAngle = end.degrees;
        const delta = endAngle - startAngle;
        const guessedDirection = delta > 0 ? "clockwise" : "counterclockwise";
        setDirection(guessedDirection);
      }
    },
    [start, end]
  );
  useEffect(
    function handleEventListeners() {
      const node = ref.current;
      if (node) {
        node.addEventListener("mousedown", onMouseDown);
        node.addEventListener("mousemove", onMouseMove);
        node.addEventListener("mouseup", onMouseUp);
      }
      if (window) {
        window.addEventListener("mouseup", onMouseUp);
      }
      return () => {
        node == null ? void 0 : node.removeEventListener("mousedown", onMouseDown);
        node == null ? void 0 : node.removeEventListener("mousemove", onMouseMove);
        node == null ? void 0 : node.removeEventListener("mouseup", onMouseUp);
        window == null ? void 0 : window.removeEventListener("mouseup", onMouseUp);
      };
    },
    [ref.current, start, direction]
  );
  return { start, end, direction };
};
function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}
const cn = classNames;
const CircularAnnotation = ({
  sequence,
  annotation,
  radius,
  center
}) => {
  const { x: cx, y: cy } = center;
  const annotationLength = getSubsequenceLength(annotation, sequence.length);
  if (annotationLength > sequence.length) {
    console.error(
      `Annotation ${annotation.text}'s length is greater than sequence length: ${annotationLength} > ${sequence.length}`
    );
  }
  const arcPath = genArc({
    innerRadius: radius,
    outerRadius: radius + 5,
    largeArc: annotationLength > sequence.length / 2,
    length: annotationLength,
    seqLength: sequence.length,
    offset: annotation.start,
    center: { x: cx, y: cy }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      className: classNames(annotation.className),
      onClick: () => {
        var _a;
        (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("path", { d: arcPath, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: annotation.text }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: "Annotation" })
      ] })
    }
  );
};
const CircularAnnotationGutter = ({
  stackedAnnotations,
  cx,
  cy,
  radius,
  annotatedSequence
}) => {
  const gutterRadius = radius * 0.3;
  const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
  const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
  stackedAnnotations = stackedAnnotations.map((annotation) => {
    const clampedBounds = clampSlice({
      slice: annotation,
      firstIdx,
      lastIdx
    });
    if (!clampedBounds) {
      return null;
    }
    return {
      ...annotation,
      start: clampedBounds.start,
      end: clampedBounds.end
    };
  }).filter(Boolean);
  const stacks = [];
  stackedAnnotations.forEach((ann) => {
    stacks[ann.stack] = stacks[ann.stack] || [];
    stacks[ann.stack].push(ann);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx, cy, r: gutterRadius, fill: "none", strokeWidth: 0.8 }),
    ";",
    stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Fragment, { children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CircularAnnotation,
      {
        annotation,
        radius: gutterRadius + stackIdx * 6,
        center: { x: cx, y: cy },
        sequence: annotatedSequence
      },
      `stack-${stackIdx}-${annotation.start}-${annotation.end}-${annotation.text}`
    )) }, `annotation-stack-${stackIdx}`))
  ] });
};
const CircularIndex = ({
  annotatedSequence,
  cx,
  cy,
  radius,
  ticks
}) => {
  const basesPerTick = Math.floor(annotatedSequence.length / ticks);
  if (annotatedSequence.length > 50) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `fill-current`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "circle",
        {
          cx,
          cy,
          r: radius * 0.75,
          fill: "none",
          stroke: "currentColor",
          strokeWidth: 2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ticks,
        {
          cx,
          cy,
          radius: radius * 0.75,
          basesPerTick,
          totalBases: annotatedSequence.length
        }
      )
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: annotatedSequence.map(({ base: letter }, index2) => {
    const { x, y } = findCoor({
      index: index2,
      radius: radius * 0.7,
      center: { x: cx, y: cy },
      seqLength: annotatedSequence.length
    });
    const rotateDegrees = index2 / annotatedSequence.length * 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tspan",
      {
        x,
        y,
        transform: `rotate(${rotateDegrees} ${x} ${y})`,
        textAnchor: "middle",
        dominantBaseline: "middle",
        color: "currentColor",
        fill: "currentColor",
        fontSize: "0.5rem",
        fontWeight: "thin",
        fontFamily: "inherit",
        "data-seq-index": index2,
        children: letter
      },
      `base-${index2}`
    );
  }) });
};
const Ticks = ({
  radius,
  cx,
  cy,
  basesPerTick,
  totalBases
}) => {
  const numberOfTicks = Math.floor(totalBases / basesPerTick);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { children: [...Array(numberOfTicks).keys()].map((i) => {
    const { x: x1, y: y1 } = findCoor({
      index: i,
      radius,
      center: { x: cx, y: cy },
      seqLength: totalBases
    });
    const { x: x2, y: y2 } = findCoor({
      index: i,
      radius: radius * 1.1,
      center: { x: cx, y: cy },
      seqLength: totalBases
    });
    const rotateDegrees = i / numberOfTicks * 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          id: `tick-${i}`,
          x1,
          y1,
          x2,
          y2,
          stroke: "currentColor",
          strokeWidth: 1,
          opacity: 0.5,
          transform: `rotate(${rotateDegrees} ${cx} ${cy})`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "text",
        {
          x: x2,
          y: y2 - 4,
          textAnchor: "middle",
          fontSize: ".8rem",
          transform: `rotate(${rotateDegrees} ${cx} ${cy})`,
          fill: "currentColor",
          opacity: 0.75,
          children: i * basesPerTick
        }
      )
    ] }, `tick-${i}`);
  }) });
};
const CircularViewer = ({
  sequence,
  annotations,
  selection,
  setSelection,
  containerClassName,
  svgSizePX = 300,
  svgPadding = 20
}) => {
  const { cx, cy, sizeX, sizeY, radius } = {
    cx: svgSizePX / 2,
    cy: svgSizePX / 2,
    sizeX: svgSizePX,
    sizeY: svgSizePX,
    radius: (svgSizePX - svgPadding) / 2
  };
  const stackedAnnotations = stackAnnsByType(annotations);
  const annotatedSequence = useMemo(
    function memoize() {
      return getAnnotatedSequence({
        sequence,
        stackedAnnotations: getStackedAnnotations(annotations)
      });
    },
    [sequence, annotations]
  );
  if (annotatedSequence && selection && annotatedSequence.length > 0) {
    const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
    const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
    selection = clampSlice({ slice: selection, firstIdx, lastIdx });
  }
  const selectionRef = useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames(
        "flex select-none items-center justify-center font-thin",
        containerClassName
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref: selectionRef,
          viewBox: `0 0 ${sizeX} ${sizeY}`,
          xmlns: "http://www.w3.org/2000/svg",
          fontFamily: "inherit",
          fontSize: "inherit",
          fontWeight: "inherit",
          className: `stroke-current`,
          width: sizeX,
          height: sizeY,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularIndex,
              {
                cx,
                cy,
                radius,
                annotatedSequence,
                ticks: 4
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularAnnotationGutter,
              {
                annotatedSequence,
                stackedAnnotations,
                cx,
                cy,
                radius
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularSelection,
              {
                annotatedSequence,
                selection,
                cx,
                cy,
                radius,
                selectionRef,
                setSelection
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "text",
              {
                x: cx,
                y: cy,
                textAnchor: "middle",
                fill: "currentColor",
                stroke: "currentColor",
                alignmentBaseline: "middle",
                fontSize: "1rem",
                children: [
                  annotatedSequence.length,
                  " bp"
                ]
              }
            )
          ]
        }
      )
    }
  );
};
const CircularSelection = ({
  radius,
  cx,
  cy,
  selection,
  selectionRef,
  setSelection,
  annotatedSequence
}) => {
  var _a, _b;
  const {
    start: internalSelectionStart,
    end: internalSelectionEnd,
    direction: internalDirection
  } = useCircularSelectionRect(selectionRef);
  useEffect(
    function propagateSelectionUp() {
      if (selectionRef.current && internalSelectionStart && internalSelectionEnd && internalDirection) {
        const start2 = findIndexFromAngle({
          angle: internalSelectionStart,
          seqLength: annotatedSequence.length
        });
        const end2 = findIndexFromAngle({
          angle: internalSelectionEnd,
          seqLength: annotatedSequence.length
        });
        const direction = internalDirection === "clockwise" ? "forward" : "reverse";
        const prevLength = selection ? Math.abs(selection.end - selection.start) : 0;
        const newLength = getSubsequenceLength(
          { start: start2, end: end2 },
          annotatedSequence.length
        );
        const deltaLength = Math.abs(prevLength - newLength);
        const deltaThreshold = Math.max(0.7 * annotatedSequence.length, 10);
        if (deltaLength > deltaThreshold && selection) {
          setSelection({
            start: start2,
            end: end2,
            direction: selection == null ? void 0 : selection.direction
          });
          return;
        }
        setSelection({
          start: start2,
          end: end2,
          direction
        });
      }
    },
    [internalSelectionStart, internalSelectionEnd]
  );
  if (selection === null) {
    return null;
  }
  const { start, end } = selection;
  if (start === null || end === null) {
    return null;
  }
  const center = { x: cx, y: cy };
  const innerRadius = radius;
  const outerRadius = radius + 10;
  const length = getSubsequenceLength(selection, annotatedSequence.length);
  const [startIdx, endIdx] = [
    (_a = annotatedSequence.at(0)) == null ? void 0 : _a.index,
    (_b = annotatedSequence.at(-1)) == null ? void 0 : _b.index
  ];
  if (startIdx === void 0 || endIdx === void 0) {
    console.error("CircularViewer: sequence has no indices");
    return null;
  }
  const offset2 = start - startIdx;
  const seqLength = annotatedSequence.length;
  const arc = genArc({
    center,
    innerRadius,
    largeArc: length > seqLength / 2,
    length,
    offset: offset2,
    outerRadius,
    seqLength
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      d: arc,
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) });
};
const LinearAnnotationGutter = ({
  stackedAnnotations,
  sequence,
  containerClassName
}) => {
  const stacks = [];
  stackedAnnotations.forEach((ann) => {
    stacks[ann.stack] = stacks[ann.stack] || [];
    stacks[ann.stack].push(ann);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames(
        "grid-rows-auto block grid grid-cols-1 gap-1",
        containerClassName
      ),
      children: stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-8", children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation,
          sequence,
          stackIdx
        },
        `annotation-${annotation.text}-${annotation.start}-${annotation.end}-${annotation.direction}`
      )) }, `annotation-stack-${stackIdx}`))
    }
  );
};
const LinearAnnotation = ({
  annotation,
  sequence,
  stackIdx
}) => {
  const annotationSpansSeam = annotation.start > annotation.end;
  if (annotationSpansSeam) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation: {
            ...annotation,
            end: sequence.length,
            onClick: () => {
              var _a;
              (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
            }
          },
          sequence,
          stackIdx
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation: {
            ...annotation,
            start: 0,
            onClick: () => {
              var _a;
              (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
            }
          },
          sequence,
          stackIdx
        }
      )
    ] });
  }
  const annotationRectangleWidthPerc = getSubsequenceLength(annotation, sequence.length) / sequence.length * 100;
  const xPerc = Math.min(annotation.start, annotation.end) / sequence.length * 100;
  const forwardClipPath = "polygon(0 0, 90% 0, 100% 50%, 90% 100%, 0 100%)";
  const reverseClipPath = "polygon(0 50%, 10% 0, 100% 0, 100% 100%, 10% 100%)";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "group absolute",
      style: {
        marginLeft: `${xPerc}%`,
        width: `${annotationRectangleWidthPerc}%`
      },
      onClick: () => {
        var _a;
        (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classNames(
              "px-2",
              annotation.direction === "forward" ? "text-left" : "text-right",
              annotation.className
            ),
            style: {
              clipPath: annotation.direction === "forward" ? forwardClipPath : reverseClipPath
            },
            children: annotation.text
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: classNames(
              "absolute left-1/2 z-10 hidden -translate-x-1/2 translate-y-4 flex-col rounded-md px-2 py-1 text-sm group-hover:flex",
              annotation.className
            ),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.text }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.type })
            ]
          }
        )
      ]
    }
  );
};
const MISMATCH_DIST_PERC_THRESHOLD = 0.01;
const LinearViewer = (props) => {
  const {
    sequences,
    selection,
    annotations,
    setSelection,
    onDoubleClick,
    selectionClassName,
    mismatchClassName,
    containerClassName,
    sequenceClassName,
    stackingFn
  } = props;
  const stackedAnnotations = useMemo(
    function memoize() {
      return stackingFn ? stackingFn(annotations) : stackAnnotationsNoOverlap(
        annotations,
        Math.max(...sequences.map((seq) => seq.length))
      );
    },
    [annotations]
  );
  const annotatedSequences = useMemo(
    function memoize() {
      return sequences.map(
        (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations })
      );
    },
    [sequences, stackedAnnotations]
  );
  const baseSequence = annotatedSequences[0];
  const selectionRef = useRef(null);
  const SVG_WIDTH = 500;
  const SVG_HEIGHT = sequences.length * 10 + 10;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClassName || "", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref: selectionRef,
        className: classNames("select-none font-thin"),
        onDoubleClick,
        viewBox: `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`,
        width: "100%",
        height: "100%",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: annotatedSequences.map((sequence, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SequenceLine,
            {
              sequenceClassName,
              baseSequence: sequence,
              alignedSequences: annotatedSequences.filter((_, j) => j !== i),
              sequenceIdx: i,
              mismatchClassName
            }
          ) }, `Sequence-${i}`)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            LinearSelection,
            {
              selectionClassName,
              selectionRef,
              selection,
              setSelection,
              sequence: baseSequence
            }
          )
        ]
      }
    ),
    stackedAnnotations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      LinearAnnotationGutter,
      {
        containerClassName: "",
        stackedAnnotations,
        sequence: baseSequence
      }
    )
  ] });
};
const SequenceLine = ({
  baseSequence,
  sequenceIdx,
  alignedSequences,
  sequenceClassName,
  mismatchClassName
}) => {
  var _a, _b;
  const start = (_a = baseSequence[0]) == null ? void 0 : _a.index;
  if (start === void 0) {
    throw new Error(`Sequence must have at least one base ${baseSequence}`);
  }
  const end = (_b = baseSequence[baseSequence.length - 1]) == null ? void 0 : _b.index;
  if (end === void 0) {
    throw new Error(`Sequence must have at least one base ${baseSequence}`);
  }
  let maxEnd = end;
  alignedSequences.forEach((alignedSequence) => {
    var _a2;
    const otherEnd = (_a2 = alignedSequence.at(alignedSequence.length - 1)) == null ? void 0 : _a2.index;
    if (otherEnd === void 0) {
      throw new Error(
        `otherSequence must have at least one base ${alignedSequence}`
      );
    }
    if (otherEnd > maxEnd) {
      maxEnd = otherEnd;
    }
  });
  const startPerc = start / maxEnd;
  const endPerc = end / maxEnd;
  const mismatches = baseSequence.filter((base) => {
    const rootBase = baseSequence.at(base.index);
    return rootBase && rootBase.base !== base.base;
  });
  mismatchClassName = mismatchClassName ?? function mismatchClassName2(mismatch) {
    if (mismatch.base === "-") {
      return "fill-black stroke-black opacity-80";
    } else {
      return "dark:fill-red-600 dark:stroke-red-600 fill-red-700 stroke-red-700";
    }
  };
  let lastXPerc = -1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("", sequenceClassName({ sequenceIdx })),
        x1: `${startPerc * 100}%`,
        y1: `${sequenceIdx * 10 + 10}`,
        x2: `${endPerc * 100}%`,
        y2: `${sequenceIdx * 10 + 10}`,
        strokeWidth: 5,
        stroke: "currentColor"
      }
    ),
    mismatches.map((base) => {
      const xPerc = base.index / maxEnd * 100;
      const width = Math.max(1 / baseSequence.length * 100, 0.01);
      const diff = xPerc - lastXPerc;
      if (diff < MISMATCH_DIST_PERC_THRESHOLD) {
        return null;
      }
      lastXPerc = xPerc;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "g",
        {
          className: classNames((mismatchClassName == null ? void 0 : mismatchClassName(base)) || "bg-red-400"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "line",
            {
              x1: `${xPerc - width / 2}%`,
              y1: `${sequenceIdx * 10 + 10}`,
              x2: `${xPerc + width / 2}%`,
              y2: `${sequenceIdx * 10 + 10}`,
              strokeWidth: 5
            }
          )
        },
        `sequence-${sequenceIdx}-mismatch-${base.index}`
      );
    })
  ] });
};
const LinearSelection = ({
  selection,
  selectionRef,
  setSelection,
  sequence,
  selectionClassName
}) => {
  const {
    start: internalSelectionStart,
    end: internalSelectionEnd,
    direction: internalDirection
  } = useLinearSelectionRect({ ref: selectionRef });
  useEffect(
    function propagateSelectionUp() {
      var _a;
      if (selectionRef.current && internalSelectionStart && internalSelectionEnd) {
        const svgWidth = (_a = selectionRef.current) == null ? void 0 : _a.getBoundingClientRect().width;
        const start2 = Math.floor(
          internalSelectionStart.x / svgWidth * sequence.length
        );
        const end2 = Math.floor(
          internalSelectionEnd.x / svgWidth * sequence.length
        );
        if (selection == null || start2 === end2) {
          setSelection({
            start: start2,
            end: start2 + 1,
            direction: internalDirection
          });
          return;
        } else {
          setSelection({ start: start2, end: end2, direction: internalDirection });
        }
      }
    },
    [internalSelectionStart, internalSelectionEnd]
  );
  if (!selection) {
    return null;
  }
  const { start, end } = selection;
  let firstRectStart = Math.min(start, end) / sequence.length * 100;
  let firstRectWidth = getSubsequenceLength(selection, sequence.length) / sequence.length * 100;
  let secondRectStart = null;
  let secondRectWidth = null;
  const selectionSpansSeam = selection.start > selection.end;
  if (selectionSpansSeam) {
    firstRectStart = 0;
    firstRectWidth = end / sequence.length * 100;
    secondRectStart = start / sequence.length * 100;
    secondRectWidth = (sequence.length - start) / sequence.length * 100;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "g",
    {
      className: classNames(
        "fill-current stroke-current",
        selectionClassName == null ? void 0 : selectionClassName(selection)
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: `${firstRectStart}%`,
            width: `${firstRectWidth}%`,
            y: `0%`,
            height: `100%`,
            fill: "currentColor",
            fillOpacity: 0.2,
            strokeWidth: 1.5
          }
        ),
        secondRectStart && secondRectWidth && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: `${secondRectStart}%`,
            width: `${secondRectWidth}%`,
            y: `0%`,
            height: `100%`,
            fill: "currentColor",
            fillOpacity: 0.2,
            strokeWidth: 1.5
          }
        )
      ]
    }
  );
};
function clamp$1(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      var _a;
      const { scope, children, ...context } = props;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const value = React.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
var Slot = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React.Children.count(newElement) > 1) return React.Children.only(null);
        return React.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    const props2 = mergeProps(slotProps, children.props);
    if (children.type !== React.Fragment) {
      props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
    }
    return React.cloneElement(children, props2);
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return React.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React__default.useRef(null);
    const itemMap = React__default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React__default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React__default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React__default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = React.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  React.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React.useContext(DismissableLayerContext);
    const [node, setNode] = React.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React.forwardRef((props, forwardedRef) => {
  const context = React.useContext(DismissableLayerContext);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React.useRef(false);
  const handleClickRef = React.useRef(() => {
  });
  React.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = React.useRef(false);
  React.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count$1 = 0;
function useFocusGuards() {
  React.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$1++;
    return () => {
      if (count$1 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$1--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : () => {
};
var useReactId = React["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return id ? `radix-${id}` : "";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? useLayoutEffect : useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1 = React.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root = Arrow$1;
function useSize(element) {
  const [size2, setSize] = React.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME$1 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1);
var PopperContent = React.forwardRef(
  (props, forwardedRef) => {
    var _a, _b, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$1, __scopePopper);
    const [content, setContent] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = React.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a = middlewareData.arrow) == null ? void 0 : _a.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$1;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$1 = "Portal";
var Portal$1 = React.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? ReactDOM__default.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$1.displayName = PORTAL_NAME$1;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = React.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  React.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
function usePrevious(value) {
  const ref = React.useRef({ value, previous: value });
  return React.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var NAME = "VisuallyHidden";
var VisuallyHidden = React.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id = React.useState(idCounter++)[0];
  var Style2 = React.useState(styleSingleton)[0];
  var lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope,
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  const [trigger, setTrigger] = React.useState(null);
  const [valueNode, setValueNode] = React.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME = "SelectTrigger";
var SelectTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection(__scopeSelect);
    const pointerTypeRef = React.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "SelectContent";
var SelectContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);
    const [fragment, setFragment] = React.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME, __scopeSelect);
    const [content, setContent] = React.useState(null);
    const [viewport, setViewport] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React.useState(null);
    const [selectedItemText, setSelectedItemText] = React.useState(
      null
    );
    const getItems = useCollection(__scopeSelect);
    const [isPositioned, setIsPositioned] = React.useState(false);
    const firstValidItemFoundRef = React.useRef(false);
    React.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = React.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    React.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a = triggerPointerDownPosRef.current) == null ? void 0 : _a.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a;
              (_a = context.trigger) == null ? void 0 : _a.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection(__scopeSelect);
  const shouldExpandOnScrollRef = React.useRef(false);
  const shouldRepositionRef = React.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp$1(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp$1(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a;
        return (_a = contentContext.itemRefCallback) == null ? void 0 : _a.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId();
    const pointerTypeRef = React.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a;
                  if (event.currentTarget === document.activeElement) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a;
                  const isTypingAhead = ((_a = contentContext.searchRef) == null ? void 0 : _a.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a;
        return (_a = contentContext.itemTextRefCallback) == null ? void 0 : _a.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React.useRef(null);
  const getItems = useCollection(__scopeSelect);
  const clearAutoScrollTimer = React.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    var _a;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a;
        (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow";
var SelectArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(ARROW_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = React.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = React.useRef("");
  const timerRef = React.useRef(0);
  const handleTypeaheadSearch = React.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root2 = Select$1;
var Trigger = SelectTrigger$1;
var Value = SelectValue$1;
var Icon$1 = SelectIcon;
var Portal = SelectPortal;
var Content2 = SelectContent$1;
var Viewport = SelectViewport;
var Label = SelectLabel$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator = SelectSeparator$1;
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size2,
        height: size2,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = forwardRef(
    ({ className, ...props }, ref) => createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Copy = createLucideIcon("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
const Select = Root2;
const SelectValue = Value;
const SelectTrigger = React.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Trigger,
  {
    ref,
    className: cn(
      "ring-offset-background focus:ring-ring flex h-4 w-full items-center justify-between whitespace-nowrap rounded-md bg-transparent px-3 py-2 text-xs focus:outline-none focus:ring-1 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      "dark:placeholder-text-zinc-600 text-black placeholder:text-noir-400 dark:text-white",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "ml-1 h-4 w-4 text-black opacity-50 dark:text-white" }) })
    ]
  }
));
SelectTrigger.displayName = Trigger.displayName;
const SelectScrollUpButton = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollUpButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-4 w-4" })
  }
));
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollDownButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4" })
  }
));
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = React.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Content2,
  {
    ref,
    className: cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
      position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      className
    ),
    position,
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Viewport,
        {
          className: cn(
            "p-1",
            position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
    ]
  }
) }));
SelectContent.displayName = Content2.displayName;
const SelectLabel = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label,
  {
    ref,
    className: cn("px-2 py-1.5 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel.displayName = Label.displayName;
const SelectItem = React.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Item,
  {
    ref,
    className: cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
    ]
  }
));
SelectItem.displayName = Item.displayName;
const SelectSeparator = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator,
  {
    ref,
    className: cn("bg-muted -mx-1 my-1 h-px", className),
    ...props
  }
));
SelectSeparator.displayName = Separator.displayName;
const CopyButton = ({
  label,
  buttonClassName,
  logoClassName,
  textToCopy,
  disabled
}) => {
  const [logo, setLogo] = useState(
    /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) })
  );
  const [internalLabel, setInternalLabel] = useState(label);
  const onClipboardCopy = () => {
    setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: cn("h-3 w-3", logoClassName) }));
    setInternalLabel("Copied!");
    setTimeout(() => {
      setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) }));
      setInternalLabel(label);
    }, 1e3);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      "aria-label": "Copy to clipboard",
      disabled,
      className: cn(
        "flex items-center gap-2 disabled:cursor-not-allowed disabled:text-noir-400 dark:text-noir-100 dark:disabled:text-zinc-600",
        buttonClassName
      ),
      onClick: () => {
        const text = textToCopy();
        navigator.clipboard.writeText(text);
        onClipboardCopy();
      },
      children: [
        logo,
        internalLabel
      ]
    }
  );
};
const SequenceViewer = ({
  sequences,
  annotations,
  selection,
  setSelection,
  containerClassName,
  charClassName,
  selectionClassName,
  hideMetadataBar,
  noValidate
}) => {
  const [hoveredPosition, setHoveredPosition] = useState(null);
  const [seqIdxToCopy, setSeqIdxToCopy] = useState(0);
  const [activeAnnotation, setActiveAnnotation] = useState(
    null
  );
  const stackedAnnotations = useMemo(
    function memoize() {
      return stackAnnotationsNoOverlap(
        annotations,
        Math.max(...sequences.map((seq) => seq.length))
      );
    },
    [annotations]
  );
  const annotatedSequences = useMemo(
    function memoize() {
      return sequences.map(
        (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations, noValidate })
      );
    },
    [sequences, stackedAnnotations]
  );
  const memoizedSeqContent = useMemo(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SeqContent,
      {
        annotatedSequences,
        selection,
        setSelection,
        setHoveredPosition,
        setActiveAnnotation,
        stackedAnnotations,
        charClassName,
        selectionClassName
      }
    );
  }, [annotatedSequences, selection, stackedAnnotations]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "relative isolate flex flex-wrap",
        containerClassName
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SeqMetadataBar,
          {
            hoveredPosition,
            activeAnnotation,
            className: classNames("sticky inset-x-0 top-0 z-[3] w-full px-2 py-1 backdrop-blur-md", hideMetadataBar ? "hidden" : ""),
            annotatedSequences,
            charClassName,
            seqIdxToCopy,
            setSeqIdxToCopy,
            selection
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap px-2", children: memoizedSeqContent })
      ]
    }
  ) });
};
const SeqContent = ({
  annotatedSequences,
  selection,
  setSelection,
  setHoveredPosition,
  setActiveAnnotation,
  stackedAnnotations,
  charClassName,
  selectionClassName
}) => {
  const mouseDown = useRef(false);
  const indicesClassName = ({
    base,
    sequenceIdx
  }) => {
    const isNotFirstSeq = sequenceIdx !== 0;
    const isNotMultipleOfTen = base.index % 10 !== 0;
    if (isNotFirstSeq || isNotMultipleOfTen) {
      return "opacity-0";
    }
    return classNames(
      "text-xs z-1",
      // don't allow selection of indices
      "dark:group-hover:text-noir-300 group-hover:text-noir-800",
      baseInSelection({
        baseIndex: base.index,
        selection,
        sequenceLength: annotatedSequences[sequenceIdx].length
      }) ? "text-brand-700 dark:text-brand-300" : "text-noir-400 dark:text-noir-600"
    );
  };
  const handleMouseUp = () => {
    mouseDown.current = false;
  };
  useEffect(function addMouseUpListener() {
    document.addEventListener("mouseup", () => {
      handleMouseUp();
    });
    return function removeMouseUpListener() {
      document.removeEventListener("mouseup", () => {
        handleMouseUp();
      });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: annotatedSequences[0].map(({ index: baseIdx }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: classNames(
          "relative mt-4 flex flex-col justify-between",
          "group hover:bg-noir-200 dark:hover:bg-noir-600"
        ),
        children: [
          annotatedSequences.map(
            (sequence, sequenceIdx) => {
              const base = sequence.find(
                (base2) => base2.index === baseIdx
              ) || { base: " ", annotations: [], index: baseIdx };
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: classNames("whitespace-pre text-center"),
                  onMouseEnter: () => {
                    setHoveredPosition(base.index);
                    if (mouseDown.current && selection) {
                      setSelection({
                        ...selection,
                        end: base.index
                      });
                    }
                  },
                  onMouseLeave: () => setHoveredPosition(null),
                  onMouseDown: () => {
                    mouseDown.current = true;
                    setSelection({
                      start: base.index,
                      end: base.index,
                      direction: "forward"
                    });
                  },
                  onMouseUp: handleMouseUp,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CharComponent,
                      {
                        char: `| ${base.index}`,
                        index: baseIdx,
                        charClassName: classNames(
                          "absolute -top-4 left-0",
                          "group-hover:text-brand-200 border-b border-noir-600 group-hover:border-noir-300",
                          indicesClassName({
                            base,
                            sequenceIdx
                          })
                        )
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CharComponent,
                      {
                        char: base.base,
                        index: baseIdx,
                        charClassName: classNames(
                          charClassName({
                            base,
                            sequenceIdx
                          }),
                          baseInSelection({
                            baseIndex: baseIdx,
                            selection,
                            sequenceLength: annotatedSequences[sequenceIdx].length
                          }) && base.base !== " " && selectionClassName
                        )
                      }
                    )
                  ]
                },
                `sequence-${sequenceIdx}-base-${baseIdx}`
              );
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SequenceAnnotation,
            {
              annotations: stackedAnnotations,
              index: baseIdx,
              maxAnnotationStack: Math.max(
                1,
                Math.max(...stackedAnnotations.map((ann) => ann.stack))
              ),
              setHoveredPosition,
              setActiveAnnotation,
              maxSequenceLength: Math.max(
                ...annotatedSequences.map((seq) => seq.length)
              )
            }
          )
        ]
      },
      `base-${baseIdx}`
    );
  }) });
};
const SeqMetadataBar = ({
  hoveredPosition,
  activeAnnotation,
  annotatedSequences,
  charClassName,
  seqIdxToCopy,
  setSeqIdxToCopy,
  selection,
  className
}) => {
  const annotationDisplay = activeAnnotation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: classNames(
        "flex gap-2 rounded-full px-2 py-px text-xs !opacity-100",
        "ml-auto",
        activeAnnotation.className
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Label: ",
          activeAnnotation.text
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Type: ",
          activeAnnotation.type
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Direction: ",
          activeAnnotation.direction
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "from ",
          activeAnnotation.start,
          " - ",
          activeAnnotation.end
        ] })
      ]
    }
  ) : null;
  const positionDisplay = /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "min-w-16 text-xs text-black dark:text-white", children: [
    "Pos: ",
    hoveredPosition ?? 0
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "flex h-8 items-center gap-1 py-1 text-xs",
        className
      ),
      children: [
        positionDisplay,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CopyDisplay,
          {
            annotatedSequences,
            charClassName,
            seqIdxToCopy,
            setSeqIdxToCopy,
            selection
          }
        ),
        annotationDisplay
      ]
    }
  );
};
const SequenceAnnotation = ({
  annotations,
  maxAnnotationStack,
  index: index2,
  setHoveredPosition,
  setActiveAnnotation,
  maxSequenceLength
}) => {
  const orderedAnnotations = annotations.sort((a, b) => a.stack - b.stack);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: " ",
      onMouseEnter: () => setHoveredPosition(index2),
      onMouseLeave: () => setHoveredPosition(null),
      children: [...Array(maxAnnotationStack).keys()].map((i) => {
        const annotation = orderedAnnotations.filter(
          (ann) => baseInSelection({
            baseIndex: index2,
            selection: ann,
            sequenceLength: maxSequenceLength
          })
        ).find((ann) => ann.stack === i);
        if (annotation) {
          if (!baseInSelection({
            baseIndex: index2,
            selection: annotation,
            sequenceLength: maxSequenceLength
          })) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-3 border-b-2 border-noir-100 opacity-10 "
              },
              `annotation-${index2}-${i}`
            );
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: classNames(
                "group/annotation h-3 border-black group-hover/annotation:border",
                annotation.className
              ),
              onClick: () => {
                var _a;
                return (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, {
                  start: annotation.start,
                  end: annotation.end,
                  diection: annotation.direction
                });
              },
              onMouseEnter: () => setActiveAnnotation(annotation),
              onMouseLeave: () => setActiveAnnotation(null)
            },
            `annotation-${index2}-${i}`
          );
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3" }, `placeholder-${index2}-${i}`);
        }
      })
    },
    `annotation-${index2}`
  );
};
const CharComponent = ({ char, charClassName }) => {
  const sharedClassName = "font-mono select-none";
  if (char === " ") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "opacity-20"), children: "." });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "mr-px"), children: char });
};
const CopyDisplay = ({
  seqIdxToCopy,
  setSeqIdxToCopy,
  annotatedSequences,
  charClassName,
  selection
}) => {
  const getStringToCopy = () => {
    if (!selection) {
      return;
    }
    const seq = annotatedSequences[seqIdxToCopy];
    const stringToCopy = seq.filter(
      (base) => baseInSelection({
        baseIndex: base.index,
        selection,
        sequenceLength: annotatedSequences[seqIdxToCopy].length
      })
    ).map((base) => base.base).join("");
    return stringToCopy;
  };
  useEffect(function mountCopyHandler() {
    const copyHandler = (e) => {
      var _a;
      const stringToCopy = getStringToCopy();
      if (!stringToCopy) {
        return;
      }
      (_a = e.clipboardData) == null ? void 0 : _a.setData("text/plain", stringToCopy);
      alert("Copied to clipboard!");
      e.preventDefault();
    };
    document.addEventListener("copy", copyHandler);
    return function unmountCopyHandler() {
      document.removeEventListener("copy", copyHandler);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        value: seqIdxToCopy.toString(),
        onValueChange: (value) => setSeqIdxToCopy(parseInt(value)),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-fit", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            SelectValue,
            {
              className: charClassName({
                base: { base: "A", annotations: [], index: 0 },
                sequenceIdx: seqIdxToCopy
              }),
              children: [
                "Sequence ",
                seqIdxToCopy + 1
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { className: "bg-white dark:bg-black", children: annotatedSequences.map((_, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            SelectItem,
            {
              value: idx.toString(),
              className: charClassName({
                base: { base: "A", annotations: [], index: 0 },
                sequenceIdx: idx
              }),
              children: [
                "Sequence ",
                idx + 1,
                " "
              ]
            },
            `sequence-${idx}`
          )) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CopyButton,
      {
        textToCopy: () => getStringToCopy() ?? "",
        label: "",
        disabled: !selection
      }
    )
  ] });
};
const ReferenceTicks = ({
  sequence,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("overflow-hiddentext-white flex", className), children: sequence.map((nucl, i) => {
    const showTicks = nucl.base !== "-" && (nucl.index + 1) % 10 === 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "relative flex h-12 flex-col items-end justify-end",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: classNames(
                "font-mono ",
                "absolute bottom-0 left-0 right-0",
                showTicks ? "opacity-100" : "opacity-0",
                nucl.base === "G" && "text-red-500",
                nucl.base === "A" && "text-yellow-500",
                nucl.base === "T" && "text-green-500",
                nucl.base === "C" && "text-blue-500"
              ),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs", children: [
                  " ",
                  nucl.index + 1
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mx-auto text-xs", children: "|" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("mr-px font-mono opacity-0"), children: nucl.base })
        ]
      },
      `base-${i}-index-wrapper`
    );
  }) });
};
export {
  CircularViewer,
  GapSchema,
  GenbankFeatureSchema,
  LinearAnnotationGutter,
  LinearViewer,
  ReferenceTicks,
  SequenceViewer,
  SpaceSchema,
  StopSchema,
  UnknownSchema,
  aaSchema,
  angleSchema,
  annotatedBaseSchema,
  annotatedSequenceSchema,
  annotationSchema,
  annotationTypeSchema,
  annotationsHaveOverlap,
  anythingToAnnotatedSequences,
  ariadneSelectionSchema,
  baseInSelection,
  coorSchema,
  genbankFeaturesToAnnotations,
  genbankToAnnotatedSequence,
  getAnnotatedSequence,
  getClassNameFromFeatureType,
  getComplement,
  getStackedAnnotations,
  getSubsequenceLength,
  inRange,
  nuclSchema,
  parseFasta,
  parseFastq,
  parseGenbank,
  safeAnythingToAnnotatedSequences,
  stackAnnotationsNoOverlap,
  stackAnnsByType,
  stackElements,
  stackedAnnotationSchema,
  stringToAnnotatedSequence,
  useCircularSelectionRect,
  useLinearSelectionRect,
  zipArrays
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibml0cm8tdWkuZXMuanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9DaXJjdWxhclZpZXdlci9jaXJjdWxhclV0aWxzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2dlbmJhbmstcGFyc2VyL3NyYy91dGlscy9tb250aHMuanMiLCIuLi9ub2RlX21vZHVsZXMvZ2VuYmFuay1wYXJzZXIvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9zY2hlbWFzLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9nZW5iYW5rVXRpbHMudHMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL3V0aWxzLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9ob29rcy91c2VTdGF0ZVJlZi50cyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvaG9va3MvdXNlU2VsZWN0aW9uLnRzIiwiLi4vc3JjL3V0aWxzL3N0cmluZ1V0aWxzLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9DaXJjdWxhclZpZXdlci9DaXJjdWxhckFubm90YXRpb25zL0NpcmN1bGFyQW5ub3RhdGlvbi50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0NpcmN1bGFyVmlld2VyL0NpcmN1bGFyQW5ub3RhdGlvbnMvQ2lyY3VsYXJBbm5vdGF0aW9uR3V0dGVyLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvQ2lyY3VsYXJJbmRleC9DaXJjdWxhckluZGV4LnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvQ2lyY3VsYXJWaWV3ZXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9MaW5lYXJWaWV3ZXIvTGluZWFyQW5ub3RhdGlvbkd1dHRlci50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0xpbmVhclZpZXdlci9MaW5lYXJWaWV3ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9udW1iZXIvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3ByaW1pdGl2ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29udGV4dC9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1zbG90L2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1jb2xsZWN0aW9uL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1kaXJlY3Rpb24vZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZi9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWVzY2FwZS1rZXlkb3duL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1kaXNtaXNzYWJsZS1sYXllci9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtZm9jdXMtZ3VhcmRzL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1mb2N1cy1zY29wZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3QvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWlkL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanMiLCIuLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCIuLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWFycm93L2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2Utc2l6ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcG9wcGVyL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1wb3J0YWwvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1jb250cm9sbGFibGUtc3RhdGUvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1wcmV2aW91cy9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdmlzdWFsbHktaGlkZGVuL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2FyaWEtaGlkZGVuL2Rpc3QvZXMyMDE1L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC1iYXIvZGlzdC9lczIwMTUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1jYWxsYmFjay1yZWYvZGlzdC9lczIwMTUvYXNzaWduUmVmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1jYWxsYmFjay1yZWYvZGlzdC9lczIwMTUvdXNlUmVmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1jYWxsYmFjay1yZWYvZGlzdC9lczIwMTUvdXNlTWVyZ2VSZWYuanMiLCIuLi9ub2RlX21vZHVsZXMvdXNlLXNpZGVjYXIvZGlzdC9lczIwMTUvbWVkaXVtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1zaWRlY2FyL2Rpc3QvZXMyMDE1L2V4cG9ydHMuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9tZWRpdW0uanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9VSS5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtbm9uY2UvZGlzdC9lczIwMTUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3R5bGUtc2luZ2xldG9uL2Rpc3QvZXMyMDE1L3NpbmdsZXRvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1zdHlsZS1zaW5nbGV0b24vZGlzdC9lczIwMTUvaG9vay5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1zdHlsZS1zaW5nbGV0b24vZGlzdC9lczIwMTUvY29tcG9uZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyL2Rpc3QvZXMyMDE1L3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyL2Rpc3QvZXMyMDE1L2NvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L2FnZ3Jlc2l2ZUNhcHR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9oYW5kbGVTY3JvbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9TaWRlRWZmZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvc2lkZWNhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L0NvbWJpbmF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1zZWxlY3QvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9JY29uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9jcmVhdGVMdWNpZGVJY29uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jaGVjay5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2hldnJvbi1kb3duLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jaGV2cm9uLXVwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jb3B5LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvdWkvc2VsZWN0LnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL3VpL2NvcHktYnV0dG9uLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvU2VxdWVuY2VWaWV3ZXIvU2VxdWVuY2VWaWV3ZXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9SZWZlcmVuY2VUaWNrcy9SZWZlcmVuY2VUaWNrcy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3ZhciBmPXJlcXVpcmUoXCJyZWFjdFwiKSxrPVN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLGw9U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLG09T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxuPWYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIscD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gcShjLGEsZyl7dmFyIGIsZD17fSxlPW51bGwsaD1udWxsO3ZvaWQgMCE9PWcmJihlPVwiXCIrZyk7dm9pZCAwIT09YS5rZXkmJihlPVwiXCIrYS5rZXkpO3ZvaWQgMCE9PWEucmVmJiYoaD1hLnJlZik7Zm9yKGIgaW4gYSltLmNhbGwoYSxiKSYmIXAuaGFzT3duUHJvcGVydHkoYikmJihkW2JdPWFbYl0pO2lmKGMmJmMuZGVmYXVsdFByb3BzKWZvcihiIGluIGE9Yy5kZWZhdWx0UHJvcHMsYSl2b2lkIDA9PT1kW2JdJiYoZFtiXT1hW2JdKTtyZXR1cm57JCR0eXBlb2Y6ayx0eXBlOmMsa2V5OmUscmVmOmgscHJvcHM6ZCxfb3duZXI6bi5jdXJyZW50fX1leHBvcnRzLkZyYWdtZW50PWw7ZXhwb3J0cy5qc3g9cTtleHBvcnRzLmpzeHM9cTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcbi8vIG9wdC1pbiBiZWhhdmlvciBmb3IgYmV0dGVyIG1lc3NhZ2VzIGJ1dCB0aGF0IHdlIHdvbid0IHN0b3Bcbi8vIGdpdmluZyB5b3Ugd2FybmluZ3MgaWYgeW91IHVzZSBwcm9kdWN0aW9uIGFwaXMuXG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsImltcG9ydCB7IEFuZ2xlLCBBcmlhZG5lU2VsZWN0aW9uLCBDb29yIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbi8qKlxuICogVGFrZW4gZnJvbSBzZXF2aXpcbiAqIEdpdmVuIGFuIGlubmVyIGFuZCBvdXRlciByYWRpdXMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50LCByZXR1cm4gdGhlXG4gKiBwYXRoIGZvciBhbiBhcmMgdGhhdCBjaXJjbGVzIHRoZSBwbGFzbWlkLiBUaGUgb3B0aW9uYWwgcGFyYW10ZXJzIHN3ZWVwRldEIGFuZCBzd2VlcFJFVlxuICogYXJlIG5lZWRlZCBmb3Igc2VsZWN0aW9uIGFyY3MgKHdoZXJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFyYyBpc24ndCBrbm93biBiZWZvcmVoYW5kKVxuICogYW5kIGFycm93RldEIGFuZCBhcnJvd1JFViBhcmUgbmVlZGVkIGZvciBhbm5vdGF0aW9ucywgd2hlcmUgdGhlcmUgbWF5IGJlIGRpcmVjdGlvbmFsaXR5XG4gKi9cbmV4cG9ydCBjb25zdCBnZW5BcmMgPSAoe1xuICBjZW50ZXIsXG4gIGlubmVyUmFkaXVzLFxuICBsYXJnZUFyYyxcbiAgbGVuZ3RoLFxuICBvZmZzZXQsXG4gIG91dGVyUmFkaXVzLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGNlbnRlcjogQ29vcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgbGFyZ2VBcmM6IGJvb2xlYW47XG4gIGxlbmd0aDogbnVtYmVyO1xuICBvZmZzZXQ6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogc3RyaW5nID0+IHtcbiAgY29uc3QgbGVmdEJvdHRvbSA9IGZpbmRDb29yKHtcbiAgICBpbmRleDogb2Zmc2V0LFxuICAgIHJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgY2VudGVyLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIGNvbnN0IGxlZnRUb3AgPSBmaW5kQ29vcih7XG4gICAgaW5kZXg6IG9mZnNldCxcbiAgICByYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgIGNlbnRlcixcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICBjb25zdCByaWdodEJvdHRvbSA9IGZpbmRDb29yKHtcbiAgICBpbmRleDogbGVuZ3RoICsgb2Zmc2V0LFxuICAgIHJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgY2VudGVyLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIGNvbnN0IHJpZ2h0VG9wID0gZmluZENvb3Ioe1xuICAgIGluZGV4OiBsZW5ndGggKyBvZmZzZXQsXG4gICAgcmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICBjZW50ZXIsXG4gICAgc2VxTGVuZ3RoLFxuICB9KTtcbiAgY29uc3Qgc0ZsYWdGID0gMTtcbiAgY29uc3Qgc0ZsYWdSID0gMDtcblxuICBjb25zdCBsQXJjID0gbGFyZ2VBcmMgPyAxIDogMDtcblxuICByZXR1cm4gYE0gJHtyaWdodEJvdHRvbS54fSAke3JpZ2h0Qm90dG9tLnl9XG4gICAgICBBICR7aW5uZXJSYWRpdXN9ICR7aW5uZXJSYWRpdXN9LCAwLCAke2xBcmN9LCAke3NGbGFnUn0sICR7bGVmdEJvdHRvbS54fSAke2xlZnRCb3R0b20ueX1cbiAgICAgIEwgJHtsZWZ0Qm90dG9tLnh9ICR7bGVmdEJvdHRvbS55fVxuICAgICAgTCAke2xlZnRUb3AueH0gJHtsZWZ0VG9wLnl9XG4gICAgICBBICR7b3V0ZXJSYWRpdXN9ICR7b3V0ZXJSYWRpdXN9LCAwLCAke2xBcmN9LCAke3NGbGFnRn0sICR7cmlnaHRUb3AueH0gJHtyaWdodFRvcC55fVxuICAgICAgWmA7XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIGluZGV4IGFsb25nIHRoZSBwbGFzbWlkIGFuZCBpdHMgcmFkaXVzLCBmaW5kIHN2ZyBjb29yZGluYXRlXG4gKiBmcm9tIHNlcXZpelxuICovXG5leHBvcnQgY29uc3QgZmluZENvb3IgPSAoe1xuICBpbmRleCxcbiAgcmFkaXVzLFxuICBjZW50ZXIsXG4gIHNlcUxlbmd0aCxcbn06IHtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGNlbnRlcjogQ29vcjtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogQ29vciA9PiB7XG4gIGNvbnN0IGxlbmd0aFBlcmMgPSBpbmRleCAvIHNlcUxlbmd0aDtcbiAgY29uc3QgbGVuZ3RoUGVyY0NlbnRlcmVkID0gbGVuZ3RoUGVyYyAtIDAuMjU7XG4gIGNvbnN0IHJhZGlhbnMgPSBsZW5ndGhQZXJjQ2VudGVyZWQgKiBNYXRoLlBJICogMjtcbiAgY29uc3QgeEFkanVzdCA9IE1hdGguY29zKHJhZGlhbnMpICogcmFkaXVzO1xuICBjb25zdCB5QWRqdXN0ID0gTWF0aC5zaW4ocmFkaWFucykgKiByYWRpdXM7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBjZW50ZXIueCArIHhBZGp1c3QsXG4gICAgeTogY2VudGVyLnkgKyB5QWRqdXN0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRJbmRleEZyb21Db29yID0gKHtcbiAgY29vcixcbiAgY2VudGVyLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGNvb3I6IENvb3I7XG4gIGNlbnRlcjogQ29vcjtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogbnVtYmVyID0+IHtcbiAgY29uc3QgeCA9IGNvb3IueCAtIGNlbnRlci54O1xuICBjb25zdCB5ID0gY29vci55IC0gY2VudGVyLnk7XG4gIGNvbnN0IHJhZGlhbnMgPSBNYXRoLmF0YW4yKHksIHgpO1xuICBjb25zdCBsZW5ndGhQZXJjID0gcmFkaWFucyAvIChNYXRoLlBJICogMikgKyAwLjI1O1xuICBjb25zdCByYXdCYXNlSWR4ID0gbGVuZ3RoUGVyYyAqIHNlcUxlbmd0aDtcbiAgLy8gaWYgd2UncmUgaW4gbmVnYXRpdmUgaW5kaWNlcywgY29udmVydCB0byB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZVxuICByZXR1cm4gTWF0aC5yb3VuZChyYXdCYXNlSWR4IDwgMCA/IHNlcUxlbmd0aCArIHJhd0Jhc2VJZHggOiByYXdCYXNlSWR4KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaW5kQW5nbGVGcm9tQ29vciA9ICh7XG4gIGNvb3IsXG4gIGNlbnRlcixcbn06IHtcbiAgY29vcjogQ29vcjtcbiAgY2VudGVyOiBDb29yO1xufSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHggPSBjb29yLnggLSBjZW50ZXIueDtcbiAgY29uc3QgeSA9IGNvb3IueSAtIGNlbnRlci55O1xuICBsZXQgcmFkaWFucyA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIGlmIChyYWRpYW5zIDwgMCkge1xuICAgIHJhZGlhbnMgPSByYWRpYW5zICsgTWF0aC5QSSAqIDI7XG4gIH1cbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZEFuZ2xlQmV0d2VlbkNvb3JzID0gKHtcbiAgY29vcjEsXG4gIGNvb3IyLFxuICBjZW50ZXIsXG59OiB7XG4gIGNvb3IxOiBDb29yO1xuICBjb29yMjogQ29vcjtcbiAgY2VudGVyOiBDb29yO1xufSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IGFuZ2xlMSA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogY29vcjEsIGNlbnRlciB9KTtcbiAgY29uc3QgYW5nbGUyID0gZmluZEFuZ2xlRnJvbUNvb3IoeyBjb29yOiBjb29yMiwgY2VudGVyIH0pO1xuICBjb25zdCBhbmdsZSA9IGFuZ2xlMiAtIGFuZ2xlMTtcbiAgcmV0dXJuIGFuZ2xlO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRJbmRleEZyb21BbmdsZSA9ICh7XG4gIGFuZ2xlLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGFuZ2xlOiBBbmdsZTtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogbnVtYmVyID0+IHtcbiAgLy8gemVybyBkZWdyZXNzIGlzIDI1JSBvZiB0aGUgc2VxdWVuY2UsIGFuZCB3ZSB3YW50IGtlZXAgZGVncmVlcyBiZXR3ZWVuIDAgYW5kIDM2MFxuICBsZXQgZWZmZWN0aXZlQW5nbGUgPSBhbmdsZS5kZWdyZWVzICsgOTA7XG4gIGlmIChlZmZlY3RpdmVBbmdsZSA8IDApIHtcbiAgICBlZmZlY3RpdmVBbmdsZSA9IDM2MCArIGVmZmVjdGl2ZUFuZ2xlO1xuICB9XG4gIGVmZmVjdGl2ZUFuZ2xlID0gZWZmZWN0aXZlQW5nbGUgJSAzNjA7XG4gIGNvbnN0IGFyY1BlcmMgPSBlZmZlY3RpdmVBbmdsZSAvIDM2MDtcblxuICBjb25zdCByYXdCYXNlSWR4ID0gYXJjUGVyYyAqIHNlcUxlbmd0aDtcbiAgcmV0dXJuIE1hdGgucm91bmQocmF3QmFzZUlkeCA8IDAgPyBzZXFMZW5ndGggKyByYXdCYXNlSWR4IDogcmF3QmFzZUlkeCk7XG59O1xuXG5leHBvcnQgY29uc3QgY2xhbXBTbGljZSA9ICh7XG4gIHNsaWNlLFxuICBmaXJzdElkeCxcbiAgbGFzdElkeCxcbn06IHtcbiAgc2xpY2U6IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkO1xuICBmaXJzdElkeDogbnVtYmVyO1xuICBsYXN0SWR4OiBudW1iZXI7XG59KTogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGwgPT4ge1xuICBpZiAoIXNsaWNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gc2xpY2U7XG5cbiAgY29uc3Qgb3V0T2ZCb3VuZHNCZWZvcmUgPSBzdGFydCA8IGZpcnN0SWR4ICYmIGVuZCA8IGZpcnN0SWR4O1xuICBjb25zdCBvdXRPZkJvdW5kc0FmdGVyID0gc3RhcnQgPiBsYXN0SWR4ICYmIGVuZCA+IGxhc3RJZHg7XG5cbiAgaWYgKG91dE9mQm91bmRzQmVmb3JlIHx8IG91dE9mQm91bmRzQWZ0ZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBsYXN0SWR4KTtcbiAgICBlbmQgPSBNYXRoLm1heChlbmQsIGZpcnN0SWR4KTtcbiAgfSBlbHNlIHtcbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGxhc3RJZHgpO1xuICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIGZpcnN0SWR4KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBkaXJlY3Rpb246IHNsaWNlLmRpcmVjdGlvbixcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnSkFOJyxcbiAgJ0ZFQicsXG4gICdNQVInLFxuICAnQVBSJyxcbiAgJ01BWScsXG4gICdKVU4nLFxuICAnSlVMJyxcbiAgJ0FVRycsXG4gICdTRVAnLFxuICAnT0NUJyxcbiAgJ05PVicsXG4gICdERUMnLFxuXTtcbiIsIi8qIGVzbGludCBuby1kaXYtcmVnZXg6IDAqL1xuLyogZXNsaW50IHByZWZlci1uYW1lZC1jYXB0dXJlLWdyb3VwOiAwICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTU9OVEhTID0gcmVxdWlyZSgnLi91dGlscy9tb250aHMnKTtcblxuZnVuY3Rpb24gZ2VuYmFua1RvSnNvbihzZXF1ZW5jZSkge1xuICBpZiAodHlwZW9mIHNlcXVlbmNlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGxldCByZXN1bHRzQXJyYXkgPSBbXTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGN1cnJlbnRGZWF0dXJlTm90ZTtcblxuICAvLyBHZW5iYW5rIHNwZWNpZmljYXRpb246IGh0dHBzOi8vd3d3Lm5jYmkubmxtLm5paC5nb3YvU2l0ZW1hcC9zYW1wbGVyZWNvcmQuaHRtbFxuICBsZXQgZ2VuYmFua0Fubm90YXRpb25LZXkgPSB7XG4gICAgLy8gQ29udGFpbnMgaW4gb3JkZXI6IGxvY3VzIG5hbWUsIHNlcXVlbmNlIGxlbmd0aCwgbW9sZWN1bGUgdHlwZSAoZS5nLiBETkEpLCBnZW5iYW5rIGRpdmlzaW9uIChzZWUgMS0xOCBiZWxvdyksIG1vZGlmaWNhdGlvbiBkYXRlXG4gICAgLy8gbG9jdXMgZGVmaW5pdGlvbiBoYXMgY2hhbmdlZCB3aXRoIHRpbWUsIHVzZSBhY2Nlc3Npb24gbnVtYmVyIGZvciBhIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgTE9DVVNfVEFHOiAnTE9DVVMnLFxuICAgIERFRklOSVRJT05fVEFHOiAnREVGSU5JVElPTicsXG4gICAgLy8gQWNjZXNzaW9uIHRhZ1xuICAgIC8vIEV4YW1wbGU6IFo3ODUzM1xuICAgIEFDQ0VTU0lPTl9UQUc6ICdBQ0NFU1NJT04nLFxuICAgIC8vIFRoZSB2ZXJzaW9uIHRhZyBjb250YWlucyAyIGluZm9ybWF0aW9uc1xuICAgIC8vIFRoZSBhY2Nlc3Npb24gbnVtYmVyIHdpdGggYSByZXZpc2lvblxuICAgIC8vIFRoZSBHSSAoR2VuSW5mbyBJZGVudGlmaWVyKSwgYSBuY2JpIHNlcXVlbnRpYWwgbnVtYmVyXG4gICAgLy8gRXhhbXBsZTogWjc4NTMzLjEgIEdJOjI3NjU2NThcbiAgICAvLyBVbmljaXR5IGdhcmFudGVlZCB3aXRoIHJlc3BlY3QgdG8gc2VxdWVuY2UuIElmIDEgbnVjbGVvdGlkZSBjaGFuZ2VzLCB0aGUgdmVyc2lvbiBpcyBkaWZmZXJlbnQuXG4gICAgVkVSU0lPTl9UQUc6ICdWRVJTSU9OJyxcbiAgICBLRVlXT1JEU19UQUc6ICdLRVlXT1JEUycsXG4gICAgLy8gU0VHTUVOVF9UQUc6XCJTRUdNRU5UXCJcbiAgICAvLyBTb3VyY2UgaXMgZnJlZSB0ZXh0XG4gICAgU09VUkNFX1RBRzogJ1NPVVJDRScsXG4gICAgT1JHQU5JU01fVEFHOiAnT1JHQU5JU00nLFxuICAgIFJFRkVSRU5DRV9UQUc6ICdSRUZFUkVOQ0UnLFxuICAgIEFVVEhPUlNfVEFHOiAnQVVUSE9SUycsXG4gICAgQ09OU09SVElVTV9UQUc6ICdDT05TUlRNJyxcbiAgICBUSVRMRV9UQUc6ICdUSVRMRScsXG4gICAgLy8gQ2FuIGJlIG11bHRpcGxlIGpvdXJuYWwgdGFnc1xuICAgIEpPVVJOQUxfVEFHOiAnSk9VUk5BTCcsXG4gICAgUFVCTUVEX1RBRzogJ1BVQk1FRCcsXG4gICAgUkVNQVJLX1RBRzogJ1JFTUFSSycsXG4gICAgRkVBVFVSRVNfVEFHOiAnRkVBVFVSRVMnLFxuICAgIEJBU0VfQ09VTlRfVEFHOiAnQkFTRSBDT1VOVCcsXG4gICAgLy8gQ09OVElHX1RBRzogXCJDT05USUdcIlxuICAgIE9SSUdJTl9UQUc6ICdPUklHSU4nLFxuICAgIEVORF9TRVFVRU5DRV9UQUc6ICcvLycsXG4gIH07XG5cbiAgLy8gR2VuYmFuayBkaXZpc2lvbnNcbiAgLy8gICAxLiBQUkkgLSBwcmltYXRlIHNlcXVlbmNlc1xuICAvLyAgIDIuIFJPRCAtIHJvZGVudCBzZXF1ZW5jZXNcbiAgLy8gICAzLiBNQU0gLSBvdGhlciBtYW1tYWxpYW4gc2VxdWVuY2VzXG4gIC8vICAgNC4gVlJUIC0gb3RoZXIgdmVydGVicmF0ZSBzZXF1ZW5jZXNcbiAgLy8gICA1LiBJTlYgLSBpbnZlcnRlYnJhdGUgc2VxdWVuY2VzXG4gIC8vICAgNi4gUExOIC0gcGxhbnQsIGZ1bmdhbCwgYW5kIGFsZ2FsIHNlcXVlbmNlc1xuICAvLyAgIDcuIEJDVCAtIGJhY3RlcmlhbCBzZXF1ZW5jZXNcbiAgLy8gICA4LiBWUkwgLSB2aXJhbCBzZXF1ZW5jZXNcbiAgLy8gICA5LiBQSEcgLSBiYWN0ZXJpb3BoYWdlIHNlcXVlbmNlc1xuICAvLyAxMC4gU1lOIC0gc3ludGhldGljIHNlcXVlbmNlc1xuICAvLyAxMS4gVU5BIC0gdW5hbm5vdGF0ZWQgc2VxdWVuY2VzXG4gIC8vIDEyLiBFU1QgLSBFU1Qgc2VxdWVuY2VzIChleHByZXNzZWQgc2VxdWVuY2UgdGFncylcbiAgLy8gMTMuIFBBVCAtIHBhdGVudCBzZXF1ZW5jZXNcbiAgLy8gMTQuIFNUUyAtIFNUUyBzZXF1ZW5jZXMgKHNlcXVlbmNlIHRhZ2dlZCBzaXRlcylcbiAgLy8gMTUuIEdTUyAtIEdTUyBzZXF1ZW5jZXMgKGdlbm9tZSBzdXJ2ZXkgc2VxdWVuY2VzKVxuICAvLyAxNi4gSFRHIC0gSFRHIHNlcXVlbmNlcyAoaGlnaC10aHJvdWdocHV0IGdlbm9taWMgc2VxdWVuY2VzKVxuICAvLyAxNy4gSFRDIC0gdW5maW5pc2hlZCBoaWdoLXRocm91Z2hwdXQgY0ROQSBzZXF1ZW5jaW5nXG4gIC8vIDE4LiBFTlYgLSBlbnZpcm9ubWVudGFsIHNhbXBsaW5nIHNlcXVlbmNlc1xuXG4gIGxldCBsaW5lcyA9IHNlcXVlbmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBmaWVsZE5hbWU7XG4gIGxldCBzdWJGaWVsZFR5cGU7XG4gIGxldCBmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbjtcbiAgbGV0IGxhc3RMaW5lV2FzRmVhdHVyZXNUYWc7XG4gIGxldCBsYXN0TGluZVdhc0xvY2F0aW9uO1xuXG4gIGxldCBoYXNGb3VuZExvY3VzID0gZmFsc2U7XG5cbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIGlmIChsaW5lID09PSBudWxsKSBicmVhaztcbiAgICBsZXQgbGluZUZpZWxkTmFtZSA9IGdldExpbmVGaWVsZE5hbWUobGluZSk7XG4gICAgbGV0IHZhbCA9IGdldExpbmVWYWwobGluZSk7XG4gICAgbGV0IGlzU3ViS2V5ID0gaXNTdWJLZXl3b3JkKGxpbmUpO1xuICAgIGxldCBpc0tleSA9IGlzS2V5d29yZChsaW5lKTtcblxuICAgIGlmIChsaW5lRmllbGROYW1lID09PSBnZW5iYW5rQW5ub3RhdGlvbktleS5FTkRfU0VRVUVOQ0VfVEFHIHx8IGlzS2V5KSB7XG4gICAgICBmaWVsZE5hbWUgPSBsaW5lRmllbGROYW1lO1xuICAgICAgc3ViRmllbGRUeXBlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzU3ViS2V5KSB7XG4gICAgICBzdWJGaWVsZFR5cGUgPSBsaW5lRmllbGROYW1lO1xuICAgIH1cbiAgICAvLyBJR05PUkUgTElORVM6IERPIE5PVCBFVkVOIFBST0NFU1NcbiAgICBpZiAobGluZS50cmltKCkgPT09ICcnIHx8IGxpbmVGaWVsZE5hbWUgPT09ICc7Jykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNGb3VuZExvY3VzICYmIGZpZWxkTmFtZSAhPT0gZ2VuYmFua0Fubm90YXRpb25LZXkuTE9DVVNfVEFHKSB7XG4gICAgICAvLyAnR2VuYmFuayBmaWxlcyBtdXN0IHN0YXJ0IHdpdGggYSBMT0NVUyB0YWcgc28gdGhpcyBtdXN0IG5vdCBiZSBhIGdlbmJhbmsnXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGZpZWxkTmFtZSkge1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5MT0NVU19UQUc6XG4gICAgICAgIGhhc0ZvdW5kTG9jdXMgPSB0cnVlO1xuICAgICAgICBwYXJzZUxvY3VzKGxpbmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuRkVBVFVSRVNfVEFHOlxuICAgICAgICBwYXJzZUZlYXR1cmVzKGxpbmUsIGxpbmVGaWVsZE5hbWUsIHZhbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5PUklHSU5fVEFHOlxuICAgICAgICBwYXJzZU9yaWdpbihsaW5lLCBsaW5lRmllbGROYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LkRFRklOSVRJT05fVEFHOlxuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5BQ0NFU1NJT05fVEFHOlxuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5WRVJTSU9OX1RBRzpcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuS0VZV09SRFNfVEFHOlxuICAgICAgICBwYXJzZU11bHRpTGluZUZpZWxkKGZpZWxkTmFtZSwgbGluZSwgZmllbGROYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuU09VUkNFX1RBRzpcbiAgICAgICAgaWYgKHN1YkZpZWxkVHlwZSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuT1JHQU5JU01fVEFHKSB7XG4gICAgICAgICAgcGFyc2VNdWx0aUxpbmVGaWVsZChzdWJGaWVsZFR5cGUsIGxpbmUsICdvcmdhbmlzbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQobGluZUZpZWxkTmFtZSwgbGluZSwgJ3NvdXJjZScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5SRUZFUkVOQ0VfVEFHOlxuICAgICAgICBpZiAobGluZUZpZWxkTmFtZSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuUkVGRVJFTkNFX1RBRykge1xuICAgICAgICAgIGNvbnN0IHJlZiA9IHJlc3VsdC5yZWZlcmVuY2VzIHx8IFtdO1xuICAgICAgICAgIHJlc3VsdC5yZWZlcmVuY2VzID0gcmVmO1xuICAgICAgICAgIHJlZi5wdXNoKHt9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVJlZmVyZW5jZShsaW5lLCBzdWJGaWVsZFR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuRU5EX1NFUVVFTkNFX1RBRzpcbiAgICAgICAgZW5kU2VxKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVW5oYW5kbGVkIHRhZ1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBjYXRjaCB0aGUgY2FzZSB3aGVyZSB3ZSd2ZSBzdWNjZXNzZnVsbHkgc3RhcnRlZCBhIHNlcXVlbmNlIGFuZCBwYXJzZWQgaXQsIGJ1dCBlbmRTZXEgaXNuJ3QgY2FsbGVkIGNvcnJlY3RseVxuICBpZiAocmVzdWx0c0FycmF5W3Jlc3VsdHNBcnJheS5sZW5ndGggLSAxXSAhPT0gcmVzdWx0KSB7XG4gICAgLy8gY3VycmVudCByZXN1bHQgaXNuJ3QgaW4gcmVzdWx0c0FycmF5IHlldFxuICAgIC8vIHNvIHdlIGNhbGwgZW5kU2VxIGhlcmVcbiAgICBlbmRTZXEoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0c0FycmF5O1xuXG4gIGZ1bmN0aW9uIGVuZFNlcSgpIHtcbiAgICAvLyBkbyBzb21lIHBvc3QgcHJvY2Vzc2luZyBjbGVhbi11cFxuICAgIHBvc3RQcm9jZXNzQ3VyU2VxKCk7XG4gICAgLy8gcHVzaCB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdHNBcnJheVxuICAgIHJlc3VsdHNBcnJheS5wdXNoKHJlc3VsdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50RmVhdHVyZSgpIHtcbiAgICByZXR1cm4gcmVzdWx0LmZlYXR1cmVzW3Jlc3VsdC5mZWF0dXJlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RQcm9jZXNzQ3VyU2VxKCkge1xuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmZlYXR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQuZmVhdHVyZXNbaV0gPSBwb3N0UHJvY2Vzc0dlbmJhbmtGZWF0dXJlKHJlc3VsdC5mZWF0dXJlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPcmlnaW4obGluZSwga2V5KSB7XG4gICAgaWYgKGtleSAhPT0gZ2VuYmFua0Fubm90YXRpb25LZXkuT1JJR0lOX1RBRykge1xuICAgICAgbGV0IG5ld0xpbmUgPSBsaW5lLnJlcGxhY2UoL1tcXHNdKlswLTldKi9nLCAnJyk7XG4gICAgICByZXN1bHQuc2VxdWVuY2UgKz0gbmV3TGluZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY3VzKGxpbmUpIHtcbiAgICByZXN1bHQgPSB7XG4gICAgICBmZWF0dXJlczogW10sXG4gICAgICBuYW1lOiAnVW50aXRsZWQgc2VxdWVuY2UnLFxuICAgICAgc2VxdWVuY2U6ICcnLFxuICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgfTtcbiAgICBsaW5lID0gcmVtb3ZlRmllbGROYW1lKGdlbmJhbmtBbm5vdGF0aW9uS2V5LkxPQ1VTX1RBRywgbGluZSk7XG4gICAgY29uc3QgbSA9IGxpbmUubWF0Y2goXG4gICAgICAvXihbXlxcc10rKVxccysoXFxkKylcXHMrYnBcXHMrKFteXFxzXSspXFxzKyhbXlxcc10rKVxccysoW15cXHNdKylcXHMqKFteXFxzXSspPyQvLFxuICAgICk7XG4gICAgbGV0IGxvY3VzTmFtZSA9IG1bMV07XG4gICAgbGV0IHNpemUgPSArbVsyXTtcbiAgICBsZXQgbW9sZWN1bGVUeXBlID0gbVszXTtcbiAgICBsZXQgY2lyY3VsYXIgPSBtWzRdID09PSAnY2lyY3VsYXInO1xuICAgIGNvbnN0IHNlcSA9IHJlc3VsdDtcbiAgICBsZXQgZGF0ZVN0ciA9ICcnO1xuICAgIGlmICghbVs2XSkge1xuICAgICAgZGF0ZVN0ciA9IG1bNV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcS5nZW5iYW5rRGl2aXNpb24gPSBtWzVdO1xuICAgICAgZGF0ZVN0ciA9IG1bNl07XG4gICAgfVxuICAgIHNlcS5jaXJjdWxhciA9IGNpcmN1bGFyO1xuICAgIHNlcS5tb2xlY3VsZVR5cGUgPSBtb2xlY3VsZVR5cGU7XG4gICAgY29uc3QgZGF0ZU1hdGNoID0gZGF0ZVN0ci5tYXRjaCgvXihcXGR7Mn0pLSguezN9KS0oXFxkezR9KSQvKTtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKCtkYXRlTWF0Y2hbM10pO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoTU9OVEhTLmluZGV4T2YoZGF0ZU1hdGNoWzJdLnRvVXBwZXJDYXNlKCkpKTtcbiAgICBkYXRlLnNldERhdGUoK2RhdGVNYXRjaFsxXSk7XG4gICAgZGF0ZS5zZXRVVENIb3VycygxMik7XG4gICAgZGF0ZS5zZXRNaW51dGVzKDApO1xuICAgIGRhdGUuc2V0U2Vjb25kcygwKTtcbiAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgICBzZXEuZGF0ZSA9IGRhdGUudG9JU09TdHJpbmcoKTtcbiAgICBzZXEubmFtZSA9IGxvY3VzTmFtZTtcbiAgICBzZXEuc2l6ZSA9IHNpemU7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGaWVsZE5hbWUoZk5hbWUsIGxpbmUpIHtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbiAgICBpZiAobGluZS5pbmRleE9mKGZOYW1lKSA9PT0gMCkge1xuICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShmTmFtZSwgJycpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZS50cmltKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJlZmVyZW5jZShsaW5lLCBzdWJUeXBlKSB7XG4gICAgY29uc3QgcmVmcyA9IHJlc3VsdC5yZWZlcmVuY2VzO1xuICAgIGxldCBsYXN0UmVmID0gcmVmc1tyZWZzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghc3ViVHlwZSkge1xuICAgICAgcGFyc2VNdWx0aUxpbmVGaWVsZChcbiAgICAgICAgZ2VuYmFua0Fubm90YXRpb25LZXkuUkVGRVJFTkNFX1RBRyxcbiAgICAgICAgbGluZSxcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgbGFzdFJlZixcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQoc3ViVHlwZSwgbGluZSwgc3ViVHlwZS50b0xvd2VyQ2FzZSgpLCBsYXN0UmVmKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZlYXR1cmVzKGxpbmUsIGtleSwgdmFsKSB7XG4gICAgbGV0IHN0cmFuZDtcbiAgICAvLyBGT1IgVEhFIE1BSU4gRkVBVFVSRVMgTE9DQVRJT04vUVVBTElGSUVSIExJTkVcbiAgICBpZiAoa2V5ID09PSBnZW5iYW5rQW5ub3RhdGlvbktleS5GRUFUVVJFU19UQUcpIHtcbiAgICAgIGxhc3RMaW5lV2FzRmVhdHVyZXNUYWcgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsYXN0TGluZVdhc0ZlYXR1cmVzVGFnKSB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIGdldCB0aGUgaW5kZW50YXRpb24gb2YgZmVhdHVyZSBsb2NhdGlvbnNcbiAgICAgIGZlYXR1cmVMb2NhdGlvbkluZGVudGF0aW9uID0gZ2V0TGVuZ3RoT2ZXaGl0ZVNwYWNlQmVmb3JlU3RhcnRPZkxldHRlcnMoXG4gICAgICAgIGxpbmUsXG4gICAgICApO1xuICAgICAgLy8gc2V0IGxhc3RMaW5lV2FzRmVhdHVyZXNUYWcgdG8gZmFsc2VcbiAgICAgIGxhc3RMaW5lV2FzRmVhdHVyZXNUYWcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGT1IgTE9DQVRJT04gJiYgUVVBTElGSUVSIExJTkVTXG4gICAgaWYgKGlzRmVhdHVyZUxpbmVSdW5vbihsaW5lLCBmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbikpIHtcbiAgICAgIC8vIHRoZSBsaW5lIGlzIGEgY29udGludWF0aW9uIG9mIHRoZSBhYm92ZSBsaW5lXG4gICAgICBpZiAobGFzdExpbmVXYXNMb2NhdGlvbikge1xuICAgICAgICAvLyB0aGUgbGFzdCBsaW5lIHdhcyBhIGxvY2F0aW9uLCBzbyB0aGUgcnVuLW9uIGxpbmUgaXMgZXhwZWN0ZWQgdG8gYmUgYSBmZWF0dXJlIGxvY2F0aW9uIGFzIHdlbGxcbiAgICAgICAgcGFyc2VGZWF0dXJlTG9jYXRpb24obGluZS50cmltKCkpO1xuICAgICAgICBsYXN0TGluZVdhc0xvY2F0aW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBsYXN0IGxpbmUgd2FzIGEgbm90ZVxuICAgICAgICBpZiAoY3VycmVudEZlYXR1cmVOb3RlKSB7XG4gICAgICAgICAgLy8gYXBwZW5kIHRvIHRoZSBjdXJyZW50RmVhdHVyZU5vdGVcbiAgICAgICAgICBjdXJyZW50RmVhdHVyZU5vdGVbXG4gICAgICAgICAgICBjdXJyZW50RmVhdHVyZU5vdGUubGVuZ3RoIC0gMVxuICAgICAgICAgIF0gKz0gbGluZS50cmltKCkucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMaW5lV2FzTG9jYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmV3IEVsZW1lbnQvUXVhbGlmaWVyIGxpbmVzLiBOb3QgcnVub24gbGluZXMuXG4gICAgICBpZiAoaXNOb3RlKGxpbmUpKSB7XG4gICAgICAgIC8vIGlzIGEgbmV3IEZlYXR1cmUgRWxlbWVudCAoZS5nLiBzb3VyY2UsIENEUykgaW4gdGhlIGZvcm0gb2YgIFwiW1xcc10gS0VZICBTRVFMT0NBVElPTlwiXG4gICAgICAgIC8vIGlzIGEgRmVhdHVyZVF1YWxpZmllciBpbiB0aGUgL0tFWT1cIkJMQUhcIiBmb3JtYXQ7IGNvdWxkIGJlIG11bHRpcGxlIHBlciBFbGVtZW50XG4gICAgICAgIC8vIENoZWNrIHRoYXQgZmVhdHVyZSBkaWQgbm90IGdldCBza2lwcGVkIGZvciBtaXNzaW5nIGxvY2F0aW9uXG4gICAgICAgIGlmIChnZXRDdXJyZW50RmVhdHVyZSgpKSB7XG4gICAgICAgICAgcGFyc2VGZWF0dXJlTm90ZShsaW5lKTtcbiAgICAgICAgICBsYXN0TGluZVdhc0xvY2F0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBsaW5lIGlzIGEgbG9jYXRpb24sIHNvIHdlIG1ha2UgYSBuZXcgZmVhdHVyZSBmcm9tIGl0XG4gICAgICAgIGlmICh2YWwubWF0Y2goL2NvbXBsZW1lbnQvZykpIHtcbiAgICAgICAgICBzdHJhbmQgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJhbmQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RmVhdHVyZSgpO1xuICAgICAgICBsZXQgZmVhdCA9IGdldEN1cnJlbnRGZWF0dXJlKCk7XG4gICAgICAgIGZlYXQudHlwZSA9IGtleTtcbiAgICAgICAgZmVhdC5zdHJhbmQgPSBzdHJhbmQ7XG5cbiAgICAgICAgcGFyc2VGZWF0dXJlTG9jYXRpb24odmFsKTtcbiAgICAgICAgbGFzdExpbmVXYXNMb2NhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV3RmVhdHVyZSgpIHtcbiAgICByZXN1bHQuZmVhdHVyZXMucHVzaCh7XG4gICAgICBub3Rlczoge30sXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vdGUobGluZSkge1xuICAgIGxldCBxdWFsID0gZmFsc2U7XG4gICAgLyogaWYgKGxpbmUuY2hhckF0KDIxKSA9PT0gXCIvXCIpIHsvL1QuSC4gSGFyZCBjb2RlZCBtZXRob2RcbiAgICAgICAgICAgcXVhbCA9IHRydWU7XG4gICAgICAgICB9Ki9cbiAgICBpZiAobGluZS50cmltKCkuY2hhckF0KDApLm1hdGNoKC9cXC8vKSkge1xuICAgICAgLy8gc2VhcmNoZXMgYmFzZWQgb24gbG9va2luZyBmb3IgLyBpbiBiZWdpbm5pbmcgb2YgbGluZVxuICAgICAgcXVhbCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKC9eW1xcc10qXFwvW1xcd10rPVtcXFNdKy8pKSB7XG4gICAgICAvLyBzZWFyY2hlcyBiYXNlZCBvbiBcIiAgIC9rZXk9QkxBSFwiIHJlZ2V4XG4gICAgICBxdWFsID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWw7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZlYXR1cmVMb2NhdGlvbihsb2NTdHIpIHtcbiAgICBsb2NTdHIgPSBsb2NTdHIudHJpbSgpO1xuICAgIGxldCBsb2NBcnIgPSBbXTtcbiAgICBsb2NTdHIucmVwbGFjZSgvKFxcZCspL2csIGZ1bmN0aW9uIChzdHJpbmcsIG1hdGNoKSB7XG4gICAgICBsb2NBcnIucHVzaChtYXRjaCk7XG4gICAgfSk7XG4gICAgbGV0IGZlYXQgPSBnZXRDdXJyZW50RmVhdHVyZSgpO1xuICAgIGZlYXQuc3RhcnQgPSArbG9jQXJyWzBdO1xuICAgIGZlYXQuZW5kID0gbG9jQXJyWzFdID09PSB1bmRlZmluZWQgPyArbG9jQXJyWzBdIDogK2xvY0FyclsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRmVhdHVyZU5vdGUobGluZSkge1xuICAgIGxldCBuZXdMaW5lLCBsaW5lQXJyO1xuXG4gICAgbmV3TGluZSA9IGxpbmUudHJpbSgpO1xuICAgIG5ld0xpbmUgPSBuZXdMaW5lLnJlcGxhY2UoL15cXC98XCIkL2csICcnKTtcbiAgICBsaW5lQXJyID0gbmV3TGluZS5zcGxpdCgvPVwifD0vKTtcblxuICAgIGxldCB2YWwgPSBsaW5lQXJyWzFdO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcXFwvZywgJyAnKTtcblxuICAgICAgaWYgKGxpbmUubWF0Y2goLz1cIi9nKSkge1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXCIuKi9nLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXlxcZCskL2cpKSB7XG4gICAgICAgIHZhbCA9ICt2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXkgPSBsaW5lQXJyWzBdO1xuICAgIGxldCBjdXJyZW50Tm90ZXMgPSBnZXRDdXJyZW50RmVhdHVyZSgpLm5vdGVzO1xuICAgIGlmIChjdXJyZW50Tm90ZXNba2V5XSkge1xuICAgICAgLy8gYXJyYXkgYWxyZWFkeSBleGlzdHMsIHNvIHB1c2ggdmFsdWUgaW50byBpdFxuICAgICAgY3VycmVudE5vdGVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhcnJheSBkb2Vzbid0IGV4aXN0IHlldCwgc28gY3JlYXRlIGl0IGFuZCBwb3B1bGF0ZSBpdCB3aXRoIHRoZSB2YWx1ZVxuICAgICAgY3VycmVudE5vdGVzW2tleV0gPSBbdmFsXTtcbiAgICB9XG4gICAgY3VycmVudEZlYXR1cmVOb3RlID0gY3VycmVudE5vdGVzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lRmllbGROYW1lKGxpbmUpIHtcbiAgICBsZXQgYXJyO1xuICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICAgIGFyciA9IGxpbmUuc3BsaXQoL1tcXHNdKy8pO1xuXG4gICAgcmV0dXJuIGFyclswXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTXVsdGlMaW5lRmllbGQoZk5hbWUsIGxpbmUsIHJlc3VsdEtleSwgcikge1xuICAgIHIgPSByIHx8IHJlc3VsdDtcbiAgICBsZXQgZmllbGRWYWx1ZSA9IHJlbW92ZUZpZWxkTmFtZShmTmFtZSwgbGluZSk7XG4gICAgcltyZXN1bHRLZXldID0gcltyZXN1bHRLZXldID8gYCR7cltyZXN1bHRLZXldfSBgIDogJyc7XG4gICAgcltyZXN1bHRLZXldICs9IGZpZWxkVmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lVmFsKGxpbmUpIHtcbiAgICBsZXQgYXJyO1xuXG4gICAgaWYgKGxpbmUuaW5kZXhPZignPScpIDwgMCkge1xuICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXltcXHNdKltcXFNdK1tcXHNdK3xbXFxzXSskLywgJycpO1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyciA9IGxpbmUuc3BsaXQoLz0vKTtcbiAgICAgIHJldHVybiBhcnJbMV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGxpbmUpIHtcbiAgICBsZXQgaXNLZXkgPSBmYWxzZTtcbiAgICBpZiAobGluZS5zdWJzdHIoMCwgMTApLm1hdGNoKC9eW1xcU10rLykpIHtcbiAgICAgIGlzS2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzS2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTdWJLZXl3b3JkKGxpbmUpIHtcbiAgICBsZXQgaXNTdWJLZXkgPSBmYWxzZTtcbiAgICBpZiAobGluZS5zdWJzdHIoMCwgMTApLm1hdGNoKC9eW1xcc10rW1xcU10rLykpIHtcbiAgICAgIGlzU3ViS2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3ViS2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zdFByb2Nlc3NHZW5iYW5rRmVhdHVyZShmZWF0KSB7XG4gICAgaWYgKGZlYXQubm90ZXMubGFiZWwpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMubGFiZWxbMF07XG4gICAgfSBlbHNlIGlmIChmZWF0Lm5vdGVzLmdlbmUpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMuZ2VuZVswXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMuQXBFaW5mb19sYWJlbCkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5BcEVpbmZvX2xhYmVsWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5uYW1lKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLm5hbWVbMF07XG4gICAgfSBlbHNlIGlmIChmZWF0Lm5vdGVzLm9yZ2FuaXNtKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLm9yZ2FuaXNtWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5sb2N1c190YWcpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMubG9jdXNfdGFnWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5ub3RlKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLm5vdGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXQubmFtZSA9ICdVbnRpdGxlZCBGZWF0dXJlJztcbiAgICB9XG4gICAgZmVhdC5uYW1lID0gdHlwZW9mIGZlYXQubmFtZSA9PT0gJ3N0cmluZycgPyBmZWF0Lm5hbWUgOiBTdHJpbmcoZmVhdC5uYW1lKTtcbiAgICByZXR1cm4gZmVhdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ZlYXR1cmVMaW5lUnVub24obGluZSwgZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb24pIHtcbiAgbGV0IGluZGVudGF0aW9uT2ZMaW5lID0gZ2V0TGVuZ3RoT2ZXaGl0ZVNwYWNlQmVmb3JlU3RhcnRPZkxldHRlcnMobGluZSk7XG4gIGlmIChmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbiA9PT0gaW5kZW50YXRpb25PZkxpbmUpIHtcbiAgICAvLyB0aGUgZmVhdHVyZSBsb2NhdGlvbiBpbmRlbnRhdGlvbiBjYWxjdWxhdGVkIHJpZ2h0IGFmdGVyIHRoZSBmZWF0dXJlIHRhZ1xuICAgIC8vIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGxpbmVcbiAgICAvL1xuICAgIC8vIEZFQVRVUkVTICAgICAgICAgICAgIExvY2F0aW9uL1F1YWxpZmllcnNcbiAgICAvLyAgICAgcmVwX29yaWdpbiAgICAgIGNvbXBsZW1lbnQoMTA3NC4uMzMwMilcbiAgICAvLyAwMTIzNCAgPC0tIHRoaXMgaXMgdGhlIGluZGVudGF0aW9uIHdlJ3JlIHRhbGtpbmcgYWJvdXRcbiAgICByZXR1cm4gZmFsc2U7IC8vIHRoZSBsaW5lIGlzIE5PVCBhIHJ1biBvblxuICB9XG5cbiAgbGV0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgaWYgKHRyaW1tZWQuY2hhckF0KDApLm1hdGNoKC9cXC8vKSkge1xuICAgIC8vIHRoZSBmaXJzdCBjaGFyIGluIHRoZSB0cmltbWVkIGxpbmUgY2Fubm90IGJlIGEgL1xuICAgIHJldHVybiBmYWxzZTsgLy8gdGhlIGxpbmUgaXMgTk9UIGEgcnVuIG9uXG4gIH1cbiAgLy8gdGhlIGxpbmUgaXMgYSBydW4gb25cbiAgcmV0dXJuIHRydWU7XG4gIC8vIHJ1bi1vbiBsaW5lIGV4YW1wbGU6XG4gIC8vIEZFQVRVUkVTICAgICAgICAgICAgIExvY2F0aW9uL1F1YWxpZmllcnNcbiAgLy8gICAgIHJlcF9vcmlnaW4gICAgICBjb21wbGVtZW50KDEwNzQuLjMzMDIpXG4gIC8vICAgICAgICAgICAgICAgICAvbGFiZWw9cFNDMTAxKipcbiAgLy8gICAgICAgICAgICAgICAgIC9ub3RlPVwiUkVQX09SSUdJTiBSRVBfT1JJR0lOIHBTQzEwMSogYWthIHBNUFA2LCBnaXZlcyBwbGFzbVxuICAvLyAgICAgICAgICAgICAgICAgaWQgbnVtYmVyIDMgLTQgY29waWVzIHBlciBjZWxsLCBCZ2xJSSBzaXRlIGluIHBTQzEwMSogb3JpIGggPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICBhcyBiZWVuIGRlbGUgdGVkIGJ5IHF1aWNrIGNoYW5nZSBhZ2F0Y1QgY2hhbmdlZCB0byBhZ2F0Y0EgZyA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgIGl2aW5nIHBTQzEwMSogKiBwU0MxMDEqIGFrYSBwTVBQNiwgZ2l2ZXMgcGxhc21pZCBudW1iZXIgMy00IDwtLXJ1bi1vbiBsaW5lIVxuICAvLyAgICAgICAgICAgICAgICAgY29waWVzIHAgZXIgY2VsbCwgQmdsSUkgc2l0ZSBpbiBwU0MxMDEqIG9yaSBoYXMgYmVlbiBkZWxldCAgPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICBlZCBieSBxdWljIGsgY2hhbmdlIGFnYXRjVCBjaGFuZ2VkIHRvIGFnYXRjQSBnaXZpbmcgcFNDMTAxKiA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgICogW3BCYlMwYS1SRlBdXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgIC9nZW5lPVwiU0MxMDEqKiBPcmlcIlxuICAvLyAgICAgICAgICAgICAgICAgL25vdGU9XCJwU0MxMDEqIGFrYSBwTVBQNiwgZ2l2ZXMgcGxhc21pZCBudW1iZXIgMy00IGNvcGllcyBwXG4gIC8vICAgICAgICAgICAgICAgICBlciBjZWxsLCBCZ2xJSSBzaXRlIGluIHBTQzEwMSogb3JpIGhhcyBiZWVuIGRlbGV0ZWQgYnkgcXVpXG4gIC8vICAgICAgICAgICAgICAgICBjIGsgY2hhbmdlIGFnYXRjVCBjaGFuZ2VkIHRvIGFnYXRjQSBnaXZpbmcgcFNDMTAxKipcIlxuICAvLyAgICAgICAgICAgICAgICAgL3ZudGlma2V5PVwiMzNcIlxufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGhPZldoaXRlU3BhY2VCZWZvcmVTdGFydE9mTGV0dGVycyhzdHJpbmcpIHtcbiAgbGV0IG1hdGNoID0gL15cXHMqLy5leGVjKHN0cmluZyk7XG4gIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5iYW5rVG9Kc29uO1xuIiwidmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICB1dGlsLmFzc2VydEVxdWFsID0gKHZhbCkgPT4gdmFsO1xuICAgIGZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHsgfVxuICAgIHV0aWwuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgICBmdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuICAgIHV0aWwuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhvYmopLmZpbHRlcigoaykgPT4gdHlwZW9mIG9ialtvYmpba11dICE9PSBcIm51bWJlclwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0VmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2VdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKG9iamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH07XG4gICAgdXRpbC5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdXRpbC5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcbiAgICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgICAgIHJldHVybiBhcnJheVxuICAgICAgICAgICAgLm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKVxuICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgdXRpbC5qb2luVmFsdWVzID0gam9pblZhbHVlcztcbiAgICB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKHV0aWwgfHwgKHV0aWwgPSB7fSkpO1xudmFyIG9iamVjdFV0aWw7XG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcbiAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpcnN0LFxuICAgICAgICAgICAgLi4uc2Vjb25kLCAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICAgICAgICB9O1xuICAgIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbmNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBpc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN5bWJvbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5hcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRhLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmtub3duO1xuICAgIH1cbn07XG5cbmNvbnN0IFpvZElzc3VlQ29kZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwiaW52YWxpZF90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2xpdGVyYWxcIixcbiAgICBcImN1c3RvbVwiLFxuICAgIFwiaW52YWxpZF91bmlvblwiLFxuICAgIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXG4gICAgXCJpbnZhbGlkX2VudW1fdmFsdWVcIixcbiAgICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxuICAgIFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiLFxuICAgIFwiaW52YWxpZF9kYXRlXCIsXG4gICAgXCJpbnZhbGlkX3N0cmluZ1wiLFxuICAgIFwidG9vX3NtYWxsXCIsXG4gICAgXCJ0b29fYmlnXCIsXG4gICAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxuICAgIFwibm90X211bHRpcGxlX29mXCIsXG4gICAgXCJub3RfZmluaXRlXCIsXG5dKTtcbmNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCBcIiQxOlwiKTtcbn07XG5jbGFzcyBab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzc3VlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS51bmlvbkVycm9ycy5tYXAocHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zdCBlcnJvckFycmF5OiBhbnkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCBlcnJvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHRoaXMpO1xuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBab2RFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcblxubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cblxuY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gICAgY29uc3QgbWFwcyA9IGVycm9yTWFwc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiAhIW0pXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB9O1xufTtcbmNvbnN0IEVNUFRZX1BBVEggPSBbXTtcbmZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVNYXAgPSBnZXRFcnJvck1hcCgpO1xuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgLy8gY29udGV4dHVhbCBlcnJvciBtYXAgaXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCwgLy8gdGhlbiBzY2hlbWEtYm91bmQgbWFwIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAsIC8vIHRoZW4gZ2xvYmFsIG92ZXJyaWRlIG1hcFxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAgPT09IGVycm9yTWFwID8gdW5kZWZpbmVkIDogZXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5jb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIgZXJyb3JVdGlsO1xuKGZ1bmN0aW9uIChlcnJvclV0aWwpIHtcbiAgICBlcnJvclV0aWwuZXJyVG9PYmogPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2UgfSA6IG1lc3NhZ2UgfHwge307XG4gICAgZXJyb3JVdGlsLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xuXG52YXIgX1pvZEVudW1fY2FjaGUsIF9ab2ROYXRpdmVFbnVtX2NhY2hlO1xuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcImludmFsaWRfZW51bV92YWx1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9hID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogcmVxdWlyZWRfZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYiA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGludmFsaWRfdHlwZV9lcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmNsYXNzIFpvZFR5cGUge1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAoY3R4IHx8IHtcbiAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmFzeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBcIn52YWxpZGF0ZVwiKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogISF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VBc3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChyZXN1bHQpID0+IGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgYXN5bmMgc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWF5YmVBc3luY1Jlc3VsdCA9IHRoaXMuX3BhcnNlKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoaXNBc3luYyhtYXliZUFzeW5jUmVzdWx0KVxuICAgICAgICAgICAgPyBtYXliZUFzeW5jUmVzdWx0XG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShtYXliZUFzeW5jUmVzdWx0KSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZ2V0SXNzdWVQcm9wZXJ0aWVzID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtZXNzYWdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVjayh2YWwpO1xuICAgICAgICAgICAgY29uc3Qgc2V0RXJyb3IgPSAoKSA9PiBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZpbmVtZW50KGNoZWNrLCByZWZpbmVtZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh0eXBlb2YgcmVmaW5lbWVudERhdGEgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHJlZmluZW1lbnREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VwZXJSZWZpbmUocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChyZWZpbmVtZW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKGRhdGEpID0+IHRoaXNbXCJ+dmFsaWRhdGVcIl0oZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgYW5kKGluY29taW5nKSB7XG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0KGRlZikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnJhbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2goZGVmKSB7XG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaXBlKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICAgIHJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBpc09wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UodW5kZWZpbmVkKS5zdWNjZXNzO1xuICAgIH1cbiAgICBpc051bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgICB9XG59XG5jb25zdCBjdWlkUmVnZXggPSAvXmNbXlxccy1dezgsfSQvaTtcbmNvbnN0IGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xuY29uc3QgdWxpZFJlZ2V4ID0gL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC9pO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuY29uc3QgbmFub2lkUmVnZXggPSAvXlthLXowLTlfLV17MjF9JC9pO1xuY29uc3Qgand0UmVnZXggPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvO1xuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjE4MS8xNTUwMTU1XG4vLyBvbGQgdmVyc2lvbjogdG9vIHNsb3csIGRpZG4ndCBzdXBwb3J0IHVuaWNvZGVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XG4vL29sZCBlbWFpbCByZWdleFxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKChbXjw+KClbXFxdLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF0uLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoPyEtKShbXjw+KClbXFxdLiw7Olxcc0BcIl0rXFwuKStbXjw+KClbXFxdLiw7Olxcc0BcIl17MSx9KVteLTw+KClbXFxdLiw7Olxcc0BcIl0kL2k7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFsoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXF0pfChcXFtJUHY2OigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSlcXF0pfChbQS1aYS16MC05XShbQS1aYS16MC05LV0qW0EtWmEtejAtOV0pKihcXC5bQS1aYS16XXsyLH0pKykpJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16QS1aMC05XFwuXFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwvXFw9XFw/XFxeXFxfXFxgXFx7XFx8XFx9XFx+XFwtXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXig/OlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSpcIilAKD86KD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xuY29uc3QgZW1haWxSZWdleCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aMC05XycrXFwtXFwuXSopW0EtWjAtOV8rLV1AKFtBLVowLTldW0EtWjAtOVxcLV0qXFwuKStbQS1aXXsyLH0kL2k7XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16MC05LiEjJCUm4oCZKisvPT9eX2B7fH1+LV0rQFthLXowLTktXSsoPzpcXC5bYS16MC05XFwtXSspKiQvaTtcbi8vIGZyb20gaHR0cHM6Ly90aGVrZXZpbnNjb3R0LmNvbS9lbW9qaXMtaW4tamF2YXNjcmlwdC8jd3JpdGluZy1hLXJlZ3VsYXItZXhwcmVzc2lvblxuY29uc3QgX2Vtb2ppUmVnZXggPSBgXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRgO1xubGV0IGVtb2ppUmVnZXg7XG4vLyBmYXN0ZXIsIHNpbXBsZXIsIHNhZmVyXG5jb25zdCBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xuY29uc3QgaXB2NENpZHJSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xuLy8gY29uc3QgaXB2NlJlZ2V4ID1cbi8vIC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuY29uc3QgaXB2NlJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC87XG5jb25zdCBpcHY2Q2lkclJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxuY29uc3QgYmFzZTY0UmVnZXggPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC87XG4vLyBodHRwczovL2Jhc2U2NC5ndXJ1L3N0YW5kYXJkcy9iYXNlNjR1cmxcbmNvbnN0IGJhc2U2NHVybFJlZ2V4ID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvO1xuLy8gc2ltcGxlXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1gO1xuLy8gbm8gbGVhcCB5ZWFyIHZhbGlkYXRpb25cbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS0oKDBbMTM1NzhdfDEwfDEyKS0zMXwoMFsxMy05XXwxWzAtMl0pLTMwfCgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFcXFxcZHwyXFxcXGQpKWA7XG4vLyB3aXRoIGxlYXAgeWVhciB2YWxpZGF0aW9uXG5jb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpYDtcbmNvbnN0IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICAgIC8vIGxldCByZWdleCA9IGBcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfWA7XG4gICAgbGV0IHJlZ2V4ID0gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGRgO1xuICAgIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgICAgICByZWdleCA9IGAke3JlZ2V4fVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICByZWdleCA9IGAke3JlZ2V4fShcXFxcLlxcXFxkKyk/YDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2V4O1xufVxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxuZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICAgIGNvbnN0IG9wdHMgPSBbXTtcbiAgICBvcHRzLnB1c2goYXJncy5sb2NhbCA/IGBaP2AgOiBgWmApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcbiAgICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKV1Qoand0LCBhbGcpIHtcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gand0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGVjb2RlZC50eXAgfHwgIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEYXRlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gICAgfVxuICAgIGdldCBpc1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDSURSKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gICAgfVxuICAgIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gcGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG5jbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5pdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhZmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8XG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fZGVmKS5lcnJvck1hcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGlzc3VlLCBjdHgpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGN0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfZCA9IGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXMobWFzaykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5b2YoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlzc3VlcyBmcm9tIGRpcnR5IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMYXp5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFbnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyh0eXBlLmVudW0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcCxcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9ab2RFbnVtX2NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZE5hdGl2ZUVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5fWm9kTmF0aXZlRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiZcbiAgICAgICAgICAgIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2VcbiAgICAgICAgICAgID8gY3R4LmRhdGFcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ3R4LmFkZElzc3VlID0gY2hlY2tDdHguYWRkSXNzdWUuYmluZChjaGVja0N0eCk7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcbiAgICAgICAgICAgIDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNBc3luYyhyZXN1bHQpXG4gICAgICAgICAgICA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpXG4gICAgICAgICAgICA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHBhcmFtcyhkYXRhKVxuICAgICAgICA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8geyBtZXNzYWdlOiBwYXJhbXMgfVxuICAgICAgICAgICAgOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcbiAqXG4gKiBgYGB0c1xuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmZhdGFsKSB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3QgY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuY29uc3QgTkVWRVIgPSBJTlZBTElEO1xuXG52YXIgeiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgICBzZXRFcnJvck1hcDogc2V0RXJyb3JNYXAsXG4gICAgZ2V0RXJyb3JNYXA6IGdldEVycm9yTWFwLFxuICAgIG1ha2VJc3N1ZTogbWFrZUlzc3VlLFxuICAgIEVNUFRZX1BBVEg6IEVNUFRZX1BBVEgsXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxuICAgIFBhcnNlU3RhdHVzOiBQYXJzZVN0YXR1cyxcbiAgICBJTlZBTElEOiBJTlZBTElELFxuICAgIERJUlRZOiBESVJUWSxcbiAgICBPSzogT0ssXG4gICAgaXNBYm9ydGVkOiBpc0Fib3J0ZWQsXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGlzQXN5bmM6IGlzQXN5bmMsXG4gICAgZ2V0IHV0aWwgKCkgeyByZXR1cm4gdXRpbDsgfSxcbiAgICBnZXQgb2JqZWN0VXRpbCAoKSB7IHJldHVybiBvYmplY3RVdGlsOyB9LFxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcbiAgICBab2RUeXBlOiBab2RUeXBlLFxuICAgIGRhdGV0aW1lUmVnZXg6IGRhdGV0aW1lUmVnZXgsXG4gICAgWm9kU3RyaW5nOiBab2RTdHJpbmcsXG4gICAgWm9kTnVtYmVyOiBab2ROdW1iZXIsXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXG4gICAgWm9kQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBab2REYXRlOiBab2REYXRlLFxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxuICAgIFpvZFVuZGVmaW5lZDogWm9kVW5kZWZpbmVkLFxuICAgIFpvZE51bGw6IFpvZE51bGwsXG4gICAgWm9kQW55OiBab2RBbnksXG4gICAgWm9kVW5rbm93bjogWm9kVW5rbm93bixcbiAgICBab2ROZXZlcjogWm9kTmV2ZXIsXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcbiAgICBab2RBcnJheTogWm9kQXJyYXksXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcbiAgICBab2ROYU46IFpvZE5hTixcbiAgICBCUkFORDogQlJBTkQsXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcbiAgICBab2RQaXBlbGluZTogWm9kUGlwZWxpbmUsXG4gICAgWm9kUmVhZG9ubHk6IFpvZFJlYWRvbmx5LFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBjb2VyY2U6IGNvZXJjZSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NUeXBlLFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgICBzZXQ6IHNldFR5cGUsXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIE5FVkVSOiBORVZFUixcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvclxufSk7XG5cbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIGRhdGV0aW1lUmVnZXgsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XG4iLCJpbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuXG5leHBvcnQgY29uc3QgY29vclNjaGVtYSA9IHoub2JqZWN0KHtcbiAgeDogei5udW1iZXIoKSxcbiAgeTogei5udW1iZXIoKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgYW5nbGVTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGRlZ3JlZXM6IHoubnVtYmVyKCksXG4gIGNlbnRlcjogY29vclNjaGVtYSxcbn0pO1xuXG5leHBvcnQgY29uc3QgYW5ub3RhdGlvblR5cGVTY2hlbWEgPSB6LnVuaW9uKFtcbiAgei5saXRlcmFsKFwiQ0RTXCIpLFxuICB6LmxpdGVyYWwoXCJlbmhhbmNlclwiKSxcbiAgei5saXRlcmFsKFwiaW50cm9uXCIpLFxuICB6LmxpdGVyYWwoXCJtaXNjX2ZlYXR1cmVcIiksXG4gIHoubGl0ZXJhbChcInBvbHlBX3NpZ25hbFwiKSxcbiAgei5saXRlcmFsKFwicHJvbW90ZXJcIiksXG4gIHoubGl0ZXJhbChcInByb3RlaW5fYmluZFwiKSxcbiAgei5saXRlcmFsKFwicmVwX29yaWdpblwiKSxcbiAgei5saXRlcmFsKFwiTFRSXCIpLFxuICB6LnN0cmluZygpLFxuXSk7XG5cbmV4cG9ydCBjb25zdCBhbm5vdGF0aW9uU2NoZW1hID0gei5vYmplY3Qoe1xuICB0eXBlOiBhbm5vdGF0aW9uVHlwZVNjaGVtYSxcbiAgZGlyZWN0aW9uOiB6LnVuaW9uKFt6LmxpdGVyYWwoXCJmb3J3YXJkXCIpLCB6LmxpdGVyYWwoXCJyZXZlcnNlXCIpXSksXG4gIHN0YXJ0OiB6Lm51bWJlcigpLFxuICBlbmQ6IHoubnVtYmVyKCksXG4gIGNsYXNzTmFtZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0ZXh0OiB6LnN0cmluZygpLFxuICBvbkNsaWNrOiB6LmZ1bmN0aW9uKCkuYXJncyh6LmFueSgpKS5vcHRpb25hbCgpLCAvLyBjaXJjdWxhciByZWZlcmVuY2Vcbn0pO1xuXG5leHBvcnQgY29uc3Qgc3RhY2tlZEFubm90YXRpb25TY2hlbWEgPSBhbm5vdGF0aW9uU2NoZW1hLmV4dGVuZCh7XG4gIHN0YWNrOiB6Lm51bWJlcigpLFxufSk7XG5cbmV4cG9ydCBjb25zdCBudWNsU2NoZW1hID0gei51bmlvbihbXG4gIHoubGl0ZXJhbChcIkFcIiksXG4gIHoubGl0ZXJhbChcIkNcIiksXG4gIHoubGl0ZXJhbChcIkdcIiksXG4gIHoubGl0ZXJhbChcIlRcIiksXG5dKTtcblxuZXhwb3J0IGNvbnN0IGFhU2NoZW1hID0gei51bmlvbihbXG4gIC8vIEFkZCBhbGwgeW91ciBhbWlubyBhY2lkcyBsaXRlcmFscyBoZXJlXG4gIHoubGl0ZXJhbChcIkFcIiksXG4gIHoubGl0ZXJhbChcIkNcIiksXG4gIHoubGl0ZXJhbChcIkRcIiksXG4gIHoubGl0ZXJhbChcIkVcIiksXG4gIHoubGl0ZXJhbChcIkZcIiksXG4gIHoubGl0ZXJhbChcIkdcIiksXG4gIHoubGl0ZXJhbChcIkhcIiksXG4gIHoubGl0ZXJhbChcIklcIiksXG4gIHoubGl0ZXJhbChcIktcIiksXG4gIHoubGl0ZXJhbChcIkxcIiksXG4gIHoubGl0ZXJhbChcIk1cIiksXG4gIHoubGl0ZXJhbChcIk5cIiksXG4gIHoubGl0ZXJhbChcIlBcIiksXG4gIHoubGl0ZXJhbChcIlFcIiksXG4gIHoubGl0ZXJhbChcIlJcIiksXG4gIHoubGl0ZXJhbChcIlNcIiksXG4gIHoubGl0ZXJhbChcIlRcIiksXG4gIHoubGl0ZXJhbChcIlZcIiksXG4gIHoubGl0ZXJhbChcIldcIiksXG4gIHoubGl0ZXJhbChcIllcIiksXG5dKTtcbmV4cG9ydCBjb25zdCBHYXBTY2hlbWEgPSB6LmxpdGVyYWwoXCItXCIpO1xuZXhwb3J0IGNvbnN0IFN0b3BTY2hlbWEgPSB6LmxpdGVyYWwoXCIqXCIpO1xuZXhwb3J0IGNvbnN0IFNwYWNlU2NoZW1hID0gei5saXRlcmFsKFwiIFwiKTtcbmV4cG9ydCBjb25zdCBVbmtub3duU2NoZW1hID0gei5saXRlcmFsKFwiP1wiKTtcbmV4cG9ydCBjb25zdCBhbm5vdGF0ZWRCYXNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBiYXNlOiB6LnN0cmluZygpLmxlbmd0aCgxKSxcbiAgYW5ub3RhdGlvbnM6IHouYXJyYXkoc3RhY2tlZEFubm90YXRpb25TY2hlbWEpLFxuICBpbmRleDogei5udW1iZXIoKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2VTY2hlbWEgPSB6LmFycmF5KGFubm90YXRlZEJhc2VTY2hlbWEpO1xuXG5leHBvcnQgY29uc3QgYXJpYWRuZVNlbGVjdGlvblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc3RhcnQ6IHoubnVtYmVyKCksXG4gIGVuZDogei5udW1iZXIoKSxcbiAgZGlyZWN0aW9uOiB6LnVuaW9uKFt6LmxpdGVyYWwoXCJmb3J3YXJkXCIpLCB6LmxpdGVyYWwoXCJyZXZlcnNlXCIpXSksXG59KTtcbiIsImltcG9ydCBnZW5iYW5rUGFyc2VyLCB7IFBhcnNlZEdlbmJhbmsgfSBmcm9tIFwiZ2VuYmFuay1wYXJzZXJcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgeyBhbm5vdGF0ZWRTZXF1ZW5jZVNjaGVtYSwgYW5ub3RhdGlvblR5cGVTY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWFzXCI7XG5pbXBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uVHlwZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcywgc3RhY2tBbm5zQnlUeXBlIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IEdlbmJhbmtGZWF0dXJlU2NoZW1hID0gei5vYmplY3Qoe1xuICBuYW1lOiB6LnN0cmluZygpLm1pbigxKSxcbiAgc3RhcnQ6IHoubnVtYmVyKCksXG4gIGVuZDogei5udW1iZXIoKSxcbiAgc3RyYW5kOiB6LnVuaW9uKFt6LmxpdGVyYWwoMSksIHoubGl0ZXJhbCgtMSldKSxcbiAgdHlwZTogYW5ub3RhdGlvblR5cGVTY2hlbWEsXG4gIG5vdGVzOiB6LnJlY29yZCh6LmFycmF5KHouc3RyaW5nKCkpKS5vcHRpb25hbCgpLFxufSk7XG5leHBvcnQgdHlwZSBHZW5iYW5rRmVhdHVyZSA9IHouaW5mZXI8dHlwZW9mIEdlbmJhbmtGZWF0dXJlU2NoZW1hPjtcblxuZXhwb3J0IGNvbnN0IGdlbmJhbmtUb0Fubm90YXRlZFNlcXVlbmNlID0gKHtcbiAgZ2VuYmFuayxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiB7XG4gIGdlbmJhbms6IFBhcnNlZEdlbmJhbms7XG4gIGFubm90YXRpb25PbkNsaWNrPzogKGFubm90YXRpb246IEFubm90YXRpb24pID0+IHZvaWQ7XG59KSA9PiB7XG4gIGNvbnN0IGZlYXR1cmVzID0gZ2VuYmFuay5mZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHtcbiAgICByZXR1cm4gR2VuYmFua0ZlYXR1cmVTY2hlbWEucGFyc2UoZmVhdHVyZSk7XG4gIH0pO1xuICBjb25zdCBhbm5vdGF0aW9ucyA9IGdlbmJhbmtGZWF0dXJlc1RvQW5ub3RhdGlvbnMoe1xuICAgIGZlYXR1cmVzLFxuICAgIGFubm90YXRpb25PbkNsaWNrLFxuICB9KTtcbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gc3RhY2tBbm5zQnlUeXBlKGFubm90YXRpb25zKTtcbiAgY29uc3QgeyBzdWNjZXNzZXMsIGZhaWx1cmVzIH0gPSBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyh7XG4gICAgcGF5bG9hZDogZ2VuYmFuay5zZXF1ZW5jZSxcbiAgICBwYXlsb2FkVHlwZTogXCJyYXdcIixcbiAgICBhbm5vdGF0aW9uczogc3RhY2tlZEFubm90YXRpb25zLFxuICB9KTtcbiAgaWYgKGZhaWx1cmVzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBnZW5iYW5rOiAke2ZhaWx1cmVzWzBdfWApO1xuICB9XG4gIGlmIChzdWNjZXNzZXMubGVuZ3RoICE9PSAxIHx8IHN1Y2Nlc3Nlc1swXS5zZXF1ZW5jZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBhbm5vdGF0ZWQgc2VxdWVuY2VgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGVkU2VxdWVuY2U6IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hLnBhcnNlKHN1Y2Nlc3Nlc1swXS5zZXF1ZW5jZXNbMF0pLFxuICAgIGFubm90YXRpb25zLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbmJhbmtGZWF0dXJlc1RvQW5ub3RhdGlvbnMgPSAoe1xuICBmZWF0dXJlcyxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiB7XG4gIGZlYXR1cmVzOiBHZW5iYW5rRmVhdHVyZVtdO1xuICBhbm5vdGF0aW9uT25DbGljaz86IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uKSA9PiB2b2lkO1xufSk6IEFubm90YXRpb25bXSA9PiB7XG4gIHJldHVybiBmZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBbZmVhdHVyZS5zdGFydCwgZmVhdHVyZS5lbmRdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBmZWF0dXJlLnR5cGUsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIGxhYmVsOiBmZWF0dXJlLnR5cGUsXG4gICAgICB0ZXh0OiBmZWF0dXJlLm5hbWUsXG4gICAgICBkaXJlY3Rpb246IGZlYXR1cmUuc3RyYW5kID09PSAxID8gXCJmb3J3YXJkXCIgOiBcInJldmVyc2VcIixcbiAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lRnJvbUZlYXR1cmVUeXBlKGZlYXR1cmUudHlwZSksXG4gICAgICBvbkNsaWNrOiBhbm5vdGF0aW9uT25DbGljayxcbiAgICB9O1xuICB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc05hbWVGcm9tRmVhdHVyZVR5cGUoYW5uVHlwZTogQW5ub3RhdGlvblR5cGUpOiBzdHJpbmcge1xuICBjb25zdCBjb21tb24gPVxuICAgIFwiY3Vyc29yLXBvaW50ZXIgb3BhY2l0eS02MCBncm91cC1ob3ZlcjpvcGFjaXR5LTEwMCAhdGV4dC14cyBob3ZlcjpvcGFjaXR5LTEwMCBwb2ludGVyLWV2ZW50cy1hbGwgdGV4dC13aGl0ZSB0ZXh0LWNsaXAgb3ZlcmZsb3ctaGlkZGVuIHdoaXRlc3BhY2Utbm93cmFwXCI7XG4gIGNvbnN0IGNsYXNzTmFtZU1hcDogeyBba2V5OiBBbm5vdGF0aW9uVHlwZV06IHN0cmluZyB9ID0gemlwQXJyYXlzKFxuICAgIFtcbiAgICAgIFwiQ0RTXCIsXG4gICAgICBcImVuaGFuY2VyXCIsXG4gICAgICBcImludHJvblwiLFxuICAgICAgXCJtaXNjX2ZlYXR1cmVcIixcbiAgICAgIFwicG9seUFfc2lnbmFsXCIsXG4gICAgICBcInByb21vdGVyXCIsXG4gICAgICBcInByb3RlaW5fYmluZFwiLFxuICAgICAgXCJyZXBfb3JpZ2luXCIsXG4gICAgICBcIkxUUlwiLFxuICAgICAgXCJzb3VyY2VcIixcbiAgICAgIFwiaW5zZXJ0aW9uXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICBcImJnLXJlZC02MDAgZmlsbC1yZWQtNjAwIHN0cm9rZS1yZWQtNjAwXCIsXG4gICAgICBcImJnLWJsdWUtNjAwIGZpbGwtYmx1ZS02MDAgc3Ryb2tlLWJsdWUtNjAwXCIsXG4gICAgICBcImJnLWdyZWVuLTYwMCBmaWxsLWdyZWVuLTYwMCBzdHJva2UtZ3JlZW4tNjAwXCIsXG4gICAgICBcImJnLXllbGxvdy02MDAgZmlsbC15ZWxsb3ctNjAwIHN0cm9rZS15ZWxsb3ctNjAwXCIsXG4gICAgICBcImJnLW9yYW5nZS02MDAgZmlsbC1vcmFuZ2UtNjAwIHN0cm9rZS1vcmFuZ2UtNjAwXCIsXG4gICAgICBcImJnLXB1cnBsZS02MDAgZmlsbC1wdXJwbGUtNjAwIHN0cm9rZS1wdXJwbGUtNjAwXCIsXG4gICAgICBcImJnLXNreS02MDAgZmlsbC1za3ktNjAwIHN0cm9rZS1za3ktNjAwXCIsXG4gICAgICBcImJnLXRlYWwtNjAwIGZpbGwtdGVhbC02MDAgc3Ryb2tlLXRlYWwtNjAwXCIsXG4gICAgICBcImJnLWdyYXktNjAwIGZpbGwtZ3JheS02MDAgc3Ryb2tlLWdyYXktNjAwXCIsXG4gICAgICBcImJnLXBpbmstNjAwIGZpbGwtcGluay02MDAgc3Ryb2tlLXBpbmstNjAwXCIsXG4gICAgXSxcbiAgKTtcbiAgaWYgKGFublR5cGUgaW4gY2xhc3NOYW1lTWFwKSB7XG4gICAgcmV0dXJuIGAke2NvbW1vbn0gJHtjbGFzc05hbWVNYXBbYW5uVHlwZV0hfWA7XG4gIH1cbiAgcmV0dXJuIGNvbW1vbjtcbn1cblxuZXhwb3J0IGNvbnN0IHppcEFycmF5cyA9IDxUMSwgVDI+KGtleXM6IFQxW10sIHZhbHVlczogVDJbXSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGtleXMubWFwKChrZXk6IFQxLCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IHZhbDogVDIgfCB1bmRlZmluZWQgPSB2YWx1ZXNbaV07XG4gICAgICByZXR1cm4gW2tleSwgdmFsXTtcbiAgICB9KSxcbiAgKSBhcyB7IFQxOiBUMiB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2VuYmFuayA9IChnZW5iYW5rU3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gZ2VuYmFua1BhcnNlcihnZW5iYW5rU3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJpbXBvcnQgZ2VuYmFua1BhcnNlciwgeyBQYXJzZWRHZW5iYW5rIH0gZnJvbSBcImdlbmJhbmstcGFyc2VyXCI7XG5pbXBvcnQgeyBnZW5iYW5rVG9Bbm5vdGF0ZWRTZXF1ZW5jZSB9IGZyb20gXCIuL2dlbmJhbmtVdGlsc1wiO1xuaW1wb3J0IHsgYW5ub3RhdGVkU2VxdWVuY2VTY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWFzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEFubm90YXRlZFNlcXVlbmNlLFxuICBBbm5vdGF0aW9uLFxuICBBbm5vdGF0aW9uVHlwZSxcbiAgQXJpYWRuZVNlbGVjdGlvbixcbiAgU3RhY2tlZEFubm90YXRpb24sXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRDb21wbGVtZW50ID0gKHNlcXVlbmNlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgY29tcGxlbWVudDoge1xuICAgIFtrZXk6IHN0cmluZ106IFwiQVwiIHwgXCJUXCIgfCBcIkNcIiB8IFwiR1wiIHwgXCJOXCI7XG4gIH0gPSB7XG4gICAgQTogXCJUXCIsXG4gICAgVDogXCJBXCIsXG4gICAgQzogXCJHXCIsXG4gICAgRzogXCJDXCIsXG4gICAgTjogXCJOXCIsXG4gIH07XG4gIHJldHVybiBzZXF1ZW5jZVxuICAgIC5zcGxpdChcIlwiKVxuICAgIC5tYXAoKGJhc2UpID0+IHtcbiAgICAgIGlmIChiYXNlIGluIGNvbXBsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZW1lbnRbYmFzZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbihcIlwiKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSA9ICh7XG4gIHNlcXVlbmNlLFxuICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIG5vVmFsaWRhdGUsXG59OiB7XG4gIHNlcXVlbmNlOiBzdHJpbmc7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogQW5ub3RhdGlvbltdO1xuICBub1ZhbGlkYXRlPzogYm9vbGVhbjtcbn0pOiBBbm5vdGF0ZWRTZXF1ZW5jZSA9PiB7XG4gIC8qIGxvb3AgdGhyb3VnaCBzZXF1ZW5jZSBmaW5kaW5nIGFsbCBhbm5vYXRhdGlvbnMgdGhhdCBhcHBseSB0byBlYWNoIGJhc2UgKi9cbiAgY29uc3QgbWFwRm4gPSAoYmFzZTogc3RyaW5nLCBpZHg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGFubm90YXRpb25zRm9yQmFzZSA9IHN0YWNrZWRBbm5vdGF0aW9ucy5maWx0ZXIoKGFubm90YXRpb24pID0+IHtcbiAgICAgIC8vIGlmIHRoZSBhbm5vdGF0aW9uIHNwYW5zIHRoZSBzZWFtIG9mIHRoZSBwbGFzbWlkXG4gICAgICBpZiAoYW5ub3RhdGlvbi5zdGFydCA+IGFubm90YXRpb24uZW5kKSB7XG4gICAgICAgIGNvbnN0IGlzQmV0d2VlbkFubm90YXRpb25TdGFydEFuZEVuZG9mU2VxdWVuY2UgPVxuICAgICAgICAgIGlkeCA+PSBhbm5vdGF0aW9uLnN0YXJ0ICYmIGlkeCA8PSBzZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzQmV0d2VlblN0YXJ0T2ZTZXF1ZW5jZUFuZEFubm90YXRpb25FbmQgPVxuICAgICAgICAgIGlkeCA+PSAwICYmIGlkeCA8PSBhbm5vdGF0aW9uLmVuZDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpc0JldHdlZW5Bbm5vdGF0aW9uU3RhcnRBbmRFbmRvZlNlcXVlbmNlIHx8XG4gICAgICAgICAgaXNCZXR3ZWVuU3RhcnRPZlNlcXVlbmNlQW5kQW5ub3RhdGlvbkVuZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVndWxhciBjYXNlXG4gICAgICAgIHJldHVybiBpZHggPj0gYW5ub3RhdGlvbi5zdGFydCAmJiBpZHggPD0gYW5ub3RhdGlvbi5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2UsXG4gICAgICBpbmRleDogaWR4LFxuICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zRm9yQmFzZSxcbiAgICAgIGNvbXBsZW1lbnQ6IGdldENvbXBsZW1lbnQoYmFzZSksXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgcmF3ID0gc2VxdWVuY2VcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKG1hcEZuKVxuICAgIC5maWx0ZXIoKHgpID0+IHguYmFzZSAhPT0gXCIgXCIpOyAvLyByZW1vdmUgcGFkZGluZ1xuICBjb25zdCBhbm5vdGF0ZWRTZXF1ZW5jZSA9IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hLnNhZmVQYXJzZShyYXcpO1xuICBpZiAobm9WYWxpZGF0ZSkge1xuICAgIGlmIChhbm5vdGF0ZWRTZXF1ZW5jZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgY29uc29sZS53YXJuKGFubm90YXRlZFNlcXVlbmNlLmVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhdyBhcyB1bmtub3duIGFzIEFubm90YXRlZFNlcXVlbmNlO1xuICB9XG4gIGlmIChhbm5vdGF0ZWRTZXF1ZW5jZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihhbm5vdGF0ZWRTZXF1ZW5jZS5lcnJvci5tZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gYW5ub3RhdGVkU2VxdWVuY2UuZGF0YTtcbn07XG5cbmludGVyZmFjZSBTdGFja2FibGUge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbn1cbi8vIG1vZGlmaWVkIGZyb20gc2Vxdml6XG5leHBvcnQgY29uc3Qgc3RhY2tFbGVtZW50cyA9IDxUIGV4dGVuZHMgU3RhY2thYmxlPihlbGVtZW50czogVFtdKSA9PiB7XG4gIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gdXRpbGl0eSBmdW5jcyBmb3Igc3RhY2tFbGVtZW50c1xuICBjb25zdCBsYXN0ID0gKGFycjogVFtdKTogVCA9PiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICBjb25zdCBmaXJzdCA9IChhcnI6IFRbXSk6IFQgPT4gYXJyWzBdO1xuICBjb25zdCBtYXhJbmRleCA9IGVsZW1lbnRzLm1hcCgoZSkgPT4gZS5lbmQpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYikpO1xuXG4gIGNvbnN0IHN0YWNrOiBUW11bXSA9IFtdO1xuICBlbGVtZW50cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgY29uc3QgaW5zZXJ0SW5kZXggPSBzdGFjay5maW5kSW5kZXgoKGVsZW1zKSA9PiB7XG4gICAgICBpZiAoYS5lbmQgPT09IGEuc3RhcnQpIHtcbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgaW5kZXggYW5kIHRoZXJlZm9yZSBzcGFucyB0aGUgd2hvbGUgYW5kIGdldHMgaXRzIG93biByb3dcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3QoZWxlbXMpLmVuZCA8PSBsYXN0KGVsZW1zKS5zdGFydCkge1xuICAgICAgICAvLyBpZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoaXMgcm93IGNyb3NzZXMgemVybyBpbmRleCBpdCBnZXRzIGl0cyBvd24gcm93XG4gICAgICAgIHJldHVybiBsYXN0KGVsZW1zKS5lbmQgKyBtYXhJbmRleCA8PSBhLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGEuZW5kID4gYS5zdGFydCkge1xuICAgICAgICAvLyB0aGlzIGVsZW1lbnQgZG9lc24ndCBjcm9zcyB0aGUgemVybyBpbmRleCBhbmQgdGhlIGxhc3QgaW4gcm93IGRvZXNuJ3RcbiAgICAgICAgcmV0dXJuIGxhc3QoZWxlbXMpLmVuZCA8PSBhLnN0YXJ0O1xuICAgICAgfVxuICAgICAgLy8gYm90aCB0aGlzIGN1cnIgZWxlbWVudCBhbmQgdGhlIGxhc3QgaW4gdGhlIHJvdyBjcm9zcyB0aGUgemVybyBpbmRleFxuICAgICAgcmV0dXJuIGxhc3QoZWxlbXMpLmVuZCA8IGEuc3RhcnQgJiYgYS5lbmQgPCBmaXJzdChlbGVtcykuc3RhcnQ7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5zZXJ0SW5kZXggPiAtMSkge1xuICAgICAgLy8gaW5zZXJ0IGluIHRoZSByb3cgd2hlcmUgaXQncyB0aGUgbmV3IGhpZ2hlc3RcbiAgICAgIHN0YWNrW2luc2VydEluZGV4XS5wdXNoKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgcm93IGZvciB0aGlzIGVudHJ5XG4gICAgICBzdGFjay5wdXNoKFthXSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0YWNrLm1hcCgocm93KSA9PiByb3cuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpKTtcbn07XG5cbi8vIHJldHVybnMgYW5ub3RhdGlvbnMgd2l0aCB0aGVpciBzdGFjayBpbmRleCBhbmQgbWF4IHN0YWNrIGluZGV4XG5leHBvcnQgY29uc3QgZ2V0U3RhY2tlZEFubm90YXRpb25zID0gKFxuICBhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdLFxuKTogU3RhY2tlZEFubm90YXRpb25bXSA9PiB7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrRWxlbWVudHMoYW5ub3RhdGlvbnMpO1xuICByZXR1cm4gc3RhY2tlZEFubm90YXRpb25zXG4gICAgLm1hcCgocm93LCBpZHgpID0+IHJvdy5tYXAoKGFubm90YXRpb24pID0+ICh7IC4uLmFubm90YXRpb24sIHN0YWNrOiBpZHggfSkpKVxuICAgIC5mbGF0KCk7XG59O1xuZXhwb3J0IGNvbnN0IGJhc2VJblNlbGVjdGlvbiA9ICh7XG4gIGJhc2VJbmRleCxcbiAgc2VsZWN0aW9uLFxuICBzZXF1ZW5jZUxlbmd0aCxcbn06IHtcbiAgYmFzZUluZGV4OiBudW1iZXI7XG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG59KSA9PiB7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uO1xuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiBiYXNlSW5kZXggPT09IHN0YXJ0O1xuICB9XG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIHJldHVybiBpblJhbmdlKGJhc2VJbmRleCwgc3RhcnQsIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gc3BhbnMgc2VhbVxuICAgIHJldHVybiAoXG4gICAgICBpblJhbmdlKGJhc2VJbmRleCwgc3RhcnQsIHNlcXVlbmNlTGVuZ3RoKSB8fCBpblJhbmdlKGJhc2VJbmRleCwgMCwgZW5kKVxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpblJhbmdlID0gKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4ge1xuICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdWJzZXF1ZW5jZUxlbmd0aCA9IChcbiAgeyBzdGFydCwgZW5kIH06IEFyaWFkbmVTZWxlY3Rpb24sXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4pID0+IHtcbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZXF1ZW5jZUxlbmd0aCAtIHN0YXJ0ICsgZW5kO1xuICB9XG59O1xuXG5pbnRlcmZhY2UgU3RyaW5nU291cmNlIHtcbiAgcGF5bG9hZFR5cGU6IFwiZ2VuYmFua1wiIHwgXCJmYXN0YVwiIHwgXCJyYXdcIjtcbiAgcGF5bG9hZDogc3RyaW5nO1xuICBhbm5vdGF0aW9ucz86IEFubm90YXRpb25bXTtcbiAgYW5ub3RhdGlvbk9uQ2xpY2s/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIEdlbmJhbmtTb3VyY2Uge1xuICBwYXlsb2FkVHlwZTogXCJwYXJzZWQtZ2VuYmFua1wiO1xuICBwYXlsb2FkOiBQYXJzZWRHZW5iYW5rO1xuICBhbm5vdGF0aW9ucz86IHVuZGVmaW5lZDtcbiAgYW5ub3RhdGlvbk9uQ2xpY2s/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4gdm9pZDtcbn1cbnR5cGUgQW55dGhpbmdTb3VyY2UgPSBTdHJpbmdTb3VyY2UgfCBHZW5iYW5rU291cmNlO1xuXG50eXBlIFBhcnNlRXJyb3IgPSB7XG4gIHNvdXJjZTogQW55dGhpbmdTb3VyY2U7XG4gIGVycm9yOiBzdHJpbmc7XG59O1xudHlwZSBQYXJzZVN1Y2Nlc3MgPSB7XG4gIHNvdXJjZTogQW55dGhpbmdTb3VyY2U7XG4gIHNlcXVlbmNlczogQW5ub3RhdGVkU2VxdWVuY2VbXTtcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbn07XG5leHBvcnQgY29uc3QgYW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyA9ICh7XG4gIHBheWxvYWQsXG4gIHBheWxvYWRUeXBlLFxuICBhbm5vdGF0aW9ucyxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiBBbnl0aGluZ1NvdXJjZSk6IHtcbiAgc2VxdWVuY2VzOiBBbm5vdGF0ZWRTZXF1ZW5jZVtdO1xuICBzdGFja2VkQW5ub3RhdGlvbnM6IFN0YWNrZWRBbm5vdGF0aW9uW107XG59ID0+IHtcbiAgY29uc3QgeyBzdWNjZXNzZXMsIGZhaWx1cmVzIH0gPSBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyh7XG4gICAgcGF5bG9hZCxcbiAgICBwYXlsb2FkVHlwZSxcbiAgICBhbm5vdGF0aW9ucyxcbiAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgfSBhcyBBbnl0aGluZ1NvdXJjZSk7XG4gIGlmIChmYWlsdXJlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmFpbFN0cmluZyA9IGZhaWx1cmVzLm1hcCgoZikgPT4gZi5lcnJvcikuam9pbihcIlxcblwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnNlIGZhaWx1cmVzOiAke2ZhaWxTdHJpbmd9YCk7XG4gIH1cbiAgY29uc3Qgc2VxdWVuY2VzID0gc3VjY2Vzc2VzLm1hcCgocykgPT4gcy5zZXF1ZW5jZXMpLmZsYXQoKTtcbiAgY29uc3QgbmV3QW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSA9IHN1Y2Nlc3Nlc1xuICAgIC5tYXAoKHMpID0+IHMuYW5ub3RhdGlvbnMpXG4gICAgLmZsYXQoKTtcbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gZ2V0U3RhY2tlZEFubm90YXRpb25zKG5ld0Fubm90YXRpb25zKTtcbiAgcmV0dXJuIHsgc2VxdWVuY2VzLCBzdGFja2VkQW5ub3RhdGlvbnMgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyA9ICh7XG4gIHBheWxvYWQsXG4gIHBheWxvYWRUeXBlLFxuICBhbm5vdGF0aW9ucyxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiBBbnl0aGluZ1NvdXJjZSk6IHsgc3VjY2Vzc2VzOiBQYXJzZVN1Y2Nlc3NbXTsgZmFpbHVyZXM6IFBhcnNlRXJyb3JbXSB9ID0+IHtcbiAgY29uc3Qgc3VjY2Vzc2VzOiBQYXJzZVN1Y2Nlc3NbXSA9IFtdO1xuICBjb25zdCBmYWlsdXJlczogUGFyc2VFcnJvcltdID0gW107XG4gIHN3aXRjaCAocGF5bG9hZFR5cGUpIHtcbiAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlcyA9IFtcbiAgICAgICAgICBzdHJpbmdUb0Fubm90YXRlZFNlcXVlbmNlKHtcbiAgICAgICAgICAgIHNlcXVlbmNlOiBwYXlsb2FkLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zID8/IFtdLFxuICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgICAgICBzdWNjZXNzZXMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VxdWVuY2VzOiBzZXF1ZW5jZXMsXG4gICAgICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zID8/IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gcGFyc2UgcmF3IHNlcXVlbmNlOiAke2V9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInBhcnNlZC1nZW5iYW5rXCI6XG4gICAgY2FzZSBcImdlbmJhbmtcIjoge1xuICAgICAgY29uc3QgcGFyc2VkID1cbiAgICAgICAgcGF5bG9hZFR5cGUgPT09IFwicGFyc2VkLWdlbmJhbmtcIiA/IFtwYXlsb2FkXSA6IGdlbmJhbmtQYXJzZXIocGF5bG9hZCk7XG5cbiAgICAgIHBhcnNlZC5mb3JFYWNoKChnZW5iYW5rKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2VxdWVuY2UgPSBnZW5iYW5rVG9Bbm5vdGF0ZWRTZXF1ZW5jZSh7XG4gICAgICAgICAgICBnZW5iYW5rLFxuICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgfSkuYW5ub3RhdGVkU2VxdWVuY2U7XG4gICAgICAgICAgc3VjY2Vzc2VzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICB9IGFzIEFueXRoaW5nU291cmNlLFxuICAgICAgICAgICAgc2VxdWVuY2VzOiBbc2VxdWVuY2VdLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IFtdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgIGFubm90YXRpb25PbkNsaWNrLFxuICAgICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgIH0gYXMgQW55dGhpbmdTb3VyY2UsXG4gICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBwYXJzZSBnZW5iYW5rOiAke2V9YCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZhc3RhXCI6IHtcbiAgICAgIGxldCByZWNvcmRzOiAoRmFzdGFSZWNvcmQgfCBGYXN0cVJlY29yZClbXTtcbiAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gXCJmYXN0YVwiKSB7XG4gICAgICAgIHJlY29yZHMgPSBwYXJzZUZhc3RhKHBheWxvYWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFzdHFcbiAgICAgICAgcmVjb3JkcyA9IHBhcnNlRmFzdHEocGF5bG9hZCk7XG4gICAgICB9XG4gICAgICByZWNvcmRzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IHNhZmVBbnl0aGluZ1RvQW5ub3RhdGVkU2VxdWVuY2VzKHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlY29yZC5zZXF1ZW5jZSxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlOiBcInJhd1wiLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZhaWx1cmVzLnB1c2goLi4ucmVzLmZhaWx1cmVzKTtcbiAgICAgICAgICBzdWNjZXNzZXMucHVzaCguLi5yZXMuc3VjY2Vzc2VzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWx1cmVzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gcGFyc2UgJHtwYXlsb2FkVHlwZX06ICR7ZX1gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBmYWlsdXJlcy5wdXNoKHtcbiAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGBVbmtub3duIHBheWxvYWQgdHlwZTogJHtwYXlsb2FkVHlwZX1gLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3NlcyxcbiAgICBmYWlsdXJlcyxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdUb0Fubm90YXRlZFNlcXVlbmNlID0gKHtcbiAgc2VxdWVuY2UsXG4gIGFubm90YXRpb25zLFxufToge1xuICBzZXF1ZW5jZTogc3RyaW5nO1xuICBhbm5vdGF0aW9ucz86IEFubm90YXRpb25bXTtcbn0pOiBBbm5vdGF0ZWRTZXF1ZW5jZSA9PiB7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IGdldFN0YWNrZWRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucyA/PyBbXSk7XG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlID0gZ2V0QW5ub3RhdGVkU2VxdWVuY2Uoe1xuICAgIHNlcXVlbmNlLFxuICAgIHN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgfSk7XG4gIHJldHVybiBhbm5vdGF0ZWRTZXF1ZW5jZTtcbn07XG5cbi8vIERldGVybWluZSBpZiB0d28gYW5ub3RhdGlvbnMgZnJvbSB0aGUgc2FtZSBzZXF1ZW5jZSBvdmVybGFwLlxuZXhwb3J0IGNvbnN0IGFubm90YXRpb25zSGF2ZU92ZXJsYXAgPSAoXG4gIGExOiBBbm5vdGF0aW9uLFxuICBhMjogQW5ub3RhdGlvbixcbiAgbWF4TGVuOiBudW1iZXIsXG4pOiBib29sZWFuID0+IHtcbiAgaWYgKFxuICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICBiYXNlSW5kZXg6IGExLnN0YXJ0LFxuICAgICAgc2VsZWN0aW9uOiBhMixcbiAgICAgIHNlcXVlbmNlTGVuZ3RoOiBtYXhMZW4sXG4gICAgfSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICBiYXNlSW5kZXg6IGExLmVuZCxcbiAgICAgIHNlbGVjdGlvbjogYTIsXG4gICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4TGVuLFxuICAgIH0pXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMi5zdGFydCxcbiAgICAgIHNlbGVjdGlvbjogYTEsXG4gICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4TGVuLFxuICAgIH0pXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMi5lbmQsXG4gICAgICBzZWxlY3Rpb246IGExLFxuICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heExlbixcbiAgICB9KVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBDcmVhdGUgU3RhY2tlZEFubm90YXRpb25zIHN1Y2ggdGhhdCBubyBcInN0YWNrXCIgb3IgbGluZSBvZiBhbm5vdGF0aW9ucyBoYXZlXG4vLyBhbnkgb3ZlcmxhcHBpbmcgYW5ub3RhdGlvbnMuXG5leHBvcnQgY29uc3Qgc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcCA9IChcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSxcbiAgbWF4TGVuOiBudW1iZXIsXG4pOiBTdGFja2VkQW5ub3RhdGlvbltdID0+IHtcbiAgY29uc3QgYW5ub3RhdGlvbnNCeVN0YWNrID0gW10gYXMgQW5ub3RhdGlvbltdW107XG5cbiAgYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgbGV0IGN1clN0YWNrID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qgc3RhY2tBbm5zID0gYW5ub3RhdGlvbnNCeVN0YWNrW2N1clN0YWNrXTtcbiAgICAgIGlmICghc3RhY2tBbm5zKSB7XG4gICAgICAgIGFubm90YXRpb25zQnlTdGFja1tjdXJTdGFja10gPSBbYW5ub3RhdGlvbl07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IG92ZXJsYXAgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgc3RhY2tlZEFubiBvZiBzdGFja0FubnMpIHtcbiAgICAgICAgaWYgKGFubm90YXRpb25zSGF2ZU92ZXJsYXAoYW5ub3RhdGlvbiwgc3RhY2tlZEFubiwgbWF4TGVuKSkge1xuICAgICAgICAgIG92ZXJsYXAgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybGFwKSB7XG4gICAgICAgIC8vIEEgb3ZlcmxhcCB3YXMgZGV0ZWN0ZWQgc28gdHJ5IHRoZSBuZXh0IGxpbmUuXG4gICAgICAgIGN1clN0YWNrICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBvdmVybGFwcyBkZXRlY3RlZCBvbiB0aGlzIHN0YWNrIHRoZW4gYWRkIHRoZVxuICAgICAgICAvLyBhbm5vdGF0aW9uIHRvIHRoaXMgbGluZS5cbiAgICAgICAgYW5ub3RhdGlvbnNCeVN0YWNrW2N1clN0YWNrXS5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBDb252ZXJ0IGFubm90YXRpb25zIHRvIHN0YWNrZWQgYW5ub3RhdGlvbnNcbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gW10gYXMgU3RhY2tlZEFubm90YXRpb25bXTtcbiAgYW5ub3RhdGlvbnNCeVN0YWNrLmZvckVhY2goKHN0YWNrZWRBbm5zLCBpbmRleCkgPT4ge1xuICAgIHN0YWNrZWRBbm5zLmZvckVhY2goKGFubm90YXRpb24pID0+IHtcbiAgICAgIHN0YWNrZWRBbm5vdGF0aW9ucy5wdXNoKHtcbiAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgc3RhY2s6IGluZGV4LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzdGFja2VkQW5ub3RhdGlvbnM7XG59O1xuXG5leHBvcnQgY29uc3Qgc3RhY2tBbm5zQnlUeXBlID0gKFxuICBhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdLFxuKTogU3RhY2tlZEFubm90YXRpb25bXSA9PiB7XG4gIC8vIGNyZWF0ZSBhIG1hcCBvZiBhbm5vdGF0aW9uIHR5cGUgdG8gbGlzdFxuICBjb25zdCBhbm5vdGF0aW9uTWFwID0gYW5ub3RhdGlvbnMucmVkdWNlKFxuICAgIChhY2M6IHsgW2tleTogQW5ub3RhdGlvblR5cGVdOiBBbm5vdGF0aW9uW10gfSwgYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4ge1xuICAgICAgaWYgKGFjY1thbm5vdGF0aW9uLnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjW2Fubm90YXRpb24udHlwZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGFjY1thbm5vdGF0aW9uLnR5cGVdIS5wdXNoKGFubm90YXRpb24pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9IGFzIHsgW2tleTogQW5ub3RhdGlvblR5cGVdOiBBbm5vdGF0aW9uW10gfSxcbiAgKTtcblxuICBjb25zdCBzdGFja3MgPSBPYmplY3QudmFsdWVzKGFubm90YXRpb25NYXApXG4gICAgLm1hcCgoc3RhY2ssIHN0YWNrSWR4KSA9PiB7XG4gICAgICByZXR1cm4gc3RhY2subWFwKChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlczogU3RhY2tlZEFubm90YXRpb24gPSB7XG4gICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICBzdGFjazogc3RhY2tJZHgsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC5mbGF0KCk7XG5cbiAgcmV0dXJuIHN0YWNrcztcbn07XG5cbmludGVyZmFjZSBGYXN0cVJlY29yZCB7XG4gIGlkOiBzdHJpbmc7XG4gIHNlcXVlbmNlOiBzdHJpbmc7XG4gIG9wdGlvbmFsSWQ6IHN0cmluZztcbiAgcXVhbGl0eTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGYXN0cShkYXRhOiBzdHJpbmcpOiBGYXN0cVJlY29yZFtdIHtcbiAgY29uc3QgbGluZXMgPSBkYXRhLnRyaW0oKS5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgcmVjb3JkczogRmFzdHFSZWNvcmRbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCByZWNvcmQ6IEZhc3RxUmVjb3JkID0ge1xuICAgICAgaWQ6IGxpbmVzW2ldLnN1YnN0cmluZygxKSxcbiAgICAgIHNlcXVlbmNlOiBsaW5lc1tpICsgMV0sXG4gICAgICBvcHRpb25hbElkOiBsaW5lc1tpICsgMl0uc3Vic3RyaW5nKDEpLFxuICAgICAgcXVhbGl0eTogbGluZXNbaSArIDNdLFxuICAgIH07XG5cbiAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvcmRzO1xufVxuXG5pbnRlcmZhY2UgRmFzdGFSZWNvcmQge1xuICBpZDogc3RyaW5nO1xuICBzZXF1ZW5jZTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGYXN0YShkYXRhOiBzdHJpbmcpOiBGYXN0YVJlY29yZFtdIHtcbiAgY29uc3QgbGluZXMgPSBkYXRhLnRyaW0oKS5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgcmVjb3JkczogRmFzdGFSZWNvcmRbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCByZWNvcmQ6IEZhc3RhUmVjb3JkID0ge1xuICAgICAgaWQ6IGxpbmVzW2ldLnN1YnN0cmluZygxKSxcbiAgICAgIHNlcXVlbmNlOiBsaW5lc1tpICsgMV0sXG4gICAgfTtcblxuICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29yZHM7XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgdXNlU3RhdGVSZWYgPSA8VD4oaW5pdGlhbFZhbHVlOiBUKSA9PiB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBbc3RhdGUsIGludGVybmFsU2V0U3RhdGVdID0gdXNlU3RhdGU8VD4oaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjaygodmFsdWU6IFQpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIGludGVybmFsU2V0U3RhdGUodmFsdWUpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIHJlZl0gYXMgY29uc3Q7XG59O1xuIiwiaW1wb3J0IHsgZmluZEFuZ2xlRnJvbUNvb3IgfSBmcm9tIFwiQEFyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvY2lyY3VsYXJVdGlsc1wiO1xuaW1wb3J0IHsgQW5nbGUsIENvb3IgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IGluUmFuZ2UgfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IFJlZk9iamVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZVJlZiB9IGZyb20gXCIuL3VzZVN0YXRlUmVmXCI7XG5cbi8qIHVzZUxpbmVhclNlbGVjdGlvblJlY3QgbWFuYWdlcyB0aGUgc2VsZWN0aW9uIG9mIGEgTGluZWFyU2VsZWN0aW9uIHdpdGhpblxuICogdGhlIExpbmVhclZpZXdlci5cbiAqXG4gKiByZWYgKFJlZk9iamVjdCkgQSByZWZlcmVuY2UgdG8gdGhlIHN2ZyBjb250YWluaW5nIHRoZSBMaW5lYXJTZWxlY3Rpb24uXG4gKiBvbk1vdXNlVXA6IE9wdGlvbmFsIGhhbmRsZXIgd2hlbiB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZVxuICogb25Nb3VzZURvd246IE9wdGlvbmFsIGhhbmRsZXIgd2hlbiB1c2VyIHByZXNzZXMgdGhlIG1vdXNlIG9uIHRoZSBMaW5lYXJTZWxlY3Rpb24uXG4gKiBvbk1vdXNlTW92ZTogT3B0aW9uYWwgaGFuZGxlciB3aGVuIHVzZXIgZHJhZ3MuXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0ID0gPFxuICBUIGV4dGVuZHMge1xuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOiBET01SZWN0O1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6ICh0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiAoZTogTW91c2VFdmVudCkgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiAoXG4gICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICBsaXN0ZW5lcjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQsXG4gICAgKSA9PiB2b2lkO1xuICB9LFxuPih7XG4gIHJlZixcbiAgb25Nb3VzZVVwLFxuICBvbk1vdXNlRG93bixcbiAgb25Nb3VzZU1vdmUsXG59OiB7XG4gIHJlZjogUmVmT2JqZWN0PFQgfCBudWxsPjtcbiAgb25Nb3VzZVVwPzogKHBheWxvYWQ6IHsgc3RhcnQ6IENvb3I7IGVuZDogQ29vciB9KSA9PiB2b2lkO1xuICBvbk1vdXNlRG93bj86IChwYXlsb2FkOiB7IHN0YXJ0OiBDb29yIH0pID0+IHZvaWQ7XG4gIG9uTW91c2VNb3ZlPzogKHBheWxvYWQ6IHsgc3RhcnQ6IENvb3I7IGVuZDogQ29vciB9KSA9PiB2b2lkO1xufSkgPT4ge1xuICBjb25zdCBbc3RhcnQsIHNldFN0YXJ0LCBzdGFydFJlZl0gPSB1c2VTdGF0ZVJlZjxDb29yIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtlbmQsIHNldEVuZCwgZW5kUmVmXSA9IHVzZVN0YXRlUmVmPENvb3IgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGU8XCJmb3J3YXJkXCIgfCBcInJldmVyc2VcIj4oXCJmb3J3YXJkXCIpO1xuXG4gIGNvbnN0IGFjdGl2ZSA9IHVzZVJlZihmYWxzZSk7XG5cbiAgY29uc3QgX29uTW91c2VEb3duID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IHJlZi5jdXJyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgIH07XG4gICAgY29uc3QgeCA9IGNsaWVudFggLSBsZWZ0O1xuICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgIGFjdGl2ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICBzZXRTdGFydCh7IHgsIHkgfSk7XG4gICAgc2V0RW5kKHsgeCwgeSB9KTtcbiAgICBvbk1vdXNlRG93bj8uKHsgc3RhcnQ6IHsgeCwgeSB9IH0pO1xuICB9O1xuICBjb25zdCBfb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgIGFjdGl2ZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKHN0YXJ0UmVmLmN1cnJlbnQgJiYgZW5kUmVmLmN1cnJlbnQpIHtcbiAgICAgIG9uTW91c2VVcD8uKHsgc3RhcnQ6IHN0YXJ0UmVmLmN1cnJlbnQsIGVuZDogZW5kUmVmLmN1cnJlbnQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdGFydCBvciBlbmQgaXMgbnVsbCB3aGVuIG1vdXNldXBcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIG11c3QgdXNlIHJlZnMgaW4gZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG1vc3QgdXAgdG8gZGF0ZSB2YWx1ZXNcbiAgY29uc3QgX29uTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoYWN0aXZlLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgIGNvbnN0IHsgbGVmdCwgdG9wIH0gPSByZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwge1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICB9O1xuICAgICAgY29uc3QgeCA9IGNsaWVudFggLSBsZWZ0O1xuICAgICAgY29uc3QgeSA9IGNsaWVudFkgLSB0b3A7XG4gICAgICBjb25zdCB7IHN0YXJ0WCB9ID0ge1xuICAgICAgICBzdGFydFg6IHN0YXJ0UmVmLmN1cnJlbnQ/LngsXG4gICAgICB9O1xuICAgICAgaWYgKHN0YXJ0WCAmJiBzdGFydFggPiB4KSB7XG4gICAgICAgIHNldERpcmVjdGlvbihcInJldmVyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXREaXJlY3Rpb24oXCJmb3J3YXJkXCIpO1xuICAgICAgfVxuICAgICAgc2V0RW5kKHsgeCwgeSB9KTtcbiAgICAgIGlmIChzdGFydFJlZi5jdXJyZW50ICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIG9uTW91c2VNb3ZlPy4oeyBzdGFydDogc3RhcnRSZWYuY3VycmVudCwgZW5kOiBlbmRSZWYuY3VycmVudCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdGFydCBpcyBudWxsIHdoZW4gbW91c2Vtb3ZlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gcmVmPy5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX29uTW91c2VEb3duKTtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfb25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgICBpZiAod2luZG93KSB7XG4gICAgICAvLyBzdGlsbCB3YW50IHRvIGNhbGwgbW91c2V1cCBpZiBtb3VzZSBsZWF2ZXMgcGFyZW50XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX29uTW91c2VVcCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF9vbk1vdXNlRG93bik7XG4gICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF9vbk1vdXNlTW92ZSk7XG4gICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF9vbk1vdXNlVXApO1xuICAgIH07XG4gIH0sIFtyZWZdKTtcbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uIH07XG59O1xuXG4vLyBmb3IgY2lyY3VsYXIgY29vcmRpbmF0ZXNcbmV4cG9ydCBjb25zdCB1c2VDaXJjdWxhclNlbGVjdGlvblJlY3QgPSAoXG4gIHJlZjogUmVmT2JqZWN0PFNWR1NWR0VsZW1lbnQgfCBudWxsPixcbikgPT4ge1xuICBjb25zdCBbc3RhcnQsIHNldFN0YXJ0LCBzdGFydFJlZl0gPSB1c2VTdGF0ZVJlZjxBbmdsZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZW5kLCBzZXRFbmRdID0gdXNlU3RhdGVSZWY8QW5nbGUgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGU8XG4gICAgXCJjbG9ja3dpc2VcIiB8IFwiY291bnRlcmNsb2Nrd2lzZVwiIHwgbnVsbFxuICA+KG51bGwpO1xuICBjb25zdCBBTkdMRV9ERUxUQV9USFJFU0hPTERfSU5fREVHUkVFUyA9IDI7XG5cbiAgY29uc3QgYWN0aXZlID0gdXNlUmVmKGZhbHNlKTtcblxuICBjb25zdCBvbk1vdXNlRG93biA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwicmVzZXR0aW5nIHN0YXJ0IGFuZCBlbmRcIik7XG4gICAgICBzZXRTdGFydChudWxsKTtcbiAgICAgIHNldEVuZChudWxsKTtcbiAgICAgIHNldERpcmVjdGlvbihudWxsKTtcbiAgICAgIGFjdGl2ZS5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xuICAgICAgY29uc3QgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IHJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgeCA9IGNsaWVudFggLSBsZWZ0O1xuICAgICAgY29uc3QgeSA9IGNsaWVudFkgLSB0b3A7XG4gICAgICBjb25zdCBjZW50ZXIgPSB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0IC8gMiB9O1xuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogeyB4LCB5IH0sIGNlbnRlciB9KTtcbiAgICAgIHNldFN0YXJ0KHtcbiAgICAgICAgZGVncmVlczogc3RhcnRBbmdsZSxcbiAgICAgICAgY2VudGVyLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICBhY3RpdmUuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgc2V0RGlyZWN0aW9uKG51bGwpO1xuICB9O1xuXG4gIGNvbnN0IG9uTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoYWN0aXZlLmN1cnJlbnQgJiYgcmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSByZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgY29uc3QgY2VudGVyID0geyB4OiB3aWR0aCAvIDIsIHk6IGhlaWdodCAvIDIgfTtcbiAgICAgIC8vIGlmIHdlJ3JlIGNsb3NlIHRvIHRoZSBjZW50ZXIsIGRvbid0IHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgIGlmIChcbiAgICAgICAgTWF0aC5zcXJ0KE1hdGgucG93KHggLSBjZW50ZXIueCwgMikgKyBNYXRoLnBvdyh5IC0gY2VudGVyLnksIDIpKSA8XG4gICAgICAgIDAuNCAqICh3aWR0aCAvIDIpXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIndpdGhpbiAwLjUgcmFkaXVzIG9mIGNlbnRlciwgbm90IHVwZGF0aW5nIHNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmRBbmdsZSA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogeyB4LCB5IH0sIGNlbnRlciB9KTtcbiAgICAgIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydFJlZi5jdXJyZW50LmRlZ3JlZXM7XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlSXNOZWFyU3RhcnRBbmdsZSA9IGluUmFuZ2UoXG4gICAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgICAgc3RhcnRBbmdsZSAtIEFOR0xFX0RFTFRBX1RIUkVTSE9MRF9JTl9ERUdSRUVTLFxuICAgICAgICAgIHN0YXJ0QW5nbGUgKyBBTkdMRV9ERUxUQV9USFJFU0hPTERfSU5fREVHUkVFUyxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlSXNOZWFyU3RhcnRBbmdsZSkge1xuICAgICAgICAgIHNldERpcmVjdGlvbihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0RW5kKHtcbiAgICAgICAgZGVncmVlczogZW5kQW5nbGUsXG4gICAgICAgIGNlbnRlcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lRGlyZWN0aW9uKCkge1xuICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBkaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0LmRlZ3JlZXM7XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gZW5kLmRlZ3JlZXM7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICBjb25zdCBndWVzc2VkRGlyZWN0aW9uID0gZGVsdGEgPiAwID8gXCJjbG9ja3dpc2VcIiA6IFwiY291bnRlcmNsb2Nrd2lzZVwiO1xuICAgICAgICBzZXREaXJlY3Rpb24oZ3Vlc3NlZERpcmVjdGlvbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBbc3RhcnQsIGVuZF0sXG4gICk7XG5cbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duKTtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgIG5vZGU/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUpO1xuICAgICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgW3JlZi5jdXJyZW50LCBzdGFydCwgZGlyZWN0aW9uXSxcbiAgKTtcbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uIH07XG59O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsYXNzTmFtZXMoXG4gIC4uLmNsYXNzZXM6IChzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsIHwgYm9vbGVhbilbXVxuKSB7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbn1cbmV4cG9ydCBjb25zdCBjbiA9IGNsYXNzTmFtZXM7XG4iLCJpbXBvcnQgeyBnZW5BcmMgfSBmcm9tIFwiLi4vY2lyY3VsYXJVdGlsc1wiO1xuaW1wb3J0IHR5cGUgeyBBbm5vdGF0ZWRTZXF1ZW5jZSwgQW5ub3RhdGlvbiwgQ29vciB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcbmltcG9ydCB7IGdldFN1YnNlcXVlbmNlTGVuZ3RoIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBDaXJjdWxhckFubm90YXRpb24gPSAoe1xuICBzZXF1ZW5jZSxcbiAgYW5ub3RhdGlvbixcbiAgcmFkaXVzLFxuICBjZW50ZXIsXG59OiB7XG4gIHNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGFubm90YXRpb246IEFubm90YXRpb247XG5cbiAgY2VudGVyOiBDb29yO1xufSkgPT4ge1xuICBjb25zdCB7IHg6IGN4LCB5OiBjeSB9ID0gY2VudGVyO1xuICBjb25zdCBhbm5vdGF0aW9uTGVuZ3RoID0gZ2V0U3Vic2VxdWVuY2VMZW5ndGgoYW5ub3RhdGlvbiwgc2VxdWVuY2UubGVuZ3RoKTtcbiAgaWYgKGFubm90YXRpb25MZW5ndGggPiBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEFubm90YXRpb24gJHthbm5vdGF0aW9uLnRleHR9J3MgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiBzZXF1ZW5jZSBsZW5ndGg6ICR7YW5ub3RhdGlvbkxlbmd0aH0gPiAke3NlcXVlbmNlLmxlbmd0aH1gLFxuICAgICk7XG4gIH1cbiAgY29uc3QgYXJjUGF0aCA9IGdlbkFyYyh7XG4gICAgaW5uZXJSYWRpdXM6IHJhZGl1cyxcbiAgICBvdXRlclJhZGl1czogcmFkaXVzICsgNSxcbiAgICBsYXJnZUFyYzogYW5ub3RhdGlvbkxlbmd0aCA+IHNlcXVlbmNlLmxlbmd0aCAvIDIsXG4gICAgbGVuZ3RoOiBhbm5vdGF0aW9uTGVuZ3RoLFxuICAgIHNlcUxlbmd0aDogc2VxdWVuY2UubGVuZ3RoLFxuICAgIG9mZnNldDogYW5ub3RhdGlvbi5zdGFydCxcbiAgICBjZW50ZXI6IHsgeDogY3gsIHk6IGN5IH0sXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGFubm90YXRpb24uY2xhc3NOYW1lKX1cbiAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgYW5ub3RhdGlvbi5vbkNsaWNrPy4oYW5ub3RhdGlvbik7XG4gICAgICB9fVxuICAgID5cbiAgICAgIDxwYXRoIGQ9e2FyY1BhdGh9PlxuICAgICAgICA8dGl0bGU+e2Fubm90YXRpb24udGV4dH08L3RpdGxlPlxuICAgICAgICA8dGV4dD5Bbm5vdGF0aW9uPC90ZXh0PlxuICAgICAgPC9wYXRoPlxuICAgIDwvc3ZnPlxuICApO1xufTtcbiIsImltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB0eXBlIHsgQW5ub3RhdGVkU2VxdWVuY2UsIFN0YWNrZWRBbm5vdGF0aW9uIH0gZnJvbSBcIkBBcmlhZG5lL3R5cGVzXCI7XG5pbXBvcnQgeyBDaXJjdWxhckFubm90YXRpb24gfSBmcm9tIFwiLi9DaXJjdWxhckFubm90YXRpb25cIjtcbmltcG9ydCB7IGNsYW1wU2xpY2UgfSBmcm9tIFwiLi4vY2lyY3VsYXJVdGlsc1wiO1xuXG5leHBvcnQgY29uc3QgQ2lyY3VsYXJBbm5vdGF0aW9uR3V0dGVyID0gKHtcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBjeCxcbiAgY3ksXG4gIHJhZGl1cyxcbiAgYW5ub3RhdGVkU2VxdWVuY2UsXG59OiB7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogU3RhY2tlZEFubm90YXRpb25bXTtcbiAgY3g6IG51bWJlcjtcbiAgY3k6IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGFubm90YXRlZFNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbn0pID0+IHtcbiAgY29uc3QgZ3V0dGVyUmFkaXVzID0gcmFkaXVzICogMC4zO1xuICBjb25zdCBmaXJzdElkeCA9XG4gICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCA/IGFubm90YXRlZFNlcXVlbmNlLmF0KDApIS5pbmRleCA6IDA7XG4gIGNvbnN0IGxhc3RJZHggPVxuICAgIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDAgPyBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgtMSkhLmluZGV4IDogMDtcbiAgc3RhY2tlZEFubm90YXRpb25zID0gc3RhY2tlZEFubm90YXRpb25zXG4gICAgLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgY29uc3QgY2xhbXBlZEJvdW5kcyA9IGNsYW1wU2xpY2Uoe1xuICAgICAgICBzbGljZTogYW5ub3RhdGlvbixcbiAgICAgICAgZmlyc3RJZHgsXG4gICAgICAgIGxhc3RJZHgsXG4gICAgICB9KTtcbiAgICAgIGlmICghY2xhbXBlZEJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgIHN0YXJ0OiBjbGFtcGVkQm91bmRzLnN0YXJ0LFxuICAgICAgICBlbmQ6IGNsYW1wZWRCb3VuZHMuZW5kLFxuICAgICAgfTtcbiAgICB9KVxuICAgIC5maWx0ZXIoQm9vbGVhbikgYXMgU3RhY2tlZEFubm90YXRpb25bXTsgLy8gZmlsdGVyIGVuc3VyZXMgdGhhdCB0aGUgYXJyYXkgaXMgb2YgdHlwZSBTdGFja2VkQW5ub3RhdGlvbltdXG4gIGNvbnN0IHN0YWNrczogU3RhY2tlZEFubm90YXRpb25bXVtdID0gW107XG4gIHN0YWNrZWRBbm5vdGF0aW9ucy5mb3JFYWNoKChhbm4pID0+IHtcbiAgICBzdGFja3NbYW5uLnN0YWNrXSA9IHN0YWNrc1thbm4uc3RhY2tdIHx8IFtdO1xuICAgIHN0YWNrc1thbm4uc3RhY2tdLnB1c2goYW5uKTtcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Zz5cbiAgICAgIDxjaXJjbGUgY3g9e2N4fSBjeT17Y3l9IHI9e2d1dHRlclJhZGl1c30gZmlsbD1cIm5vbmVcIiBzdHJva2VXaWR0aD17MC44fSAvPjtcbiAgICAgIHtzdGFja3MubWFwKChhbm5vdGF0aW9ucywgc3RhY2tJZHgpID0+IChcbiAgICAgICAgPEZyYWdtZW50IGtleT17YGFubm90YXRpb24tc3RhY2stJHtzdGFja0lkeH1gfT5cbiAgICAgICAgICB7YW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiAoXG4gICAgICAgICAgICA8Q2lyY3VsYXJBbm5vdGF0aW9uXG4gICAgICAgICAgICAgIGtleT17YHN0YWNrLSR7c3RhY2tJZHh9LSR7YW5ub3RhdGlvbi5zdGFydH0tJHthbm5vdGF0aW9uLmVuZH0tJHthbm5vdGF0aW9uLnRleHR9YH1cbiAgICAgICAgICAgICAgYW5ub3RhdGlvbj17YW5ub3RhdGlvbn1cbiAgICAgICAgICAgICAgcmFkaXVzPXtndXR0ZXJSYWRpdXMgKyBzdGFja0lkeCAqIDZ9XG4gICAgICAgICAgICAgIGNlbnRlcj17eyB4OiBjeCwgeTogY3kgfX1cbiAgICAgICAgICAgICAgc2VxdWVuY2U9e2Fubm90YXRlZFNlcXVlbmNlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICkpfVxuICAgIDwvZz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBBbm5vdGF0ZWRTZXF1ZW5jZSB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZpbmRDb29yIH0gZnJvbSBcIi4uL2NpcmN1bGFyVXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IENpcmN1bGFySW5kZXggPSAoe1xuICBhbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgY3gsXG4gIGN5LFxuICByYWRpdXMsXG4gIHRpY2tzLFxufToge1xuICBhbm5vdGF0ZWRTZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICB0aWNrczogbnVtYmVyO1xufSkgPT4ge1xuICBjb25zdCBiYXNlc1BlclRpY2sgPSBNYXRoLmZsb29yKGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCAvIHRpY2tzKTtcblxuICBpZiAoYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gNTApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHN2ZyBjbGFzc05hbWU9e2BmaWxsLWN1cnJlbnRgfT5cbiAgICAgICAgPGc+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgICAgcj17cmFkaXVzICogMC43NX1cbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxUaWNrc1xuICAgICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgICAgcmFkaXVzPXtyYWRpdXMgKiAwLjc1fVxuICAgICAgICAgICAgYmFzZXNQZXJUaWNrPXtiYXNlc1BlclRpY2t9XG4gICAgICAgICAgICB0b3RhbEJhc2VzPXthbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGh9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDx0ZXh0PlxuICAgICAge2Fubm90YXRlZFNlcXVlbmNlLm1hcCgoeyBiYXNlOiBsZXR0ZXIgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBmaW5kQ29vcih7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXMgKiAwLjcsXG4gICAgICAgICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICAgICAgICAgIHNlcUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgcm90YXRlRGVncmVlcyA9IChpbmRleCAvIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCkgKiAzNjA7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPHRzcGFuXG4gICAgICAgICAgICBrZXk9e2BiYXNlLSR7aW5kZXh9YH1cbiAgICAgICAgICAgIHg9e3h9XG4gICAgICAgICAgICB5PXt5fVxuICAgICAgICAgICAgdHJhbnNmb3JtPXtgcm90YXRlKCR7cm90YXRlRGVncmVlc30gJHt4fSAke3l9KWB9XG4gICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgICAgICAgY29sb3I9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICBmb250U2l6ZT1cIjAuNXJlbVwiXG4gICAgICAgICAgICBmb250V2VpZ2h0PVwidGhpblwiXG4gICAgICAgICAgICBmb250RmFtaWx5PVwiaW5oZXJpdFwiXG4gICAgICAgICAgICBkYXRhLXNlcS1pbmRleD17aW5kZXh9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2xldHRlcn1cbiAgICAgICAgICA8L3RzcGFuPlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC90ZXh0PlxuICApO1xufTtcblxuY29uc3QgVGlja3MgPSAoe1xuICByYWRpdXMsXG4gIGN4LFxuICBjeSxcbiAgYmFzZXNQZXJUaWNrLFxuICB0b3RhbEJhc2VzLFxufToge1xuICByYWRpdXM6IG51bWJlcjtcbiAgY3g6IG51bWJlcjtcbiAgY3k6IG51bWJlcjtcbiAgYmFzZXNQZXJUaWNrOiBudW1iZXI7XG4gIHRvdGFsQmFzZXM6IG51bWJlcjtcbn0pID0+IHtcbiAgY29uc3QgbnVtYmVyT2ZUaWNrcyA9IE1hdGguZmxvb3IodG90YWxCYXNlcyAvIGJhc2VzUGVyVGljayk7XG4gIHJldHVybiAoXG4gICAgPHN2Zz5cbiAgICAgIHtbLi4uQXJyYXkobnVtYmVyT2ZUaWNrcykua2V5cygpXS5tYXAoKGkpID0+IHtcbiAgICAgICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IGZpbmRDb29yKHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICAgICAgICAgIHNlcUxlbmd0aDogdG90YWxCYXNlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBmaW5kQ29vcih7XG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXMgKiAxLjEsXG4gICAgICAgICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICAgICAgICAgIHNlcUxlbmd0aDogdG90YWxCYXNlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZURlZ3JlZXMgPSAoaSAvIG51bWJlck9mVGlja3MpICogMzYwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxGcmFnbWVudCBrZXk9e2B0aWNrLSR7aX1gfT5cbiAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgIGlkPXtgdGljay0ke2l9YH1cbiAgICAgICAgICAgICAgeDE9e3gxfVxuICAgICAgICAgICAgICB5MT17eTF9XG4gICAgICAgICAgICAgIHgyPXt4Mn1cbiAgICAgICAgICAgICAgeTI9e3kyfVxuICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cbiAgICAgICAgICAgICAgb3BhY2l0eT17MC41fVxuICAgICAgICAgICAgICB0cmFuc2Zvcm09e2Byb3RhdGUoJHtyb3RhdGVEZWdyZWVzfSAke2N4fSAke2N5fSlgfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgIHg9e3gyfVxuICAgICAgICAgICAgICB5PXt5MiAtIDR9XG4gICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICBmb250U2l6ZT1cIi44cmVtXCJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgcm90YXRlKCR7cm90YXRlRGVncmVlc30gJHtjeH0gJHtjeX0pYH1cbiAgICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgIG9wYWNpdHk9ezAuNzV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtpICogYmFzZXNQZXJUaWNrfVxuICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICAgICk7XG4gICAgICB9KX1cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyB1c2VDaXJjdWxhclNlbGVjdGlvblJlY3QgfSBmcm9tIFwiQEFyaWFkbmUvaG9va3MvdXNlU2VsZWN0aW9uXCI7XG5pbXBvcnQge1xuICBBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgQW5ub3RhdGlvbixcbiAgQXJpYWRuZVNlbGVjdGlvbixcbn0gZnJvbSBcIkBBcmlhZG5lL3R5cGVzXCI7XG5pbXBvcnQge1xuICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgZ2V0U3RhY2tlZEFubm90YXRpb25zLFxuICBnZXRTdWJzZXF1ZW5jZUxlbmd0aCxcbn0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0YWNrQW5uc0J5VHlwZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgQ2lyY3VsYXJBbm5vdGF0aW9uR3V0dGVyIH0gZnJvbSBcIi4vQ2lyY3VsYXJBbm5vdGF0aW9uc1wiO1xuaW1wb3J0IHsgQ2lyY3VsYXJJbmRleCB9IGZyb20gXCIuL0NpcmN1bGFySW5kZXhcIjtcbmltcG9ydCB7IGNsYW1wU2xpY2UsIGZpbmRJbmRleEZyb21BbmdsZSwgZ2VuQXJjIH0gZnJvbSBcIi4vY2lyY3VsYXJVdGlsc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgc2VxdWVuY2U6IHN0cmluZztcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiB2b2lkO1xuICBjb250YWluZXJDbGFzc05hbWU/OiBzdHJpbmc7XG4gIHN2Z1NpemVQWD86IG51bWJlcjtcbiAgc3ZnUGFkZGluZz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IENpcmN1bGFyVmlld2VyID0gKHtcbiAgc2VxdWVuY2UsXG4gIGFubm90YXRpb25zLFxuICBzZWxlY3Rpb24sXG4gIHNldFNlbGVjdGlvbixcbiAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICBzdmdTaXplUFggPSAzMDAsXG4gIHN2Z1BhZGRpbmcgPSAyMCxcbn06IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY3gsIGN5LCBzaXplWCwgc2l6ZVksIHJhZGl1cyB9ID0ge1xuICAgIGN4OiBzdmdTaXplUFggLyAyLFxuICAgIGN5OiBzdmdTaXplUFggLyAyLFxuICAgIHNpemVYOiBzdmdTaXplUFgsXG4gICAgc2l6ZVk6IHN2Z1NpemVQWCxcbiAgICByYWRpdXM6IChzdmdTaXplUFggLSBzdmdQYWRkaW5nKSAvIDIsXG4gIH07XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrQW5uc0J5VHlwZShhbm5vdGF0aW9ucyk7XG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgcmV0dXJuIGdldEFubm90YXRlZFNlcXVlbmNlKHtcbiAgICAgICAgc2VxdWVuY2UsXG4gICAgICAgIHN0YWNrZWRBbm5vdGF0aW9uczogZ2V0U3RhY2tlZEFubm90YXRpb25zKGFubm90YXRpb25zKSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3NlcXVlbmNlLCBhbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgaWYgKGFubm90YXRlZFNlcXVlbmNlICYmIHNlbGVjdGlvbiAmJiBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3RJZHggPVxuICAgICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCA/IGFubm90YXRlZFNlcXVlbmNlLmF0KDApIS5pbmRleCA6IDA7XG4gICAgY29uc3QgbGFzdElkeCA9XG4gICAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggPiAwID8gYW5ub3RhdGVkU2VxdWVuY2UuYXQoLTEpIS5pbmRleCA6IDA7XG4gICAgc2VsZWN0aW9uID0gY2xhbXBTbGljZSh7IHNsaWNlOiBzZWxlY3Rpb24sIGZpcnN0SWR4LCBsYXN0SWR4IH0pO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvblJlZiA9IHVzZVJlZjxTVkdTVkdFbGVtZW50PihudWxsKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgXCJmbGV4IHNlbGVjdC1ub25lIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmb250LXRoaW5cIixcbiAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICA+XG4gICAgICA8c3ZnXG4gICAgICAgIHJlZj17c2VsZWN0aW9uUmVmfVxuICAgICAgICB2aWV3Qm94PXtgMCAwICR7c2l6ZVh9ICR7c2l6ZVl9YH1cbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIGZvbnRGYW1pbHk9XCJpbmhlcml0XCJcbiAgICAgICAgZm9udFNpemU9XCJpbmhlcml0XCJcbiAgICAgICAgZm9udFdlaWdodD1cImluaGVyaXRcIlxuICAgICAgICBjbGFzc05hbWU9e2BzdHJva2UtY3VycmVudGB9XG4gICAgICAgIHdpZHRoPXtzaXplWH1cbiAgICAgICAgaGVpZ2h0PXtzaXplWX1cbiAgICAgID5cbiAgICAgICAgPENpcmN1bGFySW5kZXhcbiAgICAgICAgICBjeD17Y3h9XG4gICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgIHJhZGl1cz17cmFkaXVzfVxuICAgICAgICAgIGFubm90YXRlZFNlcXVlbmNlPXthbm5vdGF0ZWRTZXF1ZW5jZX1cbiAgICAgICAgICB0aWNrcz17NH1cbiAgICAgICAgLz5cbiAgICAgICAgPENpcmN1bGFyQW5ub3RhdGlvbkd1dHRlclxuICAgICAgICAgIGFubm90YXRlZFNlcXVlbmNlPXthbm5vdGF0ZWRTZXF1ZW5jZX1cbiAgICAgICAgICBzdGFja2VkQW5ub3RhdGlvbnM9e3N0YWNrZWRBbm5vdGF0aW9uc31cbiAgICAgICAgICBjeD17Y3h9XG4gICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgIHJhZGl1cz17cmFkaXVzfVxuICAgICAgICAvPlxuICAgICAgICA8Q2lyY3VsYXJTZWxlY3Rpb25cbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZT17YW5ub3RhdGVkU2VxdWVuY2V9XG4gICAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICByYWRpdXM9e3JhZGl1c31cbiAgICAgICAgICBzZWxlY3Rpb25SZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgICBzZXRTZWxlY3Rpb249e3NldFNlbGVjdGlvbn1cbiAgICAgICAgLz5cblxuICAgICAgICA8dGV4dFxuICAgICAgICAgIHg9e2N4fVxuICAgICAgICAgIHk9e2N5fVxuICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgYWxpZ25tZW50QmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgICAgIGZvbnRTaXplPXtcIjFyZW1cIn1cbiAgICAgICAgPlxuICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGh9IGJwXG4gICAgICAgIDwvdGV4dD5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuY29uc3QgQ2lyY3VsYXJTZWxlY3Rpb24gPSAoe1xuICByYWRpdXMsXG4gIGN4LFxuICBjeSxcbiAgc2VsZWN0aW9uLFxuICBzZWxlY3Rpb25SZWYsXG4gIHNldFNlbGVjdGlvbixcbiAgYW5ub3RhdGVkU2VxdWVuY2UsXG59OiB7XG4gIHJhZGl1czogbnVtYmVyO1xuXG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIHNlbGVjdGlvblJlZjogUmVhY3QuUmVmT2JqZWN0PFNWR1NWR0VsZW1lbnQ+O1xuICBzZXRTZWxlY3Rpb246IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24pID0+IHZvaWQ7XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIGFubm90YXRlZFNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbn0pID0+IHtcbiAgLyogQ29sbGVjdCBpbnRlcm5hbCBzZWxlY3Rpb24gZGF0YSBhbmQgcHJvcG9nYXRlIHVwICovXG4gIGNvbnN0IHtcbiAgICBzdGFydDogaW50ZXJuYWxTZWxlY3Rpb25TdGFydCxcbiAgICBlbmQ6IGludGVybmFsU2VsZWN0aW9uRW5kLFxuICAgIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24sXG4gIH0gPSB1c2VDaXJjdWxhclNlbGVjdGlvblJlY3Qoc2VsZWN0aW9uUmVmKTtcbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVNlbGVjdGlvblVwKCkge1xuICAgICAgaWYgKFxuICAgICAgICBzZWxlY3Rpb25SZWYuY3VycmVudCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0ICYmXG4gICAgICAgIGludGVybmFsU2VsZWN0aW9uRW5kICYmXG4gICAgICAgIGludGVybmFsRGlyZWN0aW9uXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kSW5kZXhGcm9tQW5nbGUoe1xuICAgICAgICAgIGFuZ2xlOiBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIHNlcUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5kID0gZmluZEluZGV4RnJvbUFuZ2xlKHtcbiAgICAgICAgICBhbmdsZTogaW50ZXJuYWxTZWxlY3Rpb25FbmQsXG4gICAgICAgICAgc2VxTGVuZ3RoOiBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPVxuICAgICAgICAgIGludGVybmFsRGlyZWN0aW9uID09PSBcImNsb2Nrd2lzZVwiID8gXCJmb3J3YXJkXCIgOiBcInJldmVyc2VcIjtcblxuICAgICAgICBjb25zdCBwcmV2TGVuZ3RoID0gc2VsZWN0aW9uXG4gICAgICAgICAgPyBNYXRoLmFicyhzZWxlY3Rpb24uZW5kIC0gc2VsZWN0aW9uLnN0YXJ0KVxuICAgICAgICAgIDogMDtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gZ2V0U3Vic2VxdWVuY2VMZW5ndGgoXG4gICAgICAgICAgeyBzdGFydCwgZW5kLCBkaXJlY3Rpb24gfSxcbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGRlbHRhTGVuZ3RoID0gTWF0aC5hYnMocHJldkxlbmd0aCAtIG5ld0xlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRlbHRhVGhyZXNob2xkID0gTWF0aC5tYXgoMC43ICogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLCAxMCk7XG4gICAgICAgIGlmIChkZWx0YUxlbmd0aCA+IGRlbHRhVGhyZXNob2xkICYmIHNlbGVjdGlvbikge1xuICAgICAgICAgIC8vIHByZXNlcnZlIGluaXRpYWwgZGlyZWN0aW9uXG4gICAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBzZWxlY3Rpb24/LmRpcmVjdGlvbixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2ludGVybmFsU2VsZWN0aW9uU3RhcnQsIGludGVybmFsU2VsZWN0aW9uRW5kXSxcbiAgKTtcblxuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiBEaXNwbGF5IHNlbGVjdGlvbiBkYXRhIHRoYXQgaGFzIHRyaWNrbGVkIGRvd24gKi9cbiAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBzZWxlY3Rpb247XG4gIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjZW50ZXIgPSB7IHg6IGN4LCB5OiBjeSB9O1xuICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cztcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSByYWRpdXMgKyAxMDtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0U3Vic2VxdWVuY2VMZW5ndGgoc2VsZWN0aW9uLCBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgpO1xuXG4gIGNvbnN0IFtzdGFydElkeCwgZW5kSWR4XSA9IFtcbiAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgwKT8uaW5kZXgsXG4gICAgYW5ub3RhdGVkU2VxdWVuY2UuYXQoLTEpPy5pbmRleCxcbiAgXTtcbiAgaWYgKHN0YXJ0SWR4ID09PSB1bmRlZmluZWQgfHwgZW5kSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ2lyY3VsYXJWaWV3ZXI6IHNlcXVlbmNlIGhhcyBubyBpbmRpY2VzXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG9mZnNldCA9IHN0YXJ0IC0gc3RhcnRJZHg7XG4gIGNvbnN0IHNlcUxlbmd0aCA9IGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aDtcblxuICBjb25zdCBhcmMgPSBnZW5BcmMoe1xuICAgIGNlbnRlcixcbiAgICBpbm5lclJhZGl1cyxcbiAgICBsYXJnZUFyYzogbGVuZ3RoID4gc2VxTGVuZ3RoIC8gMixcbiAgICBsZW5ndGgsXG4gICAgb2Zmc2V0LFxuICAgIG91dGVyUmFkaXVzLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPGc+XG4gICAgICA8cGF0aFxuICAgICAgICBkPXthcmN9XG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgLz5cbiAgICA8L2c+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgZ2V0U3Vic2VxdWVuY2VMZW5ndGggfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQW5ub3RhdGVkU2VxdWVuY2UsIEFubm90YXRpb24sIFN0YWNrZWRBbm5vdGF0aW9uIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZWFyQW5ub3RhdGlvbkd1dHRlclByb3BzIHtcbiAgc3RhY2tlZEFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIGNvbnRhaW5lckNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IExpbmVhckFubm90YXRpb25HdXR0ZXIgPSAoe1xuICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIHNlcXVlbmNlLFxuICBjb250YWluZXJDbGFzc05hbWUsXG59OiBMaW5lYXJBbm5vdGF0aW9uR3V0dGVyUHJvcHMpID0+IHtcbiAgY29uc3Qgc3RhY2tzOiBTdGFja2VkQW5ub3RhdGlvbltdW10gPSBbXTtcbiAgc3RhY2tlZEFubm90YXRpb25zLmZvckVhY2goKGFubikgPT4ge1xuICAgIHN0YWNrc1thbm4uc3RhY2tdID0gc3RhY2tzW2Fubi5zdGFja10gfHwgW107XG4gICAgc3RhY2tzW2Fubi5zdGFja10ucHVzaChhbm4pO1xuICB9KTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgIFwiZ3JpZC1yb3dzLWF1dG8gYmxvY2sgZ3JpZCBncmlkLWNvbHMtMSBnYXAtMVwiLFxuICAgICAgICBjb250YWluZXJDbGFzc05hbWUsXG4gICAgICApfVxuICAgID5cbiAgICAgIHtzdGFja3MubWFwKChhbm5vdGF0aW9ucywgc3RhY2tJZHgpID0+IChcbiAgICAgICAgPGRpdiBrZXk9e2Bhbm5vdGF0aW9uLXN0YWNrLSR7c3RhY2tJZHh9YH0gY2xhc3NOYW1lPVwicmVsYXRpdmUgaC04XCI+XG4gICAgICAgICAge2Fubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKFxuICAgICAgICAgICAgPExpbmVhckFubm90YXRpb25cbiAgICAgICAgICAgICAga2V5PXtgYW5ub3RhdGlvbi0ke2Fubm90YXRpb24udGV4dH0tJHthbm5vdGF0aW9uLnN0YXJ0fS0ke2Fubm90YXRpb24uZW5kfS0ke2Fubm90YXRpb24uZGlyZWN0aW9ufWB9XG4gICAgICAgICAgICAgIGFubm90YXRpb249e2Fubm90YXRpb259XG4gICAgICAgICAgICAgIHNlcXVlbmNlPXtzZXF1ZW5jZX1cbiAgICAgICAgICAgICAgc3RhY2tJZHg9e3N0YWNrSWR4fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5jb25zdCBMaW5lYXJBbm5vdGF0aW9uID0gKHtcbiAgYW5ub3RhdGlvbixcbiAgc2VxdWVuY2UsXG4gIHN0YWNrSWR4LFxufToge1xuICBhbm5vdGF0aW9uOiBBbm5vdGF0aW9uO1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIHN0YWNrSWR4OiBudW1iZXI7XG59KSA9PiB7XG4gIC8qIGlmIHRoZSBhbm5vdGF0aW9uIHNwYW5zIHRoZSBzZWFtLCB3ZSBkcmF3IHR3byBsaW5lcyBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gZW5kLCBhbmQgZnJvbSBzdGFydCB0byBlbmQgKi9cblxuICBjb25zdCBhbm5vdGF0aW9uU3BhbnNTZWFtID0gYW5ub3RhdGlvbi5zdGFydCA+IGFubm90YXRpb24uZW5kO1xuICBpZiAoYW5ub3RhdGlvblNwYW5zU2VhbSkge1xuICAgIHJldHVybiAoXG4gICAgICA8RnJhZ21lbnQ+XG4gICAgICAgIDxMaW5lYXJBbm5vdGF0aW9uXG4gICAgICAgICAgYW5ub3RhdGlvbj17e1xuICAgICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICAgIGVuZDogc2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICBhbm5vdGF0aW9uLm9uQ2xpY2s/Lih7IC4uLmFubm90YXRpb24gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgICAgc2VxdWVuY2U9e3NlcXVlbmNlfVxuICAgICAgICAgIHN0YWNrSWR4PXtzdGFja0lkeH1cbiAgICAgICAgLz5cbiAgICAgICAgPExpbmVhckFubm90YXRpb25cbiAgICAgICAgICBhbm5vdGF0aW9uPXt7XG4gICAgICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGFubm90YXRpb24ub25DbGljaz8uKHsgLi4uYW5ub3RhdGlvbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgICBzZXF1ZW5jZT17c2VxdWVuY2V9XG4gICAgICAgICAgc3RhY2tJZHg9e3N0YWNrSWR4fVxuICAgICAgICAvPlxuICAgICAgPC9GcmFnbWVudD5cbiAgICApO1xuICB9XG5cbiAgY29uc3QgYW5ub3RhdGlvblJlY3RhbmdsZVdpZHRoUGVyYyA9XG4gICAgKGdldFN1YnNlcXVlbmNlTGVuZ3RoKGFubm90YXRpb24sIHNlcXVlbmNlLmxlbmd0aCkgLyBzZXF1ZW5jZS5sZW5ndGgpICogMTAwO1xuXG4gIGNvbnN0IHhQZXJjID1cbiAgICAoTWF0aC5taW4oYW5ub3RhdGlvbi5zdGFydCwgYW5ub3RhdGlvbi5lbmQpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgLy8gY2xpcCBwYXRoIHRvIGNyZWF0ZSByZWN0YW5nbGUgd2l0aCBhIHBvaW50IGF0IG9uZSBlbmRcbiAgY29uc3QgZm9yd2FyZENsaXBQYXRoID0gXCJwb2x5Z29uKDAgMCwgOTAlIDAsIDEwMCUgNTAlLCA5MCUgMTAwJSwgMCAxMDAlKVwiO1xuICBjb25zdCByZXZlcnNlQ2xpcFBhdGggPSBcInBvbHlnb24oMCA1MCUsIDEwJSAwLCAxMDAlIDAsIDEwMCUgMTAwJSwgMTAlIDEwMCUpXCI7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPVwiZ3JvdXAgYWJzb2x1dGVcIlxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgbWFyZ2luTGVmdDogYCR7eFBlcmN9JWAsXG4gICAgICAgIHdpZHRoOiBgJHthbm5vdGF0aW9uUmVjdGFuZ2xlV2lkdGhQZXJjfSVgLFxuICAgICAgfX1cbiAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgYW5ub3RhdGlvbi5vbkNsaWNrPy4oYW5ub3RhdGlvbik7XG4gICAgICB9fVxuICAgID5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwicHgtMlwiLFxuICAgICAgICAgIGFubm90YXRpb24uZGlyZWN0aW9uID09PSBcImZvcndhcmRcIiA/IFwidGV4dC1sZWZ0XCIgOiBcInRleHQtcmlnaHRcIixcbiAgICAgICAgICBhbm5vdGF0aW9uLmNsYXNzTmFtZSxcbiAgICAgICAgKX1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBjbGlwUGF0aDpcbiAgICAgICAgICAgIGFubm90YXRpb24uZGlyZWN0aW9uID09PSBcImZvcndhcmRcIlxuICAgICAgICAgICAgICA/IGZvcndhcmRDbGlwUGF0aFxuICAgICAgICAgICAgICA6IHJldmVyc2VDbGlwUGF0aCxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2Fubm90YXRpb24udGV4dH1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgXCJhYnNvbHV0ZSBsZWZ0LTEvMiB6LTEwIGhpZGRlbiAtdHJhbnNsYXRlLXgtMS8yIHRyYW5zbGF0ZS15LTQgZmxleC1jb2wgcm91bmRlZC1tZCBweC0yIHB5LTEgdGV4dC1zbSBncm91cC1ob3ZlcjpmbGV4XCIsXG4gICAgICAgICAgYW5ub3RhdGlvbi5jbGFzc05hbWUsXG4gICAgICAgICl9XG4gICAgICA+XG4gICAgICAgIDxzcGFuPnthbm5vdGF0aW9uLnRleHR9PC9zcGFuPlxuICAgICAgICA8c3Bhbj57YW5ub3RhdGlvbi50eXBlfTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCB7IHVzZUxpbmVhclNlbGVjdGlvblJlY3QgfSBmcm9tIFwiQEFyaWFkbmUvaG9va3MvdXNlU2VsZWN0aW9uXCI7XG5pbXBvcnQgeyBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSwgZ2V0U3Vic2VxdWVuY2VMZW5ndGggfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQW5ub3RhdGVkU2VxdWVuY2UsXG4gIEFyaWFkbmVTZWxlY3Rpb24sXG4gIEFubm90YXRpb24sXG4gIEFubm90YXRlZEJhc2UsXG4gIFN0YWNrZWRBbm5vdGF0aW9uLFxufSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHN0YWNrQW5ub3RhdGlvbnNOb092ZXJsYXAgfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IExpbmVhckFubm90YXRpb25HdXR0ZXIgfSBmcm9tIFwiLi9MaW5lYXJBbm5vdGF0aW9uR3V0dGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBzZXF1ZW5jZXM6IHN0cmluZ1tdO1xuICBhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBzZXRTZWxlY3Rpb246IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsKSA9PiB2b2lkO1xuICBvbkRvdWJsZUNsaWNrPzogKCkgPT4gdm9pZDtcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lPzogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbikgPT4gc3RyaW5nO1xuICBjb250YWluZXJDbGFzc05hbWU/OiBzdHJpbmc7XG4gIHNlcXVlbmNlQ2xhc3NOYW1lOiAoeyBzZXF1ZW5jZUlkeCB9OiB7IHNlcXVlbmNlSWR4OiBudW1iZXIgfSkgPT4gc3RyaW5nO1xuICBtaXNtYXRjaENsYXNzTmFtZT86IChtaXNtYXRjaGVkQmFzZTogQW5ub3RhdGVkQmFzZSkgPT4gc3RyaW5nO1xuICBzdGFja2luZ0ZuPzogKGFubm90YXRpb25zOiBBbm5vdGF0aW9uW10pID0+IFN0YWNrZWRBbm5vdGF0aW9uW107XG59XG5cbmNvbnN0IE1JU01BVENIX0RJU1RfUEVSQ19USFJFU0hPTEQgPSAwLjAxO1xuXG5leHBvcnQgY29uc3QgTGluZWFyVmlld2VyID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgc2VxdWVuY2VzLFxuICAgIHNlbGVjdGlvbixcbiAgICBhbm5vdGF0aW9ucyxcbiAgICBzZXRTZWxlY3Rpb24sXG4gICAgb25Eb3VibGVDbGljayxcbiAgICBzZWxlY3Rpb25DbGFzc05hbWUsXG4gICAgbWlzbWF0Y2hDbGFzc05hbWUsXG4gICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIHNlcXVlbmNlQ2xhc3NOYW1lLFxuICAgIHN0YWNraW5nRm4sXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSB1c2VNZW1vKFxuICAgIGZ1bmN0aW9uIG1lbW9pemUoKSB7XG4gICAgICAvLyBpZiBhIHN0YWNraW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgaXQsIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHQgd2hpY2hcbiAgICAgIC8vIHN0YWNrcyBhbm5vdGF0aW9ucyB0byBwcmV2ZW50IG92ZXJsYXAuXG4gICAgICByZXR1cm4gc3RhY2tpbmdGblxuICAgICAgICA/IHN0YWNraW5nRm4oYW5ub3RhdGlvbnMpXG4gICAgICAgIDogc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcChcbiAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgTWF0aC5tYXgoLi4uc2VxdWVuY2VzLm1hcCgoc2VxKSA9PiBzZXEubGVuZ3RoKSksXG4gICAgICAgICAgKTtcbiAgICB9LFxuICAgIFthbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2VzID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlcy5tYXAoKHNlcXVlbmNlKSA9PlxuICAgICAgICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSh7IHNlcXVlbmNlLCBzdGFja2VkQW5ub3RhdGlvbnMgfSksXG4gICAgICApO1xuICAgIH0sXG4gICAgW3NlcXVlbmNlcywgc3RhY2tlZEFubm90YXRpb25zXSxcbiAgKTtcblxuICBjb25zdCBiYXNlU2VxdWVuY2UgPSBhbm5vdGF0ZWRTZXF1ZW5jZXNbMF07XG4gIGNvbnN0IHNlbGVjdGlvblJlZiA9IHVzZVJlZjxTVkdTVkdFbGVtZW50PihudWxsKTtcblxuICAvLyBjb25zdCBudW1iZXJPZlRpY2tzID0gNTtcbiAgLy8gY29uc3QgYmFzZXNQZXJUaWNrID0gTWF0aC5mbG9vcihzZXF1ZW5jZS5sZW5ndGggLyBudW1iZXJPZlRpY2tzKTtcblxuICBjb25zdCBTVkdfV0lEVEggPSA1MDA7XG4gIGNvbnN0IFNWR19IRUlHSFQgPSBzZXF1ZW5jZXMubGVuZ3RoICogMTAgKyAxMDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjb250YWluZXJDbGFzc05hbWUgfHwgXCJcIn0+XG4gICAgICA8c3ZnXG4gICAgICAgIHJlZj17c2VsZWN0aW9uUmVmfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJzZWxlY3Qtbm9uZSBmb250LXRoaW5cIil9XG4gICAgICAgIG9uRG91YmxlQ2xpY2s9e29uRG91YmxlQ2xpY2t9XG4gICAgICAgIHZpZXdCb3g9e2AwIDAgJHtTVkdfV0lEVEh9ICR7U1ZHX0hFSUdIVH1gfVxuICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICA+XG4gICAgICAgIDxnPlxuICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKChzZXF1ZW5jZSwgaSkgPT4gKFxuICAgICAgICAgICAgPGcga2V5PXtgU2VxdWVuY2UtJHtpfWB9PlxuICAgICAgICAgICAgICA8U2VxdWVuY2VMaW5lXG4gICAgICAgICAgICAgICAgc2VxdWVuY2VDbGFzc05hbWU9e3NlcXVlbmNlQ2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIGJhc2VTZXF1ZW5jZT17c2VxdWVuY2V9XG4gICAgICAgICAgICAgICAgYWxpZ25lZFNlcXVlbmNlcz17YW5ub3RhdGVkU2VxdWVuY2VzLmZpbHRlcigoXywgaikgPT4gaiAhPT0gaSl9XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VJZHg9e2l9XG4gICAgICAgICAgICAgICAgbWlzbWF0Y2hDbGFzc05hbWU9e21pc21hdGNoQ2xhc3NOYW1lfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2c+XG4gICAgICAgIDxMaW5lYXJTZWxlY3Rpb25cbiAgICAgICAgICBzZWxlY3Rpb25DbGFzc05hbWU9e3NlbGVjdGlvbkNsYXNzTmFtZX1cbiAgICAgICAgICBzZWxlY3Rpb25SZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgICBzZXRTZWxlY3Rpb249e3NldFNlbGVjdGlvbn1cbiAgICAgICAgICBzZXF1ZW5jZT17YmFzZVNlcXVlbmNlfVxuICAgICAgICAvPlxuICAgICAgPC9zdmc+XG4gICAgICB7c3RhY2tlZEFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8TGluZWFyQW5ub3RhdGlvbkd1dHRlclxuICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZT1cIlwiXG4gICAgICAgICAgc3RhY2tlZEFubm90YXRpb25zPXtzdGFja2VkQW5ub3RhdGlvbnN9XG4gICAgICAgICAgc2VxdWVuY2U9e2Jhc2VTZXF1ZW5jZX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5pbnRlcmZhY2UgU2VxdWVuY2VMaW5lUHJvcHMge1xuICBiYXNlU2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICBhbGlnbmVkU2VxdWVuY2VzOiBBbm5vdGF0ZWRTZXF1ZW5jZVtdO1xuICBzZXF1ZW5jZUNsYXNzTmFtZTogKHsgc2VxdWVuY2VJZHggfTogeyBzZXF1ZW5jZUlkeDogbnVtYmVyIH0pID0+IHN0cmluZztcbiAgbWlzbWF0Y2hDbGFzc05hbWU/OiAobWlzbWF0Y2hlZEJhc2U6IEFubm90YXRlZEJhc2UpID0+IHN0cmluZztcbn1cblxuY29uc3QgU2VxdWVuY2VMaW5lID0gKHtcbiAgYmFzZVNlcXVlbmNlLFxuICBzZXF1ZW5jZUlkeCxcbiAgYWxpZ25lZFNlcXVlbmNlcyxcbiAgc2VxdWVuY2VDbGFzc05hbWUsXG4gIG1pc21hdGNoQ2xhc3NOYW1lLFxufTogU2VxdWVuY2VMaW5lUHJvcHMpID0+IHtcbiAgY29uc3Qgc3RhcnQgPSBiYXNlU2VxdWVuY2VbMF0/LmluZGV4O1xuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2VxdWVuY2UgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBiYXNlICR7YmFzZVNlcXVlbmNlfWApO1xuICB9XG4gIGNvbnN0IGVuZCA9IGJhc2VTZXF1ZW5jZVtiYXNlU2VxdWVuY2UubGVuZ3RoIC0gMV0/LmluZGV4O1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcXVlbmNlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYmFzZSAke2Jhc2VTZXF1ZW5jZX1gKTtcbiAgfVxuXG4gIGxldCBtYXhFbmQgPSBlbmQ7XG4gIGFsaWduZWRTZXF1ZW5jZXMuZm9yRWFjaCgoYWxpZ25lZFNlcXVlbmNlKSA9PiB7XG4gICAgY29uc3Qgb3RoZXJFbmQgPSBhbGlnbmVkU2VxdWVuY2UuYXQoYWxpZ25lZFNlcXVlbmNlLmxlbmd0aCAtIDEpPy5pbmRleDtcbiAgICBpZiAob3RoZXJFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgb3RoZXJTZXF1ZW5jZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGJhc2UgJHthbGlnbmVkU2VxdWVuY2V9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyRW5kID4gbWF4RW5kKSB7XG4gICAgICBtYXhFbmQgPSBvdGhlckVuZDtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdGFydFBlcmMgPSBzdGFydCAvIG1heEVuZDtcbiAgY29uc3QgZW5kUGVyYyA9IGVuZCAvIG1heEVuZDtcblxuICAvLyBtaXNtYXRjaGVzXG4gIGNvbnN0IG1pc21hdGNoZXMgPSBiYXNlU2VxdWVuY2UuZmlsdGVyKChiYXNlKSA9PiB7XG4gICAgY29uc3Qgcm9vdEJhc2UgPSBiYXNlU2VxdWVuY2UuYXQoYmFzZS5pbmRleCk7XG4gICAgcmV0dXJuIHJvb3RCYXNlICYmIHJvb3RCYXNlLmJhc2UgIT09IGJhc2UuYmFzZTtcbiAgfSk7XG4gIG1pc21hdGNoQ2xhc3NOYW1lID1cbiAgICBtaXNtYXRjaENsYXNzTmFtZSA/P1xuICAgIGZ1bmN0aW9uIG1pc21hdGNoQ2xhc3NOYW1lKG1pc21hdGNoOiBBbm5vdGF0ZWRCYXNlKSB7XG4gICAgICBpZiAobWlzbWF0Y2guYmFzZSA9PT0gXCItXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsbC1ibGFjayBzdHJva2UtYmxhY2sgb3BhY2l0eS04MFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiZGFyazpmaWxsLXJlZC02MDAgZGFyazpzdHJva2UtcmVkLTYwMCBmaWxsLXJlZC03MDAgc3Ryb2tlLXJlZC03MDBcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGxldCBsYXN0WFBlcmMgPSAtMTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGxpbmVcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwiXCIsIHNlcXVlbmNlQ2xhc3NOYW1lKHsgc2VxdWVuY2VJZHggfSkpfVxuICAgICAgICB4MT17YCR7c3RhcnRQZXJjICogMTAwfSVgfVxuICAgICAgICB5MT17YCR7c2VxdWVuY2VJZHggKiAxMCArIDEwfWB9XG4gICAgICAgIHgyPXtgJHtlbmRQZXJjICogMTAwfSVgfVxuICAgICAgICB5Mj17YCR7c2VxdWVuY2VJZHggKiAxMCArIDEwfWB9XG4gICAgICAgIHN0cm9rZVdpZHRoPXs1fVxuICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICAgIHttaXNtYXRjaGVzLm1hcCgoYmFzZSkgPT4ge1xuICAgICAgICBjb25zdCB4UGVyYyA9IChiYXNlLmluZGV4IC8gbWF4RW5kKSAqIDEwMDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgoMSAvIGJhc2VTZXF1ZW5jZS5sZW5ndGgpICogMTAwLCAwLjAxKTtcbiAgICAgICAgY29uc3QgZGlmZiA9IHhQZXJjIC0gbGFzdFhQZXJjO1xuICAgICAgICBpZiAoZGlmZiA8IE1JU01BVENIX0RJU1RfUEVSQ19USFJFU0hPTEQpIHtcbiAgICAgICAgICAvLyBEaXNwbGF5aW5nIGV2ZXJ5IG1pc21hdGNoIGlzIG5vdCBwYXJ0aWN1bGFybHkgaGVscGZ1bCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlbS4gSGVyZSB3ZSBjaG9vc2UgYSByZWFzb25hYmxlXG4gICAgICAgICAgLy8gdGhyZXNob2xkIGFuZCBvbmx5IGRpc3BsYXkgZWxlbWVudHMgdGhhdCBhcmUgc3VmZmljaWVudGx5IGZhciBhcGFydC5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WFBlcmMgPSB4UGVyYztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8Z1xuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKG1pc21hdGNoQ2xhc3NOYW1lPy4oYmFzZSkgfHwgXCJiZy1yZWQtNDAwXCIpfVxuICAgICAgICAgICAga2V5PXtgc2VxdWVuY2UtJHtzZXF1ZW5jZUlkeH0tbWlzbWF0Y2gtJHtiYXNlLmluZGV4fWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgeDE9e2Ake3hQZXJjIC0gd2lkdGggLyAyfSVgfVxuICAgICAgICAgICAgICB5MT17YCR7c2VxdWVuY2VJZHggKiAxMCArIDEwfWB9XG4gICAgICAgICAgICAgIHgyPXtgJHt4UGVyYyArIHdpZHRoIC8gMn0lYH1cbiAgICAgICAgICAgICAgeTI9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17NX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5jb25zdCBMaW5lYXJTZWxlY3Rpb24gPSAoe1xuICBzZWxlY3Rpb24sXG4gIHNlbGVjdGlvblJlZixcbiAgc2V0U2VsZWN0aW9uLFxuICBzZXF1ZW5jZSxcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxufToge1xuICBzZWxlY3Rpb25SZWY6IFJlYWN0LlJlZk9iamVjdDxTVkdTVkdFbGVtZW50PjtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiB2b2lkO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24pID0+IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0OiBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LFxuICAgIGVuZDogaW50ZXJuYWxTZWxlY3Rpb25FbmQsXG4gICAgZGlyZWN0aW9uOiBpbnRlcm5hbERpcmVjdGlvbixcbiAgfSA9IHVzZUxpbmVhclNlbGVjdGlvblJlY3QoeyByZWY6IHNlbGVjdGlvblJlZiB9KTtcbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVNlbGVjdGlvblVwKCkge1xuICAgICAgaWYgKFxuICAgICAgICBzZWxlY3Rpb25SZWYuY3VycmVudCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0ICYmXG4gICAgICAgIGludGVybmFsU2VsZWN0aW9uRW5kXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3ZnV2lkdGggPSBzZWxlY3Rpb25SZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAoaW50ZXJuYWxTZWxlY3Rpb25TdGFydC54IC8gc3ZnV2lkdGgpICogc2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLmZsb29yKFxuICAgICAgICAgIChpbnRlcm5hbFNlbGVjdGlvbkVuZC54IC8gc3ZnV2lkdGgpICogc2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNob3cgYSB2ZXJ5IHNtYWxsIGZpcnN0IHNlbGVjdGlvbiByZXN1bHQgYXMgc3RhcnQgPT09IGVuZCBiZWNhdXNlIHRoZSB1c2VyIHByb2JhYmx5IGRvZXNuJ3Qgd2FudCB0aGUgZW50aXJlIHNlcXVlbmNlIHRvIGJlIGhpZ2hsaWdodGVkIGV2ZXJ5IHRpbWUgdGhleSBjbGlja1xuICAgICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwgfHwgc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQgKyAxLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBpbnRlcm5hbERpcmVjdGlvbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0U2VsZWN0aW9uKHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uOiBpbnRlcm5hbERpcmVjdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2ludGVybmFsU2VsZWN0aW9uU3RhcnQsIGludGVybmFsU2VsZWN0aW9uRW5kXSxcbiAgKTtcblxuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyogRGlzcGxheSBzZWxlY3Rpb24gZGF0YSB0aGF0IGhhcyB0cmlja2xlZCBkb3duICovXG4gIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uO1xuXG4gIC8vIGJhc2ljIGNhc2VcbiAgbGV0IGZpcnN0UmVjdFN0YXJ0ID0gKE1hdGgubWluKHN0YXJ0LCBlbmQpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgbGV0IGZpcnN0UmVjdFdpZHRoID1cbiAgICAoZ2V0U3Vic2VxdWVuY2VMZW5ndGgoc2VsZWN0aW9uLCBzZXF1ZW5jZS5sZW5ndGgpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgbGV0IHNlY29uZFJlY3RTdGFydCA9IG51bGw7XG4gIGxldCBzZWNvbmRSZWN0V2lkdGggPSBudWxsO1xuXG4gIC8vIFRPRE86IGFic3RyYWN0IHRoaXMgYW5kIGxvZ2ljIGluIExpbmVhckFubm90YXRpb24gaW50byBoZWxwZXIgZnVuY3Rpb25zXG4gIGNvbnN0IHNlbGVjdGlvblNwYW5zU2VhbSA9IHNlbGVjdGlvbi5zdGFydCA+IHNlbGVjdGlvbi5lbmQ7XG5cbiAgLyogaWYgZGlyZWN0aW9uIGlzIGJhY2t3YXJkIGFuZCBlbmQgPiBzdGFydCB3ZSBuZWVkIHRvIHJlbmRlciB0d28gcmVjdGFuZ2xlcyAqL1xuICBpZiAoc2VsZWN0aW9uU3BhbnNTZWFtKSB7XG4gICAgZmlyc3RSZWN0U3RhcnQgPSAwO1xuICAgIGZpcnN0UmVjdFdpZHRoID0gKGVuZCAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gICAgc2Vjb25kUmVjdFN0YXJ0ID0gKHN0YXJ0IC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgICBzZWNvbmRSZWN0V2lkdGggPSAoKHNlcXVlbmNlLmxlbmd0aCAtIHN0YXJ0KSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxnXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgIFwiZmlsbC1jdXJyZW50IHN0cm9rZS1jdXJyZW50XCIsXG4gICAgICAgIHNlbGVjdGlvbkNsYXNzTmFtZT8uKHNlbGVjdGlvbiksXG4gICAgICApfVxuICAgID5cbiAgICAgIDxyZWN0XG4gICAgICAgIHg9e2Ake2ZpcnN0UmVjdFN0YXJ0fSVgfVxuICAgICAgICB3aWR0aD17YCR7Zmlyc3RSZWN0V2lkdGh9JWB9XG4gICAgICAgIHk9e2AwJWB9XG4gICAgICAgIGhlaWdodD17YDEwMCVgfVxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgZmlsbE9wYWNpdHk9ezAuMn1cbiAgICAgICAgc3Ryb2tlV2lkdGg9ezEuNX1cbiAgICAgIC8+XG4gICAgICB7c2Vjb25kUmVjdFN0YXJ0ICYmIHNlY29uZFJlY3RXaWR0aCAmJiAoXG4gICAgICAgIDxyZWN0XG4gICAgICAgICAgeD17YCR7c2Vjb25kUmVjdFN0YXJ0fSVgfVxuICAgICAgICAgIHdpZHRoPXtgJHtzZWNvbmRSZWN0V2lkdGh9JWB9XG4gICAgICAgICAgeT17YDAlYH1cbiAgICAgICAgICBoZWlnaHQ9e2AxMDAlYH1cbiAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICBmaWxsT3BhY2l0eT17MC4yfVxuICAgICAgICAgIHN0cm9rZVdpZHRoPXsxLjV9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvZz5cbiAgKTtcbn07XG4iLCIvLyBwYWNrYWdlcy9jb3JlL251bWJlci9zcmMvbnVtYmVyLnRzXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgW21pbiwgbWF4XSkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG5leHBvcnQge1xuICBjbGFtcFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL2NvcmUvcHJpbWl0aXZlL3NyYy9wcmltaXRpdmUudHN4XG5mdW5jdGlvbiBjb21wb3NlRXZlbnRIYW5kbGVycyhvcmlnaW5hbEV2ZW50SGFuZGxlciwgb3VyRXZlbnRIYW5kbGVyLCB7IGNoZWNrRm9yRGVmYXVsdFByZXZlbnRlZCA9IHRydWUgfSA9IHt9KSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgIG9yaWdpbmFsRXZlbnRIYW5kbGVyPy4oZXZlbnQpO1xuICAgIGlmIChjaGVja0ZvckRlZmF1bHRQcmV2ZW50ZWQgPT09IGZhbHNlIHx8ICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm4gb3VyRXZlbnRIYW5kbGVyPy4oZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGNvbXBvc2VFdmVudEhhbmRsZXJzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvY29udGV4dC9zcmMvY3JlYXRlQ29udGV4dC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0Mihyb290Q29tcG9uZW50TmFtZSwgZGVmYXVsdENvbnRleHQpIHtcbiAgY29uc3QgQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbnRleHQpO1xuICBjb25zdCBQcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmNvbnRleHQgfSA9IHByb3BzO1xuICAgIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb250ZXh0LCBPYmplY3QudmFsdWVzKGNvbnRleHQpKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlLCBjaGlsZHJlbiB9KTtcbiAgfTtcbiAgUHJvdmlkZXIuZGlzcGxheU5hbWUgPSByb290Q29tcG9uZW50TmFtZSArIFwiUHJvdmlkZXJcIjtcbiAgZnVuY3Rpb24gdXNlQ29udGV4dDIoY29uc3VtZXJOYW1lKSB7XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0O1xuICAgIGlmIChkZWZhdWx0Q29udGV4dCAhPT0gdm9pZCAwKSByZXR1cm4gZGVmYXVsdENvbnRleHQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke2NvbnN1bWVyTmFtZX1cXGAgbXVzdCBiZSB1c2VkIHdpdGhpbiBcXGAke3Jvb3RDb21wb25lbnROYW1lfVxcYGApO1xuICB9XG4gIHJldHVybiBbUHJvdmlkZXIsIHVzZUNvbnRleHQyXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRTY29wZShzY29wZU5hbWUsIGNyZWF0ZUNvbnRleHRTY29wZURlcHMgPSBbXSkge1xuICBsZXQgZGVmYXVsdENvbnRleHRzID0gW107XG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQzKHJvb3RDb21wb25lbnROYW1lLCBkZWZhdWx0Q29udGV4dCkge1xuICAgIGNvbnN0IEJhc2VDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0Q29udGV4dCk7XG4gICAgY29uc3QgaW5kZXggPSBkZWZhdWx0Q29udGV4dHMubGVuZ3RoO1xuICAgIGRlZmF1bHRDb250ZXh0cyA9IFsuLi5kZWZhdWx0Q29udGV4dHMsIGRlZmF1bHRDb250ZXh0XTtcbiAgICBjb25zdCBQcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgICAgY29uc3QgeyBzY29wZSwgY2hpbGRyZW4sIC4uLmNvbnRleHQgfSA9IHByb3BzO1xuICAgICAgY29uc3QgQ29udGV4dCA9IHNjb3BlPy5bc2NvcGVOYW1lXT8uW2luZGV4XSB8fCBCYXNlQ29udGV4dDtcbiAgICAgIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb250ZXh0LCBPYmplY3QudmFsdWVzKGNvbnRleHQpKTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUsIGNoaWxkcmVuIH0pO1xuICAgIH07XG4gICAgUHJvdmlkZXIuZGlzcGxheU5hbWUgPSByb290Q29tcG9uZW50TmFtZSArIFwiUHJvdmlkZXJcIjtcbiAgICBmdW5jdGlvbiB1c2VDb250ZXh0Mihjb25zdW1lck5hbWUsIHNjb3BlKSB7XG4gICAgICBjb25zdCBDb250ZXh0ID0gc2NvcGU/LltzY29wZU5hbWVdPy5baW5kZXhdIHx8IEJhc2VDb250ZXh0O1xuICAgICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgICBpZiAoY29udGV4dCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgICBpZiAoZGVmYXVsdENvbnRleHQgIT09IHZvaWQgMCkgcmV0dXJuIGRlZmF1bHRDb250ZXh0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke2NvbnN1bWVyTmFtZX1cXGAgbXVzdCBiZSB1c2VkIHdpdGhpbiBcXGAke3Jvb3RDb21wb25lbnROYW1lfVxcYGApO1xuICAgIH1cbiAgICByZXR1cm4gW1Byb3ZpZGVyLCB1c2VDb250ZXh0Ml07XG4gIH1cbiAgY29uc3QgY3JlYXRlU2NvcGUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2NvcGVDb250ZXh0cyA9IGRlZmF1bHRDb250ZXh0cy5tYXAoKGRlZmF1bHRDb250ZXh0KSA9PiB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0Q29udGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNjb3BlKHNjb3BlKSB7XG4gICAgICBjb25zdCBjb250ZXh0cyA9IHNjb3BlPy5bc2NvcGVOYW1lXSB8fCBzY29wZUNvbnRleHRzO1xuICAgICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgICAgICgpID0+ICh7IFtgX19zY29wZSR7c2NvcGVOYW1lfWBdOiB7IC4uLnNjb3BlLCBbc2NvcGVOYW1lXTogY29udGV4dHMgfSB9KSxcbiAgICAgICAgW3Njb3BlLCBjb250ZXh0c11cbiAgICAgICk7XG4gICAgfTtcbiAgfTtcbiAgY3JlYXRlU2NvcGUuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICByZXR1cm4gW2NyZWF0ZUNvbnRleHQzLCBjb21wb3NlQ29udGV4dFNjb3BlcyhjcmVhdGVTY29wZSwgLi4uY3JlYXRlQ29udGV4dFNjb3BlRGVwcyldO1xufVxuZnVuY3Rpb24gY29tcG9zZUNvbnRleHRTY29wZXMoLi4uc2NvcGVzKSB7XG4gIGNvbnN0IGJhc2VTY29wZSA9IHNjb3Blc1swXTtcbiAgaWYgKHNjb3Blcy5sZW5ndGggPT09IDEpIHJldHVybiBiYXNlU2NvcGU7XG4gIGNvbnN0IGNyZWF0ZVNjb3BlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlSG9va3MgPSBzY29wZXMubWFwKChjcmVhdGVTY29wZTIpID0+ICh7XG4gICAgICB1c2VTY29wZTogY3JlYXRlU2NvcGUyKCksXG4gICAgICBzY29wZU5hbWU6IGNyZWF0ZVNjb3BlMi5zY29wZU5hbWVcbiAgICB9KSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZUNvbXBvc2VkU2NvcGVzKG92ZXJyaWRlU2NvcGVzKSB7XG4gICAgICBjb25zdCBuZXh0U2NvcGVzID0gc2NvcGVIb29rcy5yZWR1Y2UoKG5leHRTY29wZXMyLCB7IHVzZVNjb3BlLCBzY29wZU5hbWUgfSkgPT4ge1xuICAgICAgICBjb25zdCBzY29wZVByb3BzID0gdXNlU2NvcGUob3ZlcnJpZGVTY29wZXMpO1xuICAgICAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBzY29wZVByb3BzW2BfX3Njb3BlJHtzY29wZU5hbWV9YF07XG4gICAgICAgIHJldHVybiB7IC4uLm5leHRTY29wZXMyLCAuLi5jdXJyZW50U2NvcGUgfTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7IFtgX19zY29wZSR7YmFzZVNjb3BlLnNjb3BlTmFtZX1gXTogbmV4dFNjb3BlcyB9KSwgW25leHRTY29wZXNdKTtcbiAgICB9O1xuICB9O1xuICBjcmVhdGVTY29wZS5zY29wZU5hbWUgPSBiYXNlU2NvcGUuc2NvcGVOYW1lO1xuICByZXR1cm4gY3JlYXRlU2NvcGU7XG59XG5leHBvcnQge1xuICBjcmVhdGVDb250ZXh0MiBhcyBjcmVhdGVDb250ZXh0LFxuICBjcmVhdGVDb250ZXh0U2NvcGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9jb21wb3NlLXJlZnMvc3JjL2NvbXBvc2VSZWZzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBzZXRSZWYocmVmLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHJlZih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICBsZXQgaGFzQ2xlYW51cCA9IGZhbHNlO1xuICAgIGNvbnN0IGNsZWFudXBzID0gcmVmcy5tYXAoKHJlZikgPT4ge1xuICAgICAgY29uc3QgY2xlYW51cCA9IHNldFJlZihyZWYsIG5vZGUpO1xuICAgICAgaWYgKCFoYXNDbGVhbnVwICYmIHR5cGVvZiBjbGVhbnVwID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBoYXNDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0pO1xuICAgIGlmIChoYXNDbGVhbnVwKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsZWFudXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2xlYW51cCA9IGNsZWFudXBzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0UmVmKHJlZnNbaV0sIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VDb21wb3NlZFJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soY29tcG9zZVJlZnMoLi4ucmVmcyksIHJlZnMpO1xufVxuZXhwb3J0IHtcbiAgY29tcG9zZVJlZnMsXG4gIHVzZUNvbXBvc2VkUmVmc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3Nsb3Qvc3JjL3Nsb3QudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNvbXBvc2VSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MiwganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2xvdCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgY2hpbGRyZW5BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICBjb25zdCBzbG90dGFibGUgPSBjaGlsZHJlbkFycmF5LmZpbmQoaXNTbG90dGFibGUpO1xuICBpZiAoc2xvdHRhYmxlKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IHNsb3R0YWJsZS5wcm9wcy5jaGlsZHJlbjtcbiAgICBjb25zdCBuZXdDaGlsZHJlbiA9IGNoaWxkcmVuQXJyYXkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkID09PSBzbG90dGFibGUpIHtcbiAgICAgICAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KG5ld0VsZW1lbnQpID4gMSkgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLm9ubHkobnVsbCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXdFbGVtZW50KSA/IG5ld0VsZW1lbnQucHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3RDbG9uZSwgeyAuLi5zbG90UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbjogUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV3RWxlbWVudCkgPyBSZWFjdC5jbG9uZUVsZW1lbnQobmV3RWxlbWVudCwgdm9pZCAwLCBuZXdDaGlsZHJlbikgOiBudWxsIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3RDbG9uZSwgeyAuLi5zbG90UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbiB9KTtcbn0pO1xuU2xvdC5kaXNwbGF5TmFtZSA9IFwiU2xvdFwiO1xudmFyIFNsb3RDbG9uZSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcbiAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuUmVmID0gZ2V0RWxlbWVudFJlZihjaGlsZHJlbik7XG4gICAgY29uc3QgcHJvcHMyID0gbWVyZ2VQcm9wcyhzbG90UHJvcHMsIGNoaWxkcmVuLnByb3BzKTtcbiAgICBpZiAoY2hpbGRyZW4udHlwZSAhPT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgIHByb3BzMi5yZWYgPSBmb3J3YXJkZWRSZWYgPyBjb21wb3NlUmVmcyhmb3J3YXJkZWRSZWYsIGNoaWxkcmVuUmVmKSA6IGNoaWxkcmVuUmVmO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCBwcm9wczIpO1xuICB9XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAxID8gUmVhY3QuQ2hpbGRyZW4ub25seShudWxsKSA6IG51bGw7XG59KTtcblNsb3RDbG9uZS5kaXNwbGF5TmFtZSA9IFwiU2xvdENsb25lXCI7XG52YXIgU2xvdHRhYmxlID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudDIsIHsgY2hpbGRyZW4gfSk7XG59O1xuZnVuY3Rpb24gaXNTbG90dGFibGUoY2hpbGQpIHtcbiAgcmV0dXJuIFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSAmJiBjaGlsZC50eXBlID09PSBTbG90dGFibGU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKHNsb3RQcm9wcywgY2hpbGRQcm9wcykge1xuICBjb25zdCBvdmVycmlkZVByb3BzID0geyAuLi5jaGlsZFByb3BzIH07XG4gIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gY2hpbGRQcm9wcykge1xuICAgIGNvbnN0IHNsb3RQcm9wVmFsdWUgPSBzbG90UHJvcHNbcHJvcE5hbWVdO1xuICAgIGNvbnN0IGNoaWxkUHJvcFZhbHVlID0gY2hpbGRQcm9wc1twcm9wTmFtZV07XG4gICAgY29uc3QgaXNIYW5kbGVyID0gL15vbltBLVpdLy50ZXN0KHByb3BOYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVyKSB7XG4gICAgICBpZiAoc2xvdFByb3BWYWx1ZSAmJiBjaGlsZFByb3BWYWx1ZSkge1xuICAgICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY2hpbGRQcm9wVmFsdWUoLi4uYXJncyk7XG4gICAgICAgICAgc2xvdFByb3BWYWx1ZSguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdFByb3BWYWx1ZSkge1xuICAgICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IHNsb3RQcm9wVmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IHsgLi4uc2xvdFByb3BWYWx1ZSwgLi4uY2hpbGRQcm9wVmFsdWUgfTtcbiAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSBcImNsYXNzTmFtZVwiKSB7XG4gICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IFtzbG90UHJvcFZhbHVlLCBjaGlsZFByb3BWYWx1ZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyAuLi5zbG90UHJvcHMsIC4uLm92ZXJyaWRlUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRSZWYoZWxlbWVudCkge1xuICBsZXQgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50LnByb3BzLCBcInJlZlwiKT8uZ2V0O1xuICBsZXQgbWF5V2FybiA9IGdldHRlciAmJiBcImlzUmVhY3RXYXJuaW5nXCIgaW4gZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZztcbiAgaWYgKG1heVdhcm4pIHtcbiAgICByZXR1cm4gZWxlbWVudC5yZWY7XG4gIH1cbiAgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50LCBcInJlZlwiKT8uZ2V0O1xuICBtYXlXYXJuID0gZ2V0dGVyICYmIFwiaXNSZWFjdFdhcm5pbmdcIiBpbiBnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nO1xuICBpZiAobWF5V2Fybikge1xuICAgIHJldHVybiBlbGVtZW50LnByb3BzLnJlZjtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wcm9wcy5yZWYgfHwgZWxlbWVudC5yZWY7XG59XG52YXIgUm9vdCA9IFNsb3Q7XG5leHBvcnQge1xuICBSb290LFxuICBTbG90LFxuICBTbG90dGFibGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvY29sbGVjdGlvbi9zcmMvY29sbGVjdGlvbi50c3hcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29udGV4dFwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNsb3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihuYW1lKSB7XG4gIGNvbnN0IFBST1ZJREVSX05BTUUgPSBuYW1lICsgXCJDb2xsZWN0aW9uUHJvdmlkZXJcIjtcbiAgY29uc3QgW2NyZWF0ZUNvbGxlY3Rpb25Db250ZXh0LCBjcmVhdGVDb2xsZWN0aW9uU2NvcGVdID0gY3JlYXRlQ29udGV4dFNjb3BlKFBST1ZJREVSX05BTUUpO1xuICBjb25zdCBbQ29sbGVjdGlvblByb3ZpZGVySW1wbCwgdXNlQ29sbGVjdGlvbkNvbnRleHRdID0gY3JlYXRlQ29sbGVjdGlvbkNvbnRleHQoXG4gICAgUFJPVklERVJfTkFNRSxcbiAgICB7IGNvbGxlY3Rpb25SZWY6IHsgY3VycmVudDogbnVsbCB9LCBpdGVtTWFwOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIH1cbiAgKTtcbiAgY29uc3QgQ29sbGVjdGlvblByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBzY29wZSwgY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpdGVtTWFwID0gUmVhY3QudXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLmN1cnJlbnQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvblByb3ZpZGVySW1wbCwgeyBzY29wZSwgaXRlbU1hcCwgY29sbGVjdGlvblJlZjogcmVmLCBjaGlsZHJlbiB9KTtcbiAgfTtcbiAgQ29sbGVjdGlvblByb3ZpZGVyLmRpc3BsYXlOYW1lID0gUFJPVklERVJfTkFNRTtcbiAgY29uc3QgQ09MTEVDVElPTl9TTE9UX05BTUUgPSBuYW1lICsgXCJDb2xsZWN0aW9uU2xvdFwiO1xuICBjb25zdCBDb2xsZWN0aW9uU2xvdCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb2xsZWN0aW9uQ29udGV4dChDT0xMRUNUSU9OX1NMT1RfTkFNRSwgc2NvcGUpO1xuICAgICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgY29udGV4dC5jb2xsZWN0aW9uUmVmKTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3QsIHsgcmVmOiBjb21wb3NlZFJlZnMsIGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgKTtcbiAgQ29sbGVjdGlvblNsb3QuZGlzcGxheU5hbWUgPSBDT0xMRUNUSU9OX1NMT1RfTkFNRTtcbiAgY29uc3QgSVRFTV9TTE9UX05BTUUgPSBuYW1lICsgXCJDb2xsZWN0aW9uSXRlbVNsb3RcIjtcbiAgY29uc3QgSVRFTV9EQVRBX0FUVFIgPSBcImRhdGEtcmFkaXgtY29sbGVjdGlvbi1pdGVtXCI7XG4gIGNvbnN0IENvbGxlY3Rpb25JdGVtU2xvdCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuLCAuLi5pdGVtRGF0YSB9ID0gcHJvcHM7XG4gICAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCByZWYpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHVzZUNvbGxlY3Rpb25Db250ZXh0KElURU1fU0xPVF9OQU1FLCBzY29wZSk7XG4gICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb250ZXh0Lml0ZW1NYXAuc2V0KHJlZiwgeyByZWYsIC4uLml0ZW1EYXRhIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdm9pZCBjb250ZXh0Lml0ZW1NYXAuZGVsZXRlKHJlZik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3QsIHsgLi4ueyBbSVRFTV9EQVRBX0FUVFJdOiBcIlwiIH0sIHJlZjogY29tcG9zZWRSZWZzLCBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICk7XG4gIENvbGxlY3Rpb25JdGVtU2xvdC5kaXNwbGF5TmFtZSA9IElURU1fU0xPVF9OQU1FO1xuICBmdW5jdGlvbiB1c2VDb2xsZWN0aW9uKHNjb3BlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbGxlY3Rpb25Db250ZXh0KG5hbWUgKyBcIkNvbGxlY3Rpb25Db25zdW1lclwiLCBzY29wZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBjb25zdCBjb2xsZWN0aW9uTm9kZSA9IGNvbnRleHQuY29sbGVjdGlvblJlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjb2xsZWN0aW9uTm9kZSkgcmV0dXJuIFtdO1xuICAgICAgY29uc3Qgb3JkZXJlZE5vZGVzID0gQXJyYXkuZnJvbShjb2xsZWN0aW9uTm9kZS5xdWVyeVNlbGVjdG9yQWxsKGBbJHtJVEVNX0RBVEFfQVRUUn1dYCkpO1xuICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKGNvbnRleHQuaXRlbU1hcC52YWx1ZXMoKSk7XG4gICAgICBjb25zdCBvcmRlcmVkSXRlbXMgPSBpdGVtcy5zb3J0KFxuICAgICAgICAoYSwgYikgPT4gb3JkZXJlZE5vZGVzLmluZGV4T2YoYS5yZWYuY3VycmVudCkgLSBvcmRlcmVkTm9kZXMuaW5kZXhPZihiLnJlZi5jdXJyZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBvcmRlcmVkSXRlbXM7XG4gICAgfSwgW2NvbnRleHQuY29sbGVjdGlvblJlZiwgY29udGV4dC5pdGVtTWFwXSk7XG4gICAgcmV0dXJuIGdldEl0ZW1zO1xuICB9XG4gIHJldHVybiBbXG4gICAgeyBQcm92aWRlcjogQ29sbGVjdGlvblByb3ZpZGVyLCBTbG90OiBDb2xsZWN0aW9uU2xvdCwgSXRlbVNsb3Q6IENvbGxlY3Rpb25JdGVtU2xvdCB9LFxuICAgIHVzZUNvbGxlY3Rpb24sXG4gICAgY3JlYXRlQ29sbGVjdGlvblNjb3BlXG4gIF07XG59XG5leHBvcnQge1xuICBjcmVhdGVDb2xsZWN0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvZGlyZWN0aW9uL3NyYy9EaXJlY3Rpb24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIERpcmVjdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG52YXIgRGlyZWN0aW9uUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBkaXIsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRGlyZWN0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGlyLCBjaGlsZHJlbiB9KTtcbn07XG5mdW5jdGlvbiB1c2VEaXJlY3Rpb24obG9jYWxEaXIpIHtcbiAgY29uc3QgZ2xvYmFsRGlyID0gUmVhY3QudXNlQ29udGV4dChEaXJlY3Rpb25Db250ZXh0KTtcbiAgcmV0dXJuIGxvY2FsRGlyIHx8IGdsb2JhbERpciB8fCBcImx0clwiO1xufVxudmFyIFByb3ZpZGVyID0gRGlyZWN0aW9uUHJvdmlkZXI7XG5leHBvcnQge1xuICBEaXJlY3Rpb25Qcm92aWRlcixcbiAgUHJvdmlkZXIsXG4gIHVzZURpcmVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3ByaW1pdGl2ZS9zcmMvcHJpbWl0aXZlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBOT0RFUyA9IFtcbiAgXCJhXCIsXG4gIFwiYnV0dG9uXCIsXG4gIFwiZGl2XCIsXG4gIFwiZm9ybVwiLFxuICBcImgyXCIsXG4gIFwiaDNcIixcbiAgXCJpbWdcIixcbiAgXCJpbnB1dFwiLFxuICBcImxhYmVsXCIsXG4gIFwibGlcIixcbiAgXCJuYXZcIixcbiAgXCJvbFwiLFxuICBcInBcIixcbiAgXCJzcGFuXCIsXG4gIFwic3ZnXCIsXG4gIFwidWxcIlxuXTtcbnZhciBQcmltaXRpdmUgPSBOT0RFUy5yZWR1Y2UoKHByaW1pdGl2ZSwgbm9kZSkgPT4ge1xuICBjb25zdCBOb2RlID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgYXNDaGlsZCwgLi4ucHJpbWl0aXZlUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IENvbXAgPSBhc0NoaWxkID8gU2xvdCA6IG5vZGU7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvd1tTeW1ib2wuZm9yKFwicmFkaXgtdWlcIildID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29tcCwgeyAuLi5wcmltaXRpdmVQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSk7XG4gIH0pO1xuICBOb2RlLmRpc3BsYXlOYW1lID0gYFByaW1pdGl2ZS4ke25vZGV9YDtcbiAgcmV0dXJuIHsgLi4ucHJpbWl0aXZlLCBbbm9kZV06IE5vZGUgfTtcbn0sIHt9KTtcbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudCh0YXJnZXQsIGV2ZW50KSB7XG4gIGlmICh0YXJnZXQpIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCkpO1xufVxudmFyIFJvb3QgPSBQcmltaXRpdmU7XG5leHBvcnQge1xuICBQcmltaXRpdmUsXG4gIFJvb3QsXG4gIGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3VzZS1jYWxsYmFjay1yZWYvc3JjL3VzZUNhbGxiYWNrUmVmLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VDYWxsYmFja1JlZihjYWxsYmFjaykge1xuICBjb25zdCBjYWxsYmFja1JlZiA9IFJlYWN0LnVzZVJlZihjYWxsYmFjayk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKC4uLmFyZ3MpID0+IGNhbGxiYWNrUmVmLmN1cnJlbnQ/LiguLi5hcmdzKSwgW10pO1xufVxuZXhwb3J0IHtcbiAgdXNlQ2FsbGJhY2tSZWZcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtZXNjYXBlLWtleWRvd24vc3JjL3VzZUVzY2FwZUtleWRvd24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5mdW5jdGlvbiB1c2VFc2NhcGVLZXlkb3duKG9uRXNjYXBlS2V5RG93blByb3AsIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzPy5kb2N1bWVudCkge1xuICBjb25zdCBvbkVzY2FwZUtleURvd24gPSB1c2VDYWxsYmFja1JlZihvbkVzY2FwZUtleURvd25Qcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIG9uRXNjYXBlS2V5RG93bihldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKCkgPT4gb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gIH0sIFtvbkVzY2FwZUtleURvd24sIG93bmVyRG9jdW1lbnRdKTtcbn1cbmV4cG9ydCB7XG4gIHVzZUVzY2FwZUtleWRvd25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvZGlzbWlzc2FibGUtbGF5ZXIvc3JjL2Rpc21pc3NhYmxlLWxheWVyLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjb21wb3NlRXZlbnRIYW5kbGVycyB9IGZyb20gXCJAcmFkaXgtdWkvcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyBQcmltaXRpdmUsIGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VDb21wb3NlZFJlZnMgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbXBvc2UtcmVmc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2tSZWYgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1jYWxsYmFjay1yZWZcIjtcbmltcG9ydCB7IHVzZUVzY2FwZUtleWRvd24gfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1lc2NhcGUta2V5ZG93blwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRElTTUlTU0FCTEVfTEFZRVJfTkFNRSA9IFwiRGlzbWlzc2FibGVMYXllclwiO1xudmFyIENPTlRFWFRfVVBEQVRFID0gXCJkaXNtaXNzYWJsZUxheWVyLnVwZGF0ZVwiO1xudmFyIFBPSU5URVJfRE9XTl9PVVRTSURFID0gXCJkaXNtaXNzYWJsZUxheWVyLnBvaW50ZXJEb3duT3V0c2lkZVwiO1xudmFyIEZPQ1VTX09VVFNJREUgPSBcImRpc21pc3NhYmxlTGF5ZXIuZm9jdXNPdXRzaWRlXCI7XG52YXIgb3JpZ2luYWxCb2R5UG9pbnRlckV2ZW50cztcbnZhciBEaXNtaXNzYWJsZUxheWVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBsYXllcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gIGxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBicmFuY2hlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxufSk7XG52YXIgRGlzbWlzc2FibGVMYXllciA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGlzYWJsZU91dHNpZGVQb2ludGVyRXZlbnRzID0gZmFsc2UsXG4gICAgICBvbkVzY2FwZUtleURvd24sXG4gICAgICBvblBvaW50ZXJEb3duT3V0c2lkZSxcbiAgICAgIG9uRm9jdXNPdXRzaWRlLFxuICAgICAgb25JbnRlcmFjdE91dHNpZGUsXG4gICAgICBvbkRpc21pc3MsXG4gICAgICAuLi5sYXllclByb3BzXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERpc21pc3NhYmxlTGF5ZXJDb250ZXh0KTtcbiAgICBjb25zdCBbbm9kZSwgc2V0Tm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gbm9kZT8ub3duZXJEb2N1bWVudCA/PyBnbG9iYWxUaGlzPy5kb2N1bWVudDtcbiAgICBjb25zdCBbLCBmb3JjZV0gPSBSZWFjdC51c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgKG5vZGUyKSA9PiBzZXROb2RlKG5vZGUyKSk7XG4gICAgY29uc3QgbGF5ZXJzID0gQXJyYXkuZnJvbShjb250ZXh0LmxheWVycyk7XG4gICAgY29uc3QgW2hpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkXSA9IFsuLi5jb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkXS5zbGljZSgtMSk7XG4gICAgY29uc3QgaGlnaGVzdExheWVyV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWRJbmRleCA9IGxheWVycy5pbmRleE9mKGhpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkKTtcbiAgICBjb25zdCBpbmRleCA9IG5vZGUgPyBsYXllcnMuaW5kZXhPZihub2RlKSA6IC0xO1xuICAgIGNvbnN0IGlzQm9keVBvaW50ZXJFdmVudHNEaXNhYmxlZCA9IGNvbnRleHQubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuc2l6ZSA+IDA7XG4gICAgY29uc3QgaXNQb2ludGVyRXZlbnRzRW5hYmxlZCA9IGluZGV4ID49IGhpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkSW5kZXg7XG4gICAgY29uc3QgcG9pbnRlckRvd25PdXRzaWRlID0gdXNlUG9pbnRlckRvd25PdXRzaWRlKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgaXNQb2ludGVyRG93bk9uQnJhbmNoID0gWy4uLmNvbnRleHQuYnJhbmNoZXNdLnNvbWUoKGJyYW5jaCkgPT4gYnJhbmNoLmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgaWYgKCFpc1BvaW50ZXJFdmVudHNFbmFibGVkIHx8IGlzUG9pbnRlckRvd25PbkJyYW5jaCkgcmV0dXJuO1xuICAgICAgb25Qb2ludGVyRG93bk91dHNpZGU/LihldmVudCk7XG4gICAgICBvbkludGVyYWN0T3V0c2lkZT8uKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgb25EaXNtaXNzPy4oKTtcbiAgICB9LCBvd25lckRvY3VtZW50KTtcbiAgICBjb25zdCBmb2N1c091dHNpZGUgPSB1c2VGb2N1c091dHNpZGUoKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5CcmFuY2ggPSBbLi4uY29udGV4dC5icmFuY2hlc10uc29tZSgoYnJhbmNoKSA9PiBicmFuY2guY29udGFpbnModGFyZ2V0KSk7XG4gICAgICBpZiAoaXNGb2N1c0luQnJhbmNoKSByZXR1cm47XG4gICAgICBvbkZvY3VzT3V0c2lkZT8uKGV2ZW50KTtcbiAgICAgIG9uSW50ZXJhY3RPdXRzaWRlPy4oZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSBvbkRpc21pc3M/LigpO1xuICAgIH0sIG93bmVyRG9jdW1lbnQpO1xuICAgIHVzZUVzY2FwZUtleWRvd24oKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBpc0hpZ2hlc3RMYXllciA9IGluZGV4ID09PSBjb250ZXh0LmxheWVycy5zaXplIC0gMTtcbiAgICAgIGlmICghaXNIaWdoZXN0TGF5ZXIpIHJldHVybjtcbiAgICAgIG9uRXNjYXBlS2V5RG93bj8uKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiBvbkRpc21pc3MpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25EaXNtaXNzKCk7XG4gICAgICB9XG4gICAgfSwgb3duZXJEb2N1bWVudCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgICAgaWYgKGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cykge1xuICAgICAgICBpZiAoY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5zaXplID09PSAwKSB7XG4gICAgICAgICAgb3JpZ2luYWxCb2R5UG9pbnRlckV2ZW50cyA9IG93bmVyRG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzO1xuICAgICAgICAgIG93bmVyRG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxheWVycy5hZGQobm9kZSk7XG4gICAgICBkaXNwYXRjaFVwZGF0ZSgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cyAmJiBjb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkLnNpemUgPT09IDEpIHtcbiAgICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9IG9yaWdpbmFsQm9keVBvaW50ZXJFdmVudHM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW25vZGUsIG93bmVyRG9jdW1lbnQsIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cywgY29udGV4dF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgY29udGV4dC5sYXllcnMuZGVsZXRlKG5vZGUpO1xuICAgICAgICBjb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkLmRlbGV0ZShub2RlKTtcbiAgICAgICAgZGlzcGF0Y2hVcGRhdGUoKTtcbiAgICAgIH07XG4gICAgfSwgW25vZGUsIGNvbnRleHRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKCkgPT4gZm9yY2Uoe30pO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihDT05URVhUX1VQREFURSwgaGFuZGxlVXBkYXRlKTtcbiAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKENPTlRFWFRfVVBEQVRFLCBoYW5kbGVVcGRhdGUpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICB7XG4gICAgICAgIC4uLmxheWVyUHJvcHMsXG4gICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGlzQm9keVBvaW50ZXJFdmVudHNEaXNhYmxlZCA/IGlzUG9pbnRlckV2ZW50c0VuYWJsZWQgPyBcImF1dG9cIiA6IFwibm9uZVwiIDogdm9pZCAwLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXNDYXB0dXJlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhwcm9wcy5vbkZvY3VzQ2FwdHVyZSwgZm9jdXNPdXRzaWRlLm9uRm9jdXNDYXB0dXJlKSxcbiAgICAgICAgb25CbHVyQ2FwdHVyZTogY29tcG9zZUV2ZW50SGFuZGxlcnMocHJvcHMub25CbHVyQ2FwdHVyZSwgZm9jdXNPdXRzaWRlLm9uQmx1ckNhcHR1cmUpLFxuICAgICAgICBvblBvaW50ZXJEb3duQ2FwdHVyZTogY29tcG9zZUV2ZW50SGFuZGxlcnMoXG4gICAgICAgICAgcHJvcHMub25Qb2ludGVyRG93bkNhcHR1cmUsXG4gICAgICAgICAgcG9pbnRlckRvd25PdXRzaWRlLm9uUG9pbnRlckRvd25DYXB0dXJlXG4gICAgICAgIClcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuRGlzbWlzc2FibGVMYXllci5kaXNwbGF5TmFtZSA9IERJU01JU1NBQkxFX0xBWUVSX05BTUU7XG52YXIgQlJBTkNIX05BTUUgPSBcIkRpc21pc3NhYmxlTGF5ZXJCcmFuY2hcIjtcbnZhciBEaXNtaXNzYWJsZUxheWVyQnJhbmNoID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEaXNtaXNzYWJsZUxheWVyQ29udGV4dCk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbnRleHQuYnJhbmNoZXMuYWRkKG5vZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29udGV4dC5icmFuY2hlcy5kZWxldGUobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2NvbnRleHQuYnJhbmNoZXNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyAuLi5wcm9wcywgcmVmOiBjb21wb3NlZFJlZnMgfSk7XG59KTtcbkRpc21pc3NhYmxlTGF5ZXJCcmFuY2guZGlzcGxheU5hbWUgPSBCUkFOQ0hfTkFNRTtcbmZ1bmN0aW9uIHVzZVBvaW50ZXJEb3duT3V0c2lkZShvblBvaW50ZXJEb3duT3V0c2lkZSwgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXM/LmRvY3VtZW50KSB7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJEb3duT3V0c2lkZSA9IHVzZUNhbGxiYWNrUmVmKG9uUG9pbnRlckRvd25PdXRzaWRlKTtcbiAgY29uc3QgaXNQb2ludGVySW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlQ2xpY2tSZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVQb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAmJiAhaXNQb2ludGVySW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbGV0IGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudChcbiAgICAgICAgICAgIFBPSU5URVJfRE9XTl9PVVRTSURFLFxuICAgICAgICAgICAgaGFuZGxlUG9pbnRlckRvd25PdXRzaWRlLFxuICAgICAgICAgICAgZXZlbnREZXRhaWwsXG4gICAgICAgICAgICB7IGRpc2NyZXRlOiB0cnVlIH1cbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlQW5kRGlzcGF0Y2hQb2ludGVyRG93bk91dHNpZGVFdmVudCA9IGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyO1xuICAgICAgICBjb25zdCBldmVudERldGFpbCA9IHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfTtcbiAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGlja1JlZi5jdXJyZW50KTtcbiAgICAgICAgICBoYW5kbGVDbGlja1JlZi5jdXJyZW50ID0gaGFuZGxlQW5kRGlzcGF0Y2hQb2ludGVyRG93bk91dHNpZGVFdmVudDI7XG4gICAgICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaXNQb2ludGVySW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IHRpbWVySWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGlja1JlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbb3duZXJEb2N1bWVudCwgaGFuZGxlUG9pbnRlckRvd25PdXRzaWRlXSk7XG4gIHJldHVybiB7XG4gICAgLy8gZW5zdXJlcyB3ZSBjaGVjayBSZWFjdCBjb21wb25lbnQgdHJlZSAobm90IGp1c3QgRE9NIHRyZWUpXG4gICAgb25Qb2ludGVyRG93bkNhcHR1cmU6ICgpID0+IGlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gdHJ1ZVxuICB9O1xufVxuZnVuY3Rpb24gdXNlRm9jdXNPdXRzaWRlKG9uRm9jdXNPdXRzaWRlLCBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcz8uZG9jdW1lbnQpIHtcbiAgY29uc3QgaGFuZGxlRm9jdXNPdXRzaWRlID0gdXNlQ2FsbGJhY2tSZWYob25Gb2N1c091dHNpZGUpO1xuICBjb25zdCBpc0ZvY3VzSW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAmJiAhaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50RGV0YWlsID0geyBvcmlnaW5hbEV2ZW50OiBldmVudCB9O1xuICAgICAgICBoYW5kbGVBbmREaXNwYXRjaEN1c3RvbUV2ZW50KEZPQ1VTX09VVFNJREUsIGhhbmRsZUZvY3VzT3V0c2lkZSwgZXZlbnREZXRhaWwsIHtcbiAgICAgICAgICBkaXNjcmV0ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGhhbmRsZUZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4gb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBoYW5kbGVGb2N1cyk7XG4gIH0sIFtvd25lckRvY3VtZW50LCBoYW5kbGVGb2N1c091dHNpZGVdKTtcbiAgcmV0dXJuIHtcbiAgICBvbkZvY3VzQ2FwdHVyZTogKCkgPT4gaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gdHJ1ZSxcbiAgICBvbkJsdXJDYXB0dXJlOiAoKSA9PiBpc0ZvY3VzSW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hVcGRhdGUoKSB7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KENPTlRFWFRfVVBEQVRFKTtcbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBoYW5kbGVBbmREaXNwYXRjaEN1c3RvbUV2ZW50KG5hbWUsIGhhbmRsZXIsIGRldGFpbCwgeyBkaXNjcmV0ZSB9KSB7XG4gIGNvbnN0IHRhcmdldCA9IGRldGFpbC5vcmlnaW5hbEV2ZW50LnRhcmdldDtcbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogdHJ1ZSwgZGV0YWlsIH0pO1xuICBpZiAoaGFuZGxlcikgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICBpZiAoZGlzY3JldGUpIHtcbiAgICBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnQodGFyZ2V0LCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG52YXIgUm9vdCA9IERpc21pc3NhYmxlTGF5ZXI7XG52YXIgQnJhbmNoID0gRGlzbWlzc2FibGVMYXllckJyYW5jaDtcbmV4cG9ydCB7XG4gIEJyYW5jaCxcbiAgRGlzbWlzc2FibGVMYXllcixcbiAgRGlzbWlzc2FibGVMYXllckJyYW5jaCxcbiAgUm9vdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9mb2N1cy1ndWFyZHMvc3JjL0ZvY3VzR3VhcmRzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgY291bnQgPSAwO1xuZnVuY3Rpb24gRm9jdXNHdWFyZHMocHJvcHMpIHtcbiAgdXNlRm9jdXNHdWFyZHMoKTtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuZnVuY3Rpb24gdXNlRm9jdXNHdWFyZHMoKSB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWRnZUd1YXJkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1yYWRpeC1mb2N1cy1ndWFyZF1cIik7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVkZ2VHdWFyZHNbMF0gPz8gY3JlYXRlRm9jdXNHdWFyZCgpKTtcbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLCBlZGdlR3VhcmRzWzFdID8/IGNyZWF0ZUZvY3VzR3VhcmQoKSk7XG4gICAgY291bnQrKztcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1yYWRpeC1mb2N1cy1ndWFyZF1cIikuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5yZW1vdmUoKSk7XG4gICAgICB9XG4gICAgICBjb3VudC0tO1xuICAgIH07XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvY3VzR3VhcmQoKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJhZGl4LWZvY3VzLWd1YXJkXCIsIFwiXCIpO1xuICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gXCJub25lXCI7XG4gIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgUm9vdCA9IEZvY3VzR3VhcmRzO1xuZXhwb3J0IHtcbiAgRm9jdXNHdWFyZHMsXG4gIFJvb3QsXG4gIHVzZUZvY3VzR3VhcmRzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L2ZvY3VzLXNjb3BlL3NyYy9mb2N1cy1zY29wZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQVVUT0ZPQ1VTX09OX01PVU5UID0gXCJmb2N1c1Njb3BlLmF1dG9Gb2N1c09uTW91bnRcIjtcbnZhciBBVVRPRk9DVVNfT05fVU5NT1VOVCA9IFwiZm9jdXNTY29wZS5hdXRvRm9jdXNPblVubW91bnRcIjtcbnZhciBFVkVOVF9PUFRJT05TID0geyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogdHJ1ZSB9O1xudmFyIEZPQ1VTX1NDT1BFX05BTUUgPSBcIkZvY3VzU2NvcGVcIjtcbnZhciBGb2N1c1Njb3BlID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgbG9vcCA9IGZhbHNlLFxuICAgIHRyYXBwZWQgPSBmYWxzZSxcbiAgICBvbk1vdW50QXV0b0ZvY3VzOiBvbk1vdW50QXV0b0ZvY3VzUHJvcCxcbiAgICBvblVubW91bnRBdXRvRm9jdXM6IG9uVW5tb3VudEF1dG9Gb2N1c1Byb3AsXG4gICAgLi4uc2NvcGVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtjb250YWluZXIsIHNldENvbnRhaW5lcl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgb25Nb3VudEF1dG9Gb2N1cyA9IHVzZUNhbGxiYWNrUmVmKG9uTW91bnRBdXRvRm9jdXNQcm9wKTtcbiAgY29uc3Qgb25Vbm1vdW50QXV0b0ZvY3VzID0gdXNlQ2FsbGJhY2tSZWYob25Vbm1vdW50QXV0b0ZvY3VzUHJvcCk7XG4gIGNvbnN0IGxhc3RGb2N1c2VkRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgKG5vZGUpID0+IHNldENvbnRhaW5lcihub2RlKSk7XG4gIGNvbnN0IGZvY3VzU2NvcGUgPSBSZWFjdC51c2VSZWYoe1xuICAgIHBhdXNlZDogZmFsc2UsXG4gICAgcGF1c2UoKSB7XG4gICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfSxcbiAgICByZXN1bWUoKSB7XG4gICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSkuY3VycmVudDtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhcHBlZCkge1xuICAgICAgbGV0IGhhbmRsZUZvY3VzSW4yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGZvY3VzU2NvcGUucGF1c2VkIHx8ICFjb250YWluZXIpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICBsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb2N1cyhsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGhhbmRsZUZvY3VzT3V0MiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChmb2N1c1Njb3BlLnBhdXNlZCB8fCAhY29udGFpbmVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICBpZiAocmVsYXRlZFRhcmdldCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgIGZvY3VzKGxhc3RGb2N1c2VkRWxlbWVudFJlZi5jdXJyZW50LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgaGFuZGxlTXV0YXRpb25zMiA9IGZ1bmN0aW9uKG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChmb2N1c2VkRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoID4gMCkgZm9jdXMoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBoYW5kbGVGb2N1c0luID0gaGFuZGxlRm9jdXNJbjIsIGhhbmRsZUZvY3VzT3V0ID0gaGFuZGxlRm9jdXNPdXQyLCBoYW5kbGVNdXRhdGlvbnMgPSBoYW5kbGVNdXRhdGlvbnMyO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgaGFuZGxlRm9jdXNJbjIpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGhhbmRsZUZvY3VzT3V0Mik7XG4gICAgICBjb25zdCBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zMik7XG4gICAgICBpZiAoY29udGFpbmVyKSBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGhhbmRsZUZvY3VzSW4yKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGhhbmRsZUZvY3VzT3V0Mik7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt0cmFwcGVkLCBjb250YWluZXIsIGZvY3VzU2NvcGUucGF1c2VkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgZm9jdXNTY29wZXNTdGFjay5hZGQoZm9jdXNTY29wZSk7XG4gICAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgY29uc3QgaGFzRm9jdXNlZENhbmRpZGF0ZSA9IGNvbnRhaW5lci5jb250YWlucyhwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgaWYgKCFoYXNGb2N1c2VkQ2FuZGlkYXRlKSB7XG4gICAgICAgIGNvbnN0IG1vdW50RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoQVVUT0ZPQ1VTX09OX01PVU5ULCBFVkVOVF9PUFRJT05TKTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoQVVUT0ZPQ1VTX09OX01PVU5ULCBvbk1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobW91bnRFdmVudCk7XG4gICAgICAgIGlmICghbW91bnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgZm9jdXNGaXJzdChyZW1vdmVMaW5rcyhnZXRUYWJiYWJsZUNhbmRpZGF0ZXMoY29udGFpbmVyKSksIHsgc2VsZWN0OiB0cnVlIH0pO1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZvY3VzKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihBVVRPRk9DVVNfT05fTU9VTlQsIG9uTW91bnRBdXRvRm9jdXMpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCB1bm1vdW50RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoQVVUT0ZPQ1VTX09OX1VOTU9VTlQsIEVWRU5UX09QVElPTlMpO1xuICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKEFVVE9GT0NVU19PTl9VTk1PVU5ULCBvblVubW91bnRBdXRvRm9jdXMpO1xuICAgICAgICAgIGNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KHVubW91bnRFdmVudCk7XG4gICAgICAgICAgaWYgKCF1bm1vdW50RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgZm9jdXMocHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID8/IGRvY3VtZW50LmJvZHksIHsgc2VsZWN0OiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihBVVRPRk9DVVNfT05fVU5NT1VOVCwgb25Vbm1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgICBmb2N1c1Njb3Blc1N0YWNrLnJlbW92ZShmb2N1c1Njb3BlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2NvbnRhaW5lciwgb25Nb3VudEF1dG9Gb2N1cywgb25Vbm1vdW50QXV0b0ZvY3VzLCBmb2N1c1Njb3BlXSk7XG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghbG9vcCAmJiAhdHJhcHBlZCkgcmV0dXJuO1xuICAgICAgaWYgKGZvY3VzU2NvcGUucGF1c2VkKSByZXR1cm47XG4gICAgICBjb25zdCBpc1RhYktleSA9IGV2ZW50LmtleSA9PT0gXCJUYWJcIiAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5O1xuICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGlzVGFiS2V5ICYmIGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcjIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICBjb25zdCBbZmlyc3QsIGxhc3RdID0gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIyKTtcbiAgICAgICAgY29uc3QgaGFzVGFiYmFibGVFbGVtZW50c0luc2lkZSA9IGZpcnN0ICYmIGxhc3Q7XG4gICAgICAgIGlmICghaGFzVGFiYmFibGVFbGVtZW50c0luc2lkZSkge1xuICAgICAgICAgIGlmIChmb2N1c2VkRWxlbWVudCA9PT0gY29udGFpbmVyMikgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzZWRFbGVtZW50ID09PSBsYXN0KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGxvb3ApIGZvY3VzKGZpcnN0LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzZWRFbGVtZW50ID09PSBmaXJzdCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChsb29wKSBmb2N1cyhsYXN0LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtsb29wLCB0cmFwcGVkLCBmb2N1c1Njb3BlLnBhdXNlZF1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyB0YWJJbmRleDogLTEsIC4uLnNjb3BlUHJvcHMsIHJlZjogY29tcG9zZWRSZWZzLCBvbktleURvd246IGhhbmRsZUtleURvd24gfSk7XG59KTtcbkZvY3VzU2NvcGUuZGlzcGxheU5hbWUgPSBGT0NVU19TQ09QRV9OQU1FO1xuZnVuY3Rpb24gZm9jdXNGaXJzdChjYW5kaWRhdGVzLCB7IHNlbGVjdCA9IGZhbHNlIH0gPSB7fSkge1xuICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgZm9jdXMoY2FuZGlkYXRlLCB7IHNlbGVjdCB9KTtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KSByZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhYmJhYmxlRWRnZXMoY29udGFpbmVyKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBnZXRUYWJiYWJsZUNhbmRpZGF0ZXMoY29udGFpbmVyKTtcbiAgY29uc3QgZmlyc3QgPSBmaW5kVmlzaWJsZShjYW5kaWRhdGVzLCBjb250YWluZXIpO1xuICBjb25zdCBsYXN0ID0gZmluZFZpc2libGUoY2FuZGlkYXRlcy5yZXZlcnNlKCksIGNvbnRhaW5lcik7XG4gIHJldHVybiBbZmlyc3QsIGxhc3RdO1xufVxuZnVuY3Rpb24gZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGNvbnRhaW5lciwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHtcbiAgICBhY2NlcHROb2RlOiAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgaXNIaWRkZW5JbnB1dCA9IG5vZGUudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIG5vZGUudHlwZSA9PT0gXCJoaWRkZW5cIjtcbiAgICAgIGlmIChub2RlLmRpc2FibGVkIHx8IG5vZGUuaGlkZGVuIHx8IGlzSGlkZGVuSW5wdXQpIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgcmV0dXJuIG5vZGUudGFiSW5kZXggPj0gMCA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuICB9KTtcbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSBub2Rlcy5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGZpbmRWaXNpYmxlKGVsZW1lbnRzLCBjb250YWluZXIpIHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKCFpc0hpZGRlbihlbGVtZW50LCB7IHVwVG86IGNvbnRhaW5lciB9KSkgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSGlkZGVuKG5vZGUsIHsgdXBUbyB9KSB7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHJldHVybiB0cnVlO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmICh1cFRvICE9PSB2b2lkIDAgJiYgbm9kZSA9PT0gdXBUbykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgPT09IFwibm9uZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0YWJsZUlucHV0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIFwic2VsZWN0XCIgaW4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGZvY3VzKGVsZW1lbnQsIHsgc2VsZWN0ID0gZmFsc2UgfSA9IHt9KSB7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuZm9jdXMpIHtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgIGlmIChlbGVtZW50ICE9PSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgJiYgaXNTZWxlY3RhYmxlSW5wdXQoZWxlbWVudCkgJiYgc2VsZWN0KVxuICAgICAgZWxlbWVudC5zZWxlY3QoKTtcbiAgfVxufVxudmFyIGZvY3VzU2NvcGVzU3RhY2sgPSBjcmVhdGVGb2N1c1Njb3Blc1N0YWNrKCk7XG5mdW5jdGlvbiBjcmVhdGVGb2N1c1Njb3Blc1N0YWNrKCkge1xuICBsZXQgc3RhY2sgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBhZGQoZm9jdXNTY29wZSkge1xuICAgICAgY29uc3QgYWN0aXZlRm9jdXNTY29wZSA9IHN0YWNrWzBdO1xuICAgICAgaWYgKGZvY3VzU2NvcGUgIT09IGFjdGl2ZUZvY3VzU2NvcGUpIHtcbiAgICAgICAgYWN0aXZlRm9jdXNTY29wZT8ucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrID0gYXJyYXlSZW1vdmUoc3RhY2ssIGZvY3VzU2NvcGUpO1xuICAgICAgc3RhY2sudW5zaGlmdChmb2N1c1Njb3BlKTtcbiAgICB9LFxuICAgIHJlbW92ZShmb2N1c1Njb3BlKSB7XG4gICAgICBzdGFjayA9IGFycmF5UmVtb3ZlKHN0YWNrLCBmb2N1c1Njb3BlKTtcbiAgICAgIHN0YWNrWzBdPy5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhcnJheVJlbW92ZShhcnJheSwgaXRlbSkge1xuICBjb25zdCB1cGRhdGVkQXJyYXkgPSBbLi4uYXJyYXldO1xuICBjb25zdCBpbmRleCA9IHVwZGF0ZWRBcnJheS5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdXBkYXRlZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpbmtzKGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udGFnTmFtZSAhPT0gXCJBXCIpO1xufVxudmFyIFJvb3QgPSBGb2N1c1Njb3BlO1xuZXhwb3J0IHtcbiAgRm9jdXNTY29wZSxcbiAgUm9vdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3VzZS1sYXlvdXQtZWZmZWN0L3NyYy91c2VMYXlvdXRFZmZlY3QudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VMYXlvdXRFZmZlY3QyID0gQm9vbGVhbihnbG9iYWxUaGlzPy5kb2N1bWVudCkgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiAoKSA9PiB7XG59O1xuZXhwb3J0IHtcbiAgdXNlTGF5b3V0RWZmZWN0MiBhcyB1c2VMYXlvdXRFZmZlY3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9pZC9zcmMvaWQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbnZhciB1c2VSZWFjdElkID0gUmVhY3RbXCJ1c2VJZFwiLnRvU3RyaW5nKCldIHx8ICgoKSA9PiB2b2lkIDApO1xudmFyIGNvdW50ID0gMDtcbmZ1bmN0aW9uIHVzZUlkKGRldGVybWluaXN0aWNJZCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKHVzZVJlYWN0SWQoKSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkZXRlcm1pbmlzdGljSWQpIHNldElkKChyZWFjdElkKSA9PiByZWFjdElkID8/IFN0cmluZyhjb3VudCsrKSk7XG4gIH0sIFtkZXRlcm1pbmlzdGljSWRdKTtcbiAgcmV0dXJuIGRldGVybWluaXN0aWNJZCB8fCAoaWQgPyBgcmFkaXgtJHtpZH1gIDogXCJcIik7XG59XG5leHBvcnQge1xuICB1c2VJZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8qKlxuICogQ3VzdG9tIHBvc2l0aW9uaW5nIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3ZpcnR1YWwtZWxlbWVudHNcbiAqL1xuXG5jb25zdCBzaWRlcyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5jb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsICdlbmQnXTtcbmNvbnN0IHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1swXSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1sxXSksIFtdKTtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSB2ID0+ICh7XG4gIHg6IHYsXG4gIHk6IHZcbn0pO1xuY29uc3Qgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gY2xhbXAoc3RhcnQsIHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIG1heChzdGFydCwgbWluKHZhbHVlLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHZhbHVlLCBwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd5JyA6ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiBnZXRPcHBvc2l0ZUF4aXMoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSk7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpIHtcbiAgaWYgKHJ0bCA9PT0gdm9pZCAwKSB7XG4gICAgcnRsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IGFsaWdubWVudEF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiBbbWFpbkFsaWdubWVudFNpZGUsIGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKV07XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBhbGlnbm1lbnQgPT4gb3Bwb3NpdGVBbGlnbm1lbnRNYXBbYWxpZ25tZW50XSk7XG59XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgY29uc3QgbHIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgY29uc3QgcmwgPSBbJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgY29uc3QgdGIgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgY29uc3QgYnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybCA6IGxyO1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsciA6IHJsO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGIgOiBidDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiIsImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoLFxuICAgIGhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0XG4gIH0gOiByZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBvZmZzZXRTY2FsZSA9IChhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkpID8gKGF3YWl0IChwbGF0Zm9ybS5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgYm90dG9tOiAoZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSAvIG9mZnNldFNjYWxlLnksXG4gICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtaWRkbGV3YXJlRGF0YVxuICAgIH0gPSBzdGF0ZTtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZS5cbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50LFxuICAgICAgcGFkZGluZyA9IDBcbiAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpIHx8IHt9O1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzWUF4aXMgPSBheGlzID09PSAneSc7XG4gICAgY29uc3QgbWluUHJvcCA9IGlzWUF4aXMgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gaXNZQXhpcyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBjbGllbnRQcm9wID0gaXNZQXhpcyA/ICdjbGllbnRIZWlnaHQnIDogJ2NsaWVudFdpZHRoJztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGFycm93T2Zmc2V0UGFyZW50W2NsaWVudFByb3BdIDogMDtcblxuICAgIC8vIERPTSBwbGF0Zm9ybSBjYW4gcmV0dXJuIGB3aW5kb3dgIGFzIHRoZSBgb2Zmc2V0UGFyZW50YC5cbiAgICBpZiAoIWNsaWVudFNpemUgfHwgIShhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoYXJyb3dPZmZzZXRQYXJlbnQpKSkpIHtcbiAgICAgIGNsaWVudFNpemUgPSBlbGVtZW50cy5mbG9hdGluZ1tjbGllbnRQcm9wXSB8fCByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAgIC8vIElmIHRoZSBwYWRkaW5nIGlzIGxhcmdlIGVub3VnaCB0aGF0IGl0IGNhdXNlcyB0aGUgYXJyb3cgdG8gbm8gbG9uZ2VyIGJlXG4gICAgLy8gY2VudGVyZWQsIG1vZGlmeSB0aGUgcGFkZGluZyBzbyB0aGF0IGl0IGlzIGNlbnRlcmVkLlxuICAgIGNvbnN0IGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiAtIDE7XG4gICAgY29uc3QgbWluUGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21pblByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWF4UHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzLlxuICAgIGNvbnN0IG1pbiQxID0gbWluUGFkZGluZztcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBtYXhQYWRkaW5nO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gY2xhbXAobWluJDEsIGNlbnRlciwgbWF4KTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhlIGFycm93J3MgcGFkZGluZyBjYXVzZXMgaXQgdG9cbiAgICAvLyB0byBwb2ludCB0byBub3RoaW5nIGZvciBhbiBhbGlnbmVkIHBsYWNlbWVudCwgYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCBpdHNlbGYuIFRvIGVuc3VyZSBgc2hpZnQoKWAgY29udGludWVzIHRvIHRha2UgYWN0aW9uLFxuICAgIC8vIGEgc2luZ2xlIHJlc2V0IGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgaXMgdHJ1ZS5cbiAgICBjb25zdCBzaG91bGRBZGRPZmZzZXQgPSAhbWlkZGxld2FyZURhdGEuYXJyb3cgJiYgZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT0gbnVsbCAmJiBjZW50ZXIgIT09IG9mZnNldCAmJiByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSAvIDIgLSAoY2VudGVyIDwgbWluJDEgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZykgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiQxID8gY2VudGVyIC0gbWluJDEgOiBjZW50ZXIgLSBtYXggOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSArIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0IC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgICAuLi4oc2hvdWxkQWRkT2Zmc2V0ICYmIHtcbiAgICAgICAgICBhbGlnbm1lbnRPZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNldDogc2hvdWxkQWRkT2Zmc2V0XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykge1xuICBjb25zdCBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50ID0gYWxpZ25tZW50ID8gWy4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCksIC4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT09IGFsaWdubWVudCldIDogYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRTaWRlKHBsYWNlbWVudCkgPT09IHBsYWNlbWVudCk7XG4gIHJldHVybiBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50LmZpbHRlcihwbGFjZW1lbnQgPT4ge1xuICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50IHx8IChhdXRvQWxpZ25tZW50ID8gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSAhPT0gcGxhY2VtZW50IDogZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX3BsYWNlbWVudHNUaGF0Rml0T25FO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyxcbiAgICAgICAgYXV0b0FsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMkMSA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBwbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXhdO1xuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlnbm1lbnRTaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzJDFbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1swXV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzFdXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICAgIC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2suXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UgPSBhbGxPdmVyZmxvd3MubWFwKGQgPT4ge1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQoZC5wbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gW2QucGxhY2VtZW50LCBhbGlnbm1lbnQgJiYgY3Jvc3NBeGlzID9cbiAgICAgICAgLy8gQ2hlY2sgYWxvbmcgdGhlIG1haW5BeGlzIGFuZCBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBkLm92ZXJmbG93cy5zbGljZSgwLCAyKS5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiwgMCkgOlxuICAgICAgICAvLyBDaGVjayBvbmx5IHRoZSBtYWluQXhpcy5cbiAgICAgICAgZC5vdmVyZmxvd3NbMF0sIGQub3ZlcmZsb3dzXTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSA9IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZS5maWx0ZXIoZCA9PiBkWzJdLnNsaWNlKDAsXG4gICAgICAvLyBBbGlnbmVkIHBsYWNlbWVudHMgc2hvdWxkIG5vdCBjaGVjayB0aGVpciBvcHBvc2l0ZSBjcm9zc0F4aXNcbiAgICAgIC8vIHNpZGUuXG4gICAgICBnZXRBbGlnbm1lbnQoZFswXSkgPyAyIDogMykuZXZlcnkodiA9PiB2IDw9IDApKTtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gKChfcGxhY2VtZW50c1RoYXRGaXRPbkUgPSBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1RoYXRGaXRPbkVbMF0pIHx8IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZVswXVswXTtcbiAgICAgIGlmIChyZXNldFBsYWNlbWVudCAhPT0gcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZsaXAnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWUsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gJ2Jlc3RGaXQnLFxuICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gJ25vbmUnLFxuICAgICAgICBmbGlwQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gICAgICAvLyBJZiBhIHJlc2V0IGJ5IHRoZSBhcnJvdyB3YXMgY2F1c2VkIGR1ZSB0byBhbiBhbGlnbm1lbnQgb2Zmc2V0IGJlaW5nXG4gICAgICAvLyBhZGRlZCwgd2Ugc2hvdWxkIHNraXAgYW55IGxvZ2ljIG5vdyBzaW5jZSBgZmxpcCgpYCBoYXMgYWxyZWFkeSBkb25lIGl0c1xuICAgICAgLy8gd29yay5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjU0OSNpc3N1ZWNvbW1lbnQtMTcxOTYwMTY0M1xuICAgICAgaWYgKChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsU2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhpbml0aWFsUGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09ICdub25lJztcbiAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyMiA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSAneSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50LFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgY29uc3QgbWFpbkF4aXNNdWx0aSA9IFsnbGVmdCcsICd0b3AnXS5pbmNsdWRlcyhzaWRlKSA/IC0xIDogMTtcbiAgY29uc3QgY3Jvc3NBeGlzTXVsdGkgPSBydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgY29uc3QgcmF3VmFsdWUgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZS5tYWluQXhpcyB8fCAwLFxuICAgIGNyb3NzQXhpczogcmF3VmFsdWUuY3Jvc3NBeGlzIHx8IDAsXG4gICAgYWxpZ25tZW50QXhpczogcmF3VmFsdWUuYWxpZ25tZW50QXhpc1xuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5LFxuICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfc3RhdGUkbWlkZGxld2FyZURhdGEsIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gbWluKGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IG1pbih3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV0sIG1heGltdW1DbGlwcGluZ1dpZHRoKTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEuZW5hYmxlZC54KSB7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEyLmVuYWJsZWQueSkge1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iLCJmdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBNb2NrZWQgbm9kZXMgaW4gdGVzdGluZyBlbnZpcm9ubWVudHMgbWF5IG5vdCBiZSBpbnN0YW5jZXMgb2YgTm9kZS4gQnlcbiAgLy8gcmV0dXJuaW5nIGAjZG9jdW1lbnRgIGFuIGluZmluaXRlIGxvb3Agd29uJ3Qgb2NjdXIuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjMxN1xuICByZXR1cm4gJyNkb2N1bWVudCc7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgfHwgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuTm9kZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkgfHwgdHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVsnaW5saW5lJywgJ2NvbnRlbnRzJ10uaW5jbHVkZXMoZGlzcGxheSk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNUb3BMYXllcihlbGVtZW50KSB7XG4gIHJldHVybiBbJzpwb3BvdmVyLW9wZW4nLCAnOm1vZGFsJ10uc29tZShzZWxlY3RvciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudE9yQ3NzKSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGlzRWxlbWVudChlbGVtZW50T3JDc3MpID8gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50T3JDc3MpIDogZWxlbWVudE9yQ3NzO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdHJhbnNmb3Jtcy0yLyNpbmRpdmlkdWFsLXRyYW5zZm9ybXNcbiAgcmV0dXJuIFsndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAncGVyc3BlY3RpdmUnXS5zb21lKHZhbHVlID0+IGNzc1t2YWx1ZV0gPyBjc3NbdmFsdWVdICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgKGNzcy5jb250YWluZXJUeXBlID8gY3NzLmNvbnRhaW5lclR5cGUgIT09ICdub3JtYWwnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgWyd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlJywgJ3NjYWxlJywgJ3JvdGF0ZScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXS5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNUb3BMYXllcihjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIGlmICh0eXBlb2YgQ1NTID09PSAndW5kZWZpbmVkJyB8fCAhQ1NTLnN1cHBvcnRzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBDU1Muc3VwcG9ydHMoJy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyJywgJ25vbmUnKTtcbn1cbmZ1bmN0aW9uIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQod2luKTtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKGZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQod2luKSB7XG4gIHJldHVybiB3aW4ucGFyZW50ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih3aW4ucGFyZW50KSA/IHdpbi5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBnZXRDb250YWluaW5nQmxvY2ssIGdldERvY3VtZW50RWxlbWVudCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNUb3BMYXllciwgaXNXZWJLaXQgfTtcbiIsImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGRldGVjdE92ZXJmbG93IGFzIGRldGVjdE92ZXJmbG93JDEsIG9mZnNldCBhcyBvZmZzZXQkMSwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgaGlkZSBhcyBoaWRlJDEsIGFycm93IGFzIGFycm93JDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0hUTUxFbGVtZW50LCBpc0VsZW1lbnQsIGdldFdpbmRvdywgaXNXZWJLaXQsIGdldEZyYW1lRWxlbWVudCwgZ2V0Tm9kZVNjcm9sbCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBpc1RvcExheWVyLCBnZXROb2RlTmFtZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzQ29udGFpbmluZ0Jsb2NrLCBpc1RhYmxlRWxlbWVudCwgZ2V0Q29udGFpbmluZ0Jsb2NrIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5leHBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudFdpbiA9IHdpbjtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB3aGlsZSAoY3VycmVudElGcmFtZSAmJiBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0V2luICE9PSBjdXJyZW50V2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudFdpbiA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKTtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG4vLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4vLyBpbmNvcnJlY3QgZm9yIFJUTC5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCwgcmVjdCkge1xuICBjb25zdCBsZWZ0U2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGxlZnRTY3JvbGw7XG4gIH1cbiAgcmV0dXJuIHJlY3QubGVmdCArIGxlZnRTY3JvbGw7XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIGlnbm9yZVNjcm9sbGJhclgpIHtcbiAgaWYgKGlnbm9yZVNjcm9sbGJhclggPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZVNjcm9sbGJhclggPSBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sUmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IGh0bWxSZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIChpZ25vcmVTY3JvbGxiYXJYID8gMCA6XG4gIC8vIFJUTCA8Ym9keT4gc2Nyb2xsYmFyLlxuICBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCwgaHRtbFJlY3QpKTtcbiAgY29uc3QgeSA9IGh0bWxSZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3A7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogZmFsc2U7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCB0cnVlKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCArIGh0bWxPZmZzZXQueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnkgKyBodG1sT2Zmc2V0LnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG4vLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlLlxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICBjb25zdCB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5LnNjcm9sbFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkuY2xpZW50SGVpZ2h0KTtcbiAgbGV0IHggPSAtc2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXNjcm9sbC5zY3JvbGxUb3A7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKSAtIHdpZHRoO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgY29uc3QgdmlzdWFsVmlld3BvcnRCYXNlZCA9IGlzV2ViS2l0KCk7XG4gICAgaWYgKCF2aXN1YWxWaWV3cG9ydEJhc2VkIHx8IHZpc3VhbFZpZXdwb3J0QmFzZWQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8vIFJldHVybnMgdGhlIGlubmVyIGNsaWVudCByZWN0LCBzdWJ0cmFjdGluZyBzY3JvbGxiYXJzIGlmIHByZXNlbnQuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgY29uc3Qgc2NhbGUgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0U2NhbGUoZWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjYWxlLng7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NhbGUueTtcbiAgY29uc3QgeCA9IGxlZnQgKiBzY2FsZS54O1xuICBjb25zdCB5ID0gdG9wICogc2NhbGUueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpIHtcbiAgbGV0IHJlY3Q7XG4gIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgcmVjdCA9IGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSk7XG4gIH0gZWxzZSBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ2RvY3VtZW50Jykge1xuICAgIHJlY3QgPSBnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgfSBlbHNlIGlmIChpc0VsZW1lbnQoY2xpcHBpbmdBbmNlc3RvcikpIHtcbiAgICByZWN0ID0gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpO1xuICAgIHJlY3QgPSB7XG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnksXG4gICAgICB3aWR0aDogY2xpcHBpbmdBbmNlc3Rvci53aWR0aCxcbiAgICAgIGhlaWdodDogY2xpcHBpbmdBbmNlc3Rvci5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBpc1RvcExheWVyKGVsZW1lbnQpID8gW10gOiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIC8vIElmIHRoZSA8Ym9keT4gc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgKGUuZy4gUlRMIHN5c3RlbXMpLiBVc2VcbiAgICAgIC8vIEZpcmVmb3ggd2l0aCBsYXlvdXQuc2Nyb2xsYmFyLnNpZGUgPSAzIGluIGFib3V0OmNvbmZpZyB0byB0ZXN0IHRoaXMuXG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCAtIGh0bWxPZmZzZXQueDtcbiAgY29uc3QgeSA9IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSAtIGh0bWxPZmZzZXQueTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYyc7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocG9seWZpbGwpIHtcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIH1cbiAgbGV0IHJhd09mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gIC8vIEZpcmVmb3ggcmV0dXJucyB0aGUgPGh0bWw+IGVsZW1lbnQgYXMgdGhlIG9mZnNldFBhcmVudCBpZiBpdCdzIG5vbi1zdGF0aWMsXG4gIC8vIHdoaWxlIENocm9tZSBhbmQgU2FmYXJpIHJldHVybiB0aGUgPGJvZHk+IGVsZW1lbnQuIFRoZSA8Ym9keT4gZWxlbWVudCBtdXN0XG4gIC8vIGJlIHVzZWQgdG8gcGVyZm9ybSB0aGUgY29ycmVjdCBjYWxjdWxhdGlvbnMgZXZlbiBpZiB0aGUgPGh0bWw+IGVsZW1lbnQgaXNcbiAgLy8gbm9uLXN0YXRpYy5cbiAgaWYgKGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSA9PT0gcmF3T2Zmc2V0UGFyZW50KSB7XG4gICAgcmF3T2Zmc2V0UGFyZW50ID0gcmF3T2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuICByZXR1cm4gcmF3T2Zmc2V0UGFyZW50O1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKGlzVG9wTGF5ZXIoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIGxldCBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIHdoaWxlIChzdmdPZmZzZXRQYXJlbnQgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KHN2Z09mZnNldFBhcmVudCkgJiYgIWlzU3RhdGljUG9zaXRpb25lZChzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBzdmdPZmZzZXRQYXJlbnQ7XG4gICAgICB9XG4gICAgICBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKHN2Z09mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aW47XG4gIH1cbiAgbGV0IG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpO1xuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgaXNMYXN0VHJhdmVyc2FibGVOb2RlKG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbjtcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgY29uc3QgZmxvYXRpbmdEaW1lbnNpb25zID0gYXdhaXQgZ2V0RGltZW5zaW9uc0ZuKGRhdGEuZmxvYXRpbmcpO1xuICByZXR1cm4ge1xuICAgIHJlZmVyZW5jZTogZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZGF0YS5yZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGRhdGEuZmxvYXRpbmcpLCBkYXRhLnN0cmF0ZWd5KSxcbiAgICBmbG9hdGluZzoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZmxvYXRpbmdEaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBmbG9hdGluZ0RpbWVuc2lvbnMuaGVpZ2h0XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gaXNSVEwoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnO1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldEVsZW1lbnRSZWN0cyxcbiAgZ2V0Q2xpZW50UmVjdHMsXG4gIGdldERpbWVuc2lvbnMsXG4gIGdldFNjYWxlLFxuICBpc0VsZW1lbnQsXG4gIGlzUlRMXG59O1xuXG5mdW5jdGlvbiByZWN0c0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEud2lkdGggPT09IGIud2lkdGggJiYgYS5oZWlnaHQgPT09IGIuaGVpZ2h0O1xufVxuXG4vLyBodHRwczovL3NhbXRob3IuYXUvMjAyMS9vYnNlcnZpbmctZG9tL1xuZnVuY3Rpb24gb2JzZXJ2ZU1vdmUoZWxlbWVudCwgb25Nb3ZlKSB7XG4gIGxldCBpbyA9IG51bGw7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGNvbnN0IHJvb3QgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgdmFyIF9pbztcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAoX2lvID0gaW8pID09IG51bGwgfHwgX2lvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbjtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIG9uTW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zZXRUb3AgPSBmbG9vcih0b3ApO1xuICAgIGNvbnN0IGluc2V0UmlnaHQgPSBmbG9vcihyb290LmNsaWVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCkpO1xuICAgIGNvbnN0IGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSk7XG4gICAgY29uc3QgaW5zZXRMZWZ0ID0gZmxvb3IobGVmdCk7XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IC1pbnNldFRvcCArIFwicHggXCIgKyAtaW5zZXRSaWdodCArIFwicHggXCIgKyAtaW5zZXRCb3R0b20gKyBcInB4IFwiICsgLWluc2V0TGVmdCArIFwicHhcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbWF4KDAsIG1pbigxLCB0aHJlc2hvbGQpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgaXNGaXJzdFVwZGF0ZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF0aW8pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGNsaXBwZWQsIHRoZSByYXRpbyBpcyAwLiBUaHJvdHRsZSB0aGUgcmVmcmVzaFxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiB1cGRhdGVzLlxuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaChmYWxzZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmF0aW8gPT09IDEgJiYgIXJlY3RzQXJlRXF1YWwoZWxlbWVudFJlY3RGb3JSb290TWFyZ2luLCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSkge1xuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZXZlbiB0aG91Z2ggdGhlIHJhdGlvIGlzIHJlcG9ydGVkIGFzIDEsIHRoZVxuICAgICAgICAvLyBlbGVtZW50IGlzIG5vdCBhY3R1YWxseSBmdWxseSB3aXRoaW4gdGhlIEludGVyc2VjdGlvbk9ic2VydmVyJ3Mgcm9vdFxuICAgICAgICAvLyBhcmVhIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiB1bmRlciBwZXJmb3JtYW5jZSBjb25zdHJhaW50cy4gVGhpcyBtYXlcbiAgICAgICAgLy8gYmUgYSBidWcgaW4gdGhlIGJyb3dzZXIncyBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbi4gVG9cbiAgICAgICAgLy8gd29yayBhcm91bmQgdGhpcywgd2UgY29tcGFyZSB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIHJlY3Qgbm93IHdpdGhcbiAgICAgICAgLy8gd2hhdCBpdCB3YXMgYXQgdGhlIHRpbWUgd2UgY3JlYXRlZCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuIElmIHRoZXlcbiAgICAgICAgLy8gYXJlIG5vdCBlcXVhbCB0aGVuIHRoZSBlbGVtZW50IG1vdmVkLCBzbyB3ZSByZWZyZXNoLlxuICAgICAgICByZWZyZXNoKCk7XG4gICAgICB9XG4gICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBhIGBkb2N1bWVudGAgYXMgdGhlIHJvb3QgYW5kIHdpbGwgdGhyb3cgYW5cbiAgICAvLyBlcnJvci5cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IHJvb3Qub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAhcmVjdHNBcmVFcXVhbChwcmV2UmVmUmVjdCwgbmV4dFJlZlJlY3QpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5jb25zdCBkZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93JDE7XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IG9mZnNldCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGF1dG9QbGFjZW1lbnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gc2hpZnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmbGlwJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IHNpemUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBoaWRlJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gYXJyb3ckMTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gaW5saW5lJDE7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBsaW1pdFNoaWZ0JDE7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH07XG4iLCJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24sIGFycm93IGFzIGFycm93JDIsIG9mZnNldCBhcyBvZmZzZXQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIGhpZGUgYXMgaGlkZSQxLCBpbmxpbmUgYXMgaW5saW5lJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCB7IGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGdldE92ZXJmbG93QW5jZXN0b3JzLCBwbGF0Zm9ybSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyBGb3JrIG9mIGBmYXN0LWRlZXAtZXF1YWxgIHRoYXQgb25seSBkb2VzIHRoZSBjb21wYXJpc29ucyB3ZSBuZWVkIGFuZCBjb21wYXJlc1xuLy8gZnVuY3Rpb25zXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGxlbmd0aDtcbiAgbGV0IGk7XG4gIGxldCBrZXlzO1xuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gJ19vd25lcicgJiYgYS4kJHR5cGVvZikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbmZ1bmN0aW9uIGdldERQUihlbGVtZW50KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGNvbnN0IHdpbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xufVxuXG5mdW5jdGlvbiByb3VuZEJ5RFBSKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRwciA9IGdldERQUihlbGVtZW50KTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkcHIpIC8gZHByO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlOiBleHRlcm5hbFJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nOiBleHRlcm5hbEZsb2F0aW5nXG4gICAgfSA9IHt9LFxuICAgIHRyYW5zZm9ybSA9IHRydWUsXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQsXG4gICAgb3BlblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBzdHJhdGVneSxcbiAgICBwbGFjZW1lbnQsXG4gICAgbWlkZGxld2FyZURhdGE6IHt9LFxuICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IFtsYXRlc3RNaWRkbGV3YXJlLCBzZXRMYXRlc3RNaWRkbGV3YXJlXSA9IFJlYWN0LnVzZVN0YXRlKG1pZGRsZXdhcmUpO1xuICBpZiAoIWRlZXBFcXVhbChsYXRlc3RNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKSkge1xuICAgIHNldExhdGVzdE1pZGRsZXdhcmUobWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgW19yZWZlcmVuY2UsIF9zZXRSZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtfZmxvYXRpbmcsIF9zZXRGbG9hdGluZ10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IHJlZmVyZW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICByZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRGbG9hdGluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSBmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICBmbG9hdGluZ1JlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRGbG9hdGluZyhub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSBleHRlcm5hbFJlZmVyZW5jZSB8fCBfcmVmZXJlbmNlO1xuICBjb25zdCBmbG9hdGluZ0VsID0gZXh0ZXJuYWxGbG9hdGluZyB8fCBfZmxvYXRpbmc7XG4gIGNvbnN0IHJlZmVyZW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZmxvYXRpbmdSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoZGF0YSk7XG4gIGNvbnN0IGhhc1doaWxlRWxlbWVudHNNb3VudGVkID0gd2hpbGVFbGVtZW50c01vdW50ZWQgIT0gbnVsbDtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZTogbGF0ZXN0TWlkZGxld2FyZVxuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbmZpZy5wbGF0Zm9ybSA9IHBsYXRmb3JtUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2VSZWYuY3VycmVudCwgZmxvYXRpbmdSZWYuY3VycmVudCwgY29uZmlnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIC8vIFRoZSBmbG9hdGluZyBlbGVtZW50J3MgcG9zaXRpb24gbWF5IGJlIHJlY29tcHV0ZWQgd2hpbGUgaXQncyBjbG9zZWRcbiAgICAgICAgLy8gYnV0IHN0aWxsIG1vdW50ZWQgKHN1Y2ggYXMgd2hlbiB0cmFuc2l0aW9uaW5nIG91dCkuIFRvIGVuc3VyZVxuICAgICAgICAvLyBgaXNQb3NpdGlvbmVkYCB3aWxsIGJlIGBmYWxzZWAgaW5pdGlhbGx5IG9uIHRoZSBuZXh0IG9wZW4sIGF2b2lkXG4gICAgICAgIC8vIHNldHRpbmcgaXQgdG8gYHRydWVgIHdoZW4gYG9wZW4gPT09IGZhbHNlYCAobXVzdCBiZSBzcGVjaWZpZWQpLlxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IG9wZW5SZWYuY3VycmVudCAhPT0gZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWRlZXBFcXVhbChkYXRhUmVmLmN1cnJlbnQsIGZ1bGxEYXRhKSkge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQgPSBmdWxsRGF0YTtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBzZXREYXRhKGZ1bGxEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsYXRlc3RNaWRkbGV3YXJlLCBwbGFjZW1lbnQsIHN0cmF0ZWd5LCBwbGF0Zm9ybVJlZiwgb3BlblJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4gPT09IGZhbHNlICYmIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgIHNldERhdGEoZGF0YSA9PiAoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChyZWZlcmVuY2VFbCkgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSByZWZlcmVuY2VFbDtcbiAgICBpZiAoZmxvYXRpbmdFbCkgZmxvYXRpbmdSZWYuY3VycmVudCA9IGZsb2F0aW5nRWw7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmIGZsb2F0aW5nRWwpIHtcbiAgICAgIGlmICh3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KHJlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUpO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9LCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSwgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYsIGhhc1doaWxlRWxlbWVudHNNb3VudGVkXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VSZWYsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nUmVmLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRGbG9hdGluZ1xuICB9KSwgW3NldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VFbCxcbiAgICBmbG9hdGluZzogZmxvYXRpbmdFbFxuICB9KSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsXSk7XG4gIGNvbnN0IGZsb2F0aW5nU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGlmICghZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3R5bGVzO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS54KTtcbiAgICBjb25zdCB5ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS55KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3R5bGVzLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIsXG4gICAgICAgIC4uLihnZXREUFIoZWxlbWVudHMuZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybSdcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5XG4gICAgfTtcbiAgfSwgW3N0cmF0ZWd5LCB0cmFuc2Zvcm0sIGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngsIGRhdGEueV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdTdHlsZXNcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIGVsZW1lbnRzLCBmbG9hdGluZ1N0eWxlc10pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3ckMSA9IG9wdGlvbnMgPT4ge1xuICBmdW5jdGlvbiBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY3VycmVudCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHBhZGRpbmdcbiAgICAgIH0gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMoc3RhdGUpIDogb3B0aW9ucztcbiAgICAgIGlmIChlbGVtZW50ICYmIGlzUmVmKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFycm93JDIoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcGFkZGluZ1xuICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLm9mZnNldCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uc2hpZnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5saW1pdFNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmZsaXAkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNpemUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uYXV0b1BsYWNlbWVudCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5oaWRlJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5pbmxpbmUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmFycm93JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUsIHVzZUZsb2F0aW5nIH07XG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9hcnJvdy9zcmMvYXJyb3cudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBOQU1FID0gXCJBcnJvd1wiO1xudmFyIEFycm93ID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCB3aWR0aCA9IDEwLCBoZWlnaHQgPSA1LCAuLi5hcnJvd1Byb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgUHJpbWl0aXZlLnN2ZyxcbiAgICB7XG4gICAgICAuLi5hcnJvd1Byb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHZpZXdCb3g6IFwiMCAwIDMwIDEwXCIsXG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIixcbiAgICAgIGNoaWxkcmVuOiBwcm9wcy5hc0NoaWxkID8gY2hpbGRyZW4gOiAvKiBAX19QVVJFX18gKi8ganN4KFwicG9seWdvblwiLCB7IHBvaW50czogXCIwLDAgMzAsMCAxNSwxMFwiIH0pXG4gICAgfVxuICApO1xufSk7XG5BcnJvdy5kaXNwbGF5TmFtZSA9IE5BTUU7XG52YXIgUm9vdCA9IEFycm93O1xuZXhwb3J0IHtcbiAgQXJyb3csXG4gIFJvb3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2Utc2l6ZS9zcmMvdXNlU2l6ZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtbGF5b3V0LWVmZmVjdFwiO1xuZnVuY3Rpb24gdXNlU2l6ZShlbGVtZW50KSB7XG4gIGNvbnN0IFtzaXplLCBzZXRTaXplXSA9IFJlYWN0LnVzZVN0YXRlKHZvaWQgMCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHNldFNpemUoeyB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCB9KTtcbiAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICBpZiAoXCJib3JkZXJCb3hTaXplXCIgaW4gZW50cnkpIHtcbiAgICAgICAgICBjb25zdCBib3JkZXJTaXplRW50cnkgPSBlbnRyeVtcImJvcmRlckJveFNpemVcIl07XG4gICAgICAgICAgY29uc3QgYm9yZGVyU2l6ZSA9IEFycmF5LmlzQXJyYXkoYm9yZGVyU2l6ZUVudHJ5KSA/IGJvcmRlclNpemVFbnRyeVswXSA6IGJvcmRlclNpemVFbnRyeTtcbiAgICAgICAgICB3aWR0aCA9IGJvcmRlclNpemVbXCJpbmxpbmVTaXplXCJdO1xuICAgICAgICAgIGhlaWdodCA9IGJvcmRlclNpemVbXCJibG9ja1NpemVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNldFNpemUoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgfSk7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgIHJldHVybiAoKSA9PiByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNpemUodm9pZCAwKTtcbiAgICB9XG4gIH0sIFtlbGVtZW50XSk7XG4gIHJldHVybiBzaXplO1xufVxuZXhwb3J0IHtcbiAgdXNlU2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9wb3BwZXIvc3JjL3BvcHBlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgdXNlRmxvYXRpbmcsXG4gIGF1dG9VcGRhdGUsXG4gIG9mZnNldCxcbiAgc2hpZnQsXG4gIGxpbWl0U2hpZnQsXG4gIGhpZGUsXG4gIGFycm93IGFzIGZsb2F0aW5nVUlhcnJvdyxcbiAgZmxpcCxcbiAgc2l6ZVxufSBmcm9tIFwiQGZsb2F0aW5nLXVpL3JlYWN0LWRvbVwiO1xuaW1wb3J0ICogYXMgQXJyb3dQcmltaXRpdmUgZnJvbSBcIkByYWRpeC11aS9yZWFjdC1hcnJvd1wiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29udGV4dFwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VTaXplIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2Utc2l6ZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU0lERV9PUFRJT05TID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xudmFyIEFMSUdOX09QVElPTlMgPSBbXCJzdGFydFwiLCBcImNlbnRlclwiLCBcImVuZFwiXTtcbnZhciBQT1BQRVJfTkFNRSA9IFwiUG9wcGVyXCI7XG52YXIgW2NyZWF0ZVBvcHBlckNvbnRleHQsIGNyZWF0ZVBvcHBlclNjb3BlXSA9IGNyZWF0ZUNvbnRleHRTY29wZShQT1BQRVJfTkFNRSk7XG52YXIgW1BvcHBlclByb3ZpZGVyLCB1c2VQb3BwZXJDb250ZXh0XSA9IGNyZWF0ZVBvcHBlckNvbnRleHQoUE9QUEVSX05BTUUpO1xudmFyIFBvcHBlciA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVQb3BwZXIsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3QgW2FuY2hvciwgc2V0QW5jaG9yXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQb3BwZXJQcm92aWRlciwgeyBzY29wZTogX19zY29wZVBvcHBlciwgYW5jaG9yLCBvbkFuY2hvckNoYW5nZTogc2V0QW5jaG9yLCBjaGlsZHJlbiB9KTtcbn07XG5Qb3BwZXIuZGlzcGxheU5hbWUgPSBQT1BQRVJfTkFNRTtcbnZhciBBTkNIT1JfTkFNRSA9IFwiUG9wcGVyQW5jaG9yXCI7XG52YXIgUG9wcGVyQW5jaG9yID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVQb3BwZXIsIHZpcnR1YWxSZWYsIC4uLmFuY2hvclByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlUG9wcGVyQ29udGV4dChBTkNIT1JfTkFNRSwgX19zY29wZVBvcHBlcik7XG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHJlZik7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnRleHQub25BbmNob3JDaGFuZ2UodmlydHVhbFJlZj8uY3VycmVudCB8fCByZWYuY3VycmVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpcnR1YWxSZWYgPyBudWxsIDogLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IC4uLmFuY2hvclByb3BzLCByZWY6IGNvbXBvc2VkUmVmcyB9KTtcbiAgfVxuKTtcblBvcHBlckFuY2hvci5kaXNwbGF5TmFtZSA9IEFOQ0hPUl9OQU1FO1xudmFyIENPTlRFTlRfTkFNRSA9IFwiUG9wcGVyQ29udGVudFwiO1xudmFyIFtQb3BwZXJDb250ZW50UHJvdmlkZXIsIHVzZUNvbnRlbnRDb250ZXh0XSA9IGNyZWF0ZVBvcHBlckNvbnRleHQoQ09OVEVOVF9OQU1FKTtcbnZhciBQb3BwZXJDb250ZW50ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBfX3Njb3BlUG9wcGVyLFxuICAgICAgc2lkZSA9IFwiYm90dG9tXCIsXG4gICAgICBzaWRlT2Zmc2V0ID0gMCxcbiAgICAgIGFsaWduID0gXCJjZW50ZXJcIixcbiAgICAgIGFsaWduT2Zmc2V0ID0gMCxcbiAgICAgIGFycm93UGFkZGluZyA9IDAsXG4gICAgICBhdm9pZENvbGxpc2lvbnMgPSB0cnVlLFxuICAgICAgY29sbGlzaW9uQm91bmRhcnkgPSBbXSxcbiAgICAgIGNvbGxpc2lvblBhZGRpbmc6IGNvbGxpc2lvblBhZGRpbmdQcm9wID0gMCxcbiAgICAgIHN0aWNreSA9IFwicGFydGlhbFwiLFxuICAgICAgaGlkZVdoZW5EZXRhY2hlZCA9IGZhbHNlLFxuICAgICAgdXBkYXRlUG9zaXRpb25TdHJhdGVneSA9IFwib3B0aW1pemVkXCIsXG4gICAgICBvblBsYWNlZCxcbiAgICAgIC4uLmNvbnRlbnRQcm9wc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlUG9wcGVyQ29udGV4dChDT05URU5UX05BTUUsIF9fc2NvcGVQb3BwZXIpO1xuICAgIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlKSA9PiBzZXRDb250ZW50KG5vZGUpKTtcbiAgICBjb25zdCBbYXJyb3csIHNldEFycm93XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGFycm93U2l6ZSA9IHVzZVNpemUoYXJyb3cpO1xuICAgIGNvbnN0IGFycm93V2lkdGggPSBhcnJvd1NpemU/LndpZHRoID8/IDA7XG4gICAgY29uc3QgYXJyb3dIZWlnaHQgPSBhcnJvd1NpemU/LmhlaWdodCA/PyAwO1xuICAgIGNvbnN0IGRlc2lyZWRQbGFjZW1lbnQgPSBzaWRlICsgKGFsaWduICE9PSBcImNlbnRlclwiID8gXCItXCIgKyBhbGlnbiA6IFwiXCIpO1xuICAgIGNvbnN0IGNvbGxpc2lvblBhZGRpbmcgPSB0eXBlb2YgY29sbGlzaW9uUGFkZGluZ1Byb3AgPT09IFwibnVtYmVyXCIgPyBjb2xsaXNpb25QYWRkaW5nUHJvcCA6IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCAuLi5jb2xsaXNpb25QYWRkaW5nUHJvcCB9O1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gQXJyYXkuaXNBcnJheShjb2xsaXNpb25Cb3VuZGFyeSkgPyBjb2xsaXNpb25Cb3VuZGFyeSA6IFtjb2xsaXNpb25Cb3VuZGFyeV07XG4gICAgY29uc3QgaGFzRXhwbGljaXRCb3VuZGFyaWVzID0gYm91bmRhcnkubGVuZ3RoID4gMDtcbiAgICBjb25zdCBkZXRlY3RPdmVyZmxvd09wdGlvbnMgPSB7XG4gICAgICBwYWRkaW5nOiBjb2xsaXNpb25QYWRkaW5nLFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LmZpbHRlcihpc05vdE51bGwpLFxuICAgICAgLy8gd2l0aCBgc3RyYXRlZ3k6ICdmaXhlZCdgLCB0aGlzIGlzIHRoZSBvbmx5IHdheSB0byBnZXQgaXQgdG8gcmVzcGVjdCBib3VuZGFyaWVzXG4gICAgICBhbHRCb3VuZGFyeTogaGFzRXhwbGljaXRCb3VuZGFyaWVzXG4gICAgfTtcbiAgICBjb25zdCB7IHJlZnMsIGZsb2F0aW5nU3R5bGVzLCBwbGFjZW1lbnQsIGlzUG9zaXRpb25lZCwgbWlkZGxld2FyZURhdGEgfSA9IHVzZUZsb2F0aW5nKHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gYGZpeGVkYCBzdHJhdGVneSBzbyB1c2VycyBkb24ndCBoYXZlIHRvIHBpY2sgYW5kIHdlIGFsc28gYXZvaWQgZm9jdXMgc2Nyb2xsIGlzc3Vlc1xuICAgICAgc3RyYXRlZ3k6IFwiZml4ZWRcIixcbiAgICAgIHBsYWNlbWVudDogZGVzaXJlZFBsYWNlbWVudCxcbiAgICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gYXV0b1VwZGF0ZSguLi5hcmdzLCB7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWU6IHVwZGF0ZVBvc2l0aW9uU3RyYXRlZ3kgPT09IFwiYWx3YXlzXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgICAgfSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogY29udGV4dC5hbmNob3JcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgIG9mZnNldCh7IG1haW5BeGlzOiBzaWRlT2Zmc2V0ICsgYXJyb3dIZWlnaHQsIGFsaWdubWVudEF4aXM6IGFsaWduT2Zmc2V0IH0pLFxuICAgICAgICBhdm9pZENvbGxpc2lvbnMgJiYgc2hpZnQoe1xuICAgICAgICAgIG1haW5BeGlzOiB0cnVlLFxuICAgICAgICAgIGNyb3NzQXhpczogZmFsc2UsXG4gICAgICAgICAgbGltaXRlcjogc3RpY2t5ID09PSBcInBhcnRpYWxcIiA/IGxpbWl0U2hpZnQoKSA6IHZvaWQgMCxcbiAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgICAgfSksXG4gICAgICAgIGF2b2lkQ29sbGlzaW9ucyAmJiBmbGlwKHsgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIH0pLFxuICAgICAgICBzaXplKHtcbiAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgYXBwbHk6ICh7IGVsZW1lbnRzLCByZWN0cywgYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoOiBhbmNob3JXaWR0aCwgaGVpZ2h0OiBhbmNob3JIZWlnaHQgfSA9IHJlY3RzLnJlZmVyZW5jZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdHlsZSA9IGVsZW1lbnRzLmZsb2F0aW5nLnN0eWxlO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLXdpZHRoXCIsIGAke2F2YWlsYWJsZVdpZHRofXB4YCk7XG4gICAgICAgICAgICBjb250ZW50U3R5bGUuc2V0UHJvcGVydHkoXCItLXJhZGl4LXBvcHBlci1hdmFpbGFibGUtaGVpZ2h0XCIsIGAke2F2YWlsYWJsZUhlaWdodH1weGApO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYW5jaG9yLXdpZHRoXCIsIGAke2FuY2hvcldpZHRofXB4YCk7XG4gICAgICAgICAgICBjb250ZW50U3R5bGUuc2V0UHJvcGVydHkoXCItLXJhZGl4LXBvcHBlci1hbmNob3ItaGVpZ2h0XCIsIGAke2FuY2hvckhlaWdodH1weGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGFycm93ICYmIGZsb2F0aW5nVUlhcnJvdyh7IGVsZW1lbnQ6IGFycm93LCBwYWRkaW5nOiBhcnJvd1BhZGRpbmcgfSksXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbih7IGFycm93V2lkdGgsIGFycm93SGVpZ2h0IH0pLFxuICAgICAgICBoaWRlV2hlbkRldGFjaGVkICYmIGhpZGUoeyBzdHJhdGVneTogXCJyZWZlcmVuY2VIaWRkZW5cIiwgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIH0pXG4gICAgICBdXG4gICAgfSk7XG4gICAgY29uc3QgW3BsYWNlZFNpZGUsIHBsYWNlZEFsaWduXSA9IGdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBoYW5kbGVQbGFjZWQgPSB1c2VDYWxsYmFja1JlZihvblBsYWNlZCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc1Bvc2l0aW9uZWQpIHtcbiAgICAgICAgaGFuZGxlUGxhY2VkPy4oKTtcbiAgICAgIH1cbiAgICB9LCBbaXNQb3NpdGlvbmVkLCBoYW5kbGVQbGFjZWRdKTtcbiAgICBjb25zdCBhcnJvd1ggPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueDtcbiAgICBjb25zdCBhcnJvd1kgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueTtcbiAgICBjb25zdCBjYW5ub3RDZW50ZXJBcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93Py5jZW50ZXJPZmZzZXQgIT09IDA7XG4gICAgY29uc3QgW2NvbnRlbnRaSW5kZXgsIHNldENvbnRlbnRaSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGNvbnRlbnQpIHNldENvbnRlbnRaSW5kZXgod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudCkuekluZGV4KTtcbiAgICB9LCBbY29udGVudF0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiByZWZzLnNldEZsb2F0aW5nLFxuICAgICAgICBcImRhdGEtcmFkaXgtcG9wcGVyLWNvbnRlbnQtd3JhcHBlclwiOiBcIlwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIC4uLmZsb2F0aW5nU3R5bGVzLFxuICAgICAgICAgIHRyYW5zZm9ybTogaXNQb3NpdGlvbmVkID8gZmxvYXRpbmdTdHlsZXMudHJhbnNmb3JtIDogXCJ0cmFuc2xhdGUoMCwgLTIwMCUpXCIsXG4gICAgICAgICAgLy8ga2VlcCBvZmYgdGhlIHBhZ2Ugd2hlbiBtZWFzdXJpbmdcbiAgICAgICAgICBtaW5XaWR0aDogXCJtYXgtY29udGVudFwiLFxuICAgICAgICAgIHpJbmRleDogY29udGVudFpJbmRleCxcbiAgICAgICAgICBbXCItLXJhZGl4LXBvcHBlci10cmFuc2Zvcm0tb3JpZ2luXCJdOiBbXG4gICAgICAgICAgICBtaWRkbGV3YXJlRGF0YS50cmFuc2Zvcm1PcmlnaW4/LngsXG4gICAgICAgICAgICBtaWRkbGV3YXJlRGF0YS50cmFuc2Zvcm1PcmlnaW4/LnlcbiAgICAgICAgICBdLmpvaW4oXCIgXCIpLFxuICAgICAgICAgIC8vIGhpZGUgdGhlIGNvbnRlbnQgaWYgdXNpbmcgdGhlIGhpZGUgbWlkZGxld2FyZSBhbmQgc2hvdWxkIGJlIGhpZGRlblxuICAgICAgICAgIC8vIHNldCB2aXNpYmlsaXR5IHRvIGhpZGRlbiBhbmQgZGlzYWJsZSBwb2ludGVyIGV2ZW50cyBzbyB0aGUgVUkgYmVoYXZlc1xuICAgICAgICAgIC8vIGFzIGlmIHRoZSBQb3BwZXJDb250ZW50IGlzbid0IHRoZXJlIGF0IGFsbFxuICAgICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLmhpZGU/LnJlZmVyZW5jZUhpZGRlbiAmJiB7XG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpcjogcHJvcHMuZGlyLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICBQb3BwZXJDb250ZW50UHJvdmlkZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2NvcGU6IF9fc2NvcGVQb3BwZXIsXG4gICAgICAgICAgICBwbGFjZWRTaWRlLFxuICAgICAgICAgICAgb25BcnJvd0NoYW5nZTogc2V0QXJyb3csXG4gICAgICAgICAgICBhcnJvd1gsXG4gICAgICAgICAgICBhcnJvd1ksXG4gICAgICAgICAgICBzaG91bGRIaWRlQXJyb3c6IGNhbm5vdENlbnRlckFycm93LFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImRhdGEtc2lkZVwiOiBwbGFjZWRTaWRlLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1hbGlnblwiOiBwbGFjZWRBbGlnbixcbiAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMsXG4gICAgICAgICAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBQb3BwZXJDb250ZW50IGhhc24ndCBiZWVuIHBsYWNlZCB5ZXQgKG5vdCBhbGwgbWVhc3VyZW1lbnRzIGRvbmUpXG4gICAgICAgICAgICAgICAgICAvLyB3ZSBwcmV2ZW50IGFuaW1hdGlvbnMgc28gdGhhdCB1c2VycydzIGFuaW1hdGlvbiBkb24ndCBraWNrIGluIHRvbyBlYXJseSByZWZlcnJpbmcgd3Jvbmcgc2lkZXNcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogIWlzUG9zaXRpb25lZCA/IFwibm9uZVwiIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblBvcHBlckNvbnRlbnQuZGlzcGxheU5hbWUgPSBDT05URU5UX05BTUU7XG52YXIgQVJST1dfTkFNRSA9IFwiUG9wcGVyQXJyb3dcIjtcbnZhciBPUFBPU0lURV9TSURFID0ge1xuICB0b3A6IFwiYm90dG9tXCIsXG4gIHJpZ2h0OiBcImxlZnRcIixcbiAgYm90dG9tOiBcInRvcFwiLFxuICBsZWZ0OiBcInJpZ2h0XCJcbn07XG52YXIgUG9wcGVyQXJyb3cgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcHBlckFycm93Mihwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGNvbnN0IHsgX19zY29wZVBvcHBlciwgLi4uYXJyb3dQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlQ29udGVudENvbnRleHQoQVJST1dfTkFNRSwgX19zY29wZVBvcHBlcik7XG4gIGNvbnN0IGJhc2VTaWRlID0gT1BQT1NJVEVfU0lERVtjb250ZW50Q29udGV4dC5wbGFjZWRTaWRlXTtcbiAgcmV0dXJuIChcbiAgICAvLyB3ZSBoYXZlIHRvIHVzZSBhbiBleHRyYSB3cmFwcGVyIGJlY2F1c2UgYFJlc2l6ZU9ic2VydmVyYCAodXNlZCBieSBgdXNlU2l6ZWApXG4gICAgLy8gZG9lc24ndCByZXBvcnQgc2l6ZSBhcyB3ZSdkIGV4cGVjdCBvbiBTVkcgZWxlbWVudHMuXG4gICAgLy8gaXQgcmVwb3J0cyB0aGVpciBib3VuZGluZyBib3ggd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIGxhcmdlc3QgcGF0aCBpbnNpZGUgdGhlIFNWRy5cbiAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgXCJzcGFuXCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogY29udGVudENvbnRleHQub25BcnJvd0NoYW5nZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIGxlZnQ6IGNvbnRlbnRDb250ZXh0LmFycm93WCxcbiAgICAgICAgICB0b3A6IGNvbnRlbnRDb250ZXh0LmFycm93WSxcbiAgICAgICAgICBbYmFzZVNpZGVdOiAwLFxuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjoge1xuICAgICAgICAgICAgdG9wOiBcIlwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiMCAwXCIsXG4gICAgICAgICAgICBib3R0b206IFwiY2VudGVyIDBcIixcbiAgICAgICAgICAgIGxlZnQ6IFwiMTAwJSAwXCJcbiAgICAgICAgICB9W2NvbnRlbnRDb250ZXh0LnBsYWNlZFNpZGVdLFxuICAgICAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICAgICAgdG9wOiBcInRyYW5zbGF0ZVkoMTAwJSlcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcInRyYW5zbGF0ZVkoNTAlKSByb3RhdGUoOTBkZWcpIHRyYW5zbGF0ZVgoLTUwJSlcIixcbiAgICAgICAgICAgIGJvdHRvbTogYHJvdGF0ZSgxODBkZWcpYCxcbiAgICAgICAgICAgIGxlZnQ6IFwidHJhbnNsYXRlWSg1MCUpIHJvdGF0ZSgtOTBkZWcpIHRyYW5zbGF0ZVgoNTAlKVwiXG4gICAgICAgICAgfVtjb250ZW50Q29udGV4dC5wbGFjZWRTaWRlXSxcbiAgICAgICAgICB2aXNpYmlsaXR5OiBjb250ZW50Q29udGV4dC5zaG91bGRIaWRlQXJyb3cgPyBcImhpZGRlblwiIDogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIEFycm93UHJpbWl0aXZlLlJvb3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uYXJyb3dQcm9wcyxcbiAgICAgICAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgLi4uYXJyb3dQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgLy8gZW5zdXJlcyB0aGUgZWxlbWVudCBjYW4gYmUgbWVhc3VyZWQgY29ycmVjdGx5IChtb3N0bHkgZm9yIGlmIFNWRylcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKVxuICApO1xufSk7XG5Qb3BwZXJBcnJvdy5kaXNwbGF5TmFtZSA9IEFSUk9XX05BTUU7XG5mdW5jdGlvbiBpc05vdE51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsO1xufVxudmFyIHRyYW5zZm9ybU9yaWdpbiA9IChvcHRpb25zKSA9PiAoe1xuICBuYW1lOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICBvcHRpb25zLFxuICBmbihkYXRhKSB7XG4gICAgY29uc3QgeyBwbGFjZW1lbnQsIHJlY3RzLCBtaWRkbGV3YXJlRGF0YSB9ID0gZGF0YTtcbiAgICBjb25zdCBjYW5ub3RDZW50ZXJBcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93Py5jZW50ZXJPZmZzZXQgIT09IDA7XG4gICAgY29uc3QgaXNBcnJvd0hpZGRlbiA9IGNhbm5vdENlbnRlckFycm93O1xuICAgIGNvbnN0IGFycm93V2lkdGggPSBpc0Fycm93SGlkZGVuID8gMCA6IG9wdGlvbnMuYXJyb3dXaWR0aDtcbiAgICBjb25zdCBhcnJvd0hlaWdodCA9IGlzQXJyb3dIaWRkZW4gPyAwIDogb3B0aW9ucy5hcnJvd0hlaWdodDtcbiAgICBjb25zdCBbcGxhY2VkU2lkZSwgcGxhY2VkQWxpZ25dID0gZ2V0U2lkZUFuZEFsaWduRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgIGNvbnN0IG5vQXJyb3dBbGlnbiA9IHsgc3RhcnQ6IFwiMCVcIiwgY2VudGVyOiBcIjUwJVwiLCBlbmQ6IFwiMTAwJVwiIH1bcGxhY2VkQWxpZ25dO1xuICAgIGNvbnN0IGFycm93WENlbnRlciA9IChtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueCA/PyAwKSArIGFycm93V2lkdGggLyAyO1xuICAgIGNvbnN0IGFycm93WUNlbnRlciA9IChtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueSA/PyAwKSArIGFycm93SGVpZ2h0IC8gMjtcbiAgICBsZXQgeCA9IFwiXCI7XG4gICAgbGV0IHkgPSBcIlwiO1xuICAgIGlmIChwbGFjZWRTaWRlID09PSBcImJvdHRvbVwiKSB7XG4gICAgICB4ID0gaXNBcnJvd0hpZGRlbiA/IG5vQXJyb3dBbGlnbiA6IGAke2Fycm93WENlbnRlcn1weGA7XG4gICAgICB5ID0gYCR7LWFycm93SGVpZ2h0fXB4YDtcbiAgICB9IGVsc2UgaWYgKHBsYWNlZFNpZGUgPT09IFwidG9wXCIpIHtcbiAgICAgIHggPSBpc0Fycm93SGlkZGVuID8gbm9BcnJvd0FsaWduIDogYCR7YXJyb3dYQ2VudGVyfXB4YDtcbiAgICAgIHkgPSBgJHtyZWN0cy5mbG9hdGluZy5oZWlnaHQgKyBhcnJvd0hlaWdodH1weGA7XG4gICAgfSBlbHNlIGlmIChwbGFjZWRTaWRlID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHggPSBgJHstYXJyb3dIZWlnaHR9cHhgO1xuICAgICAgeSA9IGlzQXJyb3dIaWRkZW4gPyBub0Fycm93QWxpZ24gOiBgJHthcnJvd1lDZW50ZXJ9cHhgO1xuICAgIH0gZWxzZSBpZiAocGxhY2VkU2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHggPSBgJHtyZWN0cy5mbG9hdGluZy53aWR0aCArIGFycm93SGVpZ2h0fXB4YDtcbiAgICAgIHkgPSBpc0Fycm93SGlkZGVuID8gbm9BcnJvd0FsaWduIDogYCR7YXJyb3dZQ2VudGVyfXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogeyB4LCB5IH0gfTtcbiAgfVxufSk7XG5mdW5jdGlvbiBnZXRTaWRlQW5kQWxpZ25Gcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICBjb25zdCBbc2lkZSwgYWxpZ24gPSBcImNlbnRlclwiXSA9IHBsYWNlbWVudC5zcGxpdChcIi1cIik7XG4gIHJldHVybiBbc2lkZSwgYWxpZ25dO1xufVxudmFyIFJvb3QyID0gUG9wcGVyO1xudmFyIEFuY2hvciA9IFBvcHBlckFuY2hvcjtcbnZhciBDb250ZW50ID0gUG9wcGVyQ29udGVudDtcbnZhciBBcnJvdyA9IFBvcHBlckFycm93O1xuZXhwb3J0IHtcbiAgQUxJR05fT1BUSU9OUyxcbiAgQW5jaG9yLFxuICBBcnJvdyxcbiAgQ29udGVudCxcbiAgUG9wcGVyLFxuICBQb3BwZXJBbmNob3IsXG4gIFBvcHBlckFycm93LFxuICBQb3BwZXJDb250ZW50LFxuICBSb290MiBhcyBSb290LFxuICBTSURFX09QVElPTlMsXG4gIGNyZWF0ZVBvcHBlclNjb3BlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L3BvcnRhbC9zcmMvcG9ydGFsLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFBPUlRBTF9OQU1FID0gXCJQb3J0YWxcIjtcbnZhciBQb3J0YWwgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgY29udGFpbmVyOiBjb250YWluZXJQcm9wLCAuLi5wb3J0YWxQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHNldE1vdW50ZWQodHJ1ZSksIFtdKTtcbiAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUHJvcCB8fCBtb3VudGVkICYmIGdsb2JhbFRoaXM/LmRvY3VtZW50Py5ib2R5O1xuICByZXR1cm4gY29udGFpbmVyID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyAuLi5wb3J0YWxQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSksIGNvbnRhaW5lcikgOiBudWxsO1xufSk7XG5Qb3J0YWwuZGlzcGxheU5hbWUgPSBQT1JUQUxfTkFNRTtcbnZhciBSb290ID0gUG9ydGFsO1xuZXhwb3J0IHtcbiAgUG9ydGFsLFxuICBSb290XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLWNvbnRyb2xsYWJsZS1zdGF0ZS9zcmMvdXNlQ29udHJvbGxhYmxlU3RhdGUudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5mdW5jdGlvbiB1c2VDb250cm9sbGFibGVTdGF0ZSh7XG4gIHByb3AsXG4gIGRlZmF1bHRQcm9wLFxuICBvbkNoYW5nZSA9ICgpID0+IHtcbiAgfVxufSkge1xuICBjb25zdCBbdW5jb250cm9sbGVkUHJvcCwgc2V0VW5jb250cm9sbGVkUHJvcF0gPSB1c2VVbmNvbnRyb2xsZWRTdGF0ZSh7IGRlZmF1bHRQcm9wLCBvbkNoYW5nZSB9KTtcbiAgY29uc3QgaXNDb250cm9sbGVkID0gcHJvcCAhPT0gdm9pZCAwO1xuICBjb25zdCB2YWx1ZSA9IGlzQ29udHJvbGxlZCA/IHByb3AgOiB1bmNvbnRyb2xsZWRQcm9wO1xuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFja1JlZihvbkNoYW5nZSk7XG4gIGNvbnN0IHNldFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5leHRWYWx1ZSkgPT4ge1xuICAgICAgaWYgKGlzQ29udHJvbGxlZCkge1xuICAgICAgICBjb25zdCBzZXR0ZXIgPSBuZXh0VmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHR5cGVvZiBuZXh0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHNldHRlcihwcm9wKSA6IG5leHRWYWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlMiAhPT0gcHJvcCkgaGFuZGxlQ2hhbmdlKHZhbHVlMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRVbmNvbnRyb2xsZWRQcm9wKG5leHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbaXNDb250cm9sbGVkLCBwcm9wLCBzZXRVbmNvbnRyb2xsZWRQcm9wLCBoYW5kbGVDaGFuZ2VdXG4gICk7XG4gIHJldHVybiBbdmFsdWUsIHNldFZhbHVlXTtcbn1cbmZ1bmN0aW9uIHVzZVVuY29udHJvbGxlZFN0YXRlKHtcbiAgZGVmYXVsdFByb3AsXG4gIG9uQ2hhbmdlXG59KSB7XG4gIGNvbnN0IHVuY29udHJvbGxlZFN0YXRlID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFByb3ApO1xuICBjb25zdCBbdmFsdWVdID0gdW5jb250cm9sbGVkU3RhdGU7XG4gIGNvbnN0IHByZXZWYWx1ZVJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrUmVmKG9uQ2hhbmdlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJldlZhbHVlUmVmLmN1cnJlbnQgIT09IHZhbHVlKSB7XG4gICAgICBoYW5kbGVDaGFuZ2UodmFsdWUpO1xuICAgICAgcHJldlZhbHVlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIFt2YWx1ZSwgcHJldlZhbHVlUmVmLCBoYW5kbGVDaGFuZ2VdKTtcbiAgcmV0dXJuIHVuY29udHJvbGxlZFN0YXRlO1xufVxuZXhwb3J0IHtcbiAgdXNlQ29udHJvbGxhYmxlU3RhdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtcHJldmlvdXMvc3JjL3VzZVByZXZpb3VzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoeyB2YWx1ZSwgcHJldmlvdXM6IHZhbHVlIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50LnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmVmLmN1cnJlbnQucHJldmlvdXMgPSByZWYuY3VycmVudC52YWx1ZTtcbiAgICAgIHJlZi5jdXJyZW50LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudC5wcmV2aW91cztcbiAgfSwgW3ZhbHVlXSk7XG59XG5leHBvcnQge1xuICB1c2VQcmV2aW91c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3Zpc3VhbGx5LWhpZGRlbi9zcmMvdmlzdWFsbHktaGlkZGVuLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTkFNRSA9IFwiVmlzdWFsbHlIaWRkZW5cIjtcbnZhciBWaXN1YWxseUhpZGRlbiA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuc3BhbixcbiAgICAgIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9zY3NzL21peGlucy9fdmlzdWFsbHktaGlkZGVuLnNjc3NcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICBtYXJnaW46IC0xLFxuICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgIGNsaXA6IFwicmVjdCgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsXG4gICAgICAgICAgLi4ucHJvcHMuc3R5bGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5WaXN1YWxseUhpZGRlbi5kaXNwbGF5TmFtZSA9IE5BTUU7XG52YXIgUm9vdCA9IFZpc3VhbGx5SGlkZGVuO1xuZXhwb3J0IHtcbiAgUm9vdCxcbiAgVmlzdWFsbHlIaWRkZW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgZ2V0RGVmYXVsdFBhcmVudCA9IGZ1bmN0aW9uIChvcmlnaW5hbFRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc2FtcGxlVGFyZ2V0ID0gQXJyYXkuaXNBcnJheShvcmlnaW5hbFRhcmdldCkgPyBvcmlnaW5hbFRhcmdldFswXSA6IG9yaWdpbmFsVGFyZ2V0O1xuICAgIHJldHVybiBzYW1wbGVUYXJnZXQub3duZXJEb2N1bWVudC5ib2R5O1xufTtcbnZhciBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciB1bmNvbnRyb2xsZWROb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgbWFya2VyTWFwID0ge307XG52YXIgbG9ja0NvdW50ID0gMDtcbnZhciB1bndyYXBIb3N0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5ob3N0IHx8IHVud3JhcEhvc3Qobm9kZS5wYXJlbnROb2RlKSk7XG59O1xudmFyIGNvcnJlY3RUYXJnZXRzID0gZnVuY3Rpb24gKHBhcmVudCwgdGFyZ2V0cykge1xuICAgIHJldHVybiB0YXJnZXRzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAocGFyZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvcnJlY3RlZFRhcmdldCA9IHVud3JhcEhvc3QodGFyZ2V0KTtcbiAgICAgICAgaWYgKGNvcnJlY3RlZFRhcmdldCAmJiBwYXJlbnQuY29udGFpbnMoY29ycmVjdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKCdhcmlhLWhpZGRlbicsIHRhcmdldCwgJ2luIG5vdCBjb250YWluZWQgaW5zaWRlJywgcGFyZW50LCAnLiBEb2luZyBub3RoaW5nJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIEJvb2xlYW4oeCk7IH0pO1xufTtcbi8qKlxuICogTWFya3MgZXZlcnl0aGluZyBleGNlcHQgZ2l2ZW4gbm9kZShvciBub2RlcykgYXMgYXJpYS1oaWRkZW5cbiAqIEBwYXJhbSB7RWxlbWVudCB8IEVsZW1lbnRbXX0gb3JpZ2luYWxUYXJnZXQgLSBlbGVtZW50cyB0byBrZWVwIG9uIHRoZSBwYWdlXG4gKiBAcGFyYW0gW3BhcmVudE5vZGVdIC0gdG9wIGVsZW1lbnQsIGRlZmF1bHRzIHRvIGRvY3VtZW50LmJvZHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWFya2VyTmFtZV0gLSBhIHNwZWNpYWwgYXR0cmlidXRlIHRvIG1hcmsgZXZlcnkgbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IFtjb250cm9sQXR0cmlidXRlXSAtIGh0bWwgQXR0cmlidXRlIHRvIGNvbnRyb2xcbiAqIEByZXR1cm4ge1VuZG99IHVuZG8gY29tbWFuZFxuICovXG52YXIgYXBwbHlBdHRyaWJ1dGVUb090aGVycyA9IGZ1bmN0aW9uIChvcmlnaW5hbFRhcmdldCwgcGFyZW50Tm9kZSwgbWFya2VyTmFtZSwgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXRzID0gY29ycmVjdFRhcmdldHMocGFyZW50Tm9kZSwgQXJyYXkuaXNBcnJheShvcmlnaW5hbFRhcmdldCkgPyBvcmlnaW5hbFRhcmdldCA6IFtvcmlnaW5hbFRhcmdldF0pO1xuICAgIGlmICghbWFya2VyTWFwW21hcmtlck5hbWVdKSB7XG4gICAgICAgIG1hcmtlck1hcFttYXJrZXJOYW1lXSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHZhciBtYXJrZXJDb3VudGVyID0gbWFya2VyTWFwW21hcmtlck5hbWVdO1xuICAgIHZhciBoaWRkZW5Ob2RlcyA9IFtdO1xuICAgIHZhciBlbGVtZW50c1RvS2VlcCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZWxlbWVudHNUb1N0b3AgPSBuZXcgU2V0KHRhcmdldHMpO1xuICAgIHZhciBrZWVwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmICghZWwgfHwgZWxlbWVudHNUb0tlZXAuaGFzKGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzVG9LZWVwLmFkZChlbCk7XG4gICAgICAgIGtlZXAoZWwucGFyZW50Tm9kZSk7XG4gICAgfTtcbiAgICB0YXJnZXRzLmZvckVhY2goa2VlcCk7XG4gICAgdmFyIGRlZXAgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIGlmICghcGFyZW50IHx8IGVsZW1lbnRzVG9TdG9wLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChwYXJlbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHNUb0tlZXAuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgZGVlcChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlck1hcC5zZXQobm9kZSwgY291bnRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ291bnRlci5zZXQobm9kZSwgbWFya2VyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5Ob2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclZhbHVlID09PSAxICYmIGFscmVhZHlIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY29udHJvbGxlZE5vZGVzLnNldChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyVmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG1hcmtlck5hbWUsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FyaWEtaGlkZGVuOiBjYW5ub3Qgb3BlcmF0ZSBvbiAnLCBub2RlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZGVlcChwYXJlbnROb2RlKTtcbiAgICBlbGVtZW50c1RvS2VlcC5jbGVhcigpO1xuICAgIGxvY2tDb3VudCsrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGRlbk5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjb3VudGVyVmFsdWUgPSBjb3VudGVyTWFwLmdldChub2RlKSAtIDE7XG4gICAgICAgICAgICB2YXIgbWFya2VyVmFsdWUgPSBtYXJrZXJDb3VudGVyLmdldChub2RlKSAtIDE7XG4gICAgICAgICAgICBjb3VudGVyTWFwLnNldChub2RlLCBjb3VudGVyVmFsdWUpO1xuICAgICAgICAgICAgbWFya2VyQ291bnRlci5zZXQobm9kZSwgbWFya2VyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFjb3VudGVyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVuY29udHJvbGxlZE5vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5jb250cm9sbGVkTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG1hcmtlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbG9ja0NvdW50LS07XG4gICAgICAgIGlmICghbG9ja0NvdW50KSB7XG4gICAgICAgICAgICAvLyBjbGVhclxuICAgICAgICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIHVuY29udHJvbGxlZE5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIG1hcmtlck1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIE1hcmtzIGV2ZXJ5dGhpbmcgZXhjZXB0IGdpdmVuIG5vZGUob3Igbm9kZXMpIGFzIGFyaWEtaGlkZGVuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBFbGVtZW50W119IG9yaWdpbmFsVGFyZ2V0IC0gZWxlbWVudHMgdG8ga2VlcCBvbiB0aGUgcGFnZVxuICogQHBhcmFtIFtwYXJlbnROb2RlXSAtIHRvcCBlbGVtZW50LCBkZWZhdWx0cyB0byBkb2N1bWVudC5ib2R5XG4gKiBAcGFyYW0ge1N0cmluZ30gW21hcmtlck5hbWVdIC0gYSBzcGVjaWFsIGF0dHJpYnV0ZSB0byBtYXJrIGV2ZXJ5IG5vZGVcbiAqIEByZXR1cm4ge1VuZG99IHVuZG8gY29tbWFuZFxuICovXG5leHBvcnQgdmFyIGhpZGVPdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpIHtcbiAgICBpZiAobWFya2VyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcmtlck5hbWUgPSAnZGF0YS1hcmlhLWhpZGRlbic7IH1cbiAgICB2YXIgdGFyZ2V0cyA9IEFycmF5LmZyb20oQXJyYXkuaXNBcnJheShvcmlnaW5hbFRhcmdldCkgPyBvcmlnaW5hbFRhcmdldCA6IFtvcmlnaW5hbFRhcmdldF0pO1xuICAgIHZhciBhY3RpdmVQYXJlbnROb2RlID0gcGFyZW50Tm9kZSB8fCBnZXREZWZhdWx0UGFyZW50KG9yaWdpbmFsVGFyZ2V0KTtcbiAgICBpZiAoIWFjdGl2ZVBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgfVxuICAgIC8vIHdlIHNob3VsZCBub3QgaGlkZSBhcmlhTGl2ZSBlbGVtZW50cyAtIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvYXJpYS1oaWRkZW4vaXNzdWVzLzEwXG4gICAgdGFyZ2V0cy5wdXNoLmFwcGx5KHRhcmdldHMsIEFycmF5LmZyb20oYWN0aXZlUGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1saXZlXScpKSk7XG4gICAgcmV0dXJuIGFwcGx5QXR0cmlidXRlVG9PdGhlcnModGFyZ2V0cywgYWN0aXZlUGFyZW50Tm9kZSwgbWFya2VyTmFtZSwgJ2FyaWEtaGlkZGVuJyk7XG59O1xuLyoqXG4gKiBNYXJrcyBldmVyeXRoaW5nIGV4Y2VwdCBnaXZlbiBub2RlKG9yIG5vZGVzKSBhcyBpbmVydFxuICogQHBhcmFtIHtFbGVtZW50IHwgRWxlbWVudFtdfSBvcmlnaW5hbFRhcmdldCAtIGVsZW1lbnRzIHRvIGtlZXAgb24gdGhlIHBhZ2VcbiAqIEBwYXJhbSBbcGFyZW50Tm9kZV0gLSB0b3AgZWxlbWVudCwgZGVmYXVsdHMgdG8gZG9jdW1lbnQuYm9keVxuICogQHBhcmFtIHtTdHJpbmd9IFttYXJrZXJOYW1lXSAtIGEgc3BlY2lhbCBhdHRyaWJ1dGUgdG8gbWFyayBldmVyeSBub2RlXG4gKiBAcmV0dXJuIHtVbmRvfSB1bmRvIGNvbW1hbmRcbiAqL1xuZXhwb3J0IHZhciBpbmVydE90aGVycyA9IGZ1bmN0aW9uIChvcmlnaW5hbFRhcmdldCwgcGFyZW50Tm9kZSwgbWFya2VyTmFtZSkge1xuICAgIGlmIChtYXJrZXJOYW1lID09PSB2b2lkIDApIHsgbWFya2VyTmFtZSA9ICdkYXRhLWluZXJ0LWVkJzsgfVxuICAgIHZhciBhY3RpdmVQYXJlbnROb2RlID0gcGFyZW50Tm9kZSB8fCBnZXREZWZhdWx0UGFyZW50KG9yaWdpbmFsVGFyZ2V0KTtcbiAgICBpZiAoIWFjdGl2ZVBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgfVxuICAgIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKG9yaWdpbmFsVGFyZ2V0LCBhY3RpdmVQYXJlbnROb2RlLCBtYXJrZXJOYW1lLCAnaW5lcnQnKTtcbn07XG4vKipcbiAqIEByZXR1cm5zIGlmIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBpbmVydFxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSW5lcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpO1xufTtcbi8qKlxuICogQXV0b21hdGljIGZ1bmN0aW9uIHRvIFwic3VwcHJlc3NcIiBET00gZWxlbWVudHMgLSBfaGlkZV8gb3IgX2luZXJ0XyBpbiB0aGUgYmVzdCBwb3NzaWJsZSB3YXlcbiAqIEBwYXJhbSB7RWxlbWVudCB8IEVsZW1lbnRbXX0gb3JpZ2luYWxUYXJnZXQgLSBlbGVtZW50cyB0byBrZWVwIG9uIHRoZSBwYWdlXG4gKiBAcGFyYW0gW3BhcmVudE5vZGVdIC0gdG9wIGVsZW1lbnQsIGRlZmF1bHRzIHRvIGRvY3VtZW50LmJvZHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWFya2VyTmFtZV0gLSBhIHNwZWNpYWwgYXR0cmlidXRlIHRvIG1hcmsgZXZlcnkgbm9kZVxuICogQHJldHVybiB7VW5kb30gdW5kbyBjb21tYW5kXG4gKi9cbmV4cG9ydCB2YXIgc3VwcHJlc3NPdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpIHtcbiAgICBpZiAobWFya2VyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcmtlck5hbWUgPSAnZGF0YS1zdXBwcmVzc2VkJzsgfVxuICAgIHJldHVybiAoc3VwcG9ydHNJbmVydCgpID8gaW5lcnRPdGhlcnMgOiBoaWRlT3RoZXJzKShvcmlnaW5hbFRhcmdldCwgcGFyZW50Tm9kZSwgbWFya2VyTmFtZSk7XG59O1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbnZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgYXIgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgIHJldHVybiBhcjtcbiAgfTtcbiAgcmV0dXJuIG93bktleXMobyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgIGlmIChhc3luYykgaW5uZXIgPSBkaXNwb3NlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRyeSB7IGlubmVyLmNhbGwodGhpcyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9IH07XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIHZhciByLCBzID0gMDtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG4gICAgICAgIGlmIChyLmRpc3Bvc2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gci5kaXNwb3NlLmNhbGwoci52YWx1ZSk7XG4gICAgICAgICAgaWYgKHIuYXN5bmMpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgfD0gMTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzID09PSAxKSByZXR1cm4gZW52Lmhhc0Vycm9yID8gUHJvbWlzZS5yZWplY3QoZW52LmVycm9yKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiICYmIC9eXFwuXFwuP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuKHRzeCkkfCgoPzpcXC5kKT8pKCg/OlxcLlteLi9dKz8pPylcXC4oW2NtXT8pdHMkL2ksIGZ1bmN0aW9uIChtLCB0c3gsIGQsIGV4dCwgY20pIHtcbiAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX2VzRGVjb3JhdGUsXG4gIF9fcnVuSW5pdGlhbGl6ZXJzLFxuICBfX3Byb3BLZXksXG4gIF9fc2V0RnVuY3Rpb25OYW1lLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbiAgX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXG59O1xuIiwiZXhwb3J0IHZhciB6ZXJvUmlnaHRDbGFzc05hbWUgPSAncmlnaHQtc2Nyb2xsLWJhci1wb3NpdGlvbic7XG5leHBvcnQgdmFyIGZ1bGxXaWR0aENsYXNzTmFtZSA9ICd3aWR0aC1iZWZvcmUtc2Nyb2xsLWJhcic7XG5leHBvcnQgdmFyIG5vU2Nyb2xsYmFyc0NsYXNzTmFtZSA9ICd3aXRoLXNjcm9sbC1iYXJzLWhpZGRlbic7XG4vKipcbiAqIE5hbWUgb2YgYSBDU1MgdmFyaWFibGUgY29udGFpbmluZyB0aGUgYW1vdW50IG9mIFwiaGlkZGVuXCIgc2Nyb2xsYmFyXG4gKiAhIG1pZ2h0IGJlIHVuZGVmaW5lZCAhIHVzZSB3aWxsIGZhbGxiYWNrIVxuICovXG5leHBvcnQgdmFyIHJlbW92ZWRCYXJTaXplVmFyaWFibGUgPSAnLS1yZW1vdmVkLWJvZHktc2Nyb2xsLWJhci1zaXplJztcbiIsIi8qKlxuICogQXNzaWducyBhIHZhbHVlIGZvciBhIGdpdmVuIHJlZiwgbm8gbWF0dGVyIG9mIHRoZSByZWYgZm9ybWF0XG4gKiBAcGFyYW0ge1JlZk9iamVjdH0gcmVmIC0gYSBjYWxsYmFjayBmdW5jdGlvbiBvciByZWYgb2JqZWN0XG4gKiBAcGFyYW0gdmFsdWUgLSBhIG5ldyB2YWx1ZVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS91c2UtY2FsbGJhY2stcmVmI2Fzc2lnbnJlZlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlZk9iamVjdCA9IHVzZVJlZigpO1xuICogY29uc3QgcmVmRm4gPSAocmVmKSA9PiB7Li4uLn1cbiAqXG4gKiBhc3NpZ25SZWYocmVmT2JqZWN0LCBcInJlZlZhbHVlXCIpO1xuICogYXNzaWduUmVmKHJlZkZuLCBcInJlZlZhbHVlXCIpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduUmVmKHJlZiwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbiIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBjcmVhdGVzIGEgTXV0YWJsZVJlZiB3aXRoIHJlZiBjaGFuZ2UgY2FsbGJhY2tcbiAqIEBwYXJhbSBpbml0aWFsVmFsdWUgLSBpbml0aWFsIHJlZiB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBhIGNhbGxiYWNrIHRvIHJ1biB3aGVuIHZhbHVlIGNoYW5nZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcmVmID0gdXNlQ2FsbGJhY2tSZWYoMCwgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4gY29uc29sZS5sb2cob2xkVmFsdWUsICctPicsIG5ld1ZhbHVlKTtcbiAqIHJlZi5jdXJyZW50ID0gMTtcbiAqIC8vIHByaW50cyAwIC0+IDFcbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCN1c2VyZWZcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS91c2UtY2FsbGJhY2stcmVmI3VzZWNhbGxiYWNrcmVmLS0tdG8tcmVwbGFjZS1yZWFjdHVzZXJlZlxuICogQHJldHVybnMge011dGFibGVSZWZPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFja1JlZihpbml0aWFsVmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlZiA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIC8vIHZhbHVlXG4gICAgICAgIHZhbHVlOiBpbml0aWFsVmFsdWUsXG4gICAgICAgIC8vIGxhc3QgY2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAvLyBcIm1lbW9pemVkXCIgcHVibGljIGludGVyZmFjZVxuICAgICAgICBmYWNhZGU6IHtcbiAgICAgICAgICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWYudmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IGN1cnJlbnQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5jYWxsYmFjayh2YWx1ZSwgbGFzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTsgfSlbMF07XG4gICAgLy8gdXBkYXRlIGNhbGxiYWNrXG4gICAgcmVmLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHJlZi5mYWNhZGU7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ25SZWYgfSBmcm9tICcuL2Fzc2lnblJlZic7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gJy4vdXNlUmVmJztcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgY3VycmVudFZhbHVlcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIE1lcmdlcyB0d28gb3IgbW9yZSByZWZzIHRvZ2V0aGVyIHByb3ZpZGluZyBhIHNpbmdsZSBpbnRlcmZhY2UgdG8gc2V0IHRoZWlyIHZhbHVlXG4gKiBAcGFyYW0ge1JlZk9iamVjdHxSZWZ9IHJlZnNcbiAqIEByZXR1cm5zIHtNdXRhYmxlUmVmT2JqZWN0fSAtIGEgbmV3IHJlZiwgd2hpY2ggdHJhbnNsYXRlcyBhbGwgY2hhbmdlcyB0byB7cmVmc31cbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZVJlZnN9IGEgdmVyc2lvbiB3aXRob3V0IGJ1aXQtaW4gbWVtb2l6YXRpb25cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS91c2UtY2FsbGJhY2stcmVmI3VzZW1lcmdlcmVmc1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IENvbXBvbmVudCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAqICAgY29uc3Qgb3duUmVmID0gdXNlUmVmKCk7XG4gKiAgIGNvbnN0IGRvbVJlZiA9IHVzZU1lcmdlUmVmcyhbcmVmLCBvd25SZWZdKTsgLy8g8J+RiCBtZXJnZSB0b2dldGhlclxuICogICByZXR1cm4gPGRpdiByZWY9e2RvbVJlZn0+Li4uPC9kaXY+XG4gKiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcywgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2tSZWYoZGVmYXVsdFZhbHVlIHx8IG51bGwsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIGFzc2lnblJlZihyZWYsIG5ld1ZhbHVlKTsgfSk7XG4gICAgfSk7XG4gICAgLy8gaGFuZGxlIHJlZnMgY2hhbmdlcyAtIGFkZGVkIG9yIHJlbW92ZWRcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gY3VycmVudFZhbHVlcy5nZXQoY2FsbGJhY2tSZWYpO1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UmVmc18xID0gbmV3IFNldChvbGRWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgbmV4dFJlZnNfMSA9IG5ldyBTZXQocmVmcyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudF8xID0gY2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHByZXZSZWZzXzEuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVmc18xLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnblJlZihyZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFJlZnNfMS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZSZWZzXzEuaGFzKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduUmVmKHJlZiwgY3VycmVudF8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VmFsdWVzLnNldChjYWxsYmFja1JlZiwgcmVmcyk7XG4gICAgfSwgW3JlZnNdKTtcbiAgICByZXR1cm4gY2FsbGJhY2tSZWY7XG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuZnVuY3Rpb24gSXRvSShhKSB7XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBpbm5lckNyZWF0ZU1lZGl1bShkZWZhdWx0cywgbWlkZGxld2FyZSkge1xuICAgIGlmIChtaWRkbGV3YXJlID09PSB2b2lkIDApIHsgbWlkZGxld2FyZSA9IEl0b0k7IH1cbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIGFzc2lnbmVkID0gZmFsc2U7XG4gICAgdmFyIG1lZGl1bSA9IHtcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFzc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWRlY2FyOiBjb3VsZCBub3QgYHJlYWRgIGZyb20gYW4gYGFzc2lnbmVkYCBtZWRpdW0uIGByZWFkYCBjb3VsZCBiZSB1c2VkIG9ubHkgd2l0aCBgdXNlTWVkaXVtYC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lZGl1bTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbWlkZGxld2FyZShkYXRhLCBhc3NpZ25lZCk7XG4gICAgICAgICAgICBidWZmZXIucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gaXRlbTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhc3NpZ25TeW5jTWVkaXVtOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNicyA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBjYnMuZm9yRWFjaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSB7XG4gICAgICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGNiKHgpOyB9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXNzaWduTWVkaXVtOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBwZW5kaW5nUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNicyA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBjYnMuZm9yRWFjaChjYik7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1F1ZXVlID0gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4ZWN1dGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2JzID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGNicy5mb3JFYWNoKGNiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3ljbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGV4ZWN1dGVRdWV1ZSk7IH07XG4gICAgICAgICAgICBjeWNsZSgpO1xuICAgICAgICAgICAgYnVmZmVyID0ge1xuICAgICAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKHgpO1xuICAgICAgICAgICAgICAgICAgICBjeWNsZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IHBlbmRpbmdRdWV1ZS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBtZWRpdW07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVkaXVtKGRlZmF1bHRzLCBtaWRkbGV3YXJlKSB7XG4gICAgaWYgKG1pZGRsZXdhcmUgPT09IHZvaWQgMCkgeyBtaWRkbGV3YXJlID0gSXRvSTsgfVxuICAgIHJldHVybiBpbm5lckNyZWF0ZU1lZGl1bShkZWZhdWx0cywgbWlkZGxld2FyZSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNpZGVjYXJNZWRpdW0ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG1lZGl1bSA9IGlubmVyQ3JlYXRlTWVkaXVtKG51bGwpO1xuICAgIG1lZGl1bS5vcHRpb25zID0gX19hc3NpZ24oeyBhc3luYzogdHJ1ZSwgc3NyOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gbWVkaXVtO1xufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xudmFyIFNpZGVDYXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgc2lkZUNhciA9IF9hLnNpZGVDYXIsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInNpZGVDYXJcIl0pO1xuICAgIGlmICghc2lkZUNhcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZGVjYXI6IHBsZWFzZSBwcm92aWRlIGBzaWRlQ2FyYCBwcm9wZXJ0eSB0byBpbXBvcnQgdGhlIHJpZ2h0IGNhcicpO1xuICAgIH1cbiAgICB2YXIgVGFyZ2V0ID0gc2lkZUNhci5yZWFkKCk7XG4gICAgaWYgKCFUYXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWRlY2FyIG1lZGl1bSBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFyZ2V0LCBfX2Fzc2lnbih7fSwgcmVzdCkpO1xufTtcblNpZGVDYXIuaXNTaWRlQ2FyRXhwb3J0ID0gdHJ1ZTtcbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRTaWRlY2FyKG1lZGl1bSwgZXhwb3J0ZWQpIHtcbiAgICBtZWRpdW0udXNlTWVkaXVtKGV4cG9ydGVkKTtcbiAgICByZXR1cm4gU2lkZUNhcjtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVNpZGVjYXJNZWRpdW0gfSBmcm9tICd1c2Utc2lkZWNhcic7XG5leHBvcnQgdmFyIGVmZmVjdENhciA9IGNyZWF0ZVNpZGVjYXJNZWRpdW0oKTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZ1bGxXaWR0aENsYXNzTmFtZSwgemVyb1JpZ2h0Q2xhc3NOYW1lIH0gZnJvbSAncmVhY3QtcmVtb3ZlLXNjcm9sbC1iYXIvY29uc3RhbnRzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJ3VzZS1jYWxsYmFjay1yZWYnO1xuaW1wb3J0IHsgZWZmZWN0Q2FyIH0gZnJvbSAnLi9tZWRpdW0nO1xudmFyIG5vdGhpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xufTtcbi8qKlxuICogUmVtb3ZlcyBzY3JvbGxiYXIgZnJvbSB0aGUgcGFnZSBhbmQgY29udGFpbiB0aGUgc2Nyb2xsIHdpdGhpbiB0aGUgTG9ja1xuICovXG52YXIgUmVtb3ZlU2Nyb2xsID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHBhcmVudFJlZikge1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoe1xuICAgICAgICBvblNjcm9sbENhcHR1cmU6IG5vdGhpbmcsXG4gICAgICAgIG9uV2hlZWxDYXB0dXJlOiBub3RoaW5nLFxuICAgICAgICBvblRvdWNoTW92ZUNhcHR1cmU6IG5vdGhpbmcsXG4gICAgfSksIGNhbGxiYWNrcyA9IF9hWzBdLCBzZXRDYWxsYmFja3MgPSBfYVsxXTtcbiAgICB2YXIgZm9yd2FyZFByb3BzID0gcHJvcHMuZm9yd2FyZFByb3BzLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIHJlbW92ZVNjcm9sbEJhciA9IHByb3BzLnJlbW92ZVNjcm9sbEJhciwgZW5hYmxlZCA9IHByb3BzLmVuYWJsZWQsIHNoYXJkcyA9IHByb3BzLnNoYXJkcywgc2lkZUNhciA9IHByb3BzLnNpZGVDYXIsIG5vSXNvbGF0aW9uID0gcHJvcHMubm9Jc29sYXRpb24sIGluZXJ0ID0gcHJvcHMuaW5lcnQsIGFsbG93UGluY2hab29tID0gcHJvcHMuYWxsb3dQaW5jaFpvb20sIF9iID0gcHJvcHMuYXMsIENvbnRhaW5lciA9IF9iID09PSB2b2lkIDAgPyAnZGl2JyA6IF9iLCBnYXBNb2RlID0gcHJvcHMuZ2FwTW9kZSwgcmVzdCA9IF9fcmVzdChwcm9wcywgW1wiZm9yd2FyZFByb3BzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJyZW1vdmVTY3JvbGxCYXJcIiwgXCJlbmFibGVkXCIsIFwic2hhcmRzXCIsIFwic2lkZUNhclwiLCBcIm5vSXNvbGF0aW9uXCIsIFwiaW5lcnRcIiwgXCJhbGxvd1BpbmNoWm9vbVwiLCBcImFzXCIsIFwiZ2FwTW9kZVwiXSk7XG4gICAgdmFyIFNpZGVDYXIgPSBzaWRlQ2FyO1xuICAgIHZhciBjb250YWluZXJSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgcGFyZW50UmVmXSk7XG4gICAgdmFyIGNvbnRhaW5lclByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3QpLCBjYWxsYmFja3MpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgZW5hYmxlZCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlQ2FyLCB7IHNpZGVDYXI6IGVmZmVjdENhciwgcmVtb3ZlU2Nyb2xsQmFyOiByZW1vdmVTY3JvbGxCYXIsIHNoYXJkczogc2hhcmRzLCBub0lzb2xhdGlvbjogbm9Jc29sYXRpb24sIGluZXJ0OiBpbmVydCwgc2V0Q2FsbGJhY2tzOiBzZXRDYWxsYmFja3MsIGFsbG93UGluY2hab29tOiAhIWFsbG93UGluY2hab29tLCBsb2NrUmVmOiByZWYsIGdhcE1vZGU6IGdhcE1vZGUgfSkpLFxuICAgICAgICBmb3J3YXJkUHJvcHMgPyAoUmVhY3QuY2xvbmVFbGVtZW50KFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGFpbmVyUHJvcHMpLCB7IHJlZjogY29udGFpbmVyUmVmIH0pKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250YWluZXIsIF9fYXNzaWduKHt9LCBjb250YWluZXJQcm9wcywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgcmVmOiBjb250YWluZXJSZWYgfSksIGNoaWxkcmVuKSkpKTtcbn0pO1xuUmVtb3ZlU2Nyb2xsLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHJlbW92ZVNjcm9sbEJhcjogdHJ1ZSxcbiAgICBpbmVydDogZmFsc2UsXG59O1xuUmVtb3ZlU2Nyb2xsLmNsYXNzTmFtZXMgPSB7XG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGhDbGFzc05hbWUsXG4gICAgemVyb1JpZ2h0OiB6ZXJvUmlnaHRDbGFzc05hbWUsXG59O1xuZXhwb3J0IHsgUmVtb3ZlU2Nyb2xsIH07XG4iLCJ2YXIgY3VycmVudE5vbmNlO1xuZXhwb3J0IHZhciBzZXROb25jZSA9IGZ1bmN0aW9uIChub25jZSkge1xuICAgIGN1cnJlbnROb25jZSA9IG5vbmNlO1xufTtcbmV4cG9ydCB2YXIgZ2V0Tm9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGN1cnJlbnROb25jZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudE5vbmNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuIiwiaW1wb3J0IHsgZ2V0Tm9uY2UgfSBmcm9tICdnZXQtbm9uY2UnO1xuZnVuY3Rpb24gbWFrZVN0eWxlVGFnKCkge1xuICAgIGlmICghZG9jdW1lbnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHRhZy50eXBlID0gJ3RleHQvY3NzJztcbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIGlmIChub25jZSkge1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbn1cbmZ1bmN0aW9uIGluamVjdFN0eWxlcyh0YWcsIGNzcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0YWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydFN0eWxlVGFnKHRhZykge1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQodGFnKTtcbn1cbmV4cG9ydCB2YXIgc3R5bGVzaGVldFNpbmdsZXRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlciA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZXNoZWV0ID0gbWFrZVN0eWxlVGFnKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdFN0eWxlcyhzdHlsZXNoZWV0LCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFN0eWxlVGFnKHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgICAgICBpZiAoIWNvdW50ZXIgJiYgc3R5bGVzaGVldCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQucGFyZW50Tm9kZSAmJiBzdHlsZXNoZWV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVzaGVldCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdHlsZXNoZWV0U2luZ2xldG9uIH0gZnJvbSAnLi9zaW5nbGV0b24nO1xuLyoqXG4gKiBjcmVhdGVzIGEgaG9vayB0byBjb250cm9sIHN0eWxlIHNpbmdsZXRvblxuICogQHNlZSB7QGxpbmsgc3R5bGVTaW5nbGV0b259IGZvciBhIHNhZmVyIGNvbXBvbmVudCB2ZXJzaW9uXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCB1c2VTdHlsZSA9IHN0eWxlSG9va1NpbmdsZXRvbigpO1xuICogLy8vXG4gKiB1c2VTdHlsZSgnYm9keSB7IG92ZXJmbG93OiBoaWRkZW59Jyk7XG4gKi9cbmV4cG9ydCB2YXIgc3R5bGVIb29rU2luZ2xldG9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaGVldCA9IHN0eWxlc2hlZXRTaW5nbGV0b24oKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0eWxlcywgaXNEeW5hbWljKSB7XG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaGVldC5hZGQoc3R5bGVzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2hlZXQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbc3R5bGVzICYmIGlzRHluYW1pY10pO1xuICAgIH07XG59O1xuIiwiaW1wb3J0IHsgc3R5bGVIb29rU2luZ2xldG9uIH0gZnJvbSAnLi9ob29rJztcbi8qKlxuICogY3JlYXRlIGEgQ29tcG9uZW50IHRvIGFkZCBzdHlsZXMgb24gZGVtYW5kXG4gKiAtIHN0eWxlcyBhcmUgYWRkZWQgd2hlbiBmaXJzdCBpbnN0YW5jZSBpcyBtb3VudGVkXG4gKiAtIHN0eWxlcyBhcmUgcmVtb3ZlZCB3aGVuIHRoZSBsYXN0IGluc3RhbmNlIGlzIHVubW91bnRlZFxuICogLSBjaGFuZ2luZyBzdHlsZXMgaW4gcnVudGltZSBkb2VzIG5vdGhpbmcgdW5sZXNzIGR5bmFtaWMgaXMgc2V0LiBCdXQgd2l0aCBtdWx0aXBsZSBjb21wb25lbnRzIHRoYXQgY2FuIGxlYWQgdG8gdGhlIHVuZGVmaW5lZCBiZWhhdmlvclxuICovXG5leHBvcnQgdmFyIHN0eWxlU2luZ2xldG9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VTdHlsZSA9IHN0eWxlSG9va1NpbmdsZXRvbigpO1xuICAgIHZhciBTaGVldCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3R5bGVzID0gX2Euc3R5bGVzLCBkeW5hbWljID0gX2EuZHluYW1pYztcbiAgICAgICAgdXNlU3R5bGUoc3R5bGVzLCBkeW5hbWljKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2hlZXQ7XG59O1xuIiwiZXhwb3J0IHZhciB6ZXJvR2FwID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGdhcDogMCxcbn07XG52YXIgcGFyc2UgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcGFyc2VJbnQoeCB8fCAnJywgMTApIHx8IDA7IH07XG52YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGdhcE1vZGUpIHtcbiAgICB2YXIgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgICB2YXIgbGVmdCA9IGNzW2dhcE1vZGUgPT09ICdwYWRkaW5nJyA/ICdwYWRkaW5nTGVmdCcgOiAnbWFyZ2luTGVmdCddO1xuICAgIHZhciB0b3AgPSBjc1tnYXBNb2RlID09PSAncGFkZGluZycgPyAncGFkZGluZ1RvcCcgOiAnbWFyZ2luVG9wJ107XG4gICAgdmFyIHJpZ2h0ID0gY3NbZ2FwTW9kZSA9PT0gJ3BhZGRpbmcnID8gJ3BhZGRpbmdSaWdodCcgOiAnbWFyZ2luUmlnaHQnXTtcbiAgICByZXR1cm4gW3BhcnNlKGxlZnQpLCBwYXJzZSh0b3ApLCBwYXJzZShyaWdodCldO1xufTtcbmV4cG9ydCB2YXIgZ2V0R2FwV2lkdGggPSBmdW5jdGlvbiAoZ2FwTW9kZSkge1xuICAgIGlmIChnYXBNb2RlID09PSB2b2lkIDApIHsgZ2FwTW9kZSA9ICdtYXJnaW4nOyB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB6ZXJvR2FwO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldChnYXBNb2RlKTtcbiAgICB2YXIgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBvZmZzZXRzWzBdLFxuICAgICAgICB0b3A6IG9mZnNldHNbMV0sXG4gICAgICAgIHJpZ2h0OiBvZmZzZXRzWzJdLFxuICAgICAgICBnYXA6IE1hdGgubWF4KDAsIHdpbmRvd1dpZHRoIC0gZG9jdW1lbnRXaWR0aCArIG9mZnNldHNbMl0gLSBvZmZzZXRzWzBdKSxcbiAgICB9O1xufTtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0eWxlU2luZ2xldG9uIH0gZnJvbSAncmVhY3Qtc3R5bGUtc2luZ2xldG9uJztcbmltcG9ydCB7IGZ1bGxXaWR0aENsYXNzTmFtZSwgemVyb1JpZ2h0Q2xhc3NOYW1lLCBub1Njcm9sbGJhcnNDbGFzc05hbWUsIHJlbW92ZWRCYXJTaXplVmFyaWFibGUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRHYXBXaWR0aCB9IGZyb20gJy4vdXRpbHMnO1xudmFyIFN0eWxlID0gc3R5bGVTaW5nbGV0b24oKTtcbmV4cG9ydCB2YXIgbG9ja0F0dHJpYnV0ZSA9ICdkYXRhLXNjcm9sbC1sb2NrZWQnO1xuLy8gaW1wb3J0YW50IHRpcCAtIG9uY2Ugd2UgbWVhc3VyZSBzY3JvbGxCYXIgd2lkdGggYW5kIHJlbW92ZSB0aGVtXG4vLyB3ZSBjb3VsZCBub3QgcmVwZWF0IHRoaXMgb3BlcmF0aW9uXG4vLyB0aHVzIHdlIGFyZSB1c2luZyBzdHlsZS1zaW5nbGV0b24gLSBvbmx5IHRoZSBmaXJzdCBcInlldCBjb3JyZWN0XCIgc3R5bGUgd2lsbCBiZSBhcHBsaWVkLlxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIChfYSwgYWxsb3dSZWxhdGl2ZSwgZ2FwTW9kZSwgaW1wb3J0YW50KSB7XG4gICAgdmFyIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGdhcCA9IF9hLmdhcDtcbiAgICBpZiAoZ2FwTW9kZSA9PT0gdm9pZCAwKSB7IGdhcE1vZGUgPSAnbWFyZ2luJzsgfVxuICAgIHJldHVybiBcIlxcbiAgLlwiLmNvbmNhdChub1Njcm9sbGJhcnNDbGFzc05hbWUsIFwiIHtcXG4gICBvdmVyZmxvdzogaGlkZGVuIFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gICBwYWRkaW5nLXJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICB9XFxuICBib2R5W1wiKS5jb25jYXQobG9ja0F0dHJpYnV0ZSwgXCJdIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbiBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3I6IGNvbnRhaW47XFxuICAgIFwiKS5jb25jYXQoW1xuICAgICAgICBhbGxvd1JlbGF0aXZlICYmIFwicG9zaXRpb246IHJlbGF0aXZlIFwiLmNvbmNhdChpbXBvcnRhbnQsIFwiO1wiKSxcbiAgICAgICAgZ2FwTW9kZSA9PT0gJ21hcmdpbicgJiZcbiAgICAgICAgICAgIFwiXFxuICAgIHBhZGRpbmctbGVmdDogXCIuY29uY2F0KGxlZnQsIFwicHg7XFxuICAgIHBhZGRpbmctdG9wOiBcIikuY29uY2F0KHRvcCwgXCJweDtcXG4gICAgcGFkZGluZy1yaWdodDogXCIpLmNvbmNhdChyaWdodCwgXCJweDtcXG4gICAgbWFyZ2luLWxlZnQ6MDtcXG4gICAgbWFyZ2luLXRvcDowO1xcbiAgICBtYXJnaW4tcmlnaHQ6IFwiKS5jb25jYXQoZ2FwLCBcInB4IFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gICAgXCIpLFxuICAgICAgICBnYXBNb2RlID09PSAncGFkZGluZycgJiYgXCJwYWRkaW5nLXJpZ2h0OiBcIi5jb25jYXQoZ2FwLCBcInB4IFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcIiksXG4gICAgXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKCcnKSwgXCJcXG4gIH1cXG4gIFxcbiAgLlwiKS5jb25jYXQoemVyb1JpZ2h0Q2xhc3NOYW1lLCBcIiB7XFxuICAgIHJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICB9XFxuICBcXG4gIC5cIikuY29uY2F0KGZ1bGxXaWR0aENsYXNzTmFtZSwgXCIge1xcbiAgICBtYXJnaW4tcmlnaHQ6IFwiKS5jb25jYXQoZ2FwLCBcInB4IFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gIH1cXG4gIFxcbiAgLlwiKS5jb25jYXQoemVyb1JpZ2h0Q2xhc3NOYW1lLCBcIiAuXCIpLmNvbmNhdCh6ZXJvUmlnaHRDbGFzc05hbWUsIFwiIHtcXG4gICAgcmlnaHQ6IDAgXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgXFxuICAuXCIpLmNvbmNhdChmdWxsV2lkdGhDbGFzc05hbWUsIFwiIC5cIikuY29uY2F0KGZ1bGxXaWR0aENsYXNzTmFtZSwgXCIge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAgXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgXFxuICBib2R5W1wiKS5jb25jYXQobG9ja0F0dHJpYnV0ZSwgXCJdIHtcXG4gICAgXCIpLmNvbmNhdChyZW1vdmVkQmFyU2l6ZVZhcmlhYmxlLCBcIjogXCIpLmNvbmNhdChnYXAsIFwicHg7XFxuICB9XFxuXCIpO1xufTtcbnZhciBnZXRDdXJyZW50VXNlQ291bnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY291bnRlciA9IHBhcnNlSW50KGRvY3VtZW50LmJvZHkuZ2V0QXR0cmlidXRlKGxvY2tBdHRyaWJ1dGUpIHx8ICcwJywgMTApO1xuICAgIHJldHVybiBpc0Zpbml0ZShjb3VudGVyKSA/IGNvdW50ZXIgOiAwO1xufTtcbmV4cG9ydCB2YXIgdXNlTG9ja0F0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShsb2NrQXR0cmlidXRlLCAoZ2V0Q3VycmVudFVzZUNvdW50ZXIoKSArIDEpLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld0NvdW50ZXIgPSBnZXRDdXJyZW50VXNlQ291bnRlcigpIC0gMTtcbiAgICAgICAgICAgIGlmIChuZXdDb3VudGVyIDw9IDApIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZShsb2NrQXR0cmlidXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKGxvY2tBdHRyaWJ1dGUsIG5ld0NvdW50ZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufTtcbi8qKlxuICogUmVtb3ZlcyBwYWdlIHNjcm9sbGJhciBhbmQgYmxvY2tzIHBhZ2Ugc2Nyb2xsIHdoZW4gbW91bnRlZFxuICovXG5leHBvcnQgdmFyIFJlbW92ZVNjcm9sbEJhciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBub1JlbGF0aXZlID0gX2Eubm9SZWxhdGl2ZSwgbm9JbXBvcnRhbnQgPSBfYS5ub0ltcG9ydGFudCwgX2IgPSBfYS5nYXBNb2RlLCBnYXBNb2RlID0gX2IgPT09IHZvaWQgMCA/ICdtYXJnaW4nIDogX2I7XG4gICAgdXNlTG9ja0F0dHJpYnV0ZSgpO1xuICAgIC8qXG4gICAgIGdhcCB3aWxsIGJlIG1lYXN1cmVkIG9uIGV2ZXJ5IGNvbXBvbmVudCBtb3VudFxuICAgICBob3dldmVyIGl0IHdpbGwgYmUgdXNlZCBvbmx5IGJ5IHRoZSBcImZpcnN0XCIgaW52b2NhdGlvblxuICAgICBkdWUgdG8gc2luZ2xldG9uIG5hdHVyZSBvZiA8U3R5bGVcbiAgICAgKi9cbiAgICB2YXIgZ2FwID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRHYXBXaWR0aChnYXBNb2RlKTsgfSwgW2dhcE1vZGVdKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTdHlsZSwgeyBzdHlsZXM6IGdldFN0eWxlcyhnYXAsICFub1JlbGF0aXZlLCBnYXBNb2RlLCAhbm9JbXBvcnRhbnQgPyAnIWltcG9ydGFudCcgOiAnJykgfSk7XG59O1xuIiwidmFyIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgdmFyIG5vblBhc3NpdmUgPSBwYXNzaXZlU3VwcG9ydGVkID8geyBwYXNzaXZlOiBmYWxzZSB9IDogZmFsc2U7XG4iLCJ2YXIgYWx3YXlzQ29udGFpbnNTY3JvbGwgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIHRleHRhcmVhIHdpbGwgYWx3YXlzIF9jb250YWluXyBzY3JvbGwgaW5zaWRlIHNlbGYuIEl0IG9ubHkgY2FuIGJlIGhpZGRlblxuICAgIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQSc7XG59O1xudmFyIGVsZW1lbnRDYW5CZVNjcm9sbGVkID0gZnVuY3Rpb24gKG5vZGUsIG92ZXJmbG93KSB7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIHJldHVybiAoXG4gICAgLy8gbm90LW5vdC1zY3JvbGxhYmxlXG4gICAgc3R5bGVzW292ZXJmbG93XSAhPT0gJ2hpZGRlbicgJiZcbiAgICAgICAgLy8gY29udGFpbnMgc2Nyb2xsIGluc2lkZSBzZWxmXG4gICAgICAgICEoc3R5bGVzLm92ZXJmbG93WSA9PT0gc3R5bGVzLm92ZXJmbG93WCAmJiAhYWx3YXlzQ29udGFpbnNTY3JvbGwobm9kZSkgJiYgc3R5bGVzW292ZXJmbG93XSA9PT0gJ3Zpc2libGUnKSk7XG59O1xudmFyIGVsZW1lbnRDb3VsZEJlVlNjcm9sbGVkID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGVsZW1lbnRDYW5CZVNjcm9sbGVkKG5vZGUsICdvdmVyZmxvd1knKTsgfTtcbnZhciBlbGVtZW50Q291bGRCZUhTY3JvbGxlZCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBlbGVtZW50Q2FuQmVTY3JvbGxlZChub2RlLCAnb3ZlcmZsb3dYJyk7IH07XG5leHBvcnQgdmFyIGxvY2F0aW9uQ291bGRCZVNjcm9sbGVkID0gZnVuY3Rpb24gKGF4aXMsIG5vZGUpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XG4gICAgZG8ge1xuICAgICAgICAvLyBTa2lwIG92ZXIgc2hhZG93IHJvb3RcbiAgICAgICAgaWYgKHR5cGVvZiBTaGFkb3dSb290ICE9PSAndW5kZWZpbmVkJyAmJiBjdXJyZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNTY3JvbGxhYmxlID0gZWxlbWVudENvdWxkQmVTY3JvbGxlZChheGlzLCBjdXJyZW50KTtcbiAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0U2Nyb2xsVmFyaWFibGVzKGF4aXMsIGN1cnJlbnQpLCBzY3JvbGxIZWlnaHQgPSBfYVsxXSwgY2xpZW50SGVpZ2h0ID0gX2FbMl07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsSGVpZ2h0ID4gY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IG93bmVyRG9jdW1lbnQuYm9keSk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBnZXRWU2Nyb2xsVmFyaWFibGVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IF9hLnNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0ID0gX2Euc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgPSBfYS5jbGllbnRIZWlnaHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2Nyb2xsVG9wLFxuICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICBdO1xufTtcbnZhciBnZXRIU2Nyb2xsVmFyaWFibGVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBfYS5zY3JvbGxMZWZ0LCBzY3JvbGxXaWR0aCA9IF9hLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aCA9IF9hLmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFdpZHRoLFxuICAgICAgICBjbGllbnRXaWR0aCxcbiAgICBdO1xufTtcbnZhciBlbGVtZW50Q291bGRCZVNjcm9sbGVkID0gZnVuY3Rpb24gKGF4aXMsIG5vZGUpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3YnID8gZWxlbWVudENvdWxkQmVWU2Nyb2xsZWQobm9kZSkgOiBlbGVtZW50Q291bGRCZUhTY3JvbGxlZChub2RlKTtcbn07XG52YXIgZ2V0U2Nyb2xsVmFyaWFibGVzID0gZnVuY3Rpb24gKGF4aXMsIG5vZGUpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3YnID8gZ2V0VlNjcm9sbFZhcmlhYmxlcyhub2RlKSA6IGdldEhTY3JvbGxWYXJpYWJsZXMobm9kZSk7XG59O1xudmFyIGdldERpcmVjdGlvbkZhY3RvciA9IGZ1bmN0aW9uIChheGlzLCBkaXJlY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCdzIGRpcmVjdGlvbiBpcyBydGwgKHJpZ2h0LXRvLWxlZnQpLCB0aGVuIHNjcm9sbExlZnQgaXMgMCB3aGVuIHRoZSBzY3JvbGxiYXIgaXMgYXQgaXRzIHJpZ2h0bW9zdCBwb3NpdGlvbixcbiAgICAgKiBhbmQgdGhlbiBpbmNyZWFzaW5nbHkgbmVnYXRpdmUgYXMgeW91IHNjcm9sbCB0b3dhcmRzIHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zY3JvbGxMZWZ0XG4gICAgICovXG4gICAgcmV0dXJuIGF4aXMgPT09ICdoJyAmJiBkaXJlY3Rpb24gPT09ICdydGwnID8gLTEgOiAxO1xufTtcbmV4cG9ydCB2YXIgaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gKGF4aXMsIGVuZFRhcmdldCwgZXZlbnQsIHNvdXJjZURlbHRhLCBub092ZXJzY3JvbGwpIHtcbiAgICB2YXIgZGlyZWN0aW9uRmFjdG9yID0gZ2V0RGlyZWN0aW9uRmFjdG9yKGF4aXMsIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVuZFRhcmdldCkuZGlyZWN0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb25GYWN0b3IgKiBzb3VyY2VEZWx0YTtcbiAgICAvLyBmaW5kIHNjcm9sbGFibGUgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgdGFyZ2V0SW5Mb2NrID0gZW5kVGFyZ2V0LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgdmFyIHNob3VsZENhbmNlbFNjcm9sbCA9IGZhbHNlO1xuICAgIHZhciBpc0RlbHRhUG9zaXRpdmUgPSBkZWx0YSA+IDA7XG4gICAgdmFyIGF2YWlsYWJsZVNjcm9sbCA9IDA7XG4gICAgdmFyIGF2YWlsYWJsZVNjcm9sbFRvcCA9IDA7XG4gICAgZG8ge1xuICAgICAgICB2YXIgX2EgPSBnZXRTY3JvbGxWYXJpYWJsZXMoYXhpcywgdGFyZ2V0KSwgcG9zaXRpb24gPSBfYVswXSwgc2Nyb2xsXzEgPSBfYVsxXSwgY2FwYWNpdHkgPSBfYVsyXTtcbiAgICAgICAgdmFyIGVsZW1lbnRTY3JvbGwgPSBzY3JvbGxfMSAtIGNhcGFjaXR5IC0gZGlyZWN0aW9uRmFjdG9yICogcG9zaXRpb247XG4gICAgICAgIGlmIChwb3NpdGlvbiB8fCBlbGVtZW50U2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudENvdWxkQmVTY3JvbGxlZChheGlzLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlU2Nyb2xsICs9IGVsZW1lbnRTY3JvbGw7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlU2Nyb2xsVG9wICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoXG4gICAgLy8gcG9ydGFsZWQgY29udGVudFxuICAgICghdGFyZ2V0SW5Mb2NrICYmIHRhcmdldCAhPT0gZG9jdW1lbnQuYm9keSkgfHxcbiAgICAgICAgLy8gc2VsZiBjb250ZW50XG4gICAgICAgICh0YXJnZXRJbkxvY2sgJiYgKGVuZFRhcmdldC5jb250YWlucyh0YXJnZXQpIHx8IGVuZFRhcmdldCA9PT0gdGFyZ2V0KSkpO1xuICAgIC8vIGhhbmRsZSBlcHNpbG9uIGFyb3VuZCAwIChub24gc3RhbmRhcmQgem9vbSBsZXZlbHMpXG4gICAgaWYgKGlzRGVsdGFQb3NpdGl2ZSAmJlxuICAgICAgICAoKG5vT3ZlcnNjcm9sbCAmJiBNYXRoLmFicyhhdmFpbGFibGVTY3JvbGwpIDwgMSkgfHwgKCFub092ZXJzY3JvbGwgJiYgZGVsdGEgPiBhdmFpbGFibGVTY3JvbGwpKSkge1xuICAgICAgICBzaG91bGRDYW5jZWxTY3JvbGwgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNEZWx0YVBvc2l0aXZlICYmXG4gICAgICAgICgobm9PdmVyc2Nyb2xsICYmIE1hdGguYWJzKGF2YWlsYWJsZVNjcm9sbFRvcCkgPCAxKSB8fCAoIW5vT3ZlcnNjcm9sbCAmJiAtZGVsdGEgPiBhdmFpbGFibGVTY3JvbGxUb3ApKSkge1xuICAgICAgICBzaG91bGRDYW5jZWxTY3JvbGwgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkQ2FuY2VsU2Nyb2xsO1xufTtcbiIsImltcG9ydCB7IF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlbW92ZVNjcm9sbEJhciB9IGZyb20gJ3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyJztcbmltcG9ydCB7IHN0eWxlU2luZ2xldG9uIH0gZnJvbSAncmVhY3Qtc3R5bGUtc2luZ2xldG9uJztcbmltcG9ydCB7IG5vblBhc3NpdmUgfSBmcm9tICcuL2FnZ3Jlc2l2ZUNhcHR1cmUnO1xuaW1wb3J0IHsgaGFuZGxlU2Nyb2xsLCBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZCB9IGZyb20gJy4vaGFuZGxlU2Nyb2xsJztcbmV4cG9ydCB2YXIgZ2V0VG91Y2hYWSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2hhbmdlZFRvdWNoZXMnIGluIGV2ZW50ID8gW2V2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFldIDogWzAsIDBdO1xufTtcbmV4cG9ydCB2YXIgZ2V0RGVsdGFYWSA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gW2V2ZW50LmRlbHRhWCwgZXZlbnQuZGVsdGFZXTsgfTtcbnZhciBleHRyYWN0UmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHJldHVybiByZWYgJiYgJ2N1cnJlbnQnIGluIHJlZiA/IHJlZi5jdXJyZW50IDogcmVmO1xufTtcbnZhciBkZWx0YUNvbXBhcmUgPSBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geFswXSA9PT0geVswXSAmJiB4WzFdID09PSB5WzFdOyB9O1xudmFyIGdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIFwiXFxuICAuYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQsIFwiIHtwb2ludGVyLWV2ZW50czogbm9uZTt9XFxuICAuYWxsb3ctaW50ZXJhY3Rpdml0eS1cIikuY29uY2F0KGlkLCBcIiB7cG9pbnRlci1ldmVudHM6IGFsbDt9XFxuXCIpOyB9O1xudmFyIGlkQ291bnRlciA9IDA7XG52YXIgbG9ja1N0YWNrID0gW107XG5leHBvcnQgZnVuY3Rpb24gUmVtb3ZlU2Nyb2xsU2lkZUNhcihwcm9wcykge1xuICAgIHZhciBzaG91bGRQcmV2ZW50UXVldWUgPSBSZWFjdC51c2VSZWYoW10pO1xuICAgIHZhciB0b3VjaFN0YXJ0UmVmID0gUmVhY3QudXNlUmVmKFswLCAwXSk7XG4gICAgdmFyIGFjdGl2ZUF4aXMgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgaWQgPSBSZWFjdC51c2VTdGF0ZShpZENvdW50ZXIrKylbMF07XG4gICAgdmFyIFN0eWxlID0gUmVhY3QudXNlU3RhdGUoc3R5bGVTaW5nbGV0b24pWzBdO1xuICAgIHZhciBsYXN0UHJvcHMgPSBSZWFjdC51c2VSZWYocHJvcHMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxhc3RQcm9wcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgfSwgW3Byb3BzXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BzLmluZXJ0KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJibG9jay1pbnRlcmFjdGl2aXR5LVwiLmNvbmNhdChpZCkpO1xuICAgICAgICAgICAgdmFyIGFsbG93XzEgPSBfX3NwcmVhZEFycmF5KFtwcm9wcy5sb2NrUmVmLmN1cnJlbnRdLCAocHJvcHMuc2hhcmRzIHx8IFtdKS5tYXAoZXh0cmFjdFJlZiksIHRydWUpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIGFsbG93XzEuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoXCJhbGxvdy1pbnRlcmFjdGl2aXR5LVwiLmNvbmNhdChpZCkpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgICAgICBhbGxvd18xLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKFwiYWxsb3ctaW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9LCBbcHJvcHMuaW5lcnQsIHByb3BzLmxvY2tSZWYuY3VycmVudCwgcHJvcHMuc2hhcmRzXSk7XG4gICAgdmFyIHNob3VsZENhbmNlbEV2ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50LCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKCgndG91Y2hlcycgaW4gZXZlbnQgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpIHx8IChldmVudC50eXBlID09PSAnd2hlZWwnICYmIGV2ZW50LmN0cmxLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gIWxhc3RQcm9wcy5jdXJyZW50LmFsbG93UGluY2hab29tO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3VjaCA9IGdldFRvdWNoWFkoZXZlbnQpO1xuICAgICAgICB2YXIgdG91Y2hTdGFydCA9IHRvdWNoU3RhcnRSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGRlbHRhWCA9ICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogdG91Y2hTdGFydFswXSAtIHRvdWNoWzBdO1xuICAgICAgICB2YXIgZGVsdGFZID0gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiB0b3VjaFN0YXJ0WzFdIC0gdG91Y2hbMV07XG4gICAgICAgIHZhciBjdXJyZW50QXhpcztcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIG1vdmVEaXJlY3Rpb24gPSBNYXRoLmFicyhkZWx0YVgpID4gTWF0aC5hYnMoZGVsdGFZKSA/ICdoJyA6ICd2JztcbiAgICAgICAgLy8gYWxsb3cgaG9yaXpvbnRhbCB0b3VjaCBtb3ZlIG9uIFJhbmdlIGlucHV0cy4gVGhleSB3aWxsIG5vdCBjYXVzZSBhbnkgc2Nyb2xsXG4gICAgICAgIGlmICgndG91Y2hlcycgaW4gZXZlbnQgJiYgbW92ZURpcmVjdGlvbiA9PT0gJ2gnICYmIHRhcmdldC50eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24gPSBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZChtb3ZlRGlyZWN0aW9uLCB0YXJnZXQpO1xuICAgICAgICBpZiAoIWNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjdXJyZW50QXhpcyA9IG1vdmVEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50QXhpcyA9IG1vdmVEaXJlY3Rpb24gPT09ICd2JyA/ICdoJyA6ICd2JztcbiAgICAgICAgICAgIGNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24gPSBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZChtb3ZlRGlyZWN0aW9uLCB0YXJnZXQpO1xuICAgICAgICAgICAgLy8gb3RoZXIgYXhpcyBtaWdodCBiZSBub3Qgc2Nyb2xsYWJsZVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuQmVTY3JvbGxlZEluTWFpbkRpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWN0aXZlQXhpcy5jdXJyZW50ICYmICdjaGFuZ2VkVG91Y2hlcycgaW4gZXZlbnQgJiYgKGRlbHRhWCB8fCBkZWx0YVkpKSB7XG4gICAgICAgICAgICBhY3RpdmVBeGlzLmN1cnJlbnQgPSBjdXJyZW50QXhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRBeGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FuY2VsaW5nQXhpcyA9IGFjdGl2ZUF4aXMuY3VycmVudCB8fCBjdXJyZW50QXhpcztcbiAgICAgICAgcmV0dXJuIGhhbmRsZVNjcm9sbChjYW5jZWxpbmdBeGlzLCBwYXJlbnQsIGV2ZW50LCBjYW5jZWxpbmdBeGlzID09PSAnaCcgPyBkZWx0YVggOiBkZWx0YVksIHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChfZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICBpZiAoIWxvY2tTdGFjay5sZW5ndGggfHwgbG9ja1N0YWNrW2xvY2tTdGFjay5sZW5ndGggLSAxXSAhPT0gU3R5bGUpIHtcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgbGFzdCBhY3RpdmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsdGEgPSAnZGVsdGFZJyBpbiBldmVudCA/IGdldERlbHRhWFkoZXZlbnQpIDogZ2V0VG91Y2hYWShldmVudCk7XG4gICAgICAgIHZhciBzb3VyY2VFdmVudCA9IHNob3VsZFByZXZlbnRRdWV1ZS5jdXJyZW50LmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5uYW1lID09PSBldmVudC50eXBlICYmIChlLnRhcmdldCA9PT0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnRhcmdldCA9PT0gZS5zaGFkb3dQYXJlbnQpICYmIGRlbHRhQ29tcGFyZShlLmRlbHRhLCBkZWx0YSk7IH0pWzBdO1xuICAgICAgICAvLyBzZWxmIGV2ZW50LCBhbmQgc2hvdWxkIGJlIGNhbmNlbGVkXG4gICAgICAgIGlmIChzb3VyY2VFdmVudCAmJiBzb3VyY2VFdmVudC5zaG91bGQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdXRzaWRlIG9yIHNoYXJkIGV2ZW50XG4gICAgICAgIGlmICghc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzaGFyZE5vZGVzID0gKGxhc3RQcm9wcy5jdXJyZW50LnNoYXJkcyB8fCBbXSlcbiAgICAgICAgICAgICAgICAubWFwKGV4dHJhY3RSZWYpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY29udGFpbnMoZXZlbnQudGFyZ2V0KTsgfSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkU3RvcCA9IHNoYXJkTm9kZXMubGVuZ3RoID4gMCA/IHNob3VsZENhbmNlbEV2ZW50KGV2ZW50LCBzaGFyZE5vZGVzWzBdKSA6ICFsYXN0UHJvcHMuY3VycmVudC5ub0lzb2xhdGlvbjtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIHNob3VsZENhbmNlbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lLCBkZWx0YSwgdGFyZ2V0LCBzaG91bGQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0geyBuYW1lOiBuYW1lLCBkZWx0YTogZGVsdGEsIHRhcmdldDogdGFyZ2V0LCBzaG91bGQ6IHNob3VsZCwgc2hhZG93UGFyZW50OiBnZXRPdXRlcm1vc3RTaGFkb3dQYXJlbnQodGFyZ2V0KSB9O1xuICAgICAgICBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudC5wdXNoKGV2ZW50KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudCA9IHNob3VsZFByZXZlbnRRdWV1ZS5jdXJyZW50LmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZSAhPT0gZXZlbnQ7IH0pO1xuICAgICAgICB9LCAxKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNjcm9sbFRvdWNoU3RhcnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdG91Y2hTdGFydFJlZi5jdXJyZW50ID0gZ2V0VG91Y2hYWShldmVudCk7XG4gICAgICAgIGFjdGl2ZUF4aXMuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNjcm9sbFdoZWVsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNob3VsZENhbmNlbChldmVudC50eXBlLCBnZXREZWx0YVhZKGV2ZW50KSwgZXZlbnQudGFyZ2V0LCBzaG91bGRDYW5jZWxFdmVudChldmVudCwgcHJvcHMubG9ja1JlZi5jdXJyZW50KSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxUb3VjaE1vdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc2hvdWxkQ2FuY2VsKGV2ZW50LnR5cGUsIGdldFRvdWNoWFkoZXZlbnQpLCBldmVudC50YXJnZXQsIHNob3VsZENhbmNlbEV2ZW50KGV2ZW50LCBwcm9wcy5sb2NrUmVmLmN1cnJlbnQpKTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9ja1N0YWNrLnB1c2goU3R5bGUpO1xuICAgICAgICBwcm9wcy5zZXRDYWxsYmFja3Moe1xuICAgICAgICAgICAgb25TY3JvbGxDYXB0dXJlOiBzY3JvbGxXaGVlbCxcbiAgICAgICAgICAgIG9uV2hlZWxDYXB0dXJlOiBzY3JvbGxXaGVlbCxcbiAgICAgICAgICAgIG9uVG91Y2hNb3ZlQ2FwdHVyZTogc2Nyb2xsVG91Y2hNb3ZlLFxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBzaG91bGRQcmV2ZW50LCBub25QYXNzaXZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBzY3JvbGxUb3VjaFN0YXJ0LCBub25QYXNzaXZlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvY2tTdGFjayA9IGxvY2tTdGFjay5maWx0ZXIoZnVuY3Rpb24gKGluc3QpIHsgcmV0dXJuIGluc3QgIT09IFN0eWxlOyB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBzaG91bGRQcmV2ZW50LCBub25QYXNzaXZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBzY3JvbGxUb3VjaFN0YXJ0LCBub25QYXNzaXZlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJlbW92ZVNjcm9sbEJhciA9IHByb3BzLnJlbW92ZVNjcm9sbEJhciwgaW5lcnQgPSBwcm9wcy5pbmVydDtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGluZXJ0ID8gUmVhY3QuY3JlYXRlRWxlbWVudChTdHlsZSwgeyBzdHlsZXM6IGdlbmVyYXRlU3R5bGUoaWQpIH0pIDogbnVsbCxcbiAgICAgICAgcmVtb3ZlU2Nyb2xsQmFyID8gUmVhY3QuY3JlYXRlRWxlbWVudChSZW1vdmVTY3JvbGxCYXIsIHsgZ2FwTW9kZTogcHJvcHMuZ2FwTW9kZSB9KSA6IG51bGwpKTtcbn1cbmZ1bmN0aW9uIGdldE91dGVybW9zdFNoYWRvd1BhcmVudChub2RlKSB7XG4gICAgdmFyIHNoYWRvd1BhcmVudCA9IG51bGw7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICBzaGFkb3dQYXJlbnQgPSBub2RlLmhvc3Q7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3dQYXJlbnQ7XG59XG4iLCJpbXBvcnQgeyBleHBvcnRTaWRlY2FyIH0gZnJvbSAndXNlLXNpZGVjYXInO1xuaW1wb3J0IHsgUmVtb3ZlU2Nyb2xsU2lkZUNhciB9IGZyb20gJy4vU2lkZUVmZmVjdCc7XG5pbXBvcnQgeyBlZmZlY3RDYXIgfSBmcm9tICcuL21lZGl1bSc7XG5leHBvcnQgZGVmYXVsdCBleHBvcnRTaWRlY2FyKGVmZmVjdENhciwgUmVtb3ZlU2Nyb2xsU2lkZUNhcik7XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVtb3ZlU2Nyb2xsIH0gZnJvbSAnLi9VSSc7XG5pbXBvcnQgU2lkZUNhciBmcm9tICcuL3NpZGVjYXInO1xudmFyIFJlYWN0UmVtb3ZlU2Nyb2xsID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtb3ZlU2Nyb2xsLCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgcmVmOiByZWYsIHNpZGVDYXI6IFNpZGVDYXIgfSkpKTsgfSk7XG5SZWFjdFJlbW92ZVNjcm9sbC5jbGFzc05hbWVzID0gUmVtb3ZlU2Nyb2xsLmNsYXNzTmFtZXM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdFJlbW92ZVNjcm9sbDtcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9zZWxlY3Qvc3JjL3NlbGVjdC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tIFwiQHJhZGl4LXVpL251bWJlclwiO1xuaW1wb3J0IHsgY29tcG9zZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiQHJhZGl4LXVpL3ByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29sbGVjdGlvbiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29sbGVjdGlvblwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29udGV4dFwiO1xuaW1wb3J0IHsgdXNlRGlyZWN0aW9uIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1kaXJlY3Rpb25cIjtcbmltcG9ydCB7IERpc21pc3NhYmxlTGF5ZXIgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWRpc21pc3NhYmxlLWxheWVyXCI7XG5pbXBvcnQgeyB1c2VGb2N1c0d1YXJkcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtZm9jdXMtZ3VhcmRzXCI7XG5pbXBvcnQgeyBGb2N1c1Njb3BlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1mb2N1cy1zY29wZVwiO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWlkXCI7XG5pbXBvcnQgKiBhcyBQb3BwZXJQcmltaXRpdmUgZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wb3BwZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcHBlclNjb3BlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wb3BwZXJcIjtcbmltcG9ydCB7IFBvcnRhbCBhcyBQb3J0YWxQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXBvcnRhbFwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNsb3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5pbXBvcnQgeyB1c2VDb250cm9sbGFibGVTdGF0ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNvbnRyb2xsYWJsZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlUHJldmlvdXMgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1wcmV2aW91c1wiO1xuaW1wb3J0IHsgVmlzdWFsbHlIaWRkZW4gfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXZpc3VhbGx5LWhpZGRlblwiO1xuaW1wb3J0IHsgaGlkZU90aGVycyB9IGZyb20gXCJhcmlhLWhpZGRlblwiO1xuaW1wb3J0IHsgUmVtb3ZlU2Nyb2xsIH0gZnJvbSBcInJlYWN0LXJlbW92ZS1zY3JvbGxcIjtcbmltcG9ydCB7IEZyYWdtZW50LCBqc3gsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBPUEVOX0tFWVMgPSBbXCIgXCIsIFwiRW50ZXJcIiwgXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCJdO1xudmFyIFNFTEVDVElPTl9LRVlTID0gW1wiIFwiLCBcIkVudGVyXCJdO1xudmFyIFNFTEVDVF9OQU1FID0gXCJTZWxlY3RcIjtcbnZhciBbQ29sbGVjdGlvbiwgdXNlQ29sbGVjdGlvbiwgY3JlYXRlQ29sbGVjdGlvblNjb3BlXSA9IGNyZWF0ZUNvbGxlY3Rpb24oU0VMRUNUX05BTUUpO1xudmFyIFtjcmVhdGVTZWxlY3RDb250ZXh0LCBjcmVhdGVTZWxlY3RTY29wZV0gPSBjcmVhdGVDb250ZXh0U2NvcGUoU0VMRUNUX05BTUUsIFtcbiAgY3JlYXRlQ29sbGVjdGlvblNjb3BlLFxuICBjcmVhdGVQb3BwZXJTY29wZVxuXSk7XG52YXIgdXNlUG9wcGVyU2NvcGUgPSBjcmVhdGVQb3BwZXJTY29wZSgpO1xudmFyIFtTZWxlY3RQcm92aWRlciwgdXNlU2VsZWN0Q29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KFNFTEVDVF9OQU1FKTtcbnZhciBbU2VsZWN0TmF0aXZlT3B0aW9uc1Byb3ZpZGVyLCB1c2VTZWxlY3ROYXRpdmVPcHRpb25zQ29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KFNFTEVDVF9OQU1FKTtcbnZhciBTZWxlY3QgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgY2hpbGRyZW4sXG4gICAgb3Blbjogb3BlblByb3AsXG4gICAgZGVmYXVsdE9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIHZhbHVlOiB2YWx1ZVByb3AsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIG9uVmFsdWVDaGFuZ2UsXG4gICAgZGlyLFxuICAgIG5hbWUsXG4gICAgYXV0b0NvbXBsZXRlLFxuICAgIGRpc2FibGVkLFxuICAgIHJlcXVpcmVkLFxuICAgIGZvcm1cbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBbdHJpZ2dlciwgc2V0VHJpZ2dlcl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3ZhbHVlTm9kZSwgc2V0VmFsdWVOb2RlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbdmFsdWVOb2RlSGFzQ2hpbGRyZW4sIHNldFZhbHVlTm9kZUhhc0NoaWxkcmVuXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgZGlyZWN0aW9uID0gdXNlRGlyZWN0aW9uKGRpcik7XG4gIGNvbnN0IFtvcGVuID0gZmFsc2UsIHNldE9wZW5dID0gdXNlQ29udHJvbGxhYmxlU3RhdGUoe1xuICAgIHByb3A6IG9wZW5Qcm9wLFxuICAgIGRlZmF1bHRQcm9wOiBkZWZhdWx0T3BlbixcbiAgICBvbkNoYW5nZTogb25PcGVuQ2hhbmdlXG4gIH0pO1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZUNvbnRyb2xsYWJsZVN0YXRlKHtcbiAgICBwcm9wOiB2YWx1ZVByb3AsXG4gICAgZGVmYXVsdFByb3A6IGRlZmF1bHRWYWx1ZSxcbiAgICBvbkNoYW5nZTogb25WYWx1ZUNoYW5nZVxuICB9KTtcbiAgY29uc3QgdHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc0Zvcm1Db250cm9sID0gdHJpZ2dlciA/IGZvcm0gfHwgISF0cmlnZ2VyLmNsb3Nlc3QoXCJmb3JtXCIpIDogdHJ1ZTtcbiAgY29uc3QgW25hdGl2ZU9wdGlvbnNTZXQsIHNldE5hdGl2ZU9wdGlvbnNTZXRdID0gUmVhY3QudXNlU3RhdGUoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIGNvbnN0IG5hdGl2ZVNlbGVjdEtleSA9IEFycmF5LmZyb20obmF0aXZlT3B0aW9uc1NldCkubWFwKChvcHRpb24pID0+IG9wdGlvbi5wcm9wcy52YWx1ZSkuam9pbihcIjtcIik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFBvcHBlclByaW1pdGl2ZS5Sb290LCB7IC4uLnBvcHBlclNjb3BlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgU2VsZWN0UHJvdmlkZXIsXG4gICAge1xuICAgICAgcmVxdWlyZWQsXG4gICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICBvblRyaWdnZXJDaGFuZ2U6IHNldFRyaWdnZXIsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBvblZhbHVlTm9kZUNoYW5nZTogc2V0VmFsdWVOb2RlLFxuICAgICAgdmFsdWVOb2RlSGFzQ2hpbGRyZW4sXG4gICAgICBvblZhbHVlTm9kZUhhc0NoaWxkcmVuQ2hhbmdlOiBzZXRWYWx1ZU5vZGVIYXNDaGlsZHJlbixcbiAgICAgIGNvbnRlbnRJZDogdXNlSWQoKSxcbiAgICAgIHZhbHVlLFxuICAgICAgb25WYWx1ZUNoYW5nZTogc2V0VmFsdWUsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlOiBzZXRPcGVuLFxuICAgICAgZGlyOiBkaXJlY3Rpb24sXG4gICAgICB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvbi5Qcm92aWRlciwgeyBzY29wZTogX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgU2VsZWN0TmF0aXZlT3B0aW9uc1Byb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNjb3BlOiBwcm9wcy5fX3Njb3BlU2VsZWN0LFxuICAgICAgICAgICAgb25OYXRpdmVPcHRpb25BZGQ6IFJlYWN0LnVzZUNhbGxiYWNrKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgc2V0TmF0aXZlT3B0aW9uc1NldCgocHJldikgPT4gbmV3IFNldChwcmV2KS5hZGQob3B0aW9uKSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBvbk5hdGl2ZU9wdGlvblJlbW92ZTogUmVhY3QudXNlQ2FsbGJhY2soKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICBzZXROYXRpdmVPcHRpb25zU2V0KChwcmV2KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uc1NldCA9IG5ldyBTZXQocHJldik7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1NldC5kZWxldGUob3B0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uc1NldDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KSxcbiAgICAgICAgaXNGb3JtQ29udHJvbCA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICAgIEJ1YmJsZVNlbGVjdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdXRvQ29tcGxldGUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAoZXZlbnQpID0+IHNldFZhbHVlKGV2ZW50LnRhcmdldC52YWx1ZSksXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB2YWx1ZSA9PT0gdm9pZCAwID8gLyogQF9fUFVSRV9fICovIGpzeChcIm9wdGlvblwiLCB7IHZhbHVlOiBcIlwiIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbShuYXRpdmVPcHRpb25zU2V0KVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlU2VsZWN0S2V5XG4gICAgICAgICkgOiBudWxsXG4gICAgICBdXG4gICAgfVxuICApIH0pO1xufTtcblNlbGVjdC5kaXNwbGF5TmFtZSA9IFNFTEVDVF9OQU1FO1xudmFyIFRSSUdHRVJfTkFNRSA9IFwiU2VsZWN0VHJpZ2dlclwiO1xudmFyIFNlbGVjdFRyaWdnZXIgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgZGlzYWJsZWQgPSBmYWxzZSwgLi4udHJpZ2dlclByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KFRSSUdHRVJfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGNvbnRleHQuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgY29udGV4dC5vblRyaWdnZXJDaGFuZ2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gdXNlQ29sbGVjdGlvbihfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZihcInRvdWNoXCIpO1xuICAgIGNvbnN0IFtzZWFyY2hSZWYsIGhhbmRsZVR5cGVhaGVhZFNlYXJjaCwgcmVzZXRUeXBlYWhlYWRdID0gdXNlVHlwZWFoZWFkU2VhcmNoKChzZWFyY2gpID0+IHtcbiAgICAgIGNvbnN0IGVuYWJsZWRJdGVtcyA9IGdldEl0ZW1zKCkuZmlsdGVyKChpdGVtKSA9PiAhaXRlbS5kaXNhYmxlZCk7XG4gICAgICBjb25zdCBjdXJyZW50SXRlbSA9IGVuYWJsZWRJdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLnZhbHVlID09PSBjb250ZXh0LnZhbHVlKTtcbiAgICAgIGNvbnN0IG5leHRJdGVtID0gZmluZE5leHRJdGVtKGVuYWJsZWRJdGVtcywgc2VhcmNoLCBjdXJyZW50SXRlbSk7XG4gICAgICBpZiAobmV4dEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm9uVmFsdWVDaGFuZ2UobmV4dEl0ZW0udmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZU9wZW4gPSAocG9pbnRlckV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgY29udGV4dC5vbk9wZW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgIHJlc2V0VHlwZWFoZWFkKCk7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQudHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZChwb2ludGVyRXZlbnQucGFnZVgpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQocG9pbnRlckV2ZW50LnBhZ2VZKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUG9wcGVyUHJpbWl0aXZlLkFuY2hvciwgeyBhc0NoaWxkOiB0cnVlLCAuLi5wb3BwZXJTY29wZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuYnV0dG9uLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICByb2xlOiBcImNvbWJvYm94XCIsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBjb250ZXh0LmNvbnRlbnRJZCxcbiAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IGNvbnRleHQub3BlbixcbiAgICAgICAgXCJhcmlhLXJlcXVpcmVkXCI6IGNvbnRleHQucmVxdWlyZWQsXG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJub25lXCIsXG4gICAgICAgIGRpcjogY29udGV4dC5kaXIsXG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiBjb250ZXh0Lm9wZW4gPyBcIm9wZW5cIiA6IFwiY2xvc2VkXCIsXG4gICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogaXNEaXNhYmxlZCA/IFwiXCIgOiB2b2lkIDAsXG4gICAgICAgIFwiZGF0YS1wbGFjZWhvbGRlclwiOiBzaG91bGRTaG93UGxhY2Vob2xkZXIoY29udGV4dC52YWx1ZSkgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICAuLi50cmlnZ2VyUHJvcHMsXG4gICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICBvbkNsaWNrOiBjb21wb3NlRXZlbnRIYW5kbGVycyh0cmlnZ2VyUHJvcHMub25DbGljaywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldC5mb2N1cygpO1xuICAgICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ICE9PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG9uUG9pbnRlckRvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKHRyaWdnZXJQcm9wcy5vblBvaW50ZXJEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmICh0YXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAwICYmIGV2ZW50LmN0cmxLZXkgPT09IGZhbHNlICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvbktleURvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKHRyaWdnZXJQcm9wcy5vbktleURvd24sIChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzVHlwaW5nQWhlYWQgPSBzZWFyY2hSZWYuY3VycmVudCAhPT0gXCJcIjtcbiAgICAgICAgICBjb25zdCBpc01vZGlmaWVyS2V5ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleTtcbiAgICAgICAgICBpZiAoIWlzTW9kaWZpZXJLZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSkgaGFuZGxlVHlwZWFoZWFkU2VhcmNoKGV2ZW50LmtleSk7XG4gICAgICAgICAgaWYgKGlzVHlwaW5nQWhlYWQgJiYgZXZlbnQua2V5ID09PSBcIiBcIikgcmV0dXJuO1xuICAgICAgICAgIGlmIChPUEVOX0tFWVMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgaGFuZGxlT3BlbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKSB9KTtcbiAgfVxuKTtcblNlbGVjdFRyaWdnZXIuZGlzcGxheU5hbWUgPSBUUklHR0VSX05BTUU7XG52YXIgVkFMVUVfTkFNRSA9IFwiU2VsZWN0VmFsdWVcIjtcbnZhciBTZWxlY3RWYWx1ZSA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBjbGFzc05hbWUsIHN0eWxlLCBjaGlsZHJlbiwgcGxhY2Vob2xkZXIgPSBcIlwiLCAuLi52YWx1ZVByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChWQUxVRV9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCB7IG9uVmFsdWVOb2RlSGFzQ2hpbGRyZW5DaGFuZ2UgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgaGFzQ2hpbGRyZW4gPSBjaGlsZHJlbiAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRleHQub25WYWx1ZU5vZGVDaGFuZ2UpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBvblZhbHVlTm9kZUhhc0NoaWxkcmVuQ2hhbmdlKGhhc0NoaWxkcmVuKTtcbiAgICB9LCBbb25WYWx1ZU5vZGVIYXNDaGlsZHJlbkNoYW5nZSwgaGFzQ2hpbGRyZW5dKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFByaW1pdGl2ZS5zcGFuLFxuICAgICAge1xuICAgICAgICAuLi52YWx1ZVByb3BzLFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgc3R5bGU6IHsgcG9pbnRlckV2ZW50czogXCJub25lXCIgfSxcbiAgICAgICAgY2hpbGRyZW46IHNob3VsZFNob3dQbGFjZWhvbGRlcihjb250ZXh0LnZhbHVlKSA/IC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IHBsYWNlaG9sZGVyIH0pIDogY2hpbGRyZW5cbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuU2VsZWN0VmFsdWUuZGlzcGxheU5hbWUgPSBWQUxVRV9OQU1FO1xudmFyIElDT05fTkFNRSA9IFwiU2VsZWN0SWNvblwiO1xudmFyIFNlbGVjdEljb24gPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgY2hpbGRyZW4sIC4uLmljb25Qcm9wcyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLnNwYW4sIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCAuLi5pY29uUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbjogY2hpbGRyZW4gfHwgXCJcXHUyNUJDXCIgfSk7XG4gIH1cbik7XG5TZWxlY3RJY29uLmRpc3BsYXlOYW1lID0gSUNPTl9OQU1FO1xudmFyIFBPUlRBTF9OQU1FID0gXCJTZWxlY3RQb3J0YWxcIjtcbnZhciBTZWxlY3RQb3J0YWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFsUHJpbWl0aXZlLCB7IGFzQ2hpbGQ6IHRydWUsIC4uLnByb3BzIH0pO1xufTtcblNlbGVjdFBvcnRhbC5kaXNwbGF5TmFtZSA9IFBPUlRBTF9OQU1FO1xudmFyIENPTlRFTlRfTkFNRSA9IFwiU2VsZWN0Q29udGVudFwiO1xudmFyIFNlbGVjdENvbnRlbnQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgW2ZyYWdtZW50LCBzZXRGcmFnbWVudF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBzZXRGcmFnbWVudChuZXcgRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKCFjb250ZXh0Lm9wZW4pIHtcbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudDtcbiAgICAgIHJldHVybiBmcmFnID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFNlbGVjdENvbnRlbnRQcm92aWRlciwgeyBzY29wZTogcHJvcHMuX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvbi5TbG90LCB7IHNjb3BlOiBwcm9wcy5fX3Njb3BlU2VsZWN0LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSB9KSB9KSxcbiAgICAgICAgZnJhZ1xuICAgICAgKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNlbGVjdENvbnRlbnRJbXBsLCB7IC4uLnByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KTtcbiAgfVxuKTtcblNlbGVjdENvbnRlbnQuZGlzcGxheU5hbWUgPSBDT05URU5UX05BTUU7XG52YXIgQ09OVEVOVF9NQVJHSU4gPSAxMDtcbnZhciBbU2VsZWN0Q29udGVudFByb3ZpZGVyLCB1c2VTZWxlY3RDb250ZW50Q29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSk7XG52YXIgQ09OVEVOVF9JTVBMX05BTUUgPSBcIlNlbGVjdENvbnRlbnRJbXBsXCI7XG52YXIgU2VsZWN0Q29udGVudEltcGwgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgICBwb3NpdGlvbiA9IFwiaXRlbS1hbGlnbmVkXCIsXG4gICAgICBvbkNsb3NlQXV0b0ZvY3VzLFxuICAgICAgb25Fc2NhcGVLZXlEb3duLFxuICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUsXG4gICAgICAvL1xuICAgICAgLy8gUG9wcGVyQ29udGVudCBwcm9wc1xuICAgICAgc2lkZSxcbiAgICAgIHNpZGVPZmZzZXQsXG4gICAgICBhbGlnbixcbiAgICAgIGFsaWduT2Zmc2V0LFxuICAgICAgYXJyb3dQYWRkaW5nLFxuICAgICAgY29sbGlzaW9uQm91bmRhcnksXG4gICAgICBjb2xsaXNpb25QYWRkaW5nLFxuICAgICAgc3RpY2t5LFxuICAgICAgaGlkZVdoZW5EZXRhY2hlZCxcbiAgICAgIGF2b2lkQ29sbGlzaW9ucyxcbiAgICAgIC8vXG4gICAgICAuLi5jb250ZW50UHJvcHNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoQ09OVEVOVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbdmlld3BvcnQsIHNldFZpZXdwb3J0XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlKSA9PiBzZXRDb250ZW50KG5vZGUpKTtcbiAgICBjb25zdCBbc2VsZWN0ZWRJdGVtLCBzZXRTZWxlY3RlZEl0ZW1dID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3NlbGVjdGVkSXRlbVRleHQsIHNldFNlbGVjdGVkSXRlbVRleHRdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgW2lzUG9zaXRpb25lZCwgc2V0SXNQb3NpdGlvbmVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBmaXJzdFZhbGlkSXRlbUZvdW5kUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGNvbnRlbnQpIHJldHVybiBoaWRlT3RoZXJzKGNvbnRlbnQpO1xuICAgIH0sIFtjb250ZW50XSk7XG4gICAgdXNlRm9jdXNHdWFyZHMoKTtcbiAgICBjb25zdCBmb2N1c0ZpcnN0ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAoY2FuZGlkYXRlcykgPT4ge1xuICAgICAgICBjb25zdCBbZmlyc3RJdGVtLCAuLi5yZXN0SXRlbXNdID0gZ2V0SXRlbXMoKS5tYXAoKGl0ZW0pID0+IGl0ZW0ucmVmLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCBbbGFzdEl0ZW1dID0gcmVzdEl0ZW1zLnNsaWNlKC0xKTtcbiAgICAgICAgY29uc3QgUFJFVklPVVNMWV9GT0NVU0VEX0VMRU1FTlQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gUFJFVklPVVNMWV9GT0NVU0VEX0VMRU1FTlQpIHJldHVybjtcbiAgICAgICAgICBjYW5kaWRhdGU/LnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwibmVhcmVzdFwiIH0pO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT09IGZpcnN0SXRlbSAmJiB2aWV3cG9ydCkgdmlld3BvcnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBsYXN0SXRlbSAmJiB2aWV3cG9ydCkgdmlld3BvcnQuc2Nyb2xsVG9wID0gdmlld3BvcnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIGNhbmRpZGF0ZT8uZm9jdXMoKTtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gUFJFVklPVVNMWV9GT0NVU0VEX0VMRU1FTlQpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtnZXRJdGVtcywgdmlld3BvcnRdXG4gICAgKTtcbiAgICBjb25zdCBmb2N1c1NlbGVjdGVkSXRlbSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKCkgPT4gZm9jdXNGaXJzdChbc2VsZWN0ZWRJdGVtLCBjb250ZW50XSksXG4gICAgICBbZm9jdXNGaXJzdCwgc2VsZWN0ZWRJdGVtLCBjb250ZW50XVxuICAgICk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc1Bvc2l0aW9uZWQpIHtcbiAgICAgICAgZm9jdXNTZWxlY3RlZEl0ZW0oKTtcbiAgICAgIH1cbiAgICB9LCBbaXNQb3NpdGlvbmVkLCBmb2N1c1NlbGVjdGVkSXRlbV0pO1xuICAgIGNvbnN0IHsgb25PcGVuQ2hhbmdlLCB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYgfSA9IGNvbnRleHQ7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIGxldCBwb2ludGVyTW92ZURlbHRhID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcG9pbnRlck1vdmVEZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguYWJzKE1hdGgucm91bmQoZXZlbnQucGFnZVgpIC0gKHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50Py54ID8/IDApKSxcbiAgICAgICAgICAgIHk6IE1hdGguYWJzKE1hdGgucm91bmQoZXZlbnQucGFnZVkpIC0gKHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50Py55ID8/IDApKVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChwb2ludGVyTW92ZURlbHRhLnggPD0gMTAgJiYgcG9pbnRlck1vdmVEZWx0YS55IDw9IDEwKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgIHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGhhbmRsZVBvaW50ZXJVcCwgeyBjYXB0dXJlOiB0cnVlLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGhhbmRsZVBvaW50ZXJVcCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIFtjb250ZW50LCBvbk9wZW5DaGFuZ2UsIHRyaWdnZXJQb2ludGVyRG93blBvc1JlZl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBjbG9zZSA9ICgpID0+IG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgY2xvc2UpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY2xvc2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNsb3NlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY2xvc2UpO1xuICAgICAgfTtcbiAgICB9LCBbb25PcGVuQ2hhbmdlXSk7XG4gICAgY29uc3QgW3NlYXJjaFJlZiwgaGFuZGxlVHlwZWFoZWFkU2VhcmNoXSA9IHVzZVR5cGVhaGVhZFNlYXJjaCgoc2VhcmNoKSA9PiB7XG4gICAgICBjb25zdCBlbmFibGVkSXRlbXMgPSBnZXRJdGVtcygpLmZpbHRlcigoaXRlbSkgPT4gIWl0ZW0uZGlzYWJsZWQpO1xuICAgICAgY29uc3QgY3VycmVudEl0ZW0gPSBlbmFibGVkSXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5yZWYuY3VycmVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICBjb25zdCBuZXh0SXRlbSA9IGZpbmROZXh0SXRlbShlbmFibGVkSXRlbXMsIHNlYXJjaCwgY3VycmVudEl0ZW0pO1xuICAgICAgaWYgKG5leHRJdGVtKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbmV4dEl0ZW0ucmVmLmN1cnJlbnQuZm9jdXMoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaXRlbVJlZkNhbGxiYWNrID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAobm9kZSwgdmFsdWUsIGRpc2FibGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RWYWxpZEl0ZW0gPSAhZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZi5jdXJyZW50ICYmICFkaXNhYmxlZDtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZEl0ZW0gPSBjb250ZXh0LnZhbHVlICE9PSB2b2lkIDAgJiYgY29udGV4dC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkSXRlbSB8fCBpc0ZpcnN0VmFsaWRJdGVtKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRJdGVtKG5vZGUpO1xuICAgICAgICAgIGlmIChpc0ZpcnN0VmFsaWRJdGVtKSBmaXJzdFZhbGlkSXRlbUZvdW5kUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2NvbnRleHQudmFsdWVdXG4gICAgKTtcbiAgICBjb25zdCBoYW5kbGVJdGVtTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBjb250ZW50Py5mb2N1cygpLCBbY29udGVudF0pO1xuICAgIGNvbnN0IGl0ZW1UZXh0UmVmQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIChub2RlLCB2YWx1ZSwgZGlzYWJsZWQpID0+IHtcbiAgICAgICAgY29uc3QgaXNGaXJzdFZhbGlkSXRlbSA9ICFmaXJzdFZhbGlkSXRlbUZvdW5kUmVmLmN1cnJlbnQgJiYgIWRpc2FibGVkO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkSXRlbSA9IGNvbnRleHQudmFsdWUgIT09IHZvaWQgMCAmJiBjb250ZXh0LnZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWRJdGVtIHx8IGlzRmlyc3RWYWxpZEl0ZW0pIHtcbiAgICAgICAgICBzZXRTZWxlY3RlZEl0ZW1UZXh0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2NvbnRleHQudmFsdWVdXG4gICAgKTtcbiAgICBjb25zdCBTZWxlY3RQb3NpdGlvbiA9IHBvc2l0aW9uID09PSBcInBvcHBlclwiID8gU2VsZWN0UG9wcGVyUG9zaXRpb24gOiBTZWxlY3RJdGVtQWxpZ25lZFBvc2l0aW9uO1xuICAgIGNvbnN0IHBvcHBlckNvbnRlbnRQcm9wcyA9IFNlbGVjdFBvc2l0aW9uID09PSBTZWxlY3RQb3BwZXJQb3NpdGlvbiA/IHtcbiAgICAgIHNpZGUsXG4gICAgICBzaWRlT2Zmc2V0LFxuICAgICAgYWxpZ24sXG4gICAgICBhbGlnbk9mZnNldCxcbiAgICAgIGFycm93UGFkZGluZyxcbiAgICAgIGNvbGxpc2lvbkJvdW5kYXJ5LFxuICAgICAgY29sbGlzaW9uUGFkZGluZyxcbiAgICAgIHN0aWNreSxcbiAgICAgIGhpZGVXaGVuRGV0YWNoZWQsXG4gICAgICBhdm9pZENvbGxpc2lvbnNcbiAgICB9IDoge307XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBTZWxlY3RDb250ZW50UHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBfX3Njb3BlU2VsZWN0LFxuICAgICAgICBjb250ZW50LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZTogc2V0Vmlld3BvcnQsXG4gICAgICAgIGl0ZW1SZWZDYWxsYmFjayxcbiAgICAgICAgc2VsZWN0ZWRJdGVtLFxuICAgICAgICBvbkl0ZW1MZWF2ZTogaGFuZGxlSXRlbUxlYXZlLFxuICAgICAgICBpdGVtVGV4dFJlZkNhbGxiYWNrLFxuICAgICAgICBmb2N1c1NlbGVjdGVkSXRlbSxcbiAgICAgICAgc2VsZWN0ZWRJdGVtVGV4dCxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGlzUG9zaXRpb25lZCxcbiAgICAgICAgc2VhcmNoUmVmLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSZW1vdmVTY3JvbGwsIHsgYXM6IFNsb3QsIGFsbG93UGluY2hab29tOiB0cnVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICBGb2N1c1Njb3BlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFzQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgICB0cmFwcGVkOiBjb250ZXh0Lm9wZW4sXG4gICAgICAgICAgICBvbk1vdW50QXV0b0ZvY3VzOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblVubW91bnRBdXRvRm9jdXM6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQ2xvc2VBdXRvRm9jdXMsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICBjb250ZXh0LnRyaWdnZXI/LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgIERpc21pc3NhYmxlTGF5ZXIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhc0NoaWxkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvbkVzY2FwZUtleURvd24sXG4gICAgICAgICAgICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUsXG4gICAgICAgICAgICAgICAgb25Gb2N1c091dHNpZGU6IChldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgICAgICAgICBvbkRpc21pc3M6ICgpID0+IGNvbnRleHQub25PcGVuQ2hhbmdlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgICAgIFNlbGVjdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNvbnRleHQuY29udGVudElkLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtc3RhdGVcIjogY29udGV4dC5vcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwiLFxuICAgICAgICAgICAgICAgICAgICBkaXI6IGNvbnRleHQuZGlyLFxuICAgICAgICAgICAgICAgICAgICBvbkNvbnRleHRNZW51OiAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucG9wcGVyQ29udGVudFByb3BzLFxuICAgICAgICAgICAgICAgICAgICBvblBsYWNlZDogKCkgPT4gc2V0SXNQb3NpdGlvbmVkKHRydWUpLFxuICAgICAgICAgICAgICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmbGV4IGxheW91dCBzbyB3ZSBjYW4gcGxhY2UgdGhlIHNjcm9sbCBidXR0b25zIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgb3V0bGluZSBieSBkZWZhdWx0IGFzIHRoZSBjb250ZW50IE1BWSBnZXQgZm9jdXNlZFxuICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRQcm9wcy5zdHlsZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKGNvbnRlbnRQcm9wcy5vbktleURvd24sIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTW9kaWZpZXJLZXkgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5O1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGlmaWVyS2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT09IDEpIGhhbmRsZVR5cGVhaGVhZFNlYXJjaChldmVudC5rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChbXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCIsIFwiSG9tZVwiLCBcIkVuZFwiXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdldEl0ZW1zKCkuZmlsdGVyKChpdGVtKSA9PiAhaXRlbS5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlTm9kZXMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0ucmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFtcIkFycm93VXBcIiwgXCJFbmRcIl0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVOb2RlcyA9IGNhbmRpZGF0ZU5vZGVzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFtcIkFycm93VXBcIiwgXCJBcnJvd0Rvd25cIl0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY2FuZGlkYXRlTm9kZXMuaW5kZXhPZihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU5vZGVzID0gY2FuZGlkYXRlTm9kZXMuc2xpY2UoY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGZvY3VzRmlyc3QoY2FuZGlkYXRlTm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5TZWxlY3RDb250ZW50SW1wbC5kaXNwbGF5TmFtZSA9IENPTlRFTlRfSU1QTF9OQU1FO1xudmFyIElURU1fQUxJR05FRF9QT1NJVElPTl9OQU1FID0gXCJTZWxlY3RJdGVtQWxpZ25lZFBvc2l0aW9uXCI7XG52YXIgU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBvblBsYWNlZCwgLi4ucG9wcGVyUHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChDT05URU5UX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZVNlbGVjdENvbnRlbnRDb250ZXh0KENPTlRFTlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IFtjb250ZW50V3JhcHBlciwgc2V0Q29udGVudFdyYXBwZXJdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCAobm9kZSkgPT4gc2V0Q29udGVudChub2RlKSk7XG4gIGNvbnN0IGdldEl0ZW1zID0gdXNlQ29sbGVjdGlvbihfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3Qgc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBzaG91bGRSZXBvc2l0aW9uUmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCB7IHZpZXdwb3J0LCBzZWxlY3RlZEl0ZW0sIHNlbGVjdGVkSXRlbVRleHQsIGZvY3VzU2VsZWN0ZWRJdGVtIH0gPSBjb250ZW50Q29udGV4dDtcbiAgY29uc3QgcG9zaXRpb24gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGNvbnRleHQudHJpZ2dlciAmJiBjb250ZXh0LnZhbHVlTm9kZSAmJiBjb250ZW50V3JhcHBlciAmJiBjb250ZW50ICYmIHZpZXdwb3J0ICYmIHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW1UZXh0KSB7XG4gICAgICBjb25zdCB0cmlnZ2VyUmVjdCA9IGNvbnRleHQudHJpZ2dlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHZhbHVlTm9kZVJlY3QgPSBjb250ZXh0LnZhbHVlTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGl0ZW1UZXh0UmVjdCA9IHNlbGVjdGVkSXRlbVRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoY29udGV4dC5kaXIgIT09IFwicnRsXCIpIHtcbiAgICAgICAgY29uc3QgaXRlbVRleHRPZmZzZXQgPSBpdGVtVGV4dFJlY3QubGVmdCAtIGNvbnRlbnRSZWN0LmxlZnQ7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB2YWx1ZU5vZGVSZWN0LmxlZnQgLSBpdGVtVGV4dE9mZnNldDtcbiAgICAgICAgY29uc3QgbGVmdERlbHRhID0gdHJpZ2dlclJlY3QubGVmdCAtIGxlZnQ7XG4gICAgICAgIGNvbnN0IG1pbkNvbnRlbnRXaWR0aCA9IHRyaWdnZXJSZWN0LndpZHRoICsgbGVmdERlbHRhO1xuICAgICAgICBjb25zdCBjb250ZW50V2lkdGggPSBNYXRoLm1heChtaW5Db250ZW50V2lkdGgsIGNvbnRlbnRSZWN0LndpZHRoKTtcbiAgICAgICAgY29uc3QgcmlnaHRFZGdlID0gd2luZG93LmlubmVyV2lkdGggLSBDT05URU5UX01BUkdJTjtcbiAgICAgICAgY29uc3QgY2xhbXBlZExlZnQgPSBjbGFtcChsZWZ0LCBbXG4gICAgICAgICAgQ09OVEVOVF9NQVJHSU4sXG4gICAgICAgICAgLy8gUHJldmVudHMgdGhlIGNvbnRlbnQgZnJvbSBnb2luZyBvZmYgdGhlIHN0YXJ0aW5nIGVkZ2Ugb2YgdGhlXG4gICAgICAgICAgLy8gdmlld3BvcnQuIEl0IG1heSBzdGlsbCBnbyBvZmYgdGhlIGVuZGluZyBlZGdlLCBidXQgdGhpcyBjYW4gYmVcbiAgICAgICAgICAvLyBjb250cm9sbGVkIGJ5IHRoZSB1c2VyIHNpbmNlIHRoZXkgbWF5IHdhbnQgdG8gbWFuYWdlIG92ZXJmbG93IGluIGFcbiAgICAgICAgICAvLyBzcGVjaWZpYyB3YXkuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JhZGl4LXVpL3ByaW1pdGl2ZXMvaXNzdWVzLzIwNDlcbiAgICAgICAgICBNYXRoLm1heChDT05URU5UX01BUkdJTiwgcmlnaHRFZGdlIC0gY29udGVudFdpZHRoKVxuICAgICAgICBdKTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUubWluV2lkdGggPSBtaW5Db250ZW50V2lkdGggKyBcInB4XCI7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmxlZnQgPSBjbGFtcGVkTGVmdCArIFwicHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGl0ZW1UZXh0T2Zmc2V0ID0gY29udGVudFJlY3QucmlnaHQgLSBpdGVtVGV4dFJlY3QucmlnaHQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSB2YWx1ZU5vZGVSZWN0LnJpZ2h0IC0gaXRlbVRleHRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0RGVsdGEgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIHRyaWdnZXJSZWN0LnJpZ2h0IC0gcmlnaHQ7XG4gICAgICAgIGNvbnN0IG1pbkNvbnRlbnRXaWR0aCA9IHRyaWdnZXJSZWN0LndpZHRoICsgcmlnaHREZWx0YTtcbiAgICAgICAgY29uc3QgY29udGVudFdpZHRoID0gTWF0aC5tYXgobWluQ29udGVudFdpZHRoLCBjb250ZW50UmVjdC53aWR0aCk7XG4gICAgICAgIGNvbnN0IGxlZnRFZGdlID0gd2luZG93LmlubmVyV2lkdGggLSBDT05URU5UX01BUkdJTjtcbiAgICAgICAgY29uc3QgY2xhbXBlZFJpZ2h0ID0gY2xhbXAocmlnaHQsIFtcbiAgICAgICAgICBDT05URU5UX01BUkdJTixcbiAgICAgICAgICBNYXRoLm1heChDT05URU5UX01BUkdJTiwgbGVmdEVkZ2UgLSBjb250ZW50V2lkdGgpXG4gICAgICAgIF0pO1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5taW5XaWR0aCA9IG1pbkNvbnRlbnRXaWR0aCArIFwicHhcIjtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUucmlnaHQgPSBjbGFtcGVkUmlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGdldEl0ZW1zKCk7XG4gICAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBDT05URU5UX01BUkdJTiAqIDI7XG4gICAgICBjb25zdCBpdGVtc0hlaWdodCA9IHZpZXdwb3J0LnNjcm9sbEhlaWdodDtcbiAgICAgIGNvbnN0IGNvbnRlbnRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50KTtcbiAgICAgIGNvbnN0IGNvbnRlbnRCb3JkZXJUb3BXaWR0aCA9IHBhcnNlSW50KGNvbnRlbnRTdHlsZXMuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRQYWRkaW5nVG9wID0gcGFyc2VJbnQoY29udGVudFN0eWxlcy5wYWRkaW5nVG9wLCAxMCk7XG4gICAgICBjb25zdCBjb250ZW50Qm9yZGVyQm90dG9tV2lkdGggPSBwYXJzZUludChjb250ZW50U3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoLCAxMCk7XG4gICAgICBjb25zdCBjb250ZW50UGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KGNvbnRlbnRTdHlsZXMucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgICAgY29uc3QgZnVsbENvbnRlbnRIZWlnaHQgPSBjb250ZW50Qm9yZGVyVG9wV2lkdGggKyBjb250ZW50UGFkZGluZ1RvcCArIGl0ZW1zSGVpZ2h0ICsgY29udGVudFBhZGRpbmdCb3R0b20gKyBjb250ZW50Qm9yZGVyQm90dG9tV2lkdGg7XG4gICAgICBjb25zdCBtaW5Db250ZW50SGVpZ2h0ID0gTWF0aC5taW4oc2VsZWN0ZWRJdGVtLm9mZnNldEhlaWdodCAqIDUsIGZ1bGxDb250ZW50SGVpZ2h0KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlld3BvcnQpO1xuICAgICAgY29uc3Qgdmlld3BvcnRQYWRkaW5nVG9wID0gcGFyc2VJbnQodmlld3BvcnRTdHlsZXMucGFkZGluZ1RvcCwgMTApO1xuICAgICAgY29uc3Qgdmlld3BvcnRQYWRkaW5nQm90dG9tID0gcGFyc2VJbnQodmlld3BvcnRTdHlsZXMucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgICAgY29uc3QgdG9wRWRnZVRvVHJpZ2dlck1pZGRsZSA9IHRyaWdnZXJSZWN0LnRvcCArIHRyaWdnZXJSZWN0LmhlaWdodCAvIDIgLSBDT05URU5UX01BUkdJTjtcbiAgICAgIGNvbnN0IHRyaWdnZXJNaWRkbGVUb0JvdHRvbUVkZ2UgPSBhdmFpbGFibGVIZWlnaHQgLSB0b3BFZGdlVG9UcmlnZ2VyTWlkZGxlO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodCA9IHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgY29uc3QgaXRlbU9mZnNldE1pZGRsZSA9IHNlbGVjdGVkSXRlbS5vZmZzZXRUb3AgKyBzZWxlY3RlZEl0ZW1IYWxmSGVpZ2h0O1xuICAgICAgY29uc3QgY29udGVudFRvcFRvSXRlbU1pZGRsZSA9IGNvbnRlbnRCb3JkZXJUb3BXaWR0aCArIGNvbnRlbnRQYWRkaW5nVG9wICsgaXRlbU9mZnNldE1pZGRsZTtcbiAgICAgIGNvbnN0IGl0ZW1NaWRkbGVUb0NvbnRlbnRCb3R0b20gPSBmdWxsQ29udGVudEhlaWdodCAtIGNvbnRlbnRUb3BUb0l0ZW1NaWRkbGU7XG4gICAgICBjb25zdCB3aWxsQWxpZ25XaXRob3V0VG9wT3ZlcmZsb3cgPSBjb250ZW50VG9wVG9JdGVtTWlkZGxlIDw9IHRvcEVkZ2VUb1RyaWdnZXJNaWRkbGU7XG4gICAgICBpZiAod2lsbEFsaWduV2l0aG91dFRvcE92ZXJmbG93KSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdEl0ZW0gPSBpdGVtcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSXRlbSA9PT0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0ucmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0T2Zmc2V0Qm90dG9tID0gY29udGVudC5jbGllbnRIZWlnaHQgLSB2aWV3cG9ydC5vZmZzZXRUb3AgLSB2aWV3cG9ydC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNsYW1wZWRUcmlnZ2VyTWlkZGxlVG9Cb3R0b21FZGdlID0gTWF0aC5tYXgoXG4gICAgICAgICAgdHJpZ2dlck1pZGRsZVRvQm90dG9tRWRnZSxcbiAgICAgICAgICBzZWxlY3RlZEl0ZW1IYWxmSGVpZ2h0ICsgLy8gdmlld3BvcnQgbWlnaHQgaGF2ZSBwYWRkaW5nIGJvdHRvbSwgaW5jbHVkZSBpdCB0byBhdm9pZCBhIHNjcm9sbGFibGUgdmlld3BvcnRcbiAgICAgICAgICAoaXNMYXN0SXRlbSA/IHZpZXdwb3J0UGFkZGluZ0JvdHRvbSA6IDApICsgdmlld3BvcnRPZmZzZXRCb3R0b20gKyBjb250ZW50Qm9yZGVyQm90dG9tV2lkdGhcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGVudFRvcFRvSXRlbU1pZGRsZSArIGNsYW1wZWRUcmlnZ2VyTWlkZGxlVG9Cb3R0b21FZGdlO1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpc0ZpcnN0SXRlbSA9IGl0ZW1zLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRJdGVtID09PSBpdGVtc1swXS5yZWYuY3VycmVudDtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgY29uc3QgY2xhbXBlZFRvcEVkZ2VUb1RyaWdnZXJNaWRkbGUgPSBNYXRoLm1heChcbiAgICAgICAgICB0b3BFZGdlVG9UcmlnZ2VyTWlkZGxlLFxuICAgICAgICAgIGNvbnRlbnRCb3JkZXJUb3BXaWR0aCArIHZpZXdwb3J0Lm9mZnNldFRvcCArIC8vIHZpZXdwb3J0IG1pZ2h0IGhhdmUgcGFkZGluZyB0b3AsIGluY2x1ZGUgaXQgdG8gYXZvaWQgYSBzY3JvbGxhYmxlIHZpZXdwb3J0XG4gICAgICAgICAgKGlzRmlyc3RJdGVtID8gdmlld3BvcnRQYWRkaW5nVG9wIDogMCkgKyBzZWxlY3RlZEl0ZW1IYWxmSGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNsYW1wZWRUb3BFZGdlVG9UcmlnZ2VyTWlkZGxlICsgaXRlbU1pZGRsZVRvQ29udGVudEJvdHRvbTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB2aWV3cG9ydC5zY3JvbGxUb3AgPSBjb250ZW50VG9wVG9JdGVtTWlkZGxlIC0gdG9wRWRnZVRvVHJpZ2dlck1pZGRsZSArIHZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1hcmdpbiA9IGAke0NPTlRFTlRfTUFSR0lOfXB4IDBgO1xuICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUubWluSGVpZ2h0ID0gbWluQ29udGVudEhlaWdodCArIFwicHhcIjtcbiAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1heEhlaWdodCA9IGF2YWlsYWJsZUhlaWdodCArIFwicHhcIjtcbiAgICAgIG9uUGxhY2VkPy4oKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBzaG91bGRFeHBhbmRPblNjcm9sbFJlZi5jdXJyZW50ID0gdHJ1ZSk7XG4gICAgfVxuICB9LCBbXG4gICAgZ2V0SXRlbXMsXG4gICAgY29udGV4dC50cmlnZ2VyLFxuICAgIGNvbnRleHQudmFsdWVOb2RlLFxuICAgIGNvbnRlbnRXcmFwcGVyLFxuICAgIGNvbnRlbnQsXG4gICAgdmlld3BvcnQsXG4gICAgc2VsZWN0ZWRJdGVtLFxuICAgIHNlbGVjdGVkSXRlbVRleHQsXG4gICAgY29udGV4dC5kaXIsXG4gICAgb25QbGFjZWRcbiAgXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiBwb3NpdGlvbigpLCBbcG9zaXRpb25dKTtcbiAgY29uc3QgW2NvbnRlbnRaSW5kZXgsIHNldENvbnRlbnRaSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29udGVudCkgc2V0Q29udGVudFpJbmRleCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50KS56SW5kZXgpO1xuICB9LCBbY29udGVudF0pO1xuICBjb25zdCBoYW5kbGVTY3JvbGxCdXR0b25DaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUgJiYgc2hvdWxkUmVwb3NpdGlvblJlZi5jdXJyZW50ID09PSB0cnVlKSB7XG4gICAgICAgIHBvc2l0aW9uKCk7XG4gICAgICAgIGZvY3VzU2VsZWN0ZWRJdGVtPy4oKTtcbiAgICAgICAgc2hvdWxkUmVwb3NpdGlvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcG9zaXRpb24sIGZvY3VzU2VsZWN0ZWRJdGVtXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTZWxlY3RWaWV3cG9ydFByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHNjb3BlOiBfX3Njb3BlU2VsZWN0LFxuICAgICAgY29udGVudFdyYXBwZXIsXG4gICAgICBzaG91bGRFeHBhbmRPblNjcm9sbFJlZixcbiAgICAgIG9uU2Nyb2xsQnV0dG9uQ2hhbmdlOiBoYW5kbGVTY3JvbGxCdXR0b25DaGFuZ2UsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogc2V0Q29udGVudFdyYXBwZXIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgICAgICB6SW5kZXg6IGNvbnRlbnRaSW5kZXhcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgUHJpbWl0aXZlLmRpdixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4ucG9wcGVyUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgZ2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRlbnQsIGl0IGluY2x1ZGVzIGJvcmRlcnMuIElmIHdlIHdlcmUgdG8gc2V0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGhlaWdodCB3aXRob3V0IGhhdmluZyBgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdgIGl0IHdvdWxkIGJlIHRvbyBiaWcuXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgY29udGVudCBkb2Vzbid0IGdldCB0YWxsZXIgdGhhbiB0aGUgd3JhcHBlclxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgLi4ucG9wcGVyUHJvcHMuc3R5bGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgKTtcbn0pO1xuU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvbi5kaXNwbGF5TmFtZSA9IElURU1fQUxJR05FRF9QT1NJVElPTl9OQU1FO1xudmFyIFBPUFBFUl9QT1NJVElPTl9OQU1FID0gXCJTZWxlY3RQb3BwZXJQb3NpdGlvblwiO1xudmFyIFNlbGVjdFBvcHBlclBvc2l0aW9uID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgX19zY29wZVNlbGVjdCxcbiAgICBhbGlnbiA9IFwic3RhcnRcIixcbiAgICBjb2xsaXNpb25QYWRkaW5nID0gQ09OVEVOVF9NQVJHSU4sXG4gICAgLi4ucG9wcGVyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBQb3BwZXJQcmltaXRpdmUuQ29udGVudCxcbiAgICB7XG4gICAgICAuLi5wb3BwZXJTY29wZSxcbiAgICAgIC4uLnBvcHBlclByb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICBhbGlnbixcbiAgICAgIGNvbGxpc2lvblBhZGRpbmcsXG4gICAgICBzdHlsZToge1xuICAgICAgICAvLyBFbnN1cmUgYm9yZGVyLWJveCBmb3IgZmxvYXRpbmctdWkgY2FsY3VsYXRpb25zXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIC4uLnBvcHBlclByb3BzLnN0eWxlLFxuICAgICAgICAvLyByZS1uYW1lc3BhY2UgZXhwb3NlZCBjb250ZW50IGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgICAgIC4uLntcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LWNvbnRlbnQtdHJhbnNmb3JtLW9yaWdpblwiOiBcInZhcigtLXJhZGl4LXBvcHBlci10cmFuc2Zvcm0tb3JpZ2luKVwiLFxuICAgICAgICAgIFwiLS1yYWRpeC1zZWxlY3QtY29udGVudC1hdmFpbGFibGUtd2lkdGhcIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLXdpZHRoKVwiLFxuICAgICAgICAgIFwiLS1yYWRpeC1zZWxlY3QtY29udGVudC1hdmFpbGFibGUtaGVpZ2h0XCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS1oZWlnaHQpXCIsXG4gICAgICAgICAgXCItLXJhZGl4LXNlbGVjdC10cmlnZ2VyLXdpZHRoXCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWFuY2hvci13aWR0aClcIixcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LXRyaWdnZXItaGVpZ2h0XCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWFuY2hvci1oZWlnaHQpXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbn0pO1xuU2VsZWN0UG9wcGVyUG9zaXRpb24uZGlzcGxheU5hbWUgPSBQT1BQRVJfUE9TSVRJT05fTkFNRTtcbnZhciBbU2VsZWN0Vmlld3BvcnRQcm92aWRlciwgdXNlU2VsZWN0Vmlld3BvcnRDb250ZXh0XSA9IGNyZWF0ZVNlbGVjdENvbnRleHQoQ09OVEVOVF9OQU1FLCB7fSk7XG52YXIgVklFV1BPUlRfTkFNRSA9IFwiU2VsZWN0Vmlld3BvcnRcIjtcbnZhciBTZWxlY3RWaWV3cG9ydCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBub25jZSwgLi4udmlld3BvcnRQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChWSUVXUE9SVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCB2aWV3cG9ydENvbnRleHQgPSB1c2VTZWxlY3RWaWV3cG9ydENvbnRleHQoVklFV1BPUlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgY29udGVudENvbnRleHQub25WaWV3cG9ydENoYW5nZSk7XG4gICAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFwic3R5bGVcIixcbiAgICAgICAge1xuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IGBbZGF0YS1yYWRpeC1zZWxlY3Qtdmlld3BvcnRde3Njcm9sbGJhci13aWR0aDpub25lOy1tcy1vdmVyZmxvdy1zdHlsZTpub25lOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO31bZGF0YS1yYWRpeC1zZWxlY3Qtdmlld3BvcnRdOjotd2Via2l0LXNjcm9sbGJhcntkaXNwbGF5Om5vbmV9YFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbm9uY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvbi5TbG90LCB7IHNjb3BlOiBfX3Njb3BlU2VsZWN0LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgUHJpbWl0aXZlLmRpdixcbiAgICAgICAge1xuICAgICAgICAgIFwiZGF0YS1yYWRpeC1zZWxlY3Qtdmlld3BvcnRcIjogXCJcIixcbiAgICAgICAgICByb2xlOiBcInByZXNlbnRhdGlvblwiLFxuICAgICAgICAgIC4uLnZpZXdwb3J0UHJvcHMsXG4gICAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC8vIHdlIHVzZSBwb3NpdGlvbjogJ3JlbGF0aXZlJyBoZXJlIG9uIHRoZSBgdmlld3BvcnRgIHNvIHRoYXQgd2hlbiB3ZSBjYWxsXG4gICAgICAgICAgICAvLyBgc2VsZWN0ZWRJdGVtLm9mZnNldFRvcGAgaW4gY2FsY3VsYXRpb25zLCB0aGUgb2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgLy8gKGluZGVwZW5kZW50IG9mIHRoZSBzY3JvbGxVcEJ1dHRvbikuXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgIC8vIFZpZXdwb3J0IHNob3VsZCBvbmx5IGJlIHNjcm9sbGFibGUgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgd29uJ3Qgd29yayBpbiB2ZXJ0aWNhbCB3cml0aW5nIG1vZGVzLCBzbyB3ZSdsbCBuZWVkIHRvXG4gICAgICAgICAgICAvLyByZXZpc2l0IHRoaXMgaWYvd2hlbiB0aGF0IGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9ibG9nL3ZlcnRpY2FsLWZvcm0tY29udHJvbHNcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICAgICAgICAuLi52aWV3cG9ydFByb3BzLnN0eWxlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblNjcm9sbDogY29tcG9zZUV2ZW50SGFuZGxlcnModmlld3BvcnRQcm9wcy5vblNjcm9sbCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRlbnRXcmFwcGVyLCBzaG91bGRFeHBhbmRPblNjcm9sbFJlZiB9ID0gdmlld3BvcnRDb250ZXh0O1xuICAgICAgICAgICAgaWYgKHNob3VsZEV4cGFuZE9uU2Nyb2xsUmVmPy5jdXJyZW50ICYmIGNvbnRlbnRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjcm9sbGVkQnkgPSBNYXRoLmFicyhwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgLSB2aWV3cG9ydC5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgICBpZiAoc2Nyb2xsZWRCeSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBDT05URU5UX01BUkdJTiAqIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgY3NzTWluSGVpZ2h0ID0gcGFyc2VGbG9hdChjb250ZW50V3JhcHBlci5zdHlsZS5taW5IZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzc0hlaWdodCA9IHBhcnNlRmxvYXQoY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gTWF0aC5tYXgoY3NzTWluSGVpZ2h0LCBjc3NIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2SGVpZ2h0IDwgYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SGVpZ2h0ID0gcHJldkhlaWdodCArIHNjcm9sbGVkQnk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjbGFtcGVkTmV4dEhlaWdodCA9IE1hdGgubWluKGF2YWlsYWJsZUhlaWdodCwgbmV4dEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHREaWZmID0gbmV4dEhlaWdodCAtIGNsYW1wZWROZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gY2xhbXBlZE5leHRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGVudFdyYXBwZXIuc3R5bGUuYm90dG9tID09PSBcIjBweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0LnNjcm9sbFRvcCA9IGhlaWdodERpZmYgPiAwID8gaGVpZ2h0RGlmZiA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJmbGV4LWVuZFwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gdmlld3BvcnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICkgfSlcbiAgICBdIH0pO1xuICB9XG4pO1xuU2VsZWN0Vmlld3BvcnQuZGlzcGxheU5hbWUgPSBWSUVXUE9SVF9OQU1FO1xudmFyIEdST1VQX05BTUUgPSBcIlNlbGVjdEdyb3VwXCI7XG52YXIgW1NlbGVjdEdyb3VwQ29udGV4dFByb3ZpZGVyLCB1c2VTZWxlY3RHcm91cENvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChHUk9VUF9OQU1FKTtcbnZhciBTZWxlY3RHcm91cCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5ncm91cFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBncm91cElkID0gdXNlSWQoKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RHcm91cENvbnRleHRQcm92aWRlciwgeyBzY29wZTogX19zY29wZVNlbGVjdCwgaWQ6IGdyb3VwSWQsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgcm9sZTogXCJncm91cFwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBncm91cElkLCAuLi5ncm91cFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KSB9KTtcbiAgfVxuKTtcblNlbGVjdEdyb3VwLmRpc3BsYXlOYW1lID0gR1JPVVBfTkFNRTtcbnZhciBMQUJFTF9OQU1FID0gXCJTZWxlY3RMYWJlbFwiO1xudmFyIFNlbGVjdExhYmVsID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLmxhYmVsUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGdyb3VwQ29udGV4dCA9IHVzZVNlbGVjdEdyb3VwQ29udGV4dChMQUJFTF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IGlkOiBncm91cENvbnRleHQuaWQsIC4uLmxhYmVsUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pO1xuICB9XG4pO1xuU2VsZWN0TGFiZWwuZGlzcGxheU5hbWUgPSBMQUJFTF9OQU1FO1xudmFyIElURU1fTkFNRSA9IFwiU2VsZWN0SXRlbVwiO1xudmFyIFtTZWxlY3RJdGVtQ29udGV4dFByb3ZpZGVyLCB1c2VTZWxlY3RJdGVtQ29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KElURU1fTkFNRSk7XG52YXIgU2VsZWN0SXRlbSA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX19zY29wZVNlbGVjdCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlUHJvcCxcbiAgICAgIC4uLml0ZW1Qcm9wc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChJVEVNX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoSVRFTV9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY29udGV4dC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgY29uc3QgW3RleHRWYWx1ZSwgc2V0VGV4dFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKHRleHRWYWx1ZVByb3AgPz8gXCJcIik7XG4gICAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoXG4gICAgICBmb3J3YXJkZWRSZWYsXG4gICAgICAobm9kZSkgPT4gY29udGVudENvbnRleHQuaXRlbVJlZkNhbGxiYWNrPy4obm9kZSwgdmFsdWUsIGRpc2FibGVkKVxuICAgICk7XG4gICAgY29uc3QgdGV4dElkID0gdXNlSWQoKTtcbiAgICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZihcInRvdWNoXCIpO1xuICAgIGNvbnN0IGhhbmRsZVNlbGVjdCA9ICgpID0+IHtcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgY29udGV4dC5vblZhbHVlQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgY29udGV4dC5vbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQSA8U2VsZWN0Lkl0ZW0gLz4gbXVzdCBoYXZlIGEgdmFsdWUgcHJvcCB0aGF0IGlzIG5vdCBhbiBlbXB0eSBzdHJpbmcuIFRoaXMgaXMgYmVjYXVzZSB0aGUgU2VsZWN0IHZhbHVlIGNhbiBiZSBzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBzZWxlY3Rpb24gYW5kIHNob3cgdGhlIHBsYWNlaG9sZGVyLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFNlbGVjdEl0ZW1Db250ZXh0UHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBfX3Njb3BlU2VsZWN0LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIHRleHRJZCxcbiAgICAgICAgaXNTZWxlY3RlZCxcbiAgICAgICAgb25JdGVtVGV4dENoYW5nZTogUmVhY3QudXNlQ2FsbGJhY2soKG5vZGUpID0+IHtcbiAgICAgICAgICBzZXRUZXh0VmFsdWUoKHByZXZUZXh0VmFsdWUpID0+IHByZXZUZXh0VmFsdWUgfHwgKG5vZGU/LnRleHRDb250ZW50ID8/IFwiXCIpLnRyaW0oKSk7XG4gICAgICAgIH0sIFtdKSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgQ29sbGVjdGlvbi5JdGVtU2xvdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICB0ZXh0VmFsdWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgUHJpbWl0aXZlLmRpdixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJvbGU6IFwib3B0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogdGV4dElkLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1oaWdobGlnaHRlZFwiOiBpc0ZvY3VzZWQgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc1NlbGVjdGVkICYmIGlzRm9jdXNlZCxcbiAgICAgICAgICAgICAgICBcImRhdGEtc3RhdGVcIjogaXNTZWxlY3RlZCA/IFwiY2hlY2tlZFwiIDogXCJ1bmNoZWNrZWRcIixcbiAgICAgICAgICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/IFwiXCIgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdGFiSW5kZXg6IGRpc2FibGVkID8gdm9pZCAwIDogLTEsXG4gICAgICAgICAgICAgICAgLi4uaXRlbVByb3BzLFxuICAgICAgICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vbkZvY3VzLCAoKSA9PiBzZXRJc0ZvY3VzZWQodHJ1ZSkpLFxuICAgICAgICAgICAgICAgIG9uQmx1cjogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uQmx1ciwgKCkgPT4gc2V0SXNGb2N1c2VkKGZhbHNlKSksXG4gICAgICAgICAgICAgICAgb25DbGljazogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uQ2xpY2ssICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ICE9PSBcIm1vdXNlXCIpIGhhbmRsZVNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlclVwOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyVXAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSBcIm1vdXNlXCIpIGhhbmRsZVNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckRvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vblBvaW50ZXJEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvblBvaW50ZXJNb3ZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyTW92ZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudENvbnRleHQub25JdGVtTGVhdmU/LigpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb25Qb2ludGVyTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vblBvaW50ZXJMZWF2ZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Q29udGV4dC5vbkl0ZW1MZWF2ZT8uKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb25LZXlEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25LZXlEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVHlwaW5nQWhlYWQgPSBjb250ZW50Q29udGV4dC5zZWFyY2hSZWY/LmN1cnJlbnQgIT09IFwiXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNUeXBpbmdBaGVhZCAmJiBldmVudC5rZXkgPT09IFwiIFwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICBpZiAoU0VMRUNUSU9OX0tFWVMuaW5jbHVkZXMoZXZlbnQua2V5KSkgaGFuZGxlU2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIiBcIikgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblNlbGVjdEl0ZW0uZGlzcGxheU5hbWUgPSBJVEVNX05BTUU7XG52YXIgSVRFTV9URVhUX05BTUUgPSBcIlNlbGVjdEl0ZW1UZXh0XCI7XG52YXIgU2VsZWN0SXRlbVRleHQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgY2xhc3NOYW1lLCBzdHlsZSwgLi4uaXRlbVRleHRQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGl0ZW1Db250ZXh0ID0gdXNlU2VsZWN0SXRlbUNvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IG5hdGl2ZU9wdGlvbnNDb250ZXh0ID0gdXNlU2VsZWN0TmF0aXZlT3B0aW9uc0NvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IFtpdGVtVGV4dE5vZGUsIHNldEl0ZW1UZXh0Tm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoXG4gICAgICBmb3J3YXJkZWRSZWYsXG4gICAgICAobm9kZSkgPT4gc2V0SXRlbVRleHROb2RlKG5vZGUpLFxuICAgICAgaXRlbUNvbnRleHQub25JdGVtVGV4dENoYW5nZSxcbiAgICAgIChub2RlKSA9PiBjb250ZW50Q29udGV4dC5pdGVtVGV4dFJlZkNhbGxiYWNrPy4obm9kZSwgaXRlbUNvbnRleHQudmFsdWUsIGl0ZW1Db250ZXh0LmRpc2FibGVkKVxuICAgICk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBpdGVtVGV4dE5vZGU/LnRleHRDb250ZW50O1xuICAgIGNvbnN0IG5hdGl2ZU9wdGlvbiA9IFJlYWN0LnVzZU1lbW8oXG4gICAgICAoKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwib3B0aW9uXCIsIHsgdmFsdWU6IGl0ZW1Db250ZXh0LnZhbHVlLCBkaXNhYmxlZDogaXRlbUNvbnRleHQuZGlzYWJsZWQsIGNoaWxkcmVuOiB0ZXh0Q29udGVudCB9LCBpdGVtQ29udGV4dC52YWx1ZSksXG4gICAgICBbaXRlbUNvbnRleHQuZGlzYWJsZWQsIGl0ZW1Db250ZXh0LnZhbHVlLCB0ZXh0Q29udGVudF1cbiAgICApO1xuICAgIGNvbnN0IHsgb25OYXRpdmVPcHRpb25BZGQsIG9uTmF0aXZlT3B0aW9uUmVtb3ZlIH0gPSBuYXRpdmVPcHRpb25zQ29udGV4dDtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgb25OYXRpdmVPcHRpb25BZGQobmF0aXZlT3B0aW9uKTtcbiAgICAgIHJldHVybiAoKSA9PiBvbk5hdGl2ZU9wdGlvblJlbW92ZShuYXRpdmVPcHRpb24pO1xuICAgIH0sIFtvbk5hdGl2ZU9wdGlvbkFkZCwgb25OYXRpdmVPcHRpb25SZW1vdmUsIG5hdGl2ZU9wdGlvbl0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuc3BhbiwgeyBpZDogaXRlbUNvbnRleHQudGV4dElkLCAuLi5pdGVtVGV4dFByb3BzLCByZWY6IGNvbXBvc2VkUmVmcyB9KSxcbiAgICAgIGl0ZW1Db250ZXh0LmlzU2VsZWN0ZWQgJiYgY29udGV4dC52YWx1ZU5vZGUgJiYgIWNvbnRleHQudmFsdWVOb2RlSGFzQ2hpbGRyZW4gPyBSZWFjdERPTS5jcmVhdGVQb3J0YWwoaXRlbVRleHRQcm9wcy5jaGlsZHJlbiwgY29udGV4dC52YWx1ZU5vZGUpIDogbnVsbFxuICAgIF0gfSk7XG4gIH1cbik7XG5TZWxlY3RJdGVtVGV4dC5kaXNwbGF5TmFtZSA9IElURU1fVEVYVF9OQU1FO1xudmFyIElURU1fSU5ESUNBVE9SX05BTUUgPSBcIlNlbGVjdEl0ZW1JbmRpY2F0b3JcIjtcbnZhciBTZWxlY3RJdGVtSW5kaWNhdG9yID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLml0ZW1JbmRpY2F0b3JQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXRlbUNvbnRleHQgPSB1c2VTZWxlY3RJdGVtQ29udGV4dChJVEVNX0lORElDQVRPUl9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICByZXR1cm4gaXRlbUNvbnRleHQuaXNTZWxlY3RlZCA/IC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLnNwYW4sIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCAuLi5pdGVtSW5kaWNhdG9yUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pIDogbnVsbDtcbiAgfVxuKTtcblNlbGVjdEl0ZW1JbmRpY2F0b3IuZGlzcGxheU5hbWUgPSBJVEVNX0lORElDQVRPUl9OQU1FO1xudmFyIFNDUk9MTF9VUF9CVVRUT05fTkFNRSA9IFwiU2VsZWN0U2Nyb2xsVXBCdXR0b25cIjtcbnZhciBTZWxlY3RTY3JvbGxVcEJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChTQ1JPTExfVVBfQlVUVE9OX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCB2aWV3cG9ydENvbnRleHQgPSB1c2VTZWxlY3RWaWV3cG9ydENvbnRleHQoU0NST0xMX1VQX0JVVFRPTl9OQU1FLCBwcm9wcy5fX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgW2NhblNjcm9sbFVwLCBzZXRDYW5TY3JvbGxVcF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHZpZXdwb3J0Q29udGV4dC5vblNjcm9sbEJ1dHRvbkNoYW5nZSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnRDb250ZXh0LnZpZXdwb3J0ICYmIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZCkge1xuICAgICAgbGV0IGhhbmRsZVNjcm9sbDIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgY2FuU2Nyb2xsVXAyID0gdmlld3BvcnQuc2Nyb2xsVG9wID4gMDtcbiAgICAgICAgc2V0Q2FuU2Nyb2xsVXAoY2FuU2Nyb2xsVXAyKTtcbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlU2Nyb2xsID0gaGFuZGxlU2Nyb2xsMjtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gY29udGVudENvbnRleHQudmlld3BvcnQ7XG4gICAgICBoYW5kbGVTY3JvbGwyKCk7XG4gICAgICB2aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbDIpO1xuICAgICAgcmV0dXJuICgpID0+IHZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsMik7XG4gICAgfVxuICB9LCBbY29udGVudENvbnRleHQudmlld3BvcnQsIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZF0pO1xuICByZXR1cm4gY2FuU2Nyb2xsVXAgPyAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFNlbGVjdFNjcm9sbEJ1dHRvbkltcGwsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgIG9uQXV0b1Njcm9sbDogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHZpZXdwb3J0LCBzZWxlY3RlZEl0ZW0gfSA9IGNvbnRlbnRDb250ZXh0O1xuICAgICAgICBpZiAodmlld3BvcnQgJiYgc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgdmlld3BvcnQuc2Nyb2xsVG9wID0gdmlld3BvcnQuc2Nyb2xsVG9wIC0gc2VsZWN0ZWRJdGVtLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKSA6IG51bGw7XG59KTtcblNlbGVjdFNjcm9sbFVwQnV0dG9uLmRpc3BsYXlOYW1lID0gU0NST0xMX1VQX0JVVFRPTl9OQU1FO1xudmFyIFNDUk9MTF9ET1dOX0JVVFRPTl9OQU1FID0gXCJTZWxlY3RTY3JvbGxEb3duQnV0dG9uXCI7XG52YXIgU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChTQ1JPTExfRE9XTl9CVVRUT05fTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IHZpZXdwb3J0Q29udGV4dCA9IHVzZVNlbGVjdFZpZXdwb3J0Q29udGV4dChTQ1JPTExfRE9XTl9CVVRUT05fTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IFtjYW5TY3JvbGxEb3duLCBzZXRDYW5TY3JvbGxEb3duXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgdmlld3BvcnRDb250ZXh0Lm9uU2Nyb2xsQnV0dG9uQ2hhbmdlKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29udGVudENvbnRleHQudmlld3BvcnQgJiYgY29udGVudENvbnRleHQuaXNQb3NpdGlvbmVkKSB7XG4gICAgICBsZXQgaGFuZGxlU2Nyb2xsMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSB2aWV3cG9ydC5zY3JvbGxIZWlnaHQgLSB2aWV3cG9ydC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNhblNjcm9sbERvd24yID0gTWF0aC5jZWlsKHZpZXdwb3J0LnNjcm9sbFRvcCkgPCBtYXhTY3JvbGw7XG4gICAgICAgIHNldENhblNjcm9sbERvd24oY2FuU2Nyb2xsRG93bjIpO1xuICAgICAgfTtcbiAgICAgIHZhciBoYW5kbGVTY3JvbGwgPSBoYW5kbGVTY3JvbGwyO1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSBjb250ZW50Q29udGV4dC52aWV3cG9ydDtcbiAgICAgIGhhbmRsZVNjcm9sbDIoKTtcbiAgICAgIHZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsMik7XG4gICAgICByZXR1cm4gKCkgPT4gdmlld3BvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwyKTtcbiAgICB9XG4gIH0sIFtjb250ZW50Q29udGV4dC52aWV3cG9ydCwgY29udGVudENvbnRleHQuaXNQb3NpdGlvbmVkXSk7XG4gIHJldHVybiBjYW5TY3JvbGxEb3duID8gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTZWxlY3RTY3JvbGxCdXR0b25JbXBsLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICBvbkF1dG9TY3JvbGw6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyB2aWV3cG9ydCwgc2VsZWN0ZWRJdGVtIH0gPSBjb250ZW50Q29udGV4dDtcbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgIHZpZXdwb3J0LnNjcm9sbFRvcCA9IHZpZXdwb3J0LnNjcm9sbFRvcCArIHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsO1xufSk7XG5TZWxlY3RTY3JvbGxEb3duQnV0dG9uLmRpc3BsYXlOYW1lID0gU0NST0xMX0RPV05fQlVUVE9OX05BTUU7XG52YXIgU2VsZWN0U2Nyb2xsQnV0dG9uSW1wbCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBvbkF1dG9TY3JvbGwsIC4uLnNjcm9sbEluZGljYXRvclByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChcIlNlbGVjdFNjcm9sbEJ1dHRvblwiLCBfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgYXV0b1Njcm9sbFRpbWVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IGNsZWFyQXV0b1Njcm9sbFRpbWVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhdXRvU2Nyb2xsVGltZXJSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBjbGVhckF1dG9TY3JvbGxUaW1lcigpO1xuICB9LCBbY2xlYXJBdXRvU2Nyb2xsVGltZXJdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0SXRlbXMoKS5maW5kKChpdGVtKSA9PiBpdGVtLnJlZi5jdXJyZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICBhY3RpdmVJdGVtPy5yZWYuY3VycmVudD8uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogXCJuZWFyZXN0XCIgfSk7XG4gIH0sIFtnZXRJdGVtc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBQcmltaXRpdmUuZGl2LFxuICAgIHtcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICAgIC4uLnNjcm9sbEluZGljYXRvclByb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICBzdHlsZTogeyBmbGV4U2hyaW5rOiAwLCAuLi5zY3JvbGxJbmRpY2F0b3JQcm9wcy5zdHlsZSB9LFxuICAgICAgb25Qb2ludGVyRG93bjogY29tcG9zZUV2ZW50SGFuZGxlcnMoc2Nyb2xsSW5kaWNhdG9yUHJvcHMub25Qb2ludGVyRG93biwgKCkgPT4ge1xuICAgICAgICBpZiAoYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsVGltZXJSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRJbnRlcnZhbChvbkF1dG9TY3JvbGwsIDUwKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBvblBvaW50ZXJNb3ZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhzY3JvbGxJbmRpY2F0b3JQcm9wcy5vblBvaW50ZXJNb3ZlLCAoKSA9PiB7XG4gICAgICAgIGNvbnRlbnRDb250ZXh0Lm9uSXRlbUxlYXZlPy4oKTtcbiAgICAgICAgaWYgKGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwob25BdXRvU2Nyb2xsLCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgb25Qb2ludGVyTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKHNjcm9sbEluZGljYXRvclByb3BzLm9uUG9pbnRlckxlYXZlLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyQXV0b1Njcm9sbFRpbWVyKCk7XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn0pO1xudmFyIFNFUEFSQVRPUl9OQU1FID0gXCJTZWxlY3RTZXBhcmF0b3JcIjtcbnZhciBTZWxlY3RTZXBhcmF0b3IgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgLi4uc2VwYXJhdG9yUHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCAuLi5zZXBhcmF0b3JQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSk7XG4gIH1cbik7XG5TZWxlY3RTZXBhcmF0b3IuZGlzcGxheU5hbWUgPSBTRVBBUkFUT1JfTkFNRTtcbnZhciBBUlJPV19OQU1FID0gXCJTZWxlY3RBcnJvd1wiO1xudmFyIFNlbGVjdEFycm93ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLmFycm93UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHBvcHBlclNjb3BlID0gdXNlUG9wcGVyU2NvcGUoX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoQVJST1dfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChBUlJPV19OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICByZXR1cm4gY29udGV4dC5vcGVuICYmIGNvbnRlbnRDb250ZXh0LnBvc2l0aW9uID09PSBcInBvcHBlclwiID8gLyogQF9fUFVSRV9fICovIGpzeChQb3BwZXJQcmltaXRpdmUuQXJyb3csIHsgLi4ucG9wcGVyU2NvcGUsIC4uLmFycm93UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pIDogbnVsbDtcbiAgfVxuKTtcblNlbGVjdEFycm93LmRpc3BsYXlOYW1lID0gQVJST1dfTkFNRTtcbmZ1bmN0aW9uIHNob3VsZFNob3dQbGFjZWhvbGRlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHZvaWQgMDtcbn1cbnZhciBCdWJibGVTZWxlY3QgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWUsIC4uLnNlbGVjdFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcbiAgICBjb25zdCBwcmV2VmFsdWUgPSB1c2VQcmV2aW91cyh2YWx1ZSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdCA9IHJlZi5jdXJyZW50O1xuICAgICAgY29uc3Qgc2VsZWN0UHJvdG8gPSB3aW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlO1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgIHNlbGVjdFByb3RvLFxuICAgICAgICBcInZhbHVlXCJcbiAgICAgICk7XG4gICAgICBjb25zdCBzZXRWYWx1ZSA9IGRlc2NyaXB0b3Iuc2V0O1xuICAgICAgaWYgKHByZXZWYWx1ZSAhPT0gdmFsdWUgJiYgc2V0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoXCJjaGFuZ2VcIiwgeyBidWJibGVzOiB0cnVlIH0pO1xuICAgICAgICBzZXRWYWx1ZS5jYWxsKHNlbGVjdCwgdmFsdWUpO1xuICAgICAgICBzZWxlY3QuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfSwgW3ByZXZWYWx1ZSwgdmFsdWVdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChWaXN1YWxseUhpZGRlbiwgeyBhc0NoaWxkOiB0cnVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInNlbGVjdFwiLCB7IC4uLnNlbGVjdFByb3BzLCByZWY6IGNvbXBvc2VkUmVmcywgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KSB9KTtcbiAgfVxuKTtcbkJ1YmJsZVNlbGVjdC5kaXNwbGF5TmFtZSA9IFwiQnViYmxlU2VsZWN0XCI7XG5mdW5jdGlvbiB1c2VUeXBlYWhlYWRTZWFyY2gob25TZWFyY2hDaGFuZ2UpIHtcbiAgY29uc3QgaGFuZGxlU2VhcmNoQ2hhbmdlID0gdXNlQ2FsbGJhY2tSZWYob25TZWFyY2hDaGFuZ2UpO1xuICBjb25zdCBzZWFyY2hSZWYgPSBSZWFjdC51c2VSZWYoXCJcIik7XG4gIGNvbnN0IHRpbWVyUmVmID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCBoYW5kbGVUeXBlYWhlYWRTZWFyY2ggPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoa2V5KSA9PiB7XG4gICAgICBjb25zdCBzZWFyY2ggPSBzZWFyY2hSZWYuY3VycmVudCArIGtleTtcbiAgICAgIGhhbmRsZVNlYXJjaENoYW5nZShzZWFyY2gpO1xuICAgICAgKGZ1bmN0aW9uIHVwZGF0ZVNlYXJjaCh2YWx1ZSkge1xuICAgICAgICBzZWFyY2hSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAodmFsdWUgIT09IFwiXCIpIHRpbWVyUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB1cGRhdGVTZWFyY2goXCJcIiksIDFlMyk7XG4gICAgICB9KShzZWFyY2gpO1xuICAgIH0sXG4gICAgW2hhbmRsZVNlYXJjaENoYW5nZV1cbiAgKTtcbiAgY29uc3QgcmVzZXRUeXBlYWhlYWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2VhcmNoUmVmLmN1cnJlbnQgPSBcIlwiO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXJSZWYuY3VycmVudCk7XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dCh0aW1lclJlZi5jdXJyZW50KTtcbiAgfSwgW10pO1xuICByZXR1cm4gW3NlYXJjaFJlZiwgaGFuZGxlVHlwZWFoZWFkU2VhcmNoLCByZXNldFR5cGVhaGVhZF07XG59XG5mdW5jdGlvbiBmaW5kTmV4dEl0ZW0oaXRlbXMsIHNlYXJjaCwgY3VycmVudEl0ZW0pIHtcbiAgY29uc3QgaXNSZXBlYXRlZCA9IHNlYXJjaC5sZW5ndGggPiAxICYmIEFycmF5LmZyb20oc2VhcmNoKS5ldmVyeSgoY2hhcikgPT4gY2hhciA9PT0gc2VhcmNoWzBdKTtcbiAgY29uc3Qgbm9ybWFsaXplZFNlYXJjaCA9IGlzUmVwZWF0ZWQgPyBzZWFyY2hbMF0gOiBzZWFyY2g7XG4gIGNvbnN0IGN1cnJlbnRJdGVtSW5kZXggPSBjdXJyZW50SXRlbSA/IGl0ZW1zLmluZGV4T2YoY3VycmVudEl0ZW0pIDogLTE7XG4gIGxldCB3cmFwcGVkSXRlbXMgPSB3cmFwQXJyYXkoaXRlbXMsIE1hdGgubWF4KGN1cnJlbnRJdGVtSW5kZXgsIDApKTtcbiAgY29uc3QgZXhjbHVkZUN1cnJlbnRJdGVtID0gbm9ybWFsaXplZFNlYXJjaC5sZW5ndGggPT09IDE7XG4gIGlmIChleGNsdWRlQ3VycmVudEl0ZW0pIHdyYXBwZWRJdGVtcyA9IHdyYXBwZWRJdGVtcy5maWx0ZXIoKHYpID0+IHYgIT09IGN1cnJlbnRJdGVtKTtcbiAgY29uc3QgbmV4dEl0ZW0gPSB3cmFwcGVkSXRlbXMuZmluZChcbiAgICAoaXRlbSkgPT4gaXRlbS50ZXh0VmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG5vcm1hbGl6ZWRTZWFyY2gudG9Mb3dlckNhc2UoKSlcbiAgKTtcbiAgcmV0dXJuIG5leHRJdGVtICE9PSBjdXJyZW50SXRlbSA/IG5leHRJdGVtIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gd3JhcEFycmF5KGFycmF5LCBzdGFydEluZGV4KSB7XG4gIHJldHVybiBhcnJheS5tYXAoKF8sIGluZGV4KSA9PiBhcnJheVsoc3RhcnRJbmRleCArIGluZGV4KSAlIGFycmF5Lmxlbmd0aF0pO1xufVxudmFyIFJvb3QyID0gU2VsZWN0O1xudmFyIFRyaWdnZXIgPSBTZWxlY3RUcmlnZ2VyO1xudmFyIFZhbHVlID0gU2VsZWN0VmFsdWU7XG52YXIgSWNvbiA9IFNlbGVjdEljb247XG52YXIgUG9ydGFsID0gU2VsZWN0UG9ydGFsO1xudmFyIENvbnRlbnQyID0gU2VsZWN0Q29udGVudDtcbnZhciBWaWV3cG9ydCA9IFNlbGVjdFZpZXdwb3J0O1xudmFyIEdyb3VwID0gU2VsZWN0R3JvdXA7XG52YXIgTGFiZWwgPSBTZWxlY3RMYWJlbDtcbnZhciBJdGVtID0gU2VsZWN0SXRlbTtcbnZhciBJdGVtVGV4dCA9IFNlbGVjdEl0ZW1UZXh0O1xudmFyIEl0ZW1JbmRpY2F0b3IgPSBTZWxlY3RJdGVtSW5kaWNhdG9yO1xudmFyIFNjcm9sbFVwQnV0dG9uID0gU2VsZWN0U2Nyb2xsVXBCdXR0b247XG52YXIgU2Nyb2xsRG93bkJ1dHRvbiA9IFNlbGVjdFNjcm9sbERvd25CdXR0b247XG52YXIgU2VwYXJhdG9yID0gU2VsZWN0U2VwYXJhdG9yO1xudmFyIEFycm93MiA9IFNlbGVjdEFycm93O1xuZXhwb3J0IHtcbiAgQXJyb3cyIGFzIEFycm93LFxuICBDb250ZW50MiBhcyBDb250ZW50LFxuICBHcm91cCxcbiAgSWNvbixcbiAgSXRlbSxcbiAgSXRlbUluZGljYXRvcixcbiAgSXRlbVRleHQsXG4gIExhYmVsLFxuICBQb3J0YWwsXG4gIFJvb3QyIGFzIFJvb3QsXG4gIFNjcm9sbERvd25CdXR0b24sXG4gIFNjcm9sbFVwQnV0dG9uLFxuICBTZWxlY3QsXG4gIFNlbGVjdEFycm93LFxuICBTZWxlY3RDb250ZW50LFxuICBTZWxlY3RHcm91cCxcbiAgU2VsZWN0SWNvbixcbiAgU2VsZWN0SXRlbSxcbiAgU2VsZWN0SXRlbUluZGljYXRvcixcbiAgU2VsZWN0SXRlbVRleHQsXG4gIFNlbGVjdExhYmVsLFxuICBTZWxlY3RQb3J0YWwsXG4gIFNlbGVjdFNjcm9sbERvd25CdXR0b24sXG4gIFNlbGVjdFNjcm9sbFVwQnV0dG9uLFxuICBTZWxlY3RTZXBhcmF0b3IsXG4gIFNlbGVjdFRyaWdnZXIsXG4gIFNlbGVjdFZhbHVlLFxuICBTZWxlY3RWaWV3cG9ydCxcbiAgU2VwYXJhdG9yLFxuICBUcmlnZ2VyLFxuICBWYWx1ZSxcbiAgVmlld3BvcnQsXG4gIGNyZWF0ZVNlbGVjdFNjb3BlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IHRvS2ViYWJDYXNlID0gKHN0cmluZykgPT4gc3RyaW5nLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcbmNvbnN0IG1lcmdlQ2xhc3NlcyA9ICguLi5jbGFzc2VzKSA9PiBjbGFzc2VzLmZpbHRlcigoY2xhc3NOYW1lLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oY2xhc3NOYW1lKSAmJiBjbGFzc05hbWUudHJpbSgpICE9PSBcIlwiICYmIGFycmF5LmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gaW5kZXg7XG59KS5qb2luKFwiIFwiKS50cmltKCk7XG5cbmV4cG9ydCB7IG1lcmdlQ2xhc3NlcywgdG9LZWJhYkNhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0QXR0cmlidXRlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0QXR0cmlidXRlcy5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzLmpzJztcblxuY29uc3QgSWNvbiA9IGZvcndhcmRSZWYoXG4gICh7XG4gICAgY29sb3IgPSBcImN1cnJlbnRDb2xvclwiLFxuICAgIHNpemUgPSAyNCxcbiAgICBzdHJva2VXaWR0aCA9IDIsXG4gICAgYWJzb2x1dGVTdHJva2VXaWR0aCxcbiAgICBjbGFzc05hbWUgPSBcIlwiLFxuICAgIGNoaWxkcmVuLFxuICAgIGljb25Ob2RlLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICByZWYsXG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogYWJzb2x1dGVTdHJva2VXaWR0aCA/IE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCAvIE51bWJlcihzaXplKSA6IHN0cm9rZVdpZHRoLFxuICAgICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcImx1Y2lkZVwiLCBjbGFzc05hbWUpLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICAuLi5pY29uTm9kZS5tYXAoKFt0YWcsIGF0dHJzXSkgPT4gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSksXG4gICAgICAgIC4uLkFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dXG4gICAgICBdXG4gICAgKTtcbiAgfVxuKTtcblxuZXhwb3J0IHsgSWNvbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IGZvcndhcmRSZWYsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtZXJnZUNsYXNzZXMsIHRvS2ViYWJDYXNlIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzLmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbmNvbnN0IGNyZWF0ZUx1Y2lkZUljb24gPSAoaWNvbk5hbWUsIGljb25Ob2RlKSA9PiB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWYoXG4gICAgKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgICAgcmVmLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhgbHVjaWRlLSR7dG9LZWJhYkNhc2UoaWNvbk5hbWUpfWAsIGNsYXNzTmFtZSksXG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gICk7XG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGAke2ljb25OYW1lfWA7XG4gIHJldHVybiBDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVMdWNpZGVJY29uIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUx1Y2lkZUljb24uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IENoZWNrID0gY3JlYXRlTHVjaWRlSWNvbihcIkNoZWNrXCIsIFtbXCJwYXRoXCIsIHsgZDogXCJNMjAgNiA5IDE3bC01LTVcIiwga2V5OiBcIjFnbWYyY1wiIH1dXSk7XG5cbmV4cG9ydCB7IENoZWNrIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDaGV2cm9uRG93biA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDaGV2cm9uRG93blwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIm02IDkgNiA2IDYtNlwiLCBrZXk6IFwicXJ1bnNsXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBDaGV2cm9uRG93biBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGV2cm9uLWRvd24uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IENoZXZyb25VcCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDaGV2cm9uVXBcIiwgW1tcInBhdGhcIiwgeyBkOiBcIm0xOCAxNS02LTYtNiA2XCIsIGtleTogXCIxNTN1ZHpcIiB9XV0pO1xuXG5leHBvcnQgeyBDaGV2cm9uVXAgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hldnJvbi11cC5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgQ29weSA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDb3B5XCIsIFtcbiAgW1wicmVjdFwiLCB7IHdpZHRoOiBcIjE0XCIsIGhlaWdodDogXCIxNFwiLCB4OiBcIjhcIiwgeTogXCI4XCIsIHJ4OiBcIjJcIiwgcnk6IFwiMlwiLCBrZXk6IFwiMTdqeWVhXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk00IDE2Yy0xLjEgMC0yLS45LTItMlY0YzAtMS4xLjktMiAyLTJoMTBjMS4xIDAgMiAuOSAyIDJcIiwga2V5OiBcInppeDl1ZlwiIH1dXG5dKTtcblxuZXhwb3J0IHsgQ29weSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5LmpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgU2VsZWN0UHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3Qtc2VsZWN0XCI7XG5pbXBvcnQgeyBDaGVjaywgQ2hldnJvbkRvd24sIENoZXZyb25VcCB9IGZyb20gXCJsdWNpZGUtcmVhY3RcIjtcbmltcG9ydCB7IGNuIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuXG5jb25zdCBTZWxlY3QgPSBTZWxlY3RQcmltaXRpdmUuUm9vdDtcblxuY29uc3QgU2VsZWN0R3JvdXAgPSBTZWxlY3RQcmltaXRpdmUuR3JvdXA7XG5cbmNvbnN0IFNlbGVjdFZhbHVlID0gU2VsZWN0UHJpbWl0aXZlLlZhbHVlO1xuXG5jb25zdCBTZWxlY3RUcmlnZ2VyID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlRyaWdnZXI+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyPlxuPigoeyBjbGFzc05hbWUsIGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyXG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwicmluZy1vZmZzZXQtYmFja2dyb3VuZCBmb2N1czpyaW5nLXJpbmcgZmxleCBoLTQgdy1mdWxsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gd2hpdGVzcGFjZS1ub3dyYXAgcm91bmRlZC1tZCBiZy10cmFuc3BhcmVudCBweC0zIHB5LTIgdGV4dC14cyBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0xIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZCBkaXNhYmxlZDpvcGFjaXR5LTUwIFsmPnNwYW5dOmxpbmUtY2xhbXAtMVwiLFxuICAgICAgXCJkYXJrOnBsYWNlaG9sZGVyLXRleHQtemluYy02MDAgdGV4dC1ibGFjayBwbGFjZWhvbGRlcjp0ZXh0LW5vaXItNDAwIGRhcms6dGV4dC13aGl0ZVwiLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICA+XG4gICAge2NoaWxkcmVufVxuICAgIDxTZWxlY3RQcmltaXRpdmUuSWNvbiBhc0NoaWxkPlxuICAgICAgPENoZXZyb25Eb3duIGNsYXNzTmFtZT1cIm1sLTEgaC00IHctNCB0ZXh0LWJsYWNrIG9wYWNpdHktNTAgZGFyazp0ZXh0LXdoaXRlXCIgLz5cbiAgICA8L1NlbGVjdFByaW1pdGl2ZS5JY29uPlxuICA8L1NlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyPlxuKSk7XG5TZWxlY3RUcmlnZ2VyLmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLlRyaWdnZXIuZGlzcGxheU5hbWU7XG5cbmNvbnN0IFNlbGVjdFNjcm9sbFVwQnV0dG9uID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b25cbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgXCJmbGV4IGN1cnNvci1kZWZhdWx0IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBweS0xXCIsXG4gICAgICBjbGFzc05hbWUsXG4gICAgKX1cbiAgICB7Li4ucHJvcHN9XG4gID5cbiAgICA8Q2hldnJvblVwIGNsYXNzTmFtZT1cImgtNCB3LTRcIiAvPlxuICA8L1NlbGVjdFByaW1pdGl2ZS5TY3JvbGxVcEJ1dHRvbj5cbikpO1xuU2VsZWN0U2Nyb2xsVXBCdXR0b24uZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24uZGlzcGxheU5hbWU7XG5cbmNvbnN0IFNlbGVjdFNjcm9sbERvd25CdXR0b24gPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBSZWFjdC5FbGVtZW50UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbj4sXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b24+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvblxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICBcImZsZXggY3Vyc29yLWRlZmF1bHQgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHB5LTFcIixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICApfVxuICAgIHsuLi5wcm9wc31cbiAgPlxuICAgIDxDaGV2cm9uRG93biBjbGFzc05hbWU9XCJoLTQgdy00XCIgLz5cbiAgPC9TZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbj5cbikpO1xuU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbi5kaXNwbGF5TmFtZSA9XG4gIFNlbGVjdFByaW1pdGl2ZS5TY3JvbGxEb3duQnV0dG9uLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RDb250ZW50ID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLkNvbnRlbnQ+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5Db250ZW50PlxuPigoeyBjbGFzc05hbWUsIGNoaWxkcmVuLCBwb3NpdGlvbiA9IFwicG9wcGVyXCIsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlBvcnRhbD5cbiAgICA8U2VsZWN0UHJpbWl0aXZlLkNvbnRlbnRcbiAgICAgIHJlZj17cmVmfVxuICAgICAgY2xhc3NOYW1lPXtjbihcbiAgICAgICAgXCJkYXRhLVtzdGF0ZT1vcGVuXTphbmltYXRlLWluIGRhdGEtW3N0YXRlPWNsb3NlZF06YW5pbWF0ZS1vdXQgZGF0YS1bc3RhdGU9Y2xvc2VkXTpmYWRlLW91dC0wIGRhdGEtW3N0YXRlPW9wZW5dOmZhZGUtaW4tMCBkYXRhLVtzdGF0ZT1jbG9zZWRdOnpvb20tb3V0LTk1IGRhdGEtW3N0YXRlPW9wZW5dOnpvb20taW4tOTUgZGF0YS1bc2lkZT1ib3R0b21dOnNsaWRlLWluLWZyb20tdG9wLTIgZGF0YS1bc2lkZT1sZWZ0XTpzbGlkZS1pbi1mcm9tLXJpZ2h0LTIgZGF0YS1bc2lkZT1yaWdodF06c2xpZGUtaW4tZnJvbS1sZWZ0LTIgZGF0YS1bc2lkZT10b3BdOnNsaWRlLWluLWZyb20tYm90dG9tLTIgcmVsYXRpdmUgei01MCBtYXgtaC05NiBtaW4tdy1bOHJlbV0gb3ZlcmZsb3ctaGlkZGVuIHJvdW5kZWQtbWQgYm9yZGVyIHNoYWRvdy1tZFwiLFxuICAgICAgICBwb3NpdGlvbiA9PT0gXCJwb3BwZXJcIiAmJlxuICAgICAgICAgIFwiZGF0YS1bc2lkZT1ib3R0b21dOnRyYW5zbGF0ZS15LTEgZGF0YS1bc2lkZT1sZWZ0XTotdHJhbnNsYXRlLXgtMSBkYXRhLVtzaWRlPXJpZ2h0XTp0cmFuc2xhdGUteC0xIGRhdGEtW3NpZGU9dG9wXTotdHJhbnNsYXRlLXktMVwiLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICApfVxuICAgICAgcG9zaXRpb249e3Bvc2l0aW9ufVxuICAgICAgey4uLnByb3BzfVxuICAgID5cbiAgICAgIDxTZWxlY3RTY3JvbGxVcEJ1dHRvbiAvPlxuICAgICAgPFNlbGVjdFByaW1pdGl2ZS5WaWV3cG9ydFxuICAgICAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgICAgIFwicC0xXCIsXG4gICAgICAgICAgcG9zaXRpb24gPT09IFwicG9wcGVyXCIgJiZcbiAgICAgICAgICAgIFwiaC1bdmFyKC0tcmFkaXgtc2VsZWN0LXRyaWdnZXItaGVpZ2h0KV0gdy1mdWxsIG1pbi13LVt2YXIoLS1yYWRpeC1zZWxlY3QtdHJpZ2dlci13aWR0aCldXCIsXG4gICAgICAgICl9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvU2VsZWN0UHJpbWl0aXZlLlZpZXdwb3J0PlxuICAgICAgPFNlbGVjdFNjcm9sbERvd25CdXR0b24gLz5cbiAgICA8L1NlbGVjdFByaW1pdGl2ZS5Db250ZW50PlxuICA8L1NlbGVjdFByaW1pdGl2ZS5Qb3J0YWw+XG4pKTtcblNlbGVjdENvbnRlbnQuZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuQ29udGVudC5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0TGFiZWwgPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBSZWFjdC5FbGVtZW50UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuTGFiZWw+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5MYWJlbD5cbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5MYWJlbFxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXCJweC0yIHB5LTEuNSB0ZXh0LXNtIGZvbnQtc2VtaWJvbGRcIiwgY2xhc3NOYW1lKX1cbiAgICB7Li4ucHJvcHN9XG4gIC8+XG4pKTtcblNlbGVjdExhYmVsLmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLkxhYmVsLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RJdGVtID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLkl0ZW0+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5JdGVtPlxuPigoeyBjbGFzc05hbWUsIGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5JdGVtXG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwicmVsYXRpdmUgZmxleCB3LWZ1bGwgY3Vyc29yLWRlZmF1bHQgc2VsZWN0LW5vbmUgaXRlbXMtY2VudGVyIHJvdW5kZWQtc20gcHktMS41IHBsLTIgcHItOCB0ZXh0LXNtIG91dGxpbmUtbm9uZSBkYXRhLVtkaXNhYmxlZF06cG9pbnRlci1ldmVudHMtbm9uZSBkYXRhLVtkaXNhYmxlZF06b3BhY2l0eS01MFwiLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICA+XG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiYWJzb2x1dGUgcmlnaHQtMiBmbGV4IGgtMy41IHctMy41IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgPFNlbGVjdFByaW1pdGl2ZS5JdGVtSW5kaWNhdG9yPlxuICAgICAgICA8Q2hlY2sgY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+XG4gICAgICA8L1NlbGVjdFByaW1pdGl2ZS5JdGVtSW5kaWNhdG9yPlxuICAgIDwvc3Bhbj5cbiAgICA8U2VsZWN0UHJpbWl0aXZlLkl0ZW1UZXh0PntjaGlsZHJlbn08L1NlbGVjdFByaW1pdGl2ZS5JdGVtVGV4dD5cbiAgPC9TZWxlY3RQcmltaXRpdmUuSXRlbT5cbikpO1xuU2VsZWN0SXRlbS5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5JdGVtLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RTZXBhcmF0b3IgPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBSZWFjdC5FbGVtZW50UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yPlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlNlcGFyYXRvclxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXCJiZy1tdXRlZCAtbXgtMSBteS0xIGgtcHhcIiwgY2xhc3NOYW1lKX1cbiAgICB7Li4ucHJvcHN9XG4gIC8+XG4pKTtcblNlbGVjdFNlcGFyYXRvci5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5TZXBhcmF0b3IuZGlzcGxheU5hbWU7XG5cbmV4cG9ydCB7XG4gIFNlbGVjdCxcbiAgU2VsZWN0R3JvdXAsXG4gIFNlbGVjdFZhbHVlLFxuICBTZWxlY3RUcmlnZ2VyLFxuICBTZWxlY3RDb250ZW50LFxuICBTZWxlY3RMYWJlbCxcbiAgU2VsZWN0SXRlbSxcbiAgU2VsZWN0U2VwYXJhdG9yLFxuICBTZWxlY3RTY3JvbGxVcEJ1dHRvbixcbiAgU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbixcbn07XG4iLCJpbXBvcnQgeyBjbiB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcbmltcG9ydCB7IENoZWNrSWNvbiwgQ29weUljb24gfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XG5pbXBvcnQgeyBSZWFjdE5vZGUsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDb3B5QnV0dG9uID0gKHtcbiAgbGFiZWwsXG4gIGJ1dHRvbkNsYXNzTmFtZSxcbiAgbG9nb0NsYXNzTmFtZSxcbiAgdGV4dFRvQ29weSxcbiAgZGlzYWJsZWQsXG59OiB7XG4gIGxhYmVsOiBSZWFjdE5vZGU7XG4gIHRleHRUb0NvcHk6ICgpID0+IHN0cmluZztcbiAgYnV0dG9uQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBsb2dvQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG59KSA9PiB7XG4gIGNvbnN0IFtsb2dvLCBzZXRMb2dvXSA9IHVzZVN0YXRlPFJlYWN0Tm9kZT4oXG4gICAgPENvcHlJY29uIGNsYXNzTmFtZT17Y24oXCJoLTMgdy0zXCIsIGxvZ29DbGFzc05hbWUpfSAvPixcbiAgKTtcbiAgY29uc3QgW2ludGVybmFsTGFiZWwsIHNldEludGVybmFsTGFiZWxdID0gdXNlU3RhdGU8UmVhY3ROb2RlPihsYWJlbCk7XG4gIGNvbnN0IG9uQ2xpcGJvYXJkQ29weSA9ICgpID0+IHtcbiAgICBzZXRMb2dvKDxDaGVja0ljb24gY2xhc3NOYW1lPXtjbihcImgtMyB3LTNcIiwgbG9nb0NsYXNzTmFtZSl9IC8+KTtcbiAgICBzZXRJbnRlcm5hbExhYmVsKFwiQ29waWVkIVwiKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldExvZ28oPENvcHlJY29uIGNsYXNzTmFtZT17Y24oXCJoLTMgdy0zXCIsIGxvZ29DbGFzc05hbWUpfSAvPik7XG4gICAgICBzZXRJbnRlcm5hbExhYmVsKGxhYmVsKTtcbiAgICB9LCAxMDAwKTtcbiAgfTtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBhcmlhLWxhYmVsPVwiQ29weSB0byBjbGlwYm9hcmRcIlxuICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgY2xhc3NOYW1lPXtjbihcbiAgICAgICAgXCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6dGV4dC1ub2lyLTQwMCBkYXJrOnRleHQtbm9pci0xMDAgZGFyazpkaXNhYmxlZDp0ZXh0LXppbmMtNjAwXCIsXG4gICAgICAgIGJ1dHRvbkNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0VG9Db3B5KCk7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpO1xuICAgICAgICBvbkNsaXBib2FyZENvcHkoKTtcbiAgICAgIH19XG4gICAgPlxuICAgICAge2xvZ299XG4gICAgICB7aW50ZXJuYWxMYWJlbH1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn07XG4iLCJpbXBvcnQge1xuICBiYXNlSW5TZWxlY3Rpb24sXG4gIGdldEFubm90YXRlZFNlcXVlbmNlLFxuICBzdGFja0Fubm90YXRpb25zTm9PdmVybGFwLFxufSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBBbm5vdGF0ZWRCYXNlLFxuICBBbm5vdGF0aW9uLFxuICBBcmlhZG5lU2VsZWN0aW9uLFxuICBTdGFja2VkQW5ub3RhdGlvbixcbn0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmltcG9ydCB7XG4gIFNlbGVjdCxcbiAgU2VsZWN0Q29udGVudCxcbiAgU2VsZWN0SXRlbSxcbiAgU2VsZWN0VmFsdWUsXG4gIFNlbGVjdFRyaWdnZXIsXG59IGZyb20gXCJAdWkvc2VsZWN0XCI7XG5pbXBvcnQgeyBDb3B5QnV0dG9uIH0gZnJvbSBcIkB1aS9jb3B5LWJ1dHRvblwiO1xuXG5leHBvcnQgY29uc3QgU2VxdWVuY2VWaWV3ZXIgPSAoe1xuICBzZXF1ZW5jZXMsXG4gIGFubm90YXRpb25zLFxuICBzZWxlY3Rpb24sXG4gIHNldFNlbGVjdGlvbixcbiAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICBjaGFyQ2xhc3NOYW1lLFxuICBzZWxlY3Rpb25DbGFzc05hbWUsXG4gIGhpZGVNZXRhZGF0YUJhcixcbiAgbm9WYWxpZGF0ZSxcbn06IHtcbiAgc2VxdWVuY2VzOiBzdHJpbmdbXTtcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgY29udGFpbmVyQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBoaWRlTWV0YWRhdGFCYXI/OiBib29sZWFuO1xuICBub1ZhbGlkYXRlPzogYm9vbGVhbjtcbn0pID0+IHtcbiAgY29uc3QgW2hvdmVyZWRQb3NpdGlvbiwgc2V0SG92ZXJlZFBvc2l0aW9uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2VxSWR4VG9Db3B5LCBzZXRTZXFJZHhUb0NvcHldID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW2FjdGl2ZUFubm90YXRpb24sIHNldEFjdGl2ZUFubm90YXRpb25dID0gdXNlU3RhdGU8QW5ub3RhdGlvbiB8IG51bGw+KFxuICAgIG51bGwsXG4gICk7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBzdGFja0Fubm90YXRpb25zTm9PdmVybGFwKFxuICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgTWF0aC5tYXgoLi4uc2VxdWVuY2VzLm1hcCgoc2VxKSA9PiBzZXEubGVuZ3RoKSksXG4gICAgICApO1xuICAgIH0sXG4gICAgW2Fubm90YXRpb25zXSxcbiAgKTtcbiAgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2VzID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlcy5tYXAoKHNlcXVlbmNlKSA9PlxuICAgICAgICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSh7IHNlcXVlbmNlLCBzdGFja2VkQW5ub3RhdGlvbnMsIG5vVmFsaWRhdGUgfSksXG4gICAgICApO1xuICAgIH0sXG4gICAgW3NlcXVlbmNlcywgc3RhY2tlZEFubm90YXRpb25zXSxcbiAgKTtcblxuICBjb25zdCBtZW1vaXplZFNlcUNvbnRlbnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPFNlcUNvbnRlbnRcbiAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2VzPXthbm5vdGF0ZWRTZXF1ZW5jZXN9XG4gICAgICAgIHNlbGVjdGlvbj17c2VsZWN0aW9ufVxuICAgICAgICBzZXRTZWxlY3Rpb249e3NldFNlbGVjdGlvbn1cbiAgICAgICAgc2V0SG92ZXJlZFBvc2l0aW9uPXtzZXRIb3ZlcmVkUG9zaXRpb259XG4gICAgICAgIHNldEFjdGl2ZUFubm90YXRpb249e3NldEFjdGl2ZUFubm90YXRpb259XG4gICAgICAgIHN0YWNrZWRBbm5vdGF0aW9ucz17c3RhY2tlZEFubm90YXRpb25zfVxuICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjaGFyQ2xhc3NOYW1lfVxuICAgICAgICBzZWxlY3Rpb25DbGFzc05hbWU9e3NlbGVjdGlvbkNsYXNzTmFtZX1cbiAgICAgIC8+XG4gICAgKTtcbiAgfSwgW2Fubm90YXRlZFNlcXVlbmNlcywgc2VsZWN0aW9uLCBzdGFja2VkQW5ub3RhdGlvbnNdKTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgXCJyZWxhdGl2ZSBpc29sYXRlIGZsZXggZmxleC13cmFwXCIsXG4gICAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgICApfVxuICAgICAgPlxuICAgICAgICAgIDxTZXFNZXRhZGF0YUJhclxuICAgICAgICAgICAgaG92ZXJlZFBvc2l0aW9uPXtob3ZlcmVkUG9zaXRpb259XG4gICAgICAgICAgICBhY3RpdmVBbm5vdGF0aW9uPXthY3RpdmVBbm5vdGF0aW9ufVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwic3RpY2t5IGluc2V0LXgtMCB0b3AtMCB6LVszXSB3LWZ1bGwgcHgtMiBweS0xIGJhY2tkcm9wLWJsdXItbWRcIiwgaGlkZU1ldGFkYXRhQmFyID8gJ2hpZGRlbicgOiAnJyl9XG4gICAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZXM9e2Fubm90YXRlZFNlcXVlbmNlc31cbiAgICAgICAgICAgIGNoYXJDbGFzc05hbWU9e2NoYXJDbGFzc05hbWV9XG4gICAgICAgICAgICBzZXFJZHhUb0NvcHk9e3NlcUlkeFRvQ29weX1cbiAgICAgICAgICAgIHNldFNlcUlkeFRvQ29weT17c2V0U2VxSWR4VG9Db3B5fVxuICAgICAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgLz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBweC0yXCI+e21lbW9pemVkU2VxQ29udGVudH08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvPlxuICApO1xufTtcbmV4cG9ydCBjb25zdCBTZXFDb250ZW50ID0gKHtcbiAgYW5ub3RhdGVkU2VxdWVuY2VzLFxuICBzZWxlY3Rpb24sXG4gIHNldFNlbGVjdGlvbixcbiAgc2V0SG92ZXJlZFBvc2l0aW9uLFxuICBzZXRBY3RpdmVBbm5vdGF0aW9uLFxuICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIGNoYXJDbGFzc05hbWUsXG4gIHNlbGVjdGlvbkNsYXNzTmFtZSxcbn06IHtcbiAgYW5ub3RhdGVkU2VxdWVuY2VzOiBBbm5vdGF0ZWRCYXNlW11bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0SG92ZXJlZFBvc2l0aW9uOiAocG9zaXRpb246IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEFjdGl2ZUFubm90YXRpb246IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgc3RhY2tlZEFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBtb3VzZURvd24gPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpbmRpY2VzQ2xhc3NOYW1lID0gKHtcbiAgICBiYXNlLFxuICAgIHNlcXVlbmNlSWR4LFxuICB9OiB7XG4gICAgYmFzZTogQW5ub3RhdGVkQmFzZTtcbiAgICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICB9KSA9PiB7XG4gICAgY29uc3QgaXNOb3RGaXJzdFNlcSA9IHNlcXVlbmNlSWR4ICE9PSAwO1xuICAgIGNvbnN0IGlzTm90TXVsdGlwbGVPZlRlbiA9IGJhc2UuaW5kZXggJSAxMCAhPT0gMDtcblxuICAgIGlmIChpc05vdEZpcnN0U2VxIHx8IGlzTm90TXVsdGlwbGVPZlRlbikge1xuICAgICAgcmV0dXJuIFwib3BhY2l0eS0wXCI7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzKFxuICAgICAgXCJ0ZXh0LXhzIHotMVwiLFxuICAgICAgLy8gZG9uJ3QgYWxsb3cgc2VsZWN0aW9uIG9mIGluZGljZXNcbiAgICAgIFwiZGFyazpncm91cC1ob3Zlcjp0ZXh0LW5vaXItMzAwIGdyb3VwLWhvdmVyOnRleHQtbm9pci04MDBcIixcbiAgICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgIGJhc2VJbmRleDogYmFzZS5pbmRleCxcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBzZXF1ZW5jZUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2VzW3NlcXVlbmNlSWR4XS5sZW5ndGgsXG4gICAgICB9KVxuICAgICAgICA/IFwidGV4dC1icmFuZC03MDAgZGFyazp0ZXh0LWJyYW5kLTMwMFwiXG4gICAgICAgIDogXCJ0ZXh0LW5vaXItNDAwIGRhcms6dGV4dC1ub2lyLTYwMFwiLFxuICAgICk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgbW91c2VEb3duLmN1cnJlbnQgPSBmYWxzZTtcbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gYWRkTW91c2VVcExpc3RlbmVyKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIGhhbmRsZU1vdXNlVXAoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTW91c2VVcExpc3RlbmVyKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgKCkgPT4ge1xuICAgICAgICBoYW5kbGVNb3VzZVVwKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2Fubm90YXRlZFNlcXVlbmNlc1swXS5tYXAoKHsgaW5kZXg6IGJhc2VJZHggfSkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgXCJyZWxhdGl2ZSBtdC00IGZsZXggZmxleC1jb2wganVzdGlmeS1iZXR3ZWVuXCIsXG4gICAgICAgICAgICAgIFwiZ3JvdXAgaG92ZXI6Ymctbm9pci0yMDAgZGFyazpob3ZlcjpiZy1ub2lyLTYwMFwiLFxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIGtleT17YGJhc2UtJHtiYXNlSWR4fWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2Fubm90YXRlZFNlcXVlbmNlcy5tYXAoXG4gICAgICAgICAgICAgIChzZXF1ZW5jZTogQW5ub3RhdGVkQmFzZVtdLCBzZXF1ZW5jZUlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBzZXF1ZW5jZS5maW5kKFxuICAgICAgICAgICAgICAgICAgKGJhc2U6IEFubm90YXRlZEJhc2UpID0+IGJhc2UuaW5kZXggPT09IGJhc2VJZHgsXG4gICAgICAgICAgICAgICAgKSB8fCB7IGJhc2U6IFwiIFwiLCBhbm5vdGF0aW9uczogW10sIGluZGV4OiBiYXNlSWR4IH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBrZXk9e2BzZXF1ZW5jZS0ke3NlcXVlbmNlSWR4fS1iYXNlLSR7YmFzZUlkeH1gfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJ3aGl0ZXNwYWNlLXByZSB0ZXh0LWNlbnRlclwiKX1cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SG92ZXJlZFBvc2l0aW9uKGJhc2UuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG1vdXNlIGlzIGRvd24sIHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2VEb3duLmN1cnJlbnQgJiYgc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogYmFzZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRIb3ZlcmVkUG9zaXRpb24obnVsbCl9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogYmFzZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogYmFzZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJmb3J3YXJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VVcD17aGFuZGxlTW91c2VVcH1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPENoYXJDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyPXtgfCAke2Jhc2UuaW5kZXh9YH1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRleD17YmFzZUlkeH1cbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhYnNvbHV0ZSAtdG9wLTQgbGVmdC0wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdyb3VwLWhvdmVyOnRleHQtYnJhbmQtMjAwIGJvcmRlci1iIGJvcmRlci1ub2lyLTYwMCBncm91cC1ob3Zlcjpib3JkZXItbm9pci0zMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNDbGFzc05hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxDaGFyQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgY2hhcj17YmFzZS5iYXNlfVxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4PXtiYXNlSWR4fVxuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VJbmRleDogYmFzZUlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZXNbc2VxdWVuY2VJZHhdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UuYmFzZSAhPT0gXCIgXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxTZXF1ZW5jZUFubm90YXRpb25cbiAgICAgICAgICAgICAgYW5ub3RhdGlvbnM9e3N0YWNrZWRBbm5vdGF0aW9uc31cbiAgICAgICAgICAgICAgaW5kZXg9e2Jhc2VJZHh9XG4gICAgICAgICAgICAgIG1heEFubm90YXRpb25TdGFjaz17TWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heCguLi5zdGFja2VkQW5ub3RhdGlvbnMubWFwKChhbm4pID0+IGFubi5zdGFjaykpLFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICBzZXRIb3ZlcmVkUG9zaXRpb249e3NldEhvdmVyZWRQb3NpdGlvbn1cbiAgICAgICAgICAgICAgc2V0QWN0aXZlQW5ub3RhdGlvbj17c2V0QWN0aXZlQW5ub3RhdGlvbn1cbiAgICAgICAgICAgICAgbWF4U2VxdWVuY2VMZW5ndGg9e01hdGgubWF4KFxuICAgICAgICAgICAgICAgIC4uLmFubm90YXRlZFNlcXVlbmNlcy5tYXAoKHNlcSkgPT4gc2VxLmxlbmd0aCksXG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgU2VxTWV0YWRhdGFCYXIgPSAoe1xuICBob3ZlcmVkUG9zaXRpb24sXG4gIGFjdGl2ZUFubm90YXRpb24sXG4gIGFubm90YXRlZFNlcXVlbmNlcyxcbiAgY2hhckNsYXNzTmFtZSxcbiAgc2VxSWR4VG9Db3B5LFxuICBzZXRTZXFJZHhUb0NvcHksXG4gIHNlbGVjdGlvbixcbiAgY2xhc3NOYW1lLFxufToge1xuICBob3ZlcmVkUG9zaXRpb246IG51bWJlciB8IG51bGw7XG4gIGFjdGl2ZUFubm90YXRpb246IEFubm90YXRpb24gfCBudWxsO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZXM6IEFubm90YXRlZEJhc2VbXVtdO1xuICBzZXFJZHhUb0NvcHk6IG51bWJlcjtcbiAgc2V0U2VxSWR4VG9Db3B5OiAoaWR4OiBudW1iZXIpID0+IHZvaWQ7XG4gIGNoYXJDbGFzc05hbWU6ICh7XG4gICAgYmFzZSxcbiAgICBzZXF1ZW5jZUlkeCxcbiAgfToge1xuICAgIGJhc2U6IEFubm90YXRlZEJhc2U7XG4gICAgc2VxdWVuY2VJZHg6IG51bWJlcjtcbiAgfSkgPT4gc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59KSA9PiB7XG4gIGNvbnN0IGFubm90YXRpb25EaXNwbGF5ID0gYWN0aXZlQW5ub3RhdGlvbiA/IChcbiAgICA8c3BhblxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICBcImZsZXggZ2FwLTIgcm91bmRlZC1mdWxsIHB4LTIgcHktcHggdGV4dC14cyAhb3BhY2l0eS0xMDBcIixcbiAgICAgICAgXCJtbC1hdXRvXCIsXG4gICAgICAgIGFjdGl2ZUFubm90YXRpb24uY2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICA+XG4gICAgICA8c3Bhbj5MYWJlbDoge2FjdGl2ZUFubm90YXRpb24udGV4dH08L3NwYW4+XG4gICAgICA8c3Bhbj5UeXBlOiB7YWN0aXZlQW5ub3RhdGlvbi50eXBlfTwvc3Bhbj5cbiAgICAgIDxzcGFuPkRpcmVjdGlvbjoge2FjdGl2ZUFubm90YXRpb24uZGlyZWN0aW9ufTwvc3Bhbj5cbiAgICAgIDxzcGFuPlxuICAgICAgICBmcm9tIHthY3RpdmVBbm5vdGF0aW9uLnN0YXJ0fSAtIHthY3RpdmVBbm5vdGF0aW9uLmVuZH1cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gICkgOiBudWxsO1xuICBjb25zdCBwb3NpdGlvbkRpc3BsYXkgPSAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwibWluLXctMTYgdGV4dC14cyB0ZXh0LWJsYWNrIGRhcms6dGV4dC13aGl0ZVwiPlxuICAgICAgUG9zOiB7aG92ZXJlZFBvc2l0aW9uID8/IDB9XG4gICAgPC9zcGFuPlxuICApO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgXCJmbGV4IGgtOCBpdGVtcy1jZW50ZXIgZ2FwLTEgcHktMSB0ZXh0LXhzXCIsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgPlxuICAgICAge3Bvc2l0aW9uRGlzcGxheX1cbiAgICAgIDxDb3B5RGlzcGxheVxuICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZXM9e2Fubm90YXRlZFNlcXVlbmNlc31cbiAgICAgICAgY2hhckNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZX1cbiAgICAgICAgc2VxSWR4VG9Db3B5PXtzZXFJZHhUb0NvcHl9XG4gICAgICAgIHNldFNlcUlkeFRvQ29weT17c2V0U2VxSWR4VG9Db3B5fVxuICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgIC8+XG4gICAgICB7YW5ub3RhdGlvbkRpc3BsYXl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgU2VxdWVuY2VBbm5vdGF0aW9uID0gKHtcbiAgYW5ub3RhdGlvbnMsXG4gIG1heEFubm90YXRpb25TdGFjayxcbiAgaW5kZXgsXG4gIHNldEhvdmVyZWRQb3NpdGlvbixcbiAgc2V0QWN0aXZlQW5ub3RhdGlvbixcbiAgbWF4U2VxdWVuY2VMZW5ndGgsXG59OiB7XG4gIGFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xuICBtYXhBbm5vdGF0aW9uU3RhY2s6IG51bWJlcjtcbiAgc2V0SG92ZXJlZFBvc2l0aW9uOiAocG9zaXRpb246IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEFjdGl2ZUFubm90YXRpb246IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgbWF4U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbn0pID0+IHtcbiAgY29uc3Qgb3JkZXJlZEFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuc29ydCgoYSwgYikgPT4gYS5zdGFjayAtIGIuc3RhY2spO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cIiBcIlxuICAgICAga2V5PXtgYW5ub3RhdGlvbi0ke2luZGV4fWB9XG4gICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHNldEhvdmVyZWRQb3NpdGlvbihpbmRleCl9XG4gICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHNldEhvdmVyZWRQb3NpdGlvbihudWxsKX1cbiAgICA+XG4gICAgICB7Wy4uLkFycmF5KG1heEFubm90YXRpb25TdGFjaykua2V5cygpXS5tYXAoKGkpID0+IHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IG9yZGVyZWRBbm5vdGF0aW9uc1xuICAgICAgICAgIC5maWx0ZXIoKGFubikgPT5cbiAgICAgICAgICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgICAgICAgIGJhc2VJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogYW5uLFxuICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG4gICAgICAgICAgLmZpbmQoKGFubikgPT4gYW5uLnN0YWNrID09PSBpKTtcbiAgICAgICAgaWYgKGFubm90YXRpb24pIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgYmFzZUluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uOiBhbm5vdGF0aW9uLFxuICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleT17YGFubm90YXRpb24tJHtpbmRleH0tJHtpfWB9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcImgtMyBib3JkZXItYi0yIGJvcmRlci1ub2lyLTEwMCBvcGFjaXR5LTEwIFwifVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBrZXk9e2Bhbm5vdGF0aW9uLSR7aW5kZXh9LSR7aX1gfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgXCJncm91cC9hbm5vdGF0aW9uIGgtMyBib3JkZXItYmxhY2sgZ3JvdXAtaG92ZXIvYW5ub3RhdGlvbjpib3JkZXJcIixcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT5cbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLm9uQ2xpY2s/Lih7XG4gICAgICAgICAgICAgICAgICBzdGFydDogYW5ub3RhdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgIGVuZDogYW5ub3RhdGlvbi5lbmQsXG4gICAgICAgICAgICAgICAgICBkaWVjdGlvbjogYW5ub3RhdGlvbi5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHNldEFjdGl2ZUFubm90YXRpb24oYW5ub3RhdGlvbil9XG4gICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0QWN0aXZlQW5ub3RhdGlvbihudWxsKX1cbiAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17YHBsYWNlaG9sZGVyLSR7aW5kZXh9LSR7aX1gfSBjbGFzc05hbWU9e1wiaC0zXCJ9IC8+O1xuICAgICAgICB9XG4gICAgICB9KX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmludGVyZmFjZSBDaGFyUHJvcHMge1xuICBjaGFyOiBzdHJpbmc7XG4gIGluZGV4OiBudW1iZXI7XG4gIGNoYXJDbGFzc05hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IENoYXJDb21wb25lbnQgPSAoeyBjaGFyLCBjaGFyQ2xhc3NOYW1lIH06IENoYXJQcm9wcykgPT4ge1xuICAvLyBkb24ndCBhbGxvdyBzZWxlY3Rpb24gb2YgY2hhcnNcbiAgY29uc3Qgc2hhcmVkQ2xhc3NOYW1lID0gXCJmb250LW1vbm8gc2VsZWN0LW5vbmVcIjtcbiAgaWYgKGNoYXIgPT09IFwiIFwiKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHNoYXJlZENsYXNzTmFtZSwgY2hhckNsYXNzTmFtZSwgXCJvcGFjaXR5LTIwXCIpfT5cbiAgICAgICAgLlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHNoYXJlZENsYXNzTmFtZSwgY2hhckNsYXNzTmFtZSwgXCJtci1weFwiKX0+XG4gICAgICB7Y2hhcn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb3B5RGlzcGxheSA9ICh7XG4gIHNlcUlkeFRvQ29weSxcbiAgc2V0U2VxSWR4VG9Db3B5LFxuICBhbm5vdGF0ZWRTZXF1ZW5jZXMsXG4gIGNoYXJDbGFzc05hbWUsXG4gIHNlbGVjdGlvbixcbn06IHtcbiAgc2VxSWR4VG9Db3B5OiBudW1iZXI7XG4gIHNldFNlcUlkeFRvQ29weTogKGlkeDogbnVtYmVyKSA9PiB2b2lkO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZXM6IEFubm90YXRlZEJhc2VbXVtdO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBnZXRTdHJpbmdUb0NvcHkgPSAoKSA9PiB7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VxID0gYW5ub3RhdGVkU2VxdWVuY2VzW3NlcUlkeFRvQ29weV07XG4gICAgY29uc3Qgc3RyaW5nVG9Db3B5ID0gc2VxXG4gICAgICAuZmlsdGVyKChiYXNlKSA9PlxuICAgICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICAgIGJhc2VJbmRleDogYmFzZS5pbmRleCxcbiAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbixcbiAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2VzW3NlcUlkeFRvQ29weV0ubGVuZ3RoLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICAgIC5tYXAoKGJhc2UpID0+IGJhc2UuYmFzZSlcbiAgICAgIC5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzdHJpbmdUb0NvcHk7XG4gIH07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBtb3VudENvcHlIYW5kbGVyKCkge1xuICAgIGNvbnN0IGNvcHlIYW5kbGVyID0gKGU6IENsaXBib2FyZEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdHJpbmdUb0NvcHkgPSBnZXRTdHJpbmdUb0NvcHkoKTtcbiAgICAgIGlmICghc3RyaW5nVG9Db3B5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YShcInRleHQvcGxhaW5cIiwgc3RyaW5nVG9Db3B5KTtcbiAgICAgIGFsZXJ0KFwiQ29waWVkIHRvIGNsaXBib2FyZCFcIik7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCBjb3B5SGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnRDb3B5SGFuZGxlcigpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIGNvcHlIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGV4XCI+XG4gICAgICA8U2VsZWN0XG4gICAgICAgIHZhbHVlPXtzZXFJZHhUb0NvcHkudG9TdHJpbmcoKX1cbiAgICAgICAgb25WYWx1ZUNoYW5nZT17KHZhbHVlKSA9PiBzZXRTZXFJZHhUb0NvcHkocGFyc2VJbnQodmFsdWUpKX1cbiAgICAgID5cbiAgICAgICAgPFNlbGVjdFRyaWdnZXIgY2xhc3NOYW1lPVwidy1maXRcIj5cbiAgICAgICAgICA8U2VsZWN0VmFsdWVcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgIGJhc2U6IHsgYmFzZTogXCJBXCIsIGFubm90YXRpb25zOiBbXSwgaW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgc2VxdWVuY2VJZHg6IHNlcUlkeFRvQ29weSxcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIFNlcXVlbmNlIHtzZXFJZHhUb0NvcHkgKyAxfVxuICAgICAgICAgIDwvU2VsZWN0VmFsdWU+XG4gICAgICAgIDwvU2VsZWN0VHJpZ2dlcj5cbiAgICAgICAgPFNlbGVjdENvbnRlbnQgY2xhc3NOYW1lPVwiYmctd2hpdGUgZGFyazpiZy1ibGFja1wiPlxuICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKChfLCBpZHgpID0+IChcbiAgICAgICAgICAgIDxTZWxlY3RJdGVtXG4gICAgICAgICAgICAgIGtleT17YHNlcXVlbmNlLSR7aWR4fWB9XG4gICAgICAgICAgICAgIHZhbHVlPXtpZHgudG9TdHJpbmcoKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjaGFyQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgICBiYXNlOiB7IGJhc2U6IFwiQVwiLCBhbm5vdGF0aW9uczogW10sIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgICAgc2VxdWVuY2VJZHg6IGlkeCxcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFNlcXVlbmNlIHtpZHggKyAxfXtcIiBcIn1cbiAgICAgICAgICAgIDwvU2VsZWN0SXRlbT5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9TZWxlY3RDb250ZW50PlxuICAgICAgPC9TZWxlY3Q+XG4gICAgICA8Q29weUJ1dHRvblxuICAgICAgICB0ZXh0VG9Db3B5PXsoKSA9PiBnZXRTdHJpbmdUb0NvcHkoKSA/PyBcIlwifVxuICAgICAgICBsYWJlbD17XCJcIn1cbiAgICAgICAgZGlzYWJsZWQ9eyFzZWxlY3Rpb259XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBBbm5vdGF0ZWRCYXNlLCBBbm5vdGF0ZWRTZXF1ZW5jZSB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IFJlZmVyZW5jZVRpY2tzID0gKHtcbiAgc2VxdWVuY2UsXG4gIGNsYXNzTmFtZSxcbn06IHtcbiAgc2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJvdmVyZmxvdy1oaWRkZW50ZXh0LXdoaXRlIGZsZXhcIiwgY2xhc3NOYW1lKX0+XG4gICAgICB7c2VxdWVuY2UubWFwKChudWNsOiBBbm5vdGF0ZWRCYXNlLCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc2hvd1RpY2tzID0gbnVjbC5iYXNlICE9PSBcIi1cIiAmJiAobnVjbC5pbmRleCArIDEpICUgMTAgPT09IDA7IC8vIHdlIGRvbid0IHdhbnQgdG8gc2hvdyB0aWNrcyBmb3IgZ2Fwc1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlIGZsZXggaC0xMiBmbGV4LWNvbCBpdGVtcy1lbmQganVzdGlmeS1lbmRcIlxuICAgICAgICAgICAga2V5PXtgYmFzZS0ke2l9LWluZGV4LXdyYXBwZXJgfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgIFwiZm9udC1tb25vIFwiLFxuICAgICAgICAgICAgICAgIFwiYWJzb2x1dGUgYm90dG9tLTAgbGVmdC0wIHJpZ2h0LTBcIixcblxuICAgICAgICAgICAgICAgIHNob3dUaWNrcyA/IFwib3BhY2l0eS0xMDBcIiA6IFwib3BhY2l0eS0wXCIsXG4gICAgICAgICAgICAgICAgbnVjbC5iYXNlID09PSBcIkdcIiAmJiBcInRleHQtcmVkLTUwMFwiLFxuICAgICAgICAgICAgICAgIG51Y2wuYmFzZSA9PT0gXCJBXCIgJiYgXCJ0ZXh0LXllbGxvdy01MDBcIixcbiAgICAgICAgICAgICAgICBudWNsLmJhc2UgPT09IFwiVFwiICYmIFwidGV4dC1ncmVlbi01MDBcIixcbiAgICAgICAgICAgICAgICBudWNsLmJhc2UgPT09IFwiQ1wiICYmIFwidGV4dC1ibHVlLTUwMFwiLFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXhzXCI+IHtudWNsLmluZGV4ICsgMX08L3A+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm14LWF1dG8gdGV4dC14c1wiPnw8L3A+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJtci1weCBmb250LW1vbm8gb3BhY2l0eS0wXCIpfT5cbiAgICAgICAgICAgICAge251Y2wuYmFzZX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbInJlcXVpcmUkJDAiLCJSZWFjdCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJqc3hSdW50aW1lTW9kdWxlIiwicmVxdWlyZSQkMSIsIm9mZnNldCIsImluZGV4Iiwic2l6ZSIsInV0aWwiLCJvYmplY3RVdGlsIiwiZXJyb3JVdGlsIiwiZXJyb3JNYXAiLCJjdHgiLCJtaW4iLCJtYXgiLCJyZXN1bHQiLCJpc3N1ZXMiLCJlbGVtZW50cyIsInByb2Nlc3NlZCIsInIiLCJfYSIsIl9iIiwiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwianN4IiwianN4cyIsInN0YXJ0IiwiZW5kIiwibWlzbWF0Y2hDbGFzc05hbWUiLCJGcmFnbWVudCIsImNsYW1wIiwiRnJhZ21lbnQyIiwiY3JlYXRlQ29sbGVjdGlvblNjb3BlIiwidXNlQ29sbGVjdGlvbiIsIk5vZGUiLCJ1c2VDYWxsYmFja1JlZiIsImNvdW50IiwidXNlTGF5b3V0RWZmZWN0IiwiY29tcHV0ZVBvc2l0aW9uIiwicGxhdGZvcm0iLCJhcnJvdyIsImZsaXAiLCJzaWRlcyIsInNpZGUiLCJwbGFjZW1lbnQiLCJvdmVyZmxvdyIsImhpZGUiLCJzaGlmdCIsIngiLCJ5IiwibGltaXRTaGlmdCIsImdldENvbXB1dGVkU3R5bGUiLCJvZmZzZXQkMSIsInNoaWZ0JDEiLCJmbGlwJDEiLCJzaXplJDEiLCJoaWRlJDEiLCJhcnJvdyQxIiwibGltaXRTaGlmdCQxIiwiZGF0YSIsIk5BTUUiLCJBcnJvdyIsIkNPTlRFTlRfTkFNRSIsImZsb2F0aW5nVUlhcnJvdyIsIkFSUk9XX05BTUUiLCJBcnJvd1ByaW1pdGl2ZS5Sb290IiwiUm9vdDIiLCJQT1JUQUxfTkFNRSIsIlBvcnRhbCIsIlJlYWN0RE9NIiwiX19hc3NpZ24iLCJjYnMiLCJTaWRlQ2FyIiwiU3R5bGUiLCJTZWxlY3QiLCJQb3BwZXJQcmltaXRpdmUuUm9vdCIsIlNlbGVjdFRyaWdnZXIiLCJQb3BwZXJQcmltaXRpdmUuQW5jaG9yIiwiU2VsZWN0VmFsdWUiLCJQb3J0YWxQcmltaXRpdmUiLCJTZWxlY3RDb250ZW50IiwiZm9jdXNGaXJzdCIsIlJlbW92ZVNjcm9sbCIsIlBvcHBlclByaW1pdGl2ZS5Db250ZW50IiwiU2VsZWN0TGFiZWwiLCJTZWxlY3RJdGVtIiwiU2VsZWN0U2Nyb2xsVXBCdXR0b24iLCJTZWxlY3RTY3JvbGxEb3duQnV0dG9uIiwiU2VsZWN0U2VwYXJhdG9yIiwiUG9wcGVyUHJpbWl0aXZlLkFycm93IiwiSWNvbiIsIlNlbGVjdFByaW1pdGl2ZS5Sb290IiwiU2VsZWN0UHJpbWl0aXZlLlZhbHVlIiwiU2VsZWN0UHJpbWl0aXZlLlRyaWdnZXIiLCJTZWxlY3RQcmltaXRpdmUuSWNvbiIsIlNlbGVjdFByaW1pdGl2ZS5TY3JvbGxVcEJ1dHRvbiIsIlNlbGVjdFByaW1pdGl2ZS5TY3JvbGxEb3duQnV0dG9uIiwiU2VsZWN0UHJpbWl0aXZlLlBvcnRhbCIsIlNlbGVjdFByaW1pdGl2ZS5Db250ZW50IiwiU2VsZWN0UHJpbWl0aXZlLlZpZXdwb3J0IiwiU2VsZWN0UHJpbWl0aXZlLkxhYmVsIiwiU2VsZWN0UHJpbWl0aXZlLkl0ZW0iLCJTZWxlY3RQcmltaXRpdmUuSXRlbUluZGljYXRvciIsIlNlbGVjdFByaW1pdGl2ZS5JdGVtVGV4dCIsIlNlbGVjdFByaW1pdGl2ZS5TZXBhcmF0b3IiLCJDb3B5SWNvbiIsIkNoZWNrSWNvbiIsImJhc2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTYSxNQUFJLElBQUVBLGdCQUFpQixJQUFFLE9BQU8sSUFBSSxlQUFlLEdBQUUsSUFBRSxPQUFPLElBQUksZ0JBQWdCLEdBQUUsSUFBRSxPQUFPLFVBQVUsZ0JBQWUsSUFBRSxFQUFFLG1EQUFtRCxtQkFBa0IsSUFBRSxF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QUFBQSxFQUNyRTtBQUFBLEVBQ0ksSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUNsRTtBQUFBLEVBQ0ksSUFBSSxRQUFRO0FBQ1IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLEtBQUs7QUFBQSxFQUNoRTtBQUFBLEVBQ0ksSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUNsRTtBQUFBLEVBQ0ksSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUNqRTtBQUFBLEVBQ0ksSUFBSSxXQUFXO0FBQ1gsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFFBQVE7QUFBQSxFQUNuRTtBQUFBLEVBQ0ksSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUNqRTtBQUFBLEVBQ0ksSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUNsRTtBQUFBLEVBQ0ksSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUNqRTtBQUFBLEVBQ0ksSUFBSSxPQUFPO0FBQ1AsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLElBQUk7QUFBQSxFQUMvRDtBQUFBLEVBQ0ksSUFBSSxTQUFTO0FBQ1Qs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LFdBQVc7QUFBQSxnQkFDVDtBQUFBLGdCQUNBO0FBQUEsZ0JBRUEsWUFBWSxnQkFBZ0I7QUFBQSxnQkFDNUIsS0FBSyxTQUFTLE9BQU87QUFBQSxnQkFDckIsS0FBSyxTQUFTLE9BQU87QUFBQSxnQkFDckIsS0FBSyxTQUFTLE9BQU87QUFBQSxnQkFDckIsS0FBSyxTQUFTLE9BQU87QUFBQSxjQUN2QjtBQUFBLGNBRUEsVUFBQTtBQUFBLGdCQUFDQSxrQ0FBQUEsS0FBQSxLQUFBLEVBQUUsV0FBVSxXQUFVLFVBQUE7QUFBQSxrQkFBQTtBQUFBLGtCQUFFLEtBQUssUUFBUTtBQUFBLGdCQUFBLEdBQUU7QUFBQSxnQkFDdkNELGtDQUFBLElBQUEsS0FBQSxFQUFFLFdBQVUsbUJBQWtCLFVBQUMsSUFBQSxDQUFBO0FBQUEsY0FBQTtBQUFBLFlBQUE7QUFBQSxVQUNsQztBQUFBLGdEQUVDLE9BQUksRUFBQSxXQUFXLFdBQVcsMkJBQTJCLEdBQ25ELGVBQUssS0FDUixDQUFBO0FBQUEsUUFBQTtBQUFBLE1BQUE7QUFBQSxNQXBCSyxRQUFRLENBQUM7QUFBQSxJQXFCaEI7QUFBQSxFQUVILENBQUEsR0FDSDtBQUVKOyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiw0LDUsNiwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NV19
