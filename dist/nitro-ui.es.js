import * as React from "react";
import React__default, { useRef, useState, useCallback, useEffect, Fragment, useMemo, useLayoutEffect, forwardRef, createElement } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default from "react-dom";
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var React2 = React__default;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
          // types supported by any Flight configuration anywhere since
          // we don't know which Flight build this will end up being used
          // with.
          type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (; s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self) ;
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== void 0) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === void 0 || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum();
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== void 0) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
      reactJsxRuntime_development.jsx = jsx;
      reactJsxRuntime_development.jsxs = jsxs;
    })();
  }
  return reactJsxRuntime_development;
}
if (process.env.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
const genArc = ({
  center,
  innerRadius,
  largeArc,
  length,
  offset: offset2,
  outerRadius,
  seqLength
}) => {
  const leftBottom = findCoor({
    index: offset2,
    radius: innerRadius,
    center,
    seqLength
  });
  const leftTop = findCoor({
    index: offset2,
    radius: outerRadius,
    center,
    seqLength
  });
  const rightBottom = findCoor({
    index: length + offset2,
    radius: innerRadius,
    center,
    seqLength
  });
  const rightTop = findCoor({
    index: length + offset2,
    radius: outerRadius,
    center,
    seqLength
  });
  const sFlagF = 1;
  const sFlagR = 0;
  const lArc = largeArc ? 1 : 0;
  return `M ${rightBottom.x} ${rightBottom.y}
      A ${innerRadius} ${innerRadius}, 0, ${lArc}, ${sFlagR}, ${leftBottom.x} ${leftBottom.y}
      L ${leftBottom.x} ${leftBottom.y}
      L ${leftTop.x} ${leftTop.y}
      A ${outerRadius} ${outerRadius}, 0, ${lArc}, ${sFlagF}, ${rightTop.x} ${rightTop.y}
      Z`;
};
const findCoor = ({
  index: index2,
  radius,
  center,
  seqLength
}) => {
  const lengthPerc = index2 / seqLength;
  const lengthPercCentered = lengthPerc - 0.25;
  const radians = lengthPercCentered * Math.PI * 2;
  const xAdjust = Math.cos(radians) * radius;
  const yAdjust = Math.sin(radians) * radius;
  return {
    x: center.x + xAdjust,
    y: center.y + yAdjust
  };
};
const findAngleFromCoor = ({
  coor,
  center
}) => {
  const x = coor.x - center.x;
  const y = coor.y - center.y;
  let radians = Math.atan2(y, x);
  if (radians < 0) {
    radians = radians + Math.PI * 2;
  }
  return radians * (180 / Math.PI);
};
const findIndexFromAngle = ({
  angle,
  seqLength
}) => {
  let effectiveAngle = angle.degrees + 90;
  if (effectiveAngle < 0) {
    effectiveAngle = 360 + effectiveAngle;
  }
  effectiveAngle = effectiveAngle % 360;
  const arcPerc = effectiveAngle / 360;
  const rawBaseIdx = arcPerc * seqLength;
  return Math.round(rawBaseIdx < 0 ? seqLength + rawBaseIdx : rawBaseIdx);
};
const clampSlice = ({
  slice,
  firstIdx,
  lastIdx
}) => {
  if (!slice) {
    return null;
  }
  let { start, end } = slice;
  const outOfBoundsBefore = start < firstIdx && end < firstIdx;
  const outOfBoundsAfter = start > lastIdx && end > lastIdx;
  if (outOfBoundsBefore || outOfBoundsAfter) {
    return null;
  }
  if (start >= end) {
    start = Math.min(start, lastIdx);
    end = Math.max(end, firstIdx);
  } else {
    end = Math.min(end, lastIdx);
    start = Math.max(start, firstIdx);
  }
  return {
    start,
    end,
    direction: slice.direction
  };
};
var months = [
  "JAN",
  "FEB",
  "MAR",
  "APR",
  "MAY",
  "JUN",
  "JUL",
  "AUG",
  "SEP",
  "OCT",
  "NOV",
  "DEC"
];
const MONTHS = months;
function genbankToJson(sequence) {
  if (typeof sequence !== "string") {
    throw new TypeError("input must be a string");
  }
  let resultsArray = [];
  let result;
  let currentFeatureNote;
  let genbankAnnotationKey = {
    // Contains in order: locus name, sequence length, molecule type (e.g. DNA), genbank division (see 1-18 below), modification date
    // locus definition has changed with time, use accession number for a unique identifier
    LOCUS_TAG: "LOCUS",
    DEFINITION_TAG: "DEFINITION",
    // Accession tag
    // Example: Z78533
    ACCESSION_TAG: "ACCESSION",
    // The version tag contains 2 informations
    // The accession number with a revision
    // The GI (GenInfo Identifier), a ncbi sequential number
    // Example: Z78533.1  GI:2765658
    // Unicity garanteed with respect to sequence. If 1 nucleotide changes, the version is different.
    VERSION_TAG: "VERSION",
    KEYWORDS_TAG: "KEYWORDS",
    // SEGMENT_TAG:"SEGMENT"
    // Source is free text
    SOURCE_TAG: "SOURCE",
    ORGANISM_TAG: "ORGANISM",
    REFERENCE_TAG: "REFERENCE",
    FEATURES_TAG: "FEATURES",
    // CONTIG_TAG: "CONTIG"
    ORIGIN_TAG: "ORIGIN",
    END_SEQUENCE_TAG: "//"
  };
  let lines = sequence.split(/\r?\n/);
  let fieldName;
  let subFieldType;
  let featureLocationIndentation;
  let lastLineWasFeaturesTag;
  let lastLineWasLocation;
  let hasFoundLocus = false;
  for (let line of lines) {
    if (line === null) break;
    let lineFieldName = getLineFieldName(line);
    let val = getLineVal(line);
    let isSubKey = isSubKeyword(line);
    let isKey = isKeyword(line);
    if (lineFieldName === genbankAnnotationKey.END_SEQUENCE_TAG || isKey) {
      fieldName = lineFieldName;
      subFieldType = null;
    } else if (isSubKey) {
      subFieldType = lineFieldName;
    }
    if (line.trim() === "" || lineFieldName === ";") {
      continue;
    }
    if (!hasFoundLocus && fieldName !== genbankAnnotationKey.LOCUS_TAG) {
      break;
    }
    switch (fieldName) {
      case genbankAnnotationKey.LOCUS_TAG:
        hasFoundLocus = true;
        parseLocus(line);
        break;
      case genbankAnnotationKey.FEATURES_TAG:
        parseFeatures(line, lineFieldName, val);
        break;
      case genbankAnnotationKey.ORIGIN_TAG:
        parseOrigin(line, lineFieldName);
        break;
      case genbankAnnotationKey.DEFINITION_TAG:
      case genbankAnnotationKey.ACCESSION_TAG:
      case genbankAnnotationKey.VERSION_TAG:
      case genbankAnnotationKey.KEYWORDS_TAG:
        parseMultiLineField(fieldName, line, fieldName.toLowerCase());
        break;
      case genbankAnnotationKey.SOURCE_TAG:
        if (subFieldType === genbankAnnotationKey.ORGANISM_TAG) {
          parseMultiLineField(subFieldType, line, "organism");
        } else {
          parseMultiLineField(lineFieldName, line, "source");
        }
        break;
      case genbankAnnotationKey.REFERENCE_TAG:
        if (lineFieldName === genbankAnnotationKey.REFERENCE_TAG) {
          const ref = result.references || [];
          result.references = ref;
          ref.push({});
        }
        parseReference(line, subFieldType);
        break;
      case genbankAnnotationKey.END_SEQUENCE_TAG:
        endSeq();
        break;
    }
  }
  if (resultsArray[resultsArray.length - 1] !== result) {
    endSeq();
  }
  return resultsArray;
  function endSeq() {
    postProcessCurSeq();
    resultsArray.push(result);
  }
  function getCurrentFeature() {
    return result.features[result.features.length - 1];
  }
  function postProcessCurSeq() {
    if (result && result.features) {
      for (let i = 0; i < result.features.length; i++) {
        result.features[i] = postProcessGenbankFeature(result.features[i]);
      }
    }
  }
  function parseOrigin(line, key) {
    if (key !== genbankAnnotationKey.ORIGIN_TAG) {
      let newLine = line.replace(/[\s]*[0-9]*/g, "");
      result.sequence += newLine;
    }
  }
  function parseLocus(line) {
    result = {
      features: [],
      name: "Untitled sequence",
      sequence: "",
      references: []
    };
    line = removeFieldName(genbankAnnotationKey.LOCUS_TAG, line);
    const m = line.match(
      /^([^\s]+)\s+(\d+)\s+bp\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s*([^\s]+)?$/
    );
    let locusName = m[1];
    let size2 = +m[2];
    let moleculeType = m[3];
    let circular = m[4] === "circular";
    const seq = result;
    let dateStr = "";
    if (!m[6]) {
      dateStr = m[5];
    } else {
      seq.genbankDivision = m[5];
      dateStr = m[6];
    }
    seq.circular = circular;
    seq.moleculeType = moleculeType;
    const dateMatch = dateStr.match(/^(\d{2})-(.{3})-(\d{4})$/);
    const date = /* @__PURE__ */ new Date();
    date.setFullYear(+dateMatch[3]);
    date.setUTCMonth(MONTHS.indexOf(dateMatch[2].toUpperCase()));
    date.setDate(+dateMatch[1]);
    date.setUTCHours(12);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    seq.date = date.toISOString();
    seq.name = locusName;
    seq.size = size2;
  }
  function removeFieldName(fName, line) {
    line = line.replace(/^\s*/, "");
    if (line.indexOf(fName) === 0) {
      line = line.replace(fName, "");
    }
    return line.trim();
  }
  function parseReference(line, subType) {
    const refs = result.references;
    let lastRef = refs[refs.length - 1];
    if (!subType) {
      parseMultiLineField(
        genbankAnnotationKey.REFERENCE_TAG,
        line,
        "description",
        lastRef
      );
    } else {
      parseMultiLineField(subType, line, subType.toLowerCase(), lastRef);
    }
  }
  function parseFeatures(line, key, val) {
    let strand;
    if (key === genbankAnnotationKey.FEATURES_TAG) {
      lastLineWasFeaturesTag = true;
      return;
    }
    if (lastLineWasFeaturesTag) {
      featureLocationIndentation = getLengthOfWhiteSpaceBeforeStartOfLetters(
        line
      );
      lastLineWasFeaturesTag = false;
    }
    if (isFeatureLineRunon(line, featureLocationIndentation)) {
      if (lastLineWasLocation) {
        parseFeatureLocation(line.trim());
        lastLineWasLocation = true;
      } else {
        if (currentFeatureNote) {
          currentFeatureNote[currentFeatureNote.length - 1] += line.trim().replace(/"/g, "");
        }
        lastLineWasLocation = false;
      }
    } else {
      if (isNote(line)) {
        if (getCurrentFeature()) {
          parseFeatureNote(line);
          lastLineWasLocation = false;
        }
      } else {
        if (val.match(/complement/g)) {
          strand = -1;
        } else {
          strand = 1;
        }
        newFeature();
        let feat = getCurrentFeature();
        feat.type = key;
        feat.strand = strand;
        parseFeatureLocation(val);
        lastLineWasLocation = true;
      }
    }
  }
  function newFeature() {
    result.features.push({
      notes: {}
    });
  }
  function isNote(line) {
    let qual = false;
    if (line.trim().charAt(0).match(/\//)) {
      qual = true;
    } else if (line.match(/^[\s]*\/[\w]+=[\S]+/)) {
      qual = true;
    }
    return qual;
  }
  function parseFeatureLocation(locStr) {
    locStr = locStr.trim();
    let locArr = [];
    locStr.replace(/(\d+)/g, function(string, match) {
      locArr.push(match);
    });
    let feat = getCurrentFeature();
    feat.start = +locArr[0];
    feat.end = locArr[1] === void 0 ? +locArr[0] : +locArr[1];
  }
  function parseFeatureNote(line) {
    let newLine, lineArr;
    newLine = line.trim();
    newLine = newLine.replace(/^\/|"$/g, "");
    lineArr = newLine.split(/="|=/);
    let val = lineArr[1];
    if (val) {
      val = val.replace(/\\/g, " ");
      if (line.match(/="/g)) {
        val = val.replace(/".*/g, "");
      } else if (val.match(/^\d+$/g)) {
        val = +val;
      }
    }
    let key = lineArr[0];
    let currentNotes = getCurrentFeature().notes;
    if (currentNotes[key]) {
      currentNotes[key].push(val);
    } else {
      currentNotes[key] = [val];
    }
    currentFeatureNote = currentNotes[key];
  }
  function getLineFieldName(line) {
    let arr;
    line = line.trim();
    arr = line.split(/[\s]+/);
    return arr[0];
  }
  function parseMultiLineField(fName, line, resultKey, r) {
    r = r || result;
    let fieldValue = removeFieldName(fName, line);
    r[resultKey] = r[resultKey] ? `${r[resultKey]} ` : "";
    r[resultKey] += fieldValue;
  }
  function getLineVal(line) {
    let arr;
    if (line.indexOf("=") < 0) {
      line = line.replace(/^[\s]*[\S]+[\s]+|[\s]+$/, "");
      line = line.trim();
      return line;
    } else {
      arr = line.split(/=/);
      return arr[1];
    }
  }
  function isKeyword(line) {
    let isKey = false;
    if (line.substr(0, 10).match(/^[\S]+/)) {
      isKey = true;
    }
    return isKey;
  }
  function isSubKeyword(line) {
    let isSubKey = false;
    if (line.substr(0, 10).match(/^[\s]+[\S]+/)) {
      isSubKey = true;
    }
    return isSubKey;
  }
  function postProcessGenbankFeature(feat) {
    if (feat.notes.label) {
      feat.name = feat.notes.label[0];
    } else if (feat.notes.gene) {
      feat.name = feat.notes.gene[0];
    } else if (feat.notes.ApEinfo_label) {
      feat.name = feat.notes.ApEinfo_label[0];
    } else if (feat.notes.name) {
      feat.name = feat.notes.name[0];
    } else if (feat.notes.organism) {
      feat.name = feat.notes.organism[0];
    } else if (feat.notes.locus_tag) {
      feat.name = feat.notes.locus_tag[0];
    } else if (feat.notes.note) {
      feat.name = feat.notes.note[0];
    } else {
      feat.name = "Untitled Feature";
    }
    feat.name = typeof feat.name === "string" ? feat.name : String(feat.name);
    return feat;
  }
}
function isFeatureLineRunon(line, featureLocationIndentation) {
  let indentationOfLine = getLengthOfWhiteSpaceBeforeStartOfLetters(line);
  if (featureLocationIndentation === indentationOfLine) {
    return false;
  }
  let trimmed = line.trim();
  if (trimmed.charAt(0).match(/\//)) {
    return false;
  }
  return true;
}
function getLengthOfWhiteSpaceBeforeStartOfLetters(string) {
  let match = /^\s*/.exec(string);
  if (match !== null) {
    return match[0].length;
  } else {
    return 0;
  }
}
var src = genbankToJson;
const genbankParser = /* @__PURE__ */ getDefaultExportFromCjs(src);
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const coorSchema = z.object({
  x: z.number(),
  y: z.number()
});
const angleSchema = z.object({
  degrees: z.number(),
  center: coorSchema
});
const annotationTypeSchema = z.union([
  z.literal("CDS"),
  z.literal("enhancer"),
  z.literal("intron"),
  z.literal("misc_feature"),
  z.literal("polyA_signal"),
  z.literal("promoter"),
  z.literal("protein_bind"),
  z.literal("rep_origin"),
  z.literal("LTR"),
  z.string()
]);
const annotationSchema = z.object({
  type: annotationTypeSchema,
  direction: z.union([z.literal("forward"), z.literal("reverse")]),
  start: z.number(),
  end: z.number(),
  className: z.string().optional(),
  text: z.string(),
  onClick: z.function().args(z.any()).optional()
  // circular reference
});
const stackedAnnotationSchema = annotationSchema.extend({
  stack: z.number()
});
const nuclSchema = z.union([
  z.literal("A"),
  z.literal("C"),
  z.literal("G"),
  z.literal("T")
]);
const aaSchema = z.union([
  // Add all your amino acids literals here
  z.literal("A"),
  z.literal("C"),
  z.literal("D"),
  z.literal("E"),
  z.literal("F"),
  z.literal("G"),
  z.literal("H"),
  z.literal("I"),
  z.literal("K"),
  z.literal("L"),
  z.literal("M"),
  z.literal("N"),
  z.literal("P"),
  z.literal("Q"),
  z.literal("R"),
  z.literal("S"),
  z.literal("T"),
  z.literal("V"),
  z.literal("W"),
  z.literal("Y")
]);
const GapSchema = z.literal("-");
const StopSchema = z.literal("*");
const SpaceSchema = z.literal(" ");
const UnknownSchema = z.literal("?");
const annotatedBaseSchema = z.object({
  base: z.string().length(1),
  annotations: z.array(stackedAnnotationSchema),
  index: z.number()
});
const annotatedSequenceSchema = z.array(annotatedBaseSchema);
const ariadneSelectionSchema = z.object({
  start: z.number(),
  end: z.number(),
  direction: z.union([z.literal("forward"), z.literal("reverse")])
});
const GenbankFeatureSchema = z.object({
  name: z.string().min(1),
  start: z.number(),
  end: z.number(),
  strand: z.union([z.literal(1), z.literal(-1)]),
  type: annotationTypeSchema,
  notes: z.record(z.array(z.string())).optional()
});
const genbankToAnnotatedSequence = ({
  genbank,
  annotationOnClick
}) => {
  const features = genbank.features.map((feature) => {
    return GenbankFeatureSchema.parse(feature);
  });
  const annotations = genbankFeaturesToAnnotations({
    features,
    annotationOnClick
  });
  const stackedAnnotations = stackAnnsByType(annotations);
  const { successes, failures } = safeAnythingToAnnotatedSequences({
    payload: genbank.sequence,
    payloadType: "raw",
    annotations: stackedAnnotations
  });
  if (failures.length > 0) {
    throw new Error(`Failed to parse genbank: ${failures[0]}`);
  }
  if (successes.length !== 1 || successes[0].sequences.length !== 1) {
    throw new Error(`Expected exactly one annotated sequence`);
  }
  return {
    annotatedSequence: annotatedSequenceSchema.parse(successes[0].sequences[0]),
    annotations
  };
};
const genbankFeaturesToAnnotations = ({
  features,
  annotationOnClick
}) => {
  return features.map((feature) => {
    const [start, end] = [feature.start, feature.end];
    return {
      type: feature.type,
      start,
      end,
      label: feature.type,
      text: feature.name,
      direction: feature.strand === 1 ? "forward" : "reverse",
      className: getClassNameFromFeatureType(feature.type),
      onClick: annotationOnClick
    };
  });
};
function getClassNameFromFeatureType(annType) {
  const common = "cursor-pointer opacity-60 group-hover:opacity-100 !text-xs hover:opacity-100 pointer-events-all text-white text-clip overflow-hidden whitespace-nowrap";
  const classNameMap = zipArrays(
    [
      "CDS",
      "enhancer",
      "intron",
      "misc_feature",
      "polyA_signal",
      "promoter",
      "protein_bind",
      "rep_origin",
      "LTR",
      "source",
      "insertion"
    ],
    [
      "bg-red-600 fill-red-600 stroke-red-600",
      "bg-blue-600 fill-blue-600 stroke-blue-600",
      "bg-green-600 fill-green-600 stroke-green-600",
      "bg-yellow-600 fill-yellow-600 stroke-yellow-600",
      "bg-orange-600 fill-orange-600 stroke-orange-600",
      "bg-purple-600 fill-purple-600 stroke-purple-600",
      "bg-sky-600 fill-sky-600 stroke-sky-600",
      "bg-teal-600 fill-teal-600 stroke-teal-600",
      "bg-gray-600 fill-gray-600 stroke-gray-600",
      "bg-pink-600 fill-pink-600 stroke-pink-600"
    ]
  );
  if (annType in classNameMap) {
    return `${common} ${classNameMap[annType]}`;
  }
  return common;
}
const zipArrays = (keys, values) => {
  return Object.fromEntries(
    keys.map((key, i) => {
      const val = values[i];
      return [key, val];
    })
  );
};
const parseGenbank = (genbankString) => {
  const result = genbankParser(genbankString);
  return result;
};
const getComplement = (sequence) => {
  const complement = {
    A: "T",
    T: "A",
    C: "G",
    G: "C",
    N: "N"
  };
  return sequence.split("").map((base) => {
    if (base in complement) {
      return complement[base];
    } else {
      return "?";
    }
  }).join("");
};
const getAnnotatedSequence = ({
  sequence,
  stackedAnnotations,
  noValidate
}) => {
  const mapFn = (base, idx) => {
    const annotationsForBase = stackedAnnotations.filter((annotation) => {
      if (annotation.start > annotation.end) {
        const isBetweenAnnotationStartAndEndofSequence = idx >= annotation.start && idx <= sequence.length;
        const isBetweenStartOfSequenceAndAnnotationEnd = idx >= 0 && idx <= annotation.end;
        return isBetweenAnnotationStartAndEndofSequence || isBetweenStartOfSequenceAndAnnotationEnd;
      } else {
        return idx >= annotation.start && idx <= annotation.end;
      }
    });
    return {
      base,
      index: idx,
      annotations: annotationsForBase,
      complement: getComplement(base)
    };
  };
  const raw = sequence.split("").map(mapFn).filter((x) => x.base !== " ");
  const annotatedSequence = annotatedSequenceSchema.safeParse(raw);
  if (noValidate) {
    if (annotatedSequence.success === false) {
      console.warn(annotatedSequence.error);
    }
    return raw;
  }
  if (annotatedSequence.success === false) {
    throw new Error(annotatedSequence.error.message);
  }
  return annotatedSequence.data;
};
const stackElements = (elements) => {
  if (elements.length === 0) {
    return [];
  }
  const last = (arr) => arr[arr.length - 1];
  const first = (arr) => arr[0];
  const maxIndex = elements.map((e) => e.end).reduce((a, b) => Math.max(a, b));
  const stack = [];
  elements.forEach((a) => {
    const insertIndex = stack.findIndex((elems) => {
      if (a.end === a.start) {
        return -1;
      }
      if (last(elems).end <= last(elems).start) {
        return last(elems).end + maxIndex <= a.start;
      }
      if (a.end > a.start) {
        return last(elems).end <= a.start;
      }
      return last(elems).end < a.start && a.end < first(elems).start;
    });
    if (insertIndex > -1) {
      stack[insertIndex].push(a);
    } else {
      stack.push([a]);
    }
  });
  return stack.map((row) => row.sort((a, b) => a.start - b.start));
};
const getStackedAnnotations = (annotations) => {
  const stackedAnnotations = stackElements(annotations);
  return stackedAnnotations.map((row, idx) => row.map((annotation) => ({ ...annotation, stack: idx }))).flat();
};
const baseInSelection = ({
  baseIndex,
  selection,
  sequenceLength
}) => {
  if (!selection) {
    return false;
  }
  const { start, end } = selection;
  if (start === end) {
    return baseIndex === start;
  }
  if (start < end) {
    return inRange(baseIndex, start, end);
  } else {
    return inRange(baseIndex, start, sequenceLength) || inRange(baseIndex, 0, end);
  }
};
const inRange = (value, min2, max2) => {
  return value >= min2 && value <= max2;
};
const getSubsequenceLength = ({ start, end }, sequenceLength) => {
  if (start < end) {
    return end - start;
  } else {
    return sequenceLength - start + end;
  }
};
const anythingToAnnotatedSequences = ({
  payload,
  payloadType,
  annotations,
  annotationOnClick
}) => {
  const { successes, failures } = safeAnythingToAnnotatedSequences({
    payload,
    payloadType,
    annotations,
    annotationOnClick
  });
  if (failures.length > 0) {
    const failString = failures.map((f) => f.error).join("\n");
    throw new Error(`Parse failures: ${failString}`);
  }
  const sequences = successes.map((s) => s.sequences).flat();
  const newAnnotations = successes.map((s) => s.annotations).flat();
  const stackedAnnotations = getStackedAnnotations(newAnnotations);
  return { sequences, stackedAnnotations };
};
const safeAnythingToAnnotatedSequences = ({
  payload,
  payloadType,
  annotations,
  annotationOnClick
}) => {
  const successes = [];
  const failures = [];
  switch (payloadType) {
    case "raw": {
      try {
        const sequences = [
          stringToAnnotatedSequence({
            sequence: payload,
            annotations: annotations ?? []
          })
        ];
        successes.push({
          source: {
            payload,
            annotations,
            annotationOnClick,
            payloadType
          },
          sequences,
          annotations: annotations ?? []
        });
      } catch (e) {
        failures.push({
          source: {
            payload,
            annotations,
            annotationOnClick,
            payloadType
          },
          error: `Failed to parse raw sequence: ${e}`
        });
      }
      break;
    }
    case "parsed-genbank":
    case "genbank": {
      const parsed = payloadType === "parsed-genbank" ? [payload] : genbankParser(payload);
      parsed.forEach((genbank) => {
        try {
          const sequence = genbankToAnnotatedSequence({
            genbank,
            annotationOnClick
          }).annotatedSequence;
          successes.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            sequences: [sequence],
            annotations: []
          });
        } catch (e) {
          failures.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            error: `Failed to parse genbank: ${e}`
          });
        }
      });
      break;
    }
    case "fasta": {
      let records;
      if (payloadType === "fasta") {
        records = parseFasta(payload);
      } else {
        records = parseFastq(payload);
      }
      records.forEach((record) => {
        try {
          const res = safeAnythingToAnnotatedSequences({
            payload: record.sequence,
            payloadType: "raw"
          });
          failures.push(...res.failures);
          successes.push(...res.successes);
        } catch (e) {
          failures.push({
            source: {
              payload,
              annotations,
              annotationOnClick,
              payloadType
            },
            error: `Failed to parse ${payloadType}: ${e}`
          });
        }
      });
      break;
    }
    default: {
      failures.push({
        source: {
          payload,
          annotations,
          annotationOnClick,
          payloadType
        },
        error: `Unknown payload type: ${payloadType}`
      });
      break;
    }
  }
  return {
    successes,
    failures
  };
};
const stringToAnnotatedSequence = ({
  sequence,
  annotations
}) => {
  const stackedAnnotations = getStackedAnnotations(annotations ?? []);
  const annotatedSequence = getAnnotatedSequence({
    sequence,
    stackedAnnotations
  });
  return annotatedSequence;
};
const annotationsHaveOverlap = (a1, a2, maxLen) => {
  if (baseInSelection({
    baseIndex: a1.start,
    selection: a2,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a1.end,
    selection: a2,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a2.start,
    selection: a1,
    sequenceLength: maxLen
  })) {
    return true;
  }
  if (baseInSelection({
    baseIndex: a2.end,
    selection: a1,
    sequenceLength: maxLen
  })) {
    return true;
  }
  return false;
};
const stackAnnotationsNoOverlap = (annotations, maxLen) => {
  const annotationsByStack = [];
  annotations.map((annotation) => {
    let curStack = 0;
    while (true) {
      const stackAnns = annotationsByStack[curStack];
      if (!stackAnns) {
        annotationsByStack[curStack] = [annotation];
        return;
      }
      let overlap = false;
      for (const stackedAnn of stackAnns) {
        if (annotationsHaveOverlap(annotation, stackedAnn, maxLen)) {
          overlap = true;
          break;
        }
      }
      if (overlap) {
        curStack += 1;
      } else {
        annotationsByStack[curStack].push(annotation);
        return;
      }
    }
  });
  const stackedAnnotations = [];
  annotationsByStack.forEach((stackedAnns, index2) => {
    stackedAnns.forEach((annotation) => {
      stackedAnnotations.push({
        ...annotation,
        stack: index2
      });
    });
  });
  return stackedAnnotations;
};
const stackAnnsByType = (annotations) => {
  const annotationMap = annotations.reduce(
    (acc, annotation) => {
      if (acc[annotation.type] === void 0) {
        acc[annotation.type] = [];
      }
      acc[annotation.type].push(annotation);
      return acc;
    },
    {}
  );
  const stacks = Object.values(annotationMap).map((stack, stackIdx) => {
    return stack.map((annotation) => {
      const res = {
        ...annotation,
        stack: stackIdx
      };
      return res;
    });
  }).flat();
  return stacks;
};
function parseFastq(data) {
  const lines = data.trim().split("\n");
  const records = [];
  for (let i = 0; i < lines.length; i += 4) {
    const record = {
      id: lines[i].substring(1),
      sequence: lines[i + 1],
      optionalId: lines[i + 2].substring(1),
      quality: lines[i + 3]
    };
    records.push(record);
  }
  return records;
}
function parseFasta(data) {
  const lines = data.trim().split("\n");
  const records = [];
  for (let i = 0; i < lines.length; i += 2) {
    const record = {
      id: lines[i].substring(1),
      sequence: lines[i + 1]
    };
    records.push(record);
  }
  return records;
}
const useStateRef = (initialValue) => {
  const ref = useRef(initialValue);
  const [state, internalSetState] = useState(initialValue);
  const setState = useCallback((value) => {
    ref.current = value;
    internalSetState(value);
  }, []);
  return [state, setState, ref];
};
const useLinearSelectionRect = ({
  ref,
  onMouseUp,
  onMouseDown,
  onMouseMove
}) => {
  const [start, setStart, startRef] = useStateRef(null);
  const [end, setEnd, endRef] = useStateRef(null);
  const [direction, setDirection] = useState("forward");
  const active = useRef(false);
  const _onMouseDown = (e) => {
    var _a;
    const { clientX, clientY } = e;
    const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
      left: 0,
      top: 0
    };
    const x = clientX - left;
    const y = clientY - top;
    active.current = true;
    setStart({ x, y });
    setEnd({ x, y });
    onMouseDown == null ? void 0 : onMouseDown({ start: { x, y } });
  };
  const _onMouseUp = () => {
    active.current = false;
    if (startRef.current && endRef.current) {
      onMouseUp == null ? void 0 : onMouseUp({ start: startRef.current, end: endRef.current });
    } else {
      console.error("start or end is null when mouseup");
    }
  };
  const _onMouseMove = (e) => {
    var _a, _b;
    if (active.current) {
      const { clientX, clientY } = e;
      const { left, top } = ((_a = ref.current) == null ? void 0 : _a.getBoundingClientRect()) || {
        left: 0,
        top: 0
      };
      const x = clientX - left;
      const y = clientY - top;
      const { startX } = {
        startX: (_b = startRef.current) == null ? void 0 : _b.x
      };
      if (startX && startX > x) {
        setDirection("reverse");
      } else {
        setDirection("forward");
      }
      setEnd({ x, y });
      if (startRef.current && endRef.current) {
        onMouseMove == null ? void 0 : onMouseMove({ start: startRef.current, end: endRef.current });
      } else {
        console.error("start is null when mousemove");
      }
    }
  };
  useEffect(() => {
    const node = ref == null ? void 0 : ref.current;
    if (node) {
      node.addEventListener("mousedown", _onMouseDown);
      node.addEventListener("mousemove", _onMouseMove);
    }
    if (window) {
      window.addEventListener("mouseup", _onMouseUp);
    }
    return () => {
      node == null ? void 0 : node.removeEventListener("mousedown", _onMouseDown);
      node == null ? void 0 : node.removeEventListener("mousemove", _onMouseMove);
      window == null ? void 0 : window.removeEventListener("mouseup", _onMouseUp);
    };
  }, [ref]);
  return { start, end, direction };
};
const useCircularSelectionRect = (ref) => {
  const [start, setStart, startRef] = useStateRef(null);
  const [end, setEnd] = useStateRef(null);
  const [direction, setDirection] = useState(null);
  const ANGLE_DELTA_THRESHOLD_IN_DEGREES = 2;
  const active = useRef(false);
  const onMouseDown = (e) => {
    if (ref.current) {
      console.debug("resetting start and end");
      setStart(null);
      setEnd(null);
      setDirection(null);
      active.current = true;
      const { clientX, clientY } = e;
      const { left, top, width, height } = ref.current.getBoundingClientRect();
      const x = clientX - left;
      const y = clientY - top;
      const center = { x: width / 2, y: height / 2 };
      const startAngle = findAngleFromCoor({ coor: { x, y }, center });
      setStart({
        degrees: startAngle,
        center
      });
    }
  };
  const onMouseUp = () => {
    active.current = false;
    setDirection(null);
  };
  const onMouseMove = (e) => {
    if (active.current && ref.current) {
      const { clientX, clientY } = e;
      const { left, top, width, height } = ref.current.getBoundingClientRect();
      const x = clientX - left;
      const y = clientY - top;
      const center = { x: width / 2, y: height / 2 };
      if (Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) < 0.4 * (width / 2)) {
        console.debug("within 0.5 radius of center, not updating selection");
        return;
      }
      const endAngle = findAngleFromCoor({ coor: { x, y }, center });
      if (startRef.current) {
        const startAngle = startRef.current.degrees;
        const endAngleIsNearStartAngle = inRange(
          endAngle,
          startAngle - ANGLE_DELTA_THRESHOLD_IN_DEGREES,
          startAngle + ANGLE_DELTA_THRESHOLD_IN_DEGREES
        );
        if (endAngleIsNearStartAngle) {
          setDirection(null);
        }
      }
      setEnd({
        degrees: endAngle,
        center
      });
    }
  };
  useEffect(
    function determineDirection() {
      if (start && end && direction === null) {
        const startAngle = start.degrees;
        const endAngle = end.degrees;
        const delta = endAngle - startAngle;
        const guessedDirection = delta > 0 ? "clockwise" : "counterclockwise";
        setDirection(guessedDirection);
      }
    },
    [start, end]
  );
  useEffect(
    function handleEventListeners() {
      const node = ref.current;
      if (node) {
        node.addEventListener("mousedown", onMouseDown);
        node.addEventListener("mousemove", onMouseMove);
        node.addEventListener("mouseup", onMouseUp);
      }
      if (window) {
        window.addEventListener("mouseup", onMouseUp);
      }
      return () => {
        node == null ? void 0 : node.removeEventListener("mousedown", onMouseDown);
        node == null ? void 0 : node.removeEventListener("mousemove", onMouseMove);
        node == null ? void 0 : node.removeEventListener("mouseup", onMouseUp);
        window == null ? void 0 : window.removeEventListener("mouseup", onMouseUp);
      };
    },
    [ref.current, start, direction]
  );
  return { start, end, direction };
};
function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}
const cn = classNames;
const CircularAnnotation = ({
  sequence,
  annotation,
  radius,
  center
}) => {
  const { x: cx, y: cy } = center;
  const annotationLength = getSubsequenceLength(annotation, sequence.length);
  if (annotationLength > sequence.length) {
    console.error(
      `Annotation ${annotation.text}'s length is greater than sequence length: ${annotationLength} > ${sequence.length}`
    );
  }
  const arcPath = genArc({
    innerRadius: radius,
    outerRadius: radius + 5,
    largeArc: annotationLength > sequence.length / 2,
    length: annotationLength,
    seqLength: sequence.length,
    offset: annotation.start,
    center: { x: cx, y: cy }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      className: classNames(annotation.className),
      onClick: () => {
        var _a;
        (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("path", { d: arcPath, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: annotation.text }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: "Annotation" })
      ] })
    }
  );
};
const CircularAnnotationGutter = ({
  stackedAnnotations,
  cx,
  cy,
  radius,
  annotatedSequence
}) => {
  const gutterRadius = radius * 0.3;
  const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
  const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
  stackedAnnotations = stackedAnnotations.map((annotation) => {
    const clampedBounds = clampSlice({
      slice: annotation,
      firstIdx,
      lastIdx
    });
    if (!clampedBounds) {
      return null;
    }
    return {
      ...annotation,
      start: clampedBounds.start,
      end: clampedBounds.end
    };
  }).filter(Boolean);
  const stacks = [];
  stackedAnnotations.forEach((ann) => {
    stacks[ann.stack] = stacks[ann.stack] || [];
    stacks[ann.stack].push(ann);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx, cy, r: gutterRadius, fill: "none", strokeWidth: 0.8 }),
    ";",
    stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Fragment, { children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CircularAnnotation,
      {
        annotation,
        radius: gutterRadius + stackIdx * 6,
        center: { x: cx, y: cy },
        sequence: annotatedSequence
      },
      `stack-${stackIdx}-${annotation.start}-${annotation.end}-${annotation.text}`
    )) }, `annotation-stack-${stackIdx}`))
  ] });
};
const CircularIndex = ({
  annotatedSequence,
  cx,
  cy,
  radius,
  ticks
}) => {
  const basesPerTick = Math.floor(annotatedSequence.length / ticks);
  if (annotatedSequence.length > 50) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `fill-current`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "circle",
        {
          cx,
          cy,
          r: radius * 0.75,
          fill: "none",
          stroke: "currentColor",
          strokeWidth: 2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ticks,
        {
          cx,
          cy,
          radius: radius * 0.75,
          basesPerTick,
          totalBases: annotatedSequence.length
        }
      )
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("text", { children: annotatedSequence.map(({ base: letter }, index2) => {
    const { x, y } = findCoor({
      index: index2,
      radius: radius * 0.7,
      center: { x: cx, y: cy },
      seqLength: annotatedSequence.length
    });
    const rotateDegrees = index2 / annotatedSequence.length * 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "tspan",
      {
        x,
        y,
        transform: `rotate(${rotateDegrees} ${x} ${y})`,
        textAnchor: "middle",
        dominantBaseline: "middle",
        color: "currentColor",
        fill: "currentColor",
        fontSize: "0.5rem",
        fontWeight: "thin",
        fontFamily: "inherit",
        "data-seq-index": index2,
        children: letter
      },
      `base-${index2}`
    );
  }) });
};
const Ticks = ({
  radius,
  cx,
  cy,
  basesPerTick,
  totalBases
}) => {
  const numberOfTicks = Math.floor(totalBases / basesPerTick);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { children: [...Array(numberOfTicks).keys()].map((i) => {
    const { x: x1, y: y1 } = findCoor({
      index: i,
      radius,
      center: { x: cx, y: cy },
      seqLength: totalBases
    });
    const { x: x2, y: y2 } = findCoor({
      index: i,
      radius: radius * 1.1,
      center: { x: cx, y: cy },
      seqLength: totalBases
    });
    const rotateDegrees = i / numberOfTicks * 360;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          id: `tick-${i}`,
          x1,
          y1,
          x2,
          y2,
          stroke: "currentColor",
          strokeWidth: 1,
          opacity: 0.5,
          transform: `rotate(${rotateDegrees} ${cx} ${cy})`
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "text",
        {
          x: x2,
          y: y2 - 4,
          textAnchor: "middle",
          fontSize: ".8rem",
          transform: `rotate(${rotateDegrees} ${cx} ${cy})`,
          fill: "currentColor",
          opacity: 0.75,
          children: i * basesPerTick
        }
      )
    ] }, `tick-${i}`);
  }) });
};
const CircularViewer = ({
  sequence,
  annotations,
  selection,
  setSelection,
  containerClassName,
  svgSizePX = 300,
  svgPadding = 20
}) => {
  const { cx, cy, sizeX, sizeY, radius } = {
    cx: svgSizePX / 2,
    cy: svgSizePX / 2,
    sizeX: svgSizePX,
    sizeY: svgSizePX,
    radius: (svgSizePX - svgPadding) / 2
  };
  const stackedAnnotations = stackAnnsByType(annotations);
  const annotatedSequence = useMemo(
    function memoize() {
      return getAnnotatedSequence({
        sequence,
        stackedAnnotations: getStackedAnnotations(annotations)
      });
    },
    [sequence, annotations]
  );
  if (annotatedSequence && selection && annotatedSequence.length > 0) {
    const firstIdx = annotatedSequence.length > 0 ? annotatedSequence.at(0).index : 0;
    const lastIdx = annotatedSequence.length > 0 ? annotatedSequence.at(-1).index : 0;
    selection = clampSlice({ slice: selection, firstIdx, lastIdx });
  }
  const selectionRef = useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames(
        "flex select-none items-center justify-center font-thin",
        containerClassName
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          ref: selectionRef,
          viewBox: `0 0 ${sizeX} ${sizeY}`,
          xmlns: "http://www.w3.org/2000/svg",
          fontFamily: "inherit",
          fontSize: "inherit",
          fontWeight: "inherit",
          className: `stroke-current`,
          width: sizeX,
          height: sizeY,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularIndex,
              {
                cx,
                cy,
                radius,
                annotatedSequence,
                ticks: 4
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularAnnotationGutter,
              {
                annotatedSequence,
                stackedAnnotations,
                cx,
                cy,
                radius
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CircularSelection,
              {
                annotatedSequence,
                selection,
                cx,
                cy,
                radius,
                selectionRef,
                setSelection
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "text",
              {
                x: cx,
                y: cy,
                textAnchor: "middle",
                fill: "currentColor",
                stroke: "currentColor",
                alignmentBaseline: "middle",
                fontSize: "1rem",
                children: [
                  annotatedSequence.length,
                  " bp"
                ]
              }
            )
          ]
        }
      )
    }
  );
};
const CircularSelection = ({
  radius,
  cx,
  cy,
  selection,
  selectionRef,
  setSelection,
  annotatedSequence
}) => {
  var _a, _b;
  const {
    start: internalSelectionStart,
    end: internalSelectionEnd,
    direction: internalDirection
  } = useCircularSelectionRect(selectionRef);
  useEffect(
    function propagateSelectionUp() {
      if (selectionRef.current && internalSelectionStart && internalSelectionEnd && internalDirection) {
        const start2 = findIndexFromAngle({
          angle: internalSelectionStart,
          seqLength: annotatedSequence.length
        });
        const end2 = findIndexFromAngle({
          angle: internalSelectionEnd,
          seqLength: annotatedSequence.length
        });
        const direction = internalDirection === "clockwise" ? "forward" : "reverse";
        const prevLength = selection ? Math.abs(selection.end - selection.start) : 0;
        const newLength = getSubsequenceLength(
          { start: start2, end: end2 },
          annotatedSequence.length
        );
        const deltaLength = Math.abs(prevLength - newLength);
        const deltaThreshold = Math.max(0.7 * annotatedSequence.length, 10);
        if (deltaLength > deltaThreshold && selection) {
          setSelection({
            start: start2,
            end: end2,
            direction: selection == null ? void 0 : selection.direction
          });
          return;
        }
        setSelection({
          start: start2,
          end: end2,
          direction
        });
      }
    },
    [internalSelectionStart, internalSelectionEnd]
  );
  if (selection === null) {
    return null;
  }
  const { start, end } = selection;
  if (start === null || end === null) {
    return null;
  }
  const center = { x: cx, y: cy };
  const innerRadius = radius;
  const outerRadius = radius + 10;
  const length = getSubsequenceLength(selection, annotatedSequence.length);
  const [startIdx, endIdx] = [
    (_a = annotatedSequence.at(0)) == null ? void 0 : _a.index,
    (_b = annotatedSequence.at(-1)) == null ? void 0 : _b.index
  ];
  if (startIdx === void 0 || endIdx === void 0) {
    console.error("CircularViewer: sequence has no indices");
    return null;
  }
  const offset2 = start - startIdx;
  const seqLength = annotatedSequence.length;
  const arc = genArc({
    center,
    innerRadius,
    largeArc: length > seqLength / 2,
    length,
    offset: offset2,
    outerRadius,
    seqLength
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      d: arc,
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }
  ) });
};
const LinearAnnotationGutter = ({
  stackedAnnotations,
  sequence,
  containerClassName
}) => {
  const stacks = [];
  stackedAnnotations.forEach((ann) => {
    stacks[ann.stack] = stacks[ann.stack] || [];
    stacks[ann.stack].push(ann);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames(
        "grid-rows-auto block grid grid-cols-1 gap-1",
        containerClassName
      ),
      children: stacks.map((annotations, stackIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-8", children: annotations.map((annotation) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation,
          sequence,
          stackIdx
        },
        `annotation-${annotation.text}-${annotation.start}-${annotation.end}-${annotation.direction}`
      )) }, `annotation-stack-${stackIdx}`))
    }
  );
};
const LinearAnnotation = ({
  annotation,
  sequence,
  stackIdx
}) => {
  const annotationSpansSeam = annotation.start > annotation.end;
  if (annotationSpansSeam) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation: {
            ...annotation,
            end: sequence.length,
            onClick: () => {
              var _a;
              (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
            }
          },
          sequence,
          stackIdx
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinearAnnotation,
        {
          annotation: {
            ...annotation,
            start: 0,
            onClick: () => {
              var _a;
              (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, { ...annotation });
            }
          },
          sequence,
          stackIdx
        }
      )
    ] });
  }
  const annotationRectangleWidthPerc = getSubsequenceLength(annotation, sequence.length) / sequence.length * 100;
  const xPerc = Math.min(annotation.start, annotation.end) / sequence.length * 100;
  const forwardClipPath = "polygon(0 0, 90% 0, 100% 50%, 90% 100%, 0 100%)";
  const reverseClipPath = "polygon(0 50%, 10% 0, 100% 0, 100% 100%, 10% 100%)";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "group absolute",
      style: {
        marginLeft: `${xPerc}%`,
        width: `${annotationRectangleWidthPerc}%`
      },
      onClick: () => {
        var _a;
        (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, annotation);
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classNames(
              "px-2",
              annotation.direction === "forward" ? "text-left" : "text-right",
              annotation.className
            ),
            style: {
              clipPath: annotation.direction === "forward" ? forwardClipPath : reverseClipPath
            },
            children: annotation.text
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: classNames(
              "absolute left-1/2 z-10 hidden -translate-x-1/2 translate-y-4 flex-col rounded-md px-2 py-1 text-sm group-hover:flex",
              annotation.className
            ),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.text }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: annotation.type })
            ]
          }
        )
      ]
    }
  );
};
const MISMATCH_DIST_PERC_THRESHOLD = 0.01;
const LinearViewer = (props) => {
  const {
    sequences,
    selection,
    annotations,
    setSelection,
    onDoubleClick,
    selectionClassName,
    mismatchClassName,
    containerClassName,
    sequenceClassName,
    stackingFn
  } = props;
  const stackedAnnotations = useMemo(
    function memoize() {
      return stackingFn ? stackingFn(annotations) : stackAnnotationsNoOverlap(
        annotations,
        Math.max(...sequences.map((seq) => seq.length))
      );
    },
    [annotations]
  );
  const annotatedSequences = useMemo(
    function memoize() {
      return sequences.map(
        (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations })
      );
    },
    [sequences, stackedAnnotations]
  );
  const baseSequence = annotatedSequences[0];
  const selectionRef = useRef(null);
  const SVG_WIDTH = 500;
  const SVG_HEIGHT = sequences.length * 10 + 10;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClassName || "", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        ref: selectionRef,
        className: classNames("select-none font-thin"),
        onDoubleClick,
        viewBox: `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`,
        width: "100%",
        height: "100%",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: annotatedSequences.map((sequence, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SequenceLine,
            {
              sequenceClassName,
              baseSequence: sequence,
              alignedSequences: annotatedSequences.filter((_, j) => j !== i),
              sequenceIdx: i,
              mismatchClassName
            }
          ) }, `Sequence-${i}`)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            LinearSelection,
            {
              selectionClassName,
              selectionRef,
              selection,
              setSelection,
              sequence: baseSequence
            }
          )
        ]
      }
    ),
    stackedAnnotations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      LinearAnnotationGutter,
      {
        containerClassName: "",
        stackedAnnotations,
        sequence: baseSequence
      }
    )
  ] });
};
const SequenceLine = ({
  baseSequence,
  sequenceIdx,
  alignedSequences,
  sequenceClassName,
  mismatchClassName
}) => {
  var _a, _b;
  const start = (_a = baseSequence[0]) == null ? void 0 : _a.index;
  if (start === void 0) {
    throw new Error(`Sequence must have at least one base ${baseSequence}`);
  }
  const end = (_b = baseSequence[baseSequence.length - 1]) == null ? void 0 : _b.index;
  if (end === void 0) {
    throw new Error(`Sequence must have at least one base ${baseSequence}`);
  }
  let maxEnd = end;
  alignedSequences.forEach((alignedSequence) => {
    var _a2;
    const otherEnd = (_a2 = alignedSequence.at(alignedSequence.length - 1)) == null ? void 0 : _a2.index;
    if (otherEnd === void 0) {
      throw new Error(
        `otherSequence must have at least one base ${alignedSequence}`
      );
    }
    if (otherEnd > maxEnd) {
      maxEnd = otherEnd;
    }
  });
  const startPerc = start / maxEnd;
  const endPerc = end / maxEnd;
  const mismatches = baseSequence.filter((base) => {
    const rootBase = baseSequence.at(base.index);
    return rootBase && rootBase.base !== base.base;
  });
  mismatchClassName = mismatchClassName ?? function mismatchClassName2(mismatch) {
    if (mismatch.base === "-") {
      return "fill-black stroke-black opacity-80";
    } else {
      return "dark:fill-red-600 dark:stroke-red-600 fill-red-700 stroke-red-700";
    }
  };
  let lastXPerc = -1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("", sequenceClassName({ sequenceIdx })),
        x1: `${startPerc * 100}%`,
        y1: `${sequenceIdx * 10 + 10}`,
        x2: `${endPerc * 100}%`,
        y2: `${sequenceIdx * 10 + 10}`,
        strokeWidth: 5,
        stroke: "currentColor"
      }
    ),
    mismatches.map((base) => {
      const xPerc = base.index / maxEnd * 100;
      const width = Math.max(1 / baseSequence.length * 100, 0.01);
      const diff = xPerc - lastXPerc;
      if (diff < MISMATCH_DIST_PERC_THRESHOLD) {
        return null;
      }
      lastXPerc = xPerc;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "g",
        {
          className: classNames((mismatchClassName == null ? void 0 : mismatchClassName(base)) || "bg-red-400"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "line",
            {
              x1: `${xPerc - width / 2}%`,
              y1: `${sequenceIdx * 10 + 10}`,
              x2: `${xPerc + width / 2}%`,
              y2: `${sequenceIdx * 10 + 10}`,
              strokeWidth: 5
            }
          )
        },
        `sequence-${sequenceIdx}-mismatch-${base.index}`
      );
    })
  ] });
};
const LinearSelection = ({
  selection,
  selectionRef,
  setSelection,
  sequence,
  selectionClassName
}) => {
  const {
    start: internalSelectionStart,
    end: internalSelectionEnd,
    direction: internalDirection
  } = useLinearSelectionRect({ ref: selectionRef });
  useEffect(
    function propagateSelectionUp() {
      var _a;
      if (selectionRef.current && internalSelectionStart && internalSelectionEnd) {
        const svgWidth = (_a = selectionRef.current) == null ? void 0 : _a.getBoundingClientRect().width;
        const start2 = Math.floor(
          internalSelectionStart.x / svgWidth * sequence.length
        );
        const end2 = Math.floor(
          internalSelectionEnd.x / svgWidth * sequence.length
        );
        if (selection == null || start2 === end2) {
          setSelection({
            start: start2,
            end: start2 + 1,
            direction: internalDirection
          });
          return;
        } else {
          setSelection({ start: start2, end: end2, direction: internalDirection });
        }
      }
    },
    [internalSelectionStart, internalSelectionEnd]
  );
  if (!selection) {
    return null;
  }
  const { start, end } = selection;
  let firstRectStart = Math.min(start, end) / sequence.length * 100;
  let firstRectWidth = getSubsequenceLength(selection, sequence.length) / sequence.length * 100;
  let secondRectStart = null;
  let secondRectWidth = null;
  const selectionSpansSeam = selection.start > selection.end;
  if (selectionSpansSeam) {
    firstRectStart = 0;
    firstRectWidth = end / sequence.length * 100;
    secondRectStart = start / sequence.length * 100;
    secondRectWidth = (sequence.length - start) / sequence.length * 100;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "g",
    {
      className: classNames(
        "fill-current stroke-current",
        selectionClassName == null ? void 0 : selectionClassName(selection)
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: `${firstRectStart}%`,
            width: `${firstRectWidth}%`,
            y: `0%`,
            height: `100%`,
            fill: "currentColor",
            fillOpacity: 0.2,
            strokeWidth: 1.5
          }
        ),
        secondRectStart && secondRectWidth && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: `${secondRectStart}%`,
            width: `${secondRectWidth}%`,
            y: `0%`,
            height: `100%`,
            fill: "currentColor",
            fillOpacity: 0.2,
            strokeWidth: 1.5
          }
        )
      ]
    }
  );
};
function clamp$1(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = React.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      var _a;
      const { scope, children, ...context } = props;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const value = React.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a;
      const Context = ((_a = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
var Slot = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React.Children.count(newElement) > 1) return React.Children.only(null);
        return React.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    const props2 = mergeProps(slotProps, children.props);
    if (children.type !== React.Fragment) {
      props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
    }
    return React.cloneElement(children, props2);
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return React.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React__default.useRef(null);
    const itemMap = React__default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React__default.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React__default.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React__default.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React__default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = React.createContext(void 0);
function useDirection(localDir) {
  const globalDir = React.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = React.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = React.useRef(callback);
  React.useEffect(() => {
    callbackRef.current = callback;
  });
  return React.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  React.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React.useContext(DismissableLayerContext);
    const [node, setNode] = React.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React.forwardRef((props, forwardedRef) => {
  const context = React.useContext(DismissableLayerContext);
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React.useRef(false);
  const handleClickRef = React.useRef(() => {
  });
  React.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = React.useRef(false);
  React.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count$1 = 0;
function useFocusGuards() {
  React.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$1++;
    return () => {
      if (count$1 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$1--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React.useLayoutEffect : () => {
};
var useReactId = React["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return id ? `radix-${id}` : "";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? useLayoutEffect : useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$1 = "Arrow";
var Arrow$1 = React.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$1;
var Root = Arrow$1;
function useSize(element) {
  const [size2, setSize] = React.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    React.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME$1 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1);
var PopperContent = React.forwardRef(
  (props, forwardedRef) => {
    var _a, _b, _c, _d, _e, _f;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$1, __scopePopper);
    const [content, setContent] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = React.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a = middlewareData.arrow) == null ? void 0 : _a.x;
    const arrowY = (_b = middlewareData.arrow) == null ? void 0 : _b.y;
    const cannotCenterArrow = ((_c = middlewareData.arrow) == null ? void 0 : _c.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = React.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d = middlewareData.transformOrigin) == null ? void 0 : _d.x,
            (_e = middlewareData.transformOrigin) == null ? void 0 : _e.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$1;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a, _b, _c;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a = middlewareData.arrow) == null ? void 0 : _a.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b = middlewareData.arrow) == null ? void 0 : _b.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c = middlewareData.arrow) == null ? void 0 : _c.y) ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$1 = "Portal";
var Portal$1 = React.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? ReactDOM__default.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$1.displayName = PORTAL_NAME$1;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = React.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  React.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
function usePrevious(value) {
  const ref = React.useRef({ value, previous: value });
  return React.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var NAME = "VisuallyHidden";
var VisuallyHidden = React.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id = React.useState(idCounter++)[0];
  var Style2 = React.useState(styleSingleton)[0];
  var lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope,
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  const [trigger, setTrigger] = React.useState(null);
  const [valueNode, setValueNode] = React.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = React.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: React.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: React.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME = "SelectTrigger";
var SelectTrigger$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection(__scopeSelect);
    const pointerTypeRef = React.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "SelectContent";
var SelectContent$1 = React.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);
    const [fragment, setFragment] = React.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME, __scopeSelect);
    const [content, setContent] = React.useState(null);
    const [viewport, setViewport] = React.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = React.useState(null);
    const [selectedItemText, setSelectedItemText] = React.useState(
      null
    );
    const getItems = useCollection(__scopeSelect);
    const [isPositioned, setIsPositioned] = React.useState(false);
    const firstValidItemFoundRef = React.useRef(false);
    React.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = React.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate == null ? void 0 : candidate.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate == null ? void 0 : candidate.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = React.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    React.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    React.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          var _a, _b;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (((_a = triggerPointerDownPosRef.current) == null ? void 0 : _a.x) ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (((_b = triggerPointerDownPosRef.current) == null ? void 0 : _b.y) ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    React.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = React.useCallback(() => content == null ? void 0 : content.focus(), [content]);
    const itemTextRefCallback = React.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              var _a;
              (_a = context.trigger) == null ? void 0 : _a.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);
  const [contentWrapper, setContentWrapper] = React.useState(null);
  const [content, setContent] = React.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection(__scopeSelect);
  const shouldExpandOnScrollRef = React.useRef(false);
  const shouldRepositionRef = React.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = React.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp$1(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp$1(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced == null ? void 0 : onPlaced();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = React.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = React.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem == null ? void 0 : focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = React.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = React.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if ((shouldExpandOnScrollRef == null ? void 0 : shouldExpandOnScrollRef.current) && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = React.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = React.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => {
        var _a;
        return (_a = contentContext.itemRefCallback) == null ? void 0 : _a.call(contentContext, node, value, disabled);
      }
    );
    const textId = useId();
    const pointerTypeRef = React.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: React.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || ((node == null ? void 0 : node.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  var _a;
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  var _a;
                  if (event.currentTarget === document.activeElement) {
                    (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  var _a;
                  const isTypingAhead = ((_a = contentContext.searchRef) == null ? void 0 : _a.current) !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = React.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _a;
        return (_a = contentContext.itemTextRefCallback) == null ? void 0 : _a.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode == null ? void 0 : itemTextNode.textContent;
    const nativeOption = React.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = React.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = React.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = React.useRef(null);
  const getItems = useCollection(__scopeSelect);
  const clearAutoScrollTimer = React.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  React.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    var _a;
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    (_a = activeItem == null ? void 0 : activeItem.ref.current) == null ? void 0 : _a.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        var _a;
        (_a = contentContext.onItemLeave) == null ? void 0 : _a.call(contentContext);
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator$1 = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow";
var SelectArrow = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(ARROW_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = React.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    React.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = React.useRef("");
  const timerRef = React.useRef(0);
  const handleTypeaheadSearch = React.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = React.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  React.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index2) => array[(startIndex + index2) % array.length]);
}
var Root2 = Select$1;
var Trigger = SelectTrigger$1;
var Value = SelectValue$1;
var Icon$1 = SelectIcon;
var Portal = SelectPortal;
var Content2 = SelectContent$1;
var Viewport = SelectViewport;
var Label = SelectLabel$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator = SelectSeparator$1;
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size2,
        height: size2,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = forwardRef(
    ({ className, ...props }, ref) => createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Copy = createLucideIcon("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
const Select = Root2;
const SelectValue = Value;
const SelectTrigger = React.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Trigger,
  {
    ref,
    className: cn(
      "ring-offset-background focus:ring-ring flex h-4 w-full items-center justify-between whitespace-nowrap rounded-md bg-transparent px-3 py-2 text-xs focus:outline-none focus:ring-1 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      "dark:placeholder-text-zinc-600 text-black placeholder:text-noir-400 dark:text-white",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "ml-1 h-4 w-4 text-black opacity-50 dark:text-white" }) })
    ]
  }
));
SelectTrigger.displayName = Trigger.displayName;
const SelectScrollUpButton = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollUpButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-4 w-4" })
  }
));
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollDownButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4" })
  }
));
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = React.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Content2,
  {
    ref,
    className: cn(
      "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
      position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      className
    ),
    position,
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Viewport,
        {
          className: cn(
            "p-1",
            position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
    ]
  }
) }));
SelectContent.displayName = Content2.displayName;
const SelectLabel = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label,
  {
    ref,
    className: cn("px-2 py-1.5 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel.displayName = Label.displayName;
const SelectItem = React.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Item,
  {
    ref,
    className: cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
    ]
  }
));
SelectItem.displayName = Item.displayName;
const SelectSeparator = React.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator,
  {
    ref,
    className: cn("bg-muted -mx-1 my-1 h-px", className),
    ...props
  }
));
SelectSeparator.displayName = Separator.displayName;
const CopyButton = ({
  label,
  buttonClassName,
  logoClassName,
  textToCopy,
  disabled
}) => {
  const [logo, setLogo] = useState(
    /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) })
  );
  const [internalLabel, setInternalLabel] = useState(label);
  const onClipboardCopy = () => {
    setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: cn("h-3 w-3", logoClassName) }));
    setInternalLabel("Copied!");
    setTimeout(() => {
      setLogo(/* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: cn("h-3 w-3", logoClassName) }));
      setInternalLabel(label);
    }, 1e3);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      "aria-label": "Copy to clipboard",
      disabled,
      className: cn(
        "flex items-center gap-2 disabled:cursor-not-allowed disabled:text-noir-400 dark:text-noir-100 dark:disabled:text-zinc-600",
        buttonClassName
      ),
      onClick: () => {
        const text = textToCopy();
        navigator.clipboard.writeText(text);
        onClipboardCopy();
      },
      children: [
        logo,
        internalLabel
      ]
    }
  );
};
const SequenceViewer = ({
  sequences,
  annotations,
  selection,
  setSelection,
  containerClassName,
  charClassName,
  selectionClassName,
  hideMetadataBar,
  noValidate
}) => {
  const [hoveredPosition, setHoveredPosition] = useState(null);
  const [seqIdxToCopy, setSeqIdxToCopy] = useState(0);
  const [activeAnnotation, setActiveAnnotation] = useState(
    null
  );
  const stackedAnnotations = useMemo(
    function memoize() {
      return stackAnnotationsNoOverlap(
        annotations,
        Math.max(...sequences.map((seq) => seq.length))
      );
    },
    [annotations]
  );
  const annotatedSequences = useMemo(
    function memoize() {
      return sequences.map(
        (sequence) => getAnnotatedSequence({ sequence, stackedAnnotations, noValidate })
      );
    },
    [sequences, stackedAnnotations]
  );
  const memoizedSeqContent = useMemo(() => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SeqContent,
      {
        annotatedSequences,
        selection,
        setSelection,
        setHoveredPosition,
        setActiveAnnotation,
        stackedAnnotations,
        charClassName,
        selectionClassName
      }
    );
  }, [annotatedSequences, selection, stackedAnnotations]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "relative isolate flex flex-wrap",
        containerClassName
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SeqMetadataBar,
          {
            hoveredPosition,
            activeAnnotation,
            className: classNames("sticky inset-x-0 top-0 z-[3] w-full px-2 py-1 backdrop-blur-md", hideMetadataBar ? "hidden" : ""),
            annotatedSequences,
            charClassName,
            seqIdxToCopy,
            setSeqIdxToCopy,
            selection
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap px-2", children: memoizedSeqContent })
      ]
    }
  ) });
};
const SeqContent = ({
  annotatedSequences,
  selection,
  setSelection,
  setHoveredPosition,
  setActiveAnnotation,
  stackedAnnotations,
  charClassName,
  selectionClassName
}) => {
  const mouseDown = useRef(false);
  const indicesClassName = ({
    base,
    sequenceIdx
  }) => {
    const isNotFirstSeq = sequenceIdx !== 0;
    const isNotMultipleOfTen = base.index % 10 !== 0;
    if (isNotFirstSeq || isNotMultipleOfTen) {
      return "opacity-0";
    }
    return classNames(
      "text-xs z-1",
      // don't allow selection of indices
      "dark:group-hover:text-noir-300 group-hover:text-noir-800",
      baseInSelection({
        baseIndex: base.index,
        selection,
        sequenceLength: annotatedSequences[sequenceIdx].length
      }) ? "text-brand-700 dark:text-brand-300" : "text-noir-400 dark:text-noir-600"
    );
  };
  const handleMouseUp = () => {
    mouseDown.current = false;
  };
  useEffect(function addMouseUpListener() {
    document.addEventListener("mouseup", () => {
      handleMouseUp();
    });
    return function removeMouseUpListener() {
      document.removeEventListener("mouseup", () => {
        handleMouseUp();
      });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: annotatedSequences[0].map(({ index: baseIdx }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: classNames(
          "relative mt-4 flex flex-col justify-between",
          "group hover:bg-noir-200 dark:hover:bg-noir-600"
        ),
        children: [
          annotatedSequences.map(
            (sequence, sequenceIdx) => {
              const base = sequence.find(
                (base2) => base2.index === baseIdx
              ) || { base: " ", annotations: [], index: baseIdx };
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: classNames("whitespace-pre text-center"),
                  onMouseEnter: () => {
                    setHoveredPosition(base.index);
                    if (mouseDown.current && selection) {
                      setSelection({
                        ...selection,
                        end: base.index
                      });
                    }
                  },
                  onMouseLeave: () => setHoveredPosition(null),
                  onMouseDown: () => {
                    mouseDown.current = true;
                    setSelection({
                      start: base.index,
                      end: base.index,
                      direction: "forward"
                    });
                  },
                  onMouseUp: handleMouseUp,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CharComponent,
                      {
                        char: `| ${base.index}`,
                        index: baseIdx,
                        charClassName: classNames(
                          "absolute -top-4 left-0",
                          "group-hover:text-brand-200 border-b border-noir-600 group-hover:border-noir-300",
                          indicesClassName({
                            base,
                            sequenceIdx
                          })
                        )
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CharComponent,
                      {
                        char: base.base,
                        index: baseIdx,
                        charClassName: classNames(
                          charClassName({
                            base,
                            sequenceIdx
                          }),
                          baseInSelection({
                            baseIndex: baseIdx,
                            selection,
                            sequenceLength: annotatedSequences[sequenceIdx].length
                          }) && base.base !== " " && selectionClassName
                        )
                      }
                    )
                  ]
                },
                `sequence-${sequenceIdx}-base-${baseIdx}`
              );
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SequenceAnnotation,
            {
              annotations: stackedAnnotations,
              index: baseIdx,
              maxAnnotationStack: Math.max(
                1,
                Math.max(...stackedAnnotations.map((ann) => ann.stack))
              ),
              setHoveredPosition,
              setActiveAnnotation,
              maxSequenceLength: Math.max(
                ...annotatedSequences.map((seq) => seq.length)
              )
            }
          )
        ]
      },
      `base-${baseIdx}`
    );
  }) });
};
const SeqMetadataBar = ({
  hoveredPosition,
  activeAnnotation,
  annotatedSequences,
  charClassName,
  seqIdxToCopy,
  setSeqIdxToCopy,
  selection,
  className
}) => {
  const annotationDisplay = activeAnnotation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: classNames(
        "flex gap-2 rounded-full px-2 py-px text-xs !opacity-100",
        "ml-auto",
        activeAnnotation.className
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Label: ",
          activeAnnotation.text
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Type: ",
          activeAnnotation.type
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Direction: ",
          activeAnnotation.direction
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "from ",
          activeAnnotation.start,
          " - ",
          activeAnnotation.end
        ] })
      ]
    }
  ) : null;
  const positionDisplay = /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "min-w-16 text-xs text-black dark:text-white", children: [
    "Pos: ",
    hoveredPosition ?? 0
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "flex h-8 items-center gap-1 py-1 text-xs",
        className
      ),
      children: [
        positionDisplay,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CopyDisplay,
          {
            annotatedSequences,
            charClassName,
            seqIdxToCopy,
            setSeqIdxToCopy,
            selection
          }
        ),
        annotationDisplay
      ]
    }
  );
};
const SequenceAnnotation = ({
  annotations,
  maxAnnotationStack,
  index: index2,
  setHoveredPosition,
  setActiveAnnotation,
  maxSequenceLength
}) => {
  const orderedAnnotations = annotations.sort((a, b) => a.stack - b.stack);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: " ",
      onMouseEnter: () => setHoveredPosition(index2),
      onMouseLeave: () => setHoveredPosition(null),
      children: [...Array(maxAnnotationStack).keys()].map((i) => {
        const annotation = orderedAnnotations.filter(
          (ann) => baseInSelection({
            baseIndex: index2,
            selection: ann,
            sequenceLength: maxSequenceLength
          })
        ).find((ann) => ann.stack === i);
        if (annotation) {
          if (!baseInSelection({
            baseIndex: index2,
            selection: annotation,
            sequenceLength: maxSequenceLength
          })) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-3 border-b-2 border-noir-100 opacity-10 "
              },
              `annotation-${index2}-${i}`
            );
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: classNames(
                "group/annotation h-3 border-black group-hover/annotation:border",
                annotation.className
              ),
              onClick: () => {
                var _a;
                return (_a = annotation.onClick) == null ? void 0 : _a.call(annotation, {
                  start: annotation.start,
                  end: annotation.end,
                  diection: annotation.direction
                });
              },
              onMouseEnter: () => setActiveAnnotation(annotation),
              onMouseLeave: () => setActiveAnnotation(null)
            },
            `annotation-${index2}-${i}`
          );
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3" }, `placeholder-${index2}-${i}`);
        }
      })
    },
    `annotation-${index2}`
  );
};
const CharComponent = ({ char, charClassName }) => {
  const sharedClassName = "font-mono select-none";
  if (char === " ") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "opacity-20"), children: "." });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(sharedClassName, charClassName, "mr-px"), children: char });
};
const CopyDisplay = ({
  seqIdxToCopy,
  setSeqIdxToCopy,
  annotatedSequences,
  charClassName,
  selection
}) => {
  const getStringToCopy = () => {
    if (!selection) {
      return;
    }
    const seq = annotatedSequences[seqIdxToCopy];
    const stringToCopy = seq.filter(
      (base) => baseInSelection({
        baseIndex: base.index,
        selection,
        sequenceLength: annotatedSequences[seqIdxToCopy].length
      })
    ).map((base) => base.base).join("");
    return stringToCopy;
  };
  useEffect(function mountCopyHandler() {
    const copyHandler = async (e) => {
      const stringToCopy = getStringToCopy();
      if (!stringToCopy) {
        return;
      }
      e.preventDefault();
      await navigator.clipboard.writeText(stringToCopy);
    };
    document.addEventListener("copy", copyHandler);
    return function unmountCopyHandler() {
      document.removeEventListener("copy", copyHandler);
    };
  }, [selection, annotatedSequences, seqIdxToCopy]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Select,
      {
        value: seqIdxToCopy.toString(),
        onValueChange: (value) => setSeqIdxToCopy(parseInt(value)),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-fit", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            SelectValue,
            {
              className: charClassName({
                base: { base: "A", annotations: [], index: 0 },
                sequenceIdx: seqIdxToCopy
              }),
              children: [
                "Sequence ",
                seqIdxToCopy + 1
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { className: "bg-white dark:bg-black", children: annotatedSequences.map((_, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            SelectItem,
            {
              value: idx.toString(),
              className: charClassName({
                base: { base: "A", annotations: [], index: 0 },
                sequenceIdx: idx
              }),
              children: [
                "Sequence ",
                idx + 1,
                " "
              ]
            },
            `sequence-${idx}`
          )) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CopyButton,
      {
        textToCopy: () => getStringToCopy() ?? "",
        label: "",
        disabled: !selection
      }
    )
  ] });
};
const ReferenceTicks = ({
  sequence,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("overflow-hiddentext-white flex", className), children: sequence.map((nucl, i) => {
    const showTicks = nucl.base !== "-" && (nucl.index + 1) % 10 === 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "relative flex h-12 flex-col items-end justify-end",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: classNames(
                "font-mono ",
                "absolute bottom-0 left-0 right-0",
                showTicks ? "opacity-100" : "opacity-0",
                nucl.base === "G" && "text-red-500",
                nucl.base === "A" && "text-yellow-500",
                nucl.base === "T" && "text-green-500",
                nucl.base === "C" && "text-blue-500"
              ),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs", children: [
                  " ",
                  nucl.index + 1
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mx-auto text-xs", children: "|" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("mr-px font-mono opacity-0"), children: nucl.base })
        ]
      },
      `base-${i}-index-wrapper`
    );
  }) });
};
export {
  CircularViewer,
  GapSchema,
  GenbankFeatureSchema,
  LinearAnnotationGutter,
  LinearViewer,
  ReferenceTicks,
  SequenceViewer,
  SpaceSchema,
  StopSchema,
  UnknownSchema,
  aaSchema,
  angleSchema,
  annotatedBaseSchema,
  annotatedSequenceSchema,
  annotationSchema,
  annotationTypeSchema,
  annotationsHaveOverlap,
  anythingToAnnotatedSequences,
  ariadneSelectionSchema,
  baseInSelection,
  coorSchema,
  genbankFeaturesToAnnotations,
  genbankToAnnotatedSequence,
  getAnnotatedSequence,
  getClassNameFromFeatureType,
  getComplement,
  getStackedAnnotations,
  getSubsequenceLength,
  inRange,
  nuclSchema,
  parseFasta,
  parseFastq,
  parseGenbank,
  safeAnythingToAnnotatedSequences,
  stackAnnotationsNoOverlap,
  stackAnnsByType,
  stackElements,
  stackedAnnotationSchema,
  stringToAnnotatedSequence,
  useCircularSelectionRect,
  useLinearSelectionRect,
  zipArrays
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibml0cm8tdWkuZXMuanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9DaXJjdWxhclZpZXdlci9jaXJjdWxhclV0aWxzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2dlbmJhbmstcGFyc2VyL3NyYy91dGlscy9tb250aHMuanMiLCIuLi9ub2RlX21vZHVsZXMvZ2VuYmFuay1wYXJzZXIvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9zY2hlbWFzLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9nZW5iYW5rVXRpbHMudHMiLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL3V0aWxzLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9ob29rcy91c2VTdGF0ZVJlZi50cyIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvaG9va3MvdXNlU2VsZWN0aW9uLnRzIiwiLi4vc3JjL3V0aWxzL3N0cmluZ1V0aWxzLnRzIiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9DaXJjdWxhclZpZXdlci9DaXJjdWxhckFubm90YXRpb25zL0NpcmN1bGFyQW5ub3RhdGlvbi50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0NpcmN1bGFyVmlld2VyL0NpcmN1bGFyQW5ub3RhdGlvbnMvQ2lyY3VsYXJBbm5vdGF0aW9uR3V0dGVyLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvQ2lyY3VsYXJJbmRleC9DaXJjdWxhckluZGV4LnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvQ2lyY3VsYXJWaWV3ZXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9MaW5lYXJWaWV3ZXIvTGluZWFyQW5ub3RhdGlvbkd1dHRlci50c3giLCIuLi9zcmMvY29tcG9uZW50cy9BcmlhZG5lL0xpbmVhclZpZXdlci9MaW5lYXJWaWV3ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9udW1iZXIvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3ByaW1pdGl2ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29udGV4dC9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtY29tcG9zZS1yZWZzL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1zbG90L2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1jb2xsZWN0aW9uL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1kaXJlY3Rpb24vZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZi9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWVzY2FwZS1rZXlkb3duL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1kaXNtaXNzYWJsZS1sYXllci9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtZm9jdXMtZ3VhcmRzL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1mb2N1cy1zY29wZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3QvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWlkL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanMiLCIuLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCIuLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LWFycm93L2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC11c2Utc2l6ZS9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtcG9wcGVyL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1wb3J0YWwvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1jb250cm9sbGFibGUtc3RhdGUvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvQHJhZGl4LXVpL3JlYWN0LXVzZS1wcmV2aW91cy9kaXN0L2luZGV4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9AcmFkaXgtdWkvcmVhY3QtdmlzdWFsbHktaGlkZGVuL2Rpc3QvaW5kZXgubWpzIiwiLi4vbm9kZV9tb2R1bGVzL2FyaWEtaGlkZGVuL2Rpc3QvZXMyMDE1L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC1iYXIvZGlzdC9lczIwMTUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1jYWxsYmFjay1yZWYvZGlzdC9lczIwMTUvYXNzaWduUmVmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1jYWxsYmFjay1yZWYvZGlzdC9lczIwMTUvdXNlUmVmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1jYWxsYmFjay1yZWYvZGlzdC9lczIwMTUvdXNlTWVyZ2VSZWYuanMiLCIuLi9ub2RlX21vZHVsZXMvdXNlLXNpZGVjYXIvZGlzdC9lczIwMTUvbWVkaXVtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3VzZS1zaWRlY2FyL2Rpc3QvZXMyMDE1L2V4cG9ydHMuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9tZWRpdW0uanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9VSS5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtbm9uY2UvZGlzdC9lczIwMTUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3R5bGUtc2luZ2xldG9uL2Rpc3QvZXMyMDE1L3NpbmdsZXRvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1zdHlsZS1zaW5nbGV0b24vZGlzdC9lczIwMTUvaG9vay5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1zdHlsZS1zaW5nbGV0b24vZGlzdC9lczIwMTUvY29tcG9uZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyL2Rpc3QvZXMyMDE1L3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyL2Rpc3QvZXMyMDE1L2NvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L2FnZ3Jlc2l2ZUNhcHR1cmUuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9oYW5kbGVTY3JvbGwuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVtb3ZlLXNjcm9sbC9kaXN0L2VzMjAxNS9TaWRlRWZmZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlbW92ZS1zY3JvbGwvZGlzdC9lczIwMTUvc2lkZWNhci5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZW1vdmUtc2Nyb2xsL2Rpc3QvZXMyMDE1L0NvbWJpbmF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0ByYWRpeC11aS9yZWFjdC1zZWxlY3QvZGlzdC9pbmRleC5tanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9JY29uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9jcmVhdGVMdWNpZGVJY29uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jaGVjay5qcyIsIi4uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2hldnJvbi1kb3duLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jaGV2cm9uLXVwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9pY29ucy9jb3B5LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvdWkvc2VsZWN0LnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL3VpL2NvcHktYnV0dG9uLnRzeCIsIi4uL3NyYy9jb21wb25lbnRzL0FyaWFkbmUvU2VxdWVuY2VWaWV3ZXIvU2VxdWVuY2VWaWV3ZXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudHMvQXJpYWRuZS9SZWZlcmVuY2VUaWNrcy9SZWZlcmVuY2VUaWNrcy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3ZhciBmPXJlcXVpcmUoXCJyZWFjdFwiKSxrPVN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLGw9U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLG09T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxuPWYuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIscD17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gcShjLGEsZyl7dmFyIGIsZD17fSxlPW51bGwsaD1udWxsO3ZvaWQgMCE9PWcmJihlPVwiXCIrZyk7dm9pZCAwIT09YS5rZXkmJihlPVwiXCIrYS5rZXkpO3ZvaWQgMCE9PWEucmVmJiYoaD1hLnJlZik7Zm9yKGIgaW4gYSltLmNhbGwoYSxiKSYmIXAuaGFzT3duUHJvcGVydHkoYikmJihkW2JdPWFbYl0pO2lmKGMmJmMuZGVmYXVsdFByb3BzKWZvcihiIGluIGE9Yy5kZWZhdWx0UHJvcHMsYSl2b2lkIDA9PT1kW2JdJiYoZFtiXT1hW2JdKTtyZXR1cm57JCR0eXBlb2Y6ayx0eXBlOmMsa2V5OmUscmVmOmgscHJvcHM6ZCxfb3duZXI6bi5jdXJyZW50fX1leHBvcnRzLkZyYWdtZW50PWw7ZXhwb3J0cy5qc3g9cTtleHBvcnRzLmpzeHM9cTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFO1xuXG57XG4gIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuLy8gZXZlbiB3aXRoIHRoZSBwcm9kIHRyYW5zZm9ybS4gVGhpcyBtZWFucyB0aGF0IGpzeERFViBpcyBwdXJlbHlcbi8vIG9wdC1pbiBiZWhhdmlvciBmb3IgYmV0dGVyIG1lc3NhZ2VzIGJ1dCB0aGF0IHdlIHdvbid0IHN0b3Bcbi8vIGdpdmluZyB5b3Ugd2FybmluZ3MgaWYgeW91IHVzZSBwcm9kdWN0aW9uIGFwaXMuXG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljKHR5cGUsIHByb3BzLCBrZXkpIHtcbiAge1xuICAgIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGpzeCA9ICBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWMgOyAvLyB3ZSBtYXkgd2FudCB0byBzcGVjaWFsIGNhc2UganN4cyBpbnRlcm5hbGx5IHRvIHRha2UgYWR2YW50YWdlIG9mIHN0YXRpYyBjaGlsZHJlbi5cbi8vIGZvciBub3cgd2UgY2FuIHNoaXAgaWRlbnRpY2FsIHByb2QgZnVuY3Rpb25zXG5cbnZhciBqc3hzID0gIGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsImltcG9ydCB7IEFuZ2xlLCBBcmlhZG5lU2VsZWN0aW9uLCBDb29yIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbi8qKlxuICogVGFrZW4gZnJvbSBzZXF2aXpcbiAqIEdpdmVuIGFuIGlubmVyIGFuZCBvdXRlciByYWRpdXMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50LCByZXR1cm4gdGhlXG4gKiBwYXRoIGZvciBhbiBhcmMgdGhhdCBjaXJjbGVzIHRoZSBwbGFzbWlkLiBUaGUgb3B0aW9uYWwgcGFyYW10ZXJzIHN3ZWVwRldEIGFuZCBzd2VlcFJFVlxuICogYXJlIG5lZWRlZCBmb3Igc2VsZWN0aW9uIGFyY3MgKHdoZXJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFyYyBpc24ndCBrbm93biBiZWZvcmVoYW5kKVxuICogYW5kIGFycm93RldEIGFuZCBhcnJvd1JFViBhcmUgbmVlZGVkIGZvciBhbm5vdGF0aW9ucywgd2hlcmUgdGhlcmUgbWF5IGJlIGRpcmVjdGlvbmFsaXR5XG4gKi9cbmV4cG9ydCBjb25zdCBnZW5BcmMgPSAoe1xuICBjZW50ZXIsXG4gIGlubmVyUmFkaXVzLFxuICBsYXJnZUFyYyxcbiAgbGVuZ3RoLFxuICBvZmZzZXQsXG4gIG91dGVyUmFkaXVzLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGNlbnRlcjogQ29vcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgbGFyZ2VBcmM6IGJvb2xlYW47XG4gIGxlbmd0aDogbnVtYmVyO1xuICBvZmZzZXQ6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogc3RyaW5nID0+IHtcbiAgY29uc3QgbGVmdEJvdHRvbSA9IGZpbmRDb29yKHtcbiAgICBpbmRleDogb2Zmc2V0LFxuICAgIHJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgY2VudGVyLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIGNvbnN0IGxlZnRUb3AgPSBmaW5kQ29vcih7XG4gICAgaW5kZXg6IG9mZnNldCxcbiAgICByYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgIGNlbnRlcixcbiAgICBzZXFMZW5ndGgsXG4gIH0pO1xuICBjb25zdCByaWdodEJvdHRvbSA9IGZpbmRDb29yKHtcbiAgICBpbmRleDogbGVuZ3RoICsgb2Zmc2V0LFxuICAgIHJhZGl1czogaW5uZXJSYWRpdXMsXG4gICAgY2VudGVyLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIGNvbnN0IHJpZ2h0VG9wID0gZmluZENvb3Ioe1xuICAgIGluZGV4OiBsZW5ndGggKyBvZmZzZXQsXG4gICAgcmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICBjZW50ZXIsXG4gICAgc2VxTGVuZ3RoLFxuICB9KTtcbiAgY29uc3Qgc0ZsYWdGID0gMTtcbiAgY29uc3Qgc0ZsYWdSID0gMDtcblxuICBjb25zdCBsQXJjID0gbGFyZ2VBcmMgPyAxIDogMDtcblxuICByZXR1cm4gYE0gJHtyaWdodEJvdHRvbS54fSAke3JpZ2h0Qm90dG9tLnl9XG4gICAgICBBICR7aW5uZXJSYWRpdXN9ICR7aW5uZXJSYWRpdXN9LCAwLCAke2xBcmN9LCAke3NGbGFnUn0sICR7bGVmdEJvdHRvbS54fSAke2xlZnRCb3R0b20ueX1cbiAgICAgIEwgJHtsZWZ0Qm90dG9tLnh9ICR7bGVmdEJvdHRvbS55fVxuICAgICAgTCAke2xlZnRUb3AueH0gJHtsZWZ0VG9wLnl9XG4gICAgICBBICR7b3V0ZXJSYWRpdXN9ICR7b3V0ZXJSYWRpdXN9LCAwLCAke2xBcmN9LCAke3NGbGFnRn0sICR7cmlnaHRUb3AueH0gJHtyaWdodFRvcC55fVxuICAgICAgWmA7XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIGluZGV4IGFsb25nIHRoZSBwbGFzbWlkIGFuZCBpdHMgcmFkaXVzLCBmaW5kIHN2ZyBjb29yZGluYXRlXG4gKiBmcm9tIHNlcXZpelxuICovXG5leHBvcnQgY29uc3QgZmluZENvb3IgPSAoe1xuICBpbmRleCxcbiAgcmFkaXVzLFxuICBjZW50ZXIsXG4gIHNlcUxlbmd0aCxcbn06IHtcbiAgaW5kZXg6IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGNlbnRlcjogQ29vcjtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogQ29vciA9PiB7XG4gIGNvbnN0IGxlbmd0aFBlcmMgPSBpbmRleCAvIHNlcUxlbmd0aDtcbiAgY29uc3QgbGVuZ3RoUGVyY0NlbnRlcmVkID0gbGVuZ3RoUGVyYyAtIDAuMjU7XG4gIGNvbnN0IHJhZGlhbnMgPSBsZW5ndGhQZXJjQ2VudGVyZWQgKiBNYXRoLlBJICogMjtcbiAgY29uc3QgeEFkanVzdCA9IE1hdGguY29zKHJhZGlhbnMpICogcmFkaXVzO1xuICBjb25zdCB5QWRqdXN0ID0gTWF0aC5zaW4ocmFkaWFucykgKiByYWRpdXM7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBjZW50ZXIueCArIHhBZGp1c3QsXG4gICAgeTogY2VudGVyLnkgKyB5QWRqdXN0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRJbmRleEZyb21Db29yID0gKHtcbiAgY29vcixcbiAgY2VudGVyLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGNvb3I6IENvb3I7XG4gIGNlbnRlcjogQ29vcjtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogbnVtYmVyID0+IHtcbiAgY29uc3QgeCA9IGNvb3IueCAtIGNlbnRlci54O1xuICBjb25zdCB5ID0gY29vci55IC0gY2VudGVyLnk7XG4gIGNvbnN0IHJhZGlhbnMgPSBNYXRoLmF0YW4yKHksIHgpO1xuICBjb25zdCBsZW5ndGhQZXJjID0gcmFkaWFucyAvIChNYXRoLlBJICogMikgKyAwLjI1O1xuICBjb25zdCByYXdCYXNlSWR4ID0gbGVuZ3RoUGVyYyAqIHNlcUxlbmd0aDtcbiAgLy8gaWYgd2UncmUgaW4gbmVnYXRpdmUgaW5kaWNlcywgY29udmVydCB0byB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZVxuICByZXR1cm4gTWF0aC5yb3VuZChyYXdCYXNlSWR4IDwgMCA/IHNlcUxlbmd0aCArIHJhd0Jhc2VJZHggOiByYXdCYXNlSWR4KTtcbn07XG5cbmV4cG9ydCBjb25zdCBmaW5kQW5nbGVGcm9tQ29vciA9ICh7XG4gIGNvb3IsXG4gIGNlbnRlcixcbn06IHtcbiAgY29vcjogQ29vcjtcbiAgY2VudGVyOiBDb29yO1xufSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHggPSBjb29yLnggLSBjZW50ZXIueDtcbiAgY29uc3QgeSA9IGNvb3IueSAtIGNlbnRlci55O1xuICBsZXQgcmFkaWFucyA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIGlmIChyYWRpYW5zIDwgMCkge1xuICAgIHJhZGlhbnMgPSByYWRpYW5zICsgTWF0aC5QSSAqIDI7XG4gIH1cbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZEFuZ2xlQmV0d2VlbkNvb3JzID0gKHtcbiAgY29vcjEsXG4gIGNvb3IyLFxuICBjZW50ZXIsXG59OiB7XG4gIGNvb3IxOiBDb29yO1xuICBjb29yMjogQ29vcjtcbiAgY2VudGVyOiBDb29yO1xufSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IGFuZ2xlMSA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogY29vcjEsIGNlbnRlciB9KTtcbiAgY29uc3QgYW5nbGUyID0gZmluZEFuZ2xlRnJvbUNvb3IoeyBjb29yOiBjb29yMiwgY2VudGVyIH0pO1xuICBjb25zdCBhbmdsZSA9IGFuZ2xlMiAtIGFuZ2xlMTtcbiAgcmV0dXJuIGFuZ2xlO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRJbmRleEZyb21BbmdsZSA9ICh7XG4gIGFuZ2xlLFxuICBzZXFMZW5ndGgsXG59OiB7XG4gIGFuZ2xlOiBBbmdsZTtcbiAgc2VxTGVuZ3RoOiBudW1iZXI7XG59KTogbnVtYmVyID0+IHtcbiAgLy8gemVybyBkZWdyZXNzIGlzIDI1JSBvZiB0aGUgc2VxdWVuY2UsIGFuZCB3ZSB3YW50IGtlZXAgZGVncmVlcyBiZXR3ZWVuIDAgYW5kIDM2MFxuICBsZXQgZWZmZWN0aXZlQW5nbGUgPSBhbmdsZS5kZWdyZWVzICsgOTA7XG4gIGlmIChlZmZlY3RpdmVBbmdsZSA8IDApIHtcbiAgICBlZmZlY3RpdmVBbmdsZSA9IDM2MCArIGVmZmVjdGl2ZUFuZ2xlO1xuICB9XG4gIGVmZmVjdGl2ZUFuZ2xlID0gZWZmZWN0aXZlQW5nbGUgJSAzNjA7XG4gIGNvbnN0IGFyY1BlcmMgPSBlZmZlY3RpdmVBbmdsZSAvIDM2MDtcblxuICBjb25zdCByYXdCYXNlSWR4ID0gYXJjUGVyYyAqIHNlcUxlbmd0aDtcbiAgcmV0dXJuIE1hdGgucm91bmQocmF3QmFzZUlkeCA8IDAgPyBzZXFMZW5ndGggKyByYXdCYXNlSWR4IDogcmF3QmFzZUlkeCk7XG59O1xuXG5leHBvcnQgY29uc3QgY2xhbXBTbGljZSA9ICh7XG4gIHNsaWNlLFxuICBmaXJzdElkeCxcbiAgbGFzdElkeCxcbn06IHtcbiAgc2xpY2U6IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkO1xuICBmaXJzdElkeDogbnVtYmVyO1xuICBsYXN0SWR4OiBudW1iZXI7XG59KTogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGwgPT4ge1xuICBpZiAoIXNsaWNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gc2xpY2U7XG5cbiAgY29uc3Qgb3V0T2ZCb3VuZHNCZWZvcmUgPSBzdGFydCA8IGZpcnN0SWR4ICYmIGVuZCA8IGZpcnN0SWR4O1xuICBjb25zdCBvdXRPZkJvdW5kc0FmdGVyID0gc3RhcnQgPiBsYXN0SWR4ICYmIGVuZCA+IGxhc3RJZHg7XG5cbiAgaWYgKG91dE9mQm91bmRzQmVmb3JlIHx8IG91dE9mQm91bmRzQWZ0ZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICBzdGFydCA9IE1hdGgubWluKHN0YXJ0LCBsYXN0SWR4KTtcbiAgICBlbmQgPSBNYXRoLm1heChlbmQsIGZpcnN0SWR4KTtcbiAgfSBlbHNlIHtcbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGxhc3RJZHgpO1xuICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIGZpcnN0SWR4KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBkaXJlY3Rpb246IHNsaWNlLmRpcmVjdGlvbixcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnSkFOJyxcbiAgJ0ZFQicsXG4gICdNQVInLFxuICAnQVBSJyxcbiAgJ01BWScsXG4gICdKVU4nLFxuICAnSlVMJyxcbiAgJ0FVRycsXG4gICdTRVAnLFxuICAnT0NUJyxcbiAgJ05PVicsXG4gICdERUMnLFxuXTtcbiIsIi8qIGVzbGludCBuby1kaXYtcmVnZXg6IDAqL1xuLyogZXNsaW50IHByZWZlci1uYW1lZC1jYXB0dXJlLWdyb3VwOiAwICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTU9OVEhTID0gcmVxdWlyZSgnLi91dGlscy9tb250aHMnKTtcblxuZnVuY3Rpb24gZ2VuYmFua1RvSnNvbihzZXF1ZW5jZSkge1xuICBpZiAodHlwZW9mIHNlcXVlbmNlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGxldCByZXN1bHRzQXJyYXkgPSBbXTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IGN1cnJlbnRGZWF0dXJlTm90ZTtcblxuICAvLyBHZW5iYW5rIHNwZWNpZmljYXRpb246IGh0dHBzOi8vd3d3Lm5jYmkubmxtLm5paC5nb3YvU2l0ZW1hcC9zYW1wbGVyZWNvcmQuaHRtbFxuICBsZXQgZ2VuYmFua0Fubm90YXRpb25LZXkgPSB7XG4gICAgLy8gQ29udGFpbnMgaW4gb3JkZXI6IGxvY3VzIG5hbWUsIHNlcXVlbmNlIGxlbmd0aCwgbW9sZWN1bGUgdHlwZSAoZS5nLiBETkEpLCBnZW5iYW5rIGRpdmlzaW9uIChzZWUgMS0xOCBiZWxvdyksIG1vZGlmaWNhdGlvbiBkYXRlXG4gICAgLy8gbG9jdXMgZGVmaW5pdGlvbiBoYXMgY2hhbmdlZCB3aXRoIHRpbWUsIHVzZSBhY2Nlc3Npb24gbnVtYmVyIGZvciBhIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgTE9DVVNfVEFHOiAnTE9DVVMnLFxuICAgIERFRklOSVRJT05fVEFHOiAnREVGSU5JVElPTicsXG4gICAgLy8gQWNjZXNzaW9uIHRhZ1xuICAgIC8vIEV4YW1wbGU6IFo3ODUzM1xuICAgIEFDQ0VTU0lPTl9UQUc6ICdBQ0NFU1NJT04nLFxuICAgIC8vIFRoZSB2ZXJzaW9uIHRhZyBjb250YWlucyAyIGluZm9ybWF0aW9uc1xuICAgIC8vIFRoZSBhY2Nlc3Npb24gbnVtYmVyIHdpdGggYSByZXZpc2lvblxuICAgIC8vIFRoZSBHSSAoR2VuSW5mbyBJZGVudGlmaWVyKSwgYSBuY2JpIHNlcXVlbnRpYWwgbnVtYmVyXG4gICAgLy8gRXhhbXBsZTogWjc4NTMzLjEgIEdJOjI3NjU2NThcbiAgICAvLyBVbmljaXR5IGdhcmFudGVlZCB3aXRoIHJlc3BlY3QgdG8gc2VxdWVuY2UuIElmIDEgbnVjbGVvdGlkZSBjaGFuZ2VzLCB0aGUgdmVyc2lvbiBpcyBkaWZmZXJlbnQuXG4gICAgVkVSU0lPTl9UQUc6ICdWRVJTSU9OJyxcbiAgICBLRVlXT1JEU19UQUc6ICdLRVlXT1JEUycsXG4gICAgLy8gU0VHTUVOVF9UQUc6XCJTRUdNRU5UXCJcbiAgICAvLyBTb3VyY2UgaXMgZnJlZSB0ZXh0XG4gICAgU09VUkNFX1RBRzogJ1NPVVJDRScsXG4gICAgT1JHQU5JU01fVEFHOiAnT1JHQU5JU00nLFxuICAgIFJFRkVSRU5DRV9UQUc6ICdSRUZFUkVOQ0UnLFxuICAgIEFVVEhPUlNfVEFHOiAnQVVUSE9SUycsXG4gICAgQ09OU09SVElVTV9UQUc6ICdDT05TUlRNJyxcbiAgICBUSVRMRV9UQUc6ICdUSVRMRScsXG4gICAgLy8gQ2FuIGJlIG11bHRpcGxlIGpvdXJuYWwgdGFnc1xuICAgIEpPVVJOQUxfVEFHOiAnSk9VUk5BTCcsXG4gICAgUFVCTUVEX1RBRzogJ1BVQk1FRCcsXG4gICAgUkVNQVJLX1RBRzogJ1JFTUFSSycsXG4gICAgRkVBVFVSRVNfVEFHOiAnRkVBVFVSRVMnLFxuICAgIEJBU0VfQ09VTlRfVEFHOiAnQkFTRSBDT1VOVCcsXG4gICAgLy8gQ09OVElHX1RBRzogXCJDT05USUdcIlxuICAgIE9SSUdJTl9UQUc6ICdPUklHSU4nLFxuICAgIEVORF9TRVFVRU5DRV9UQUc6ICcvLycsXG4gIH07XG5cbiAgLy8gR2VuYmFuayBkaXZpc2lvbnNcbiAgLy8gICAxLiBQUkkgLSBwcmltYXRlIHNlcXVlbmNlc1xuICAvLyAgIDIuIFJPRCAtIHJvZGVudCBzZXF1ZW5jZXNcbiAgLy8gICAzLiBNQU0gLSBvdGhlciBtYW1tYWxpYW4gc2VxdWVuY2VzXG4gIC8vICAgNC4gVlJUIC0gb3RoZXIgdmVydGVicmF0ZSBzZXF1ZW5jZXNcbiAgLy8gICA1LiBJTlYgLSBpbnZlcnRlYnJhdGUgc2VxdWVuY2VzXG4gIC8vICAgNi4gUExOIC0gcGxhbnQsIGZ1bmdhbCwgYW5kIGFsZ2FsIHNlcXVlbmNlc1xuICAvLyAgIDcuIEJDVCAtIGJhY3RlcmlhbCBzZXF1ZW5jZXNcbiAgLy8gICA4LiBWUkwgLSB2aXJhbCBzZXF1ZW5jZXNcbiAgLy8gICA5LiBQSEcgLSBiYWN0ZXJpb3BoYWdlIHNlcXVlbmNlc1xuICAvLyAxMC4gU1lOIC0gc3ludGhldGljIHNlcXVlbmNlc1xuICAvLyAxMS4gVU5BIC0gdW5hbm5vdGF0ZWQgc2VxdWVuY2VzXG4gIC8vIDEyLiBFU1QgLSBFU1Qgc2VxdWVuY2VzIChleHByZXNzZWQgc2VxdWVuY2UgdGFncylcbiAgLy8gMTMuIFBBVCAtIHBhdGVudCBzZXF1ZW5jZXNcbiAgLy8gMTQuIFNUUyAtIFNUUyBzZXF1ZW5jZXMgKHNlcXVlbmNlIHRhZ2dlZCBzaXRlcylcbiAgLy8gMTUuIEdTUyAtIEdTUyBzZXF1ZW5jZXMgKGdlbm9tZSBzdXJ2ZXkgc2VxdWVuY2VzKVxuICAvLyAxNi4gSFRHIC0gSFRHIHNlcXVlbmNlcyAoaGlnaC10aHJvdWdocHV0IGdlbm9taWMgc2VxdWVuY2VzKVxuICAvLyAxNy4gSFRDIC0gdW5maW5pc2hlZCBoaWdoLXRocm91Z2hwdXQgY0ROQSBzZXF1ZW5jaW5nXG4gIC8vIDE4LiBFTlYgLSBlbnZpcm9ubWVudGFsIHNhbXBsaW5nIHNlcXVlbmNlc1xuXG4gIGxldCBsaW5lcyA9IHNlcXVlbmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBmaWVsZE5hbWU7XG4gIGxldCBzdWJGaWVsZFR5cGU7XG4gIGxldCBmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbjtcbiAgbGV0IGxhc3RMaW5lV2FzRmVhdHVyZXNUYWc7XG4gIGxldCBsYXN0TGluZVdhc0xvY2F0aW9uO1xuXG4gIGxldCBoYXNGb3VuZExvY3VzID0gZmFsc2U7XG5cbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIGlmIChsaW5lID09PSBudWxsKSBicmVhaztcbiAgICBsZXQgbGluZUZpZWxkTmFtZSA9IGdldExpbmVGaWVsZE5hbWUobGluZSk7XG4gICAgbGV0IHZhbCA9IGdldExpbmVWYWwobGluZSk7XG4gICAgbGV0IGlzU3ViS2V5ID0gaXNTdWJLZXl3b3JkKGxpbmUpO1xuICAgIGxldCBpc0tleSA9IGlzS2V5d29yZChsaW5lKTtcblxuICAgIGlmIChsaW5lRmllbGROYW1lID09PSBnZW5iYW5rQW5ub3RhdGlvbktleS5FTkRfU0VRVUVOQ0VfVEFHIHx8IGlzS2V5KSB7XG4gICAgICBmaWVsZE5hbWUgPSBsaW5lRmllbGROYW1lO1xuICAgICAgc3ViRmllbGRUeXBlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGlzU3ViS2V5KSB7XG4gICAgICBzdWJGaWVsZFR5cGUgPSBsaW5lRmllbGROYW1lO1xuICAgIH1cbiAgICAvLyBJR05PUkUgTElORVM6IERPIE5PVCBFVkVOIFBST0NFU1NcbiAgICBpZiAobGluZS50cmltKCkgPT09ICcnIHx8IGxpbmVGaWVsZE5hbWUgPT09ICc7Jykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNGb3VuZExvY3VzICYmIGZpZWxkTmFtZSAhPT0gZ2VuYmFua0Fubm90YXRpb25LZXkuTE9DVVNfVEFHKSB7XG4gICAgICAvLyAnR2VuYmFuayBmaWxlcyBtdXN0IHN0YXJ0IHdpdGggYSBMT0NVUyB0YWcgc28gdGhpcyBtdXN0IG5vdCBiZSBhIGdlbmJhbmsnXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGZpZWxkTmFtZSkge1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5MT0NVU19UQUc6XG4gICAgICAgIGhhc0ZvdW5kTG9jdXMgPSB0cnVlO1xuICAgICAgICBwYXJzZUxvY3VzKGxpbmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuRkVBVFVSRVNfVEFHOlxuICAgICAgICBwYXJzZUZlYXR1cmVzKGxpbmUsIGxpbmVGaWVsZE5hbWUsIHZhbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5PUklHSU5fVEFHOlxuICAgICAgICBwYXJzZU9yaWdpbihsaW5lLCBsaW5lRmllbGROYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdlbmJhbmtBbm5vdGF0aW9uS2V5LkRFRklOSVRJT05fVEFHOlxuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5BQ0NFU1NJT05fVEFHOlxuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5WRVJTSU9OX1RBRzpcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuS0VZV09SRFNfVEFHOlxuICAgICAgICBwYXJzZU11bHRpTGluZUZpZWxkKGZpZWxkTmFtZSwgbGluZSwgZmllbGROYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuU09VUkNFX1RBRzpcbiAgICAgICAgaWYgKHN1YkZpZWxkVHlwZSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuT1JHQU5JU01fVEFHKSB7XG4gICAgICAgICAgcGFyc2VNdWx0aUxpbmVGaWVsZChzdWJGaWVsZFR5cGUsIGxpbmUsICdvcmdhbmlzbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQobGluZUZpZWxkTmFtZSwgbGluZSwgJ3NvdXJjZScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnZW5iYW5rQW5ub3RhdGlvbktleS5SRUZFUkVOQ0VfVEFHOlxuICAgICAgICBpZiAobGluZUZpZWxkTmFtZSA9PT0gZ2VuYmFua0Fubm90YXRpb25LZXkuUkVGRVJFTkNFX1RBRykge1xuICAgICAgICAgIGNvbnN0IHJlZiA9IHJlc3VsdC5yZWZlcmVuY2VzIHx8IFtdO1xuICAgICAgICAgIHJlc3VsdC5yZWZlcmVuY2VzID0gcmVmO1xuICAgICAgICAgIHJlZi5wdXNoKHt9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVJlZmVyZW5jZShsaW5lLCBzdWJGaWVsZFR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2VuYmFua0Fubm90YXRpb25LZXkuRU5EX1NFUVVFTkNFX1RBRzpcbiAgICAgICAgZW5kU2VxKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVW5oYW5kbGVkIHRhZ1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBjYXRjaCB0aGUgY2FzZSB3aGVyZSB3ZSd2ZSBzdWNjZXNzZnVsbHkgc3RhcnRlZCBhIHNlcXVlbmNlIGFuZCBwYXJzZWQgaXQsIGJ1dCBlbmRTZXEgaXNuJ3QgY2FsbGVkIGNvcnJlY3RseVxuICBpZiAocmVzdWx0c0FycmF5W3Jlc3VsdHNBcnJheS5sZW5ndGggLSAxXSAhPT0gcmVzdWx0KSB7XG4gICAgLy8gY3VycmVudCByZXN1bHQgaXNuJ3QgaW4gcmVzdWx0c0FycmF5IHlldFxuICAgIC8vIHNvIHdlIGNhbGwgZW5kU2VxIGhlcmVcbiAgICBlbmRTZXEoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0c0FycmF5O1xuXG4gIGZ1bmN0aW9uIGVuZFNlcSgpIHtcbiAgICAvLyBkbyBzb21lIHBvc3QgcHJvY2Vzc2luZyBjbGVhbi11cFxuICAgIHBvc3RQcm9jZXNzQ3VyU2VxKCk7XG4gICAgLy8gcHVzaCB0aGUgcmVzdWx0IGludG8gdGhlIHJlc3VsdHNBcnJheVxuICAgIHJlc3VsdHNBcnJheS5wdXNoKHJlc3VsdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50RmVhdHVyZSgpIHtcbiAgICByZXR1cm4gcmVzdWx0LmZlYXR1cmVzW3Jlc3VsdC5mZWF0dXJlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RQcm9jZXNzQ3VyU2VxKCkge1xuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmZlYXR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQuZmVhdHVyZXNbaV0gPSBwb3N0UHJvY2Vzc0dlbmJhbmtGZWF0dXJlKHJlc3VsdC5mZWF0dXJlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPcmlnaW4obGluZSwga2V5KSB7XG4gICAgaWYgKGtleSAhPT0gZ2VuYmFua0Fubm90YXRpb25LZXkuT1JJR0lOX1RBRykge1xuICAgICAgbGV0IG5ld0xpbmUgPSBsaW5lLnJlcGxhY2UoL1tcXHNdKlswLTldKi9nLCAnJyk7XG4gICAgICByZXN1bHQuc2VxdWVuY2UgKz0gbmV3TGluZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY3VzKGxpbmUpIHtcbiAgICByZXN1bHQgPSB7XG4gICAgICBmZWF0dXJlczogW10sXG4gICAgICBuYW1lOiAnVW50aXRsZWQgc2VxdWVuY2UnLFxuICAgICAgc2VxdWVuY2U6ICcnLFxuICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgfTtcbiAgICBsaW5lID0gcmVtb3ZlRmllbGROYW1lKGdlbmJhbmtBbm5vdGF0aW9uS2V5LkxPQ1VTX1RBRywgbGluZSk7XG4gICAgY29uc3QgbSA9IGxpbmUubWF0Y2goXG4gICAgICAvXihbXlxcc10rKVxccysoXFxkKylcXHMrYnBcXHMrKFteXFxzXSspXFxzKyhbXlxcc10rKVxccysoW15cXHNdKylcXHMqKFteXFxzXSspPyQvLFxuICAgICk7XG4gICAgbGV0IGxvY3VzTmFtZSA9IG1bMV07XG4gICAgbGV0IHNpemUgPSArbVsyXTtcbiAgICBsZXQgbW9sZWN1bGVUeXBlID0gbVszXTtcbiAgICBsZXQgY2lyY3VsYXIgPSBtWzRdID09PSAnY2lyY3VsYXInO1xuICAgIGNvbnN0IHNlcSA9IHJlc3VsdDtcbiAgICBsZXQgZGF0ZVN0ciA9ICcnO1xuICAgIGlmICghbVs2XSkge1xuICAgICAgZGF0ZVN0ciA9IG1bNV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcS5nZW5iYW5rRGl2aXNpb24gPSBtWzVdO1xuICAgICAgZGF0ZVN0ciA9IG1bNl07XG4gICAgfVxuICAgIHNlcS5jaXJjdWxhciA9IGNpcmN1bGFyO1xuICAgIHNlcS5tb2xlY3VsZVR5cGUgPSBtb2xlY3VsZVR5cGU7XG4gICAgY29uc3QgZGF0ZU1hdGNoID0gZGF0ZVN0ci5tYXRjaCgvXihcXGR7Mn0pLSguezN9KS0oXFxkezR9KSQvKTtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKCtkYXRlTWF0Y2hbM10pO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoTU9OVEhTLmluZGV4T2YoZGF0ZU1hdGNoWzJdLnRvVXBwZXJDYXNlKCkpKTtcbiAgICBkYXRlLnNldERhdGUoK2RhdGVNYXRjaFsxXSk7XG4gICAgZGF0ZS5zZXRVVENIb3VycygxMik7XG4gICAgZGF0ZS5zZXRNaW51dGVzKDApO1xuICAgIGRhdGUuc2V0U2Vjb25kcygwKTtcbiAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgICBzZXEuZGF0ZSA9IGRhdGUudG9JU09TdHJpbmcoKTtcbiAgICBzZXEubmFtZSA9IGxvY3VzTmFtZTtcbiAgICBzZXEuc2l6ZSA9IHNpemU7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGaWVsZE5hbWUoZk5hbWUsIGxpbmUpIHtcbiAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbiAgICBpZiAobGluZS5pbmRleE9mKGZOYW1lKSA9PT0gMCkge1xuICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShmTmFtZSwgJycpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZS50cmltKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJlZmVyZW5jZShsaW5lLCBzdWJUeXBlKSB7XG4gICAgY29uc3QgcmVmcyA9IHJlc3VsdC5yZWZlcmVuY2VzO1xuICAgIGxldCBsYXN0UmVmID0gcmVmc1tyZWZzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghc3ViVHlwZSkge1xuICAgICAgcGFyc2VNdWx0aUxpbmVGaWVsZChcbiAgICAgICAgZ2VuYmFua0Fubm90YXRpb25LZXkuUkVGRVJFTkNFX1RBRyxcbiAgICAgICAgbGluZSxcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgbGFzdFJlZixcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlTXVsdGlMaW5lRmllbGQoc3ViVHlwZSwgbGluZSwgc3ViVHlwZS50b0xvd2VyQ2FzZSgpLCBsYXN0UmVmKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZlYXR1cmVzKGxpbmUsIGtleSwgdmFsKSB7XG4gICAgbGV0IHN0cmFuZDtcbiAgICAvLyBGT1IgVEhFIE1BSU4gRkVBVFVSRVMgTE9DQVRJT04vUVVBTElGSUVSIExJTkVcbiAgICBpZiAoa2V5ID09PSBnZW5iYW5rQW5ub3RhdGlvbktleS5GRUFUVVJFU19UQUcpIHtcbiAgICAgIGxhc3RMaW5lV2FzRmVhdHVyZXNUYWcgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsYXN0TGluZVdhc0ZlYXR1cmVzVGFnKSB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIGdldCB0aGUgaW5kZW50YXRpb24gb2YgZmVhdHVyZSBsb2NhdGlvbnNcbiAgICAgIGZlYXR1cmVMb2NhdGlvbkluZGVudGF0aW9uID0gZ2V0TGVuZ3RoT2ZXaGl0ZVNwYWNlQmVmb3JlU3RhcnRPZkxldHRlcnMoXG4gICAgICAgIGxpbmUsXG4gICAgICApO1xuICAgICAgLy8gc2V0IGxhc3RMaW5lV2FzRmVhdHVyZXNUYWcgdG8gZmFsc2VcbiAgICAgIGxhc3RMaW5lV2FzRmVhdHVyZXNUYWcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGT1IgTE9DQVRJT04gJiYgUVVBTElGSUVSIExJTkVTXG4gICAgaWYgKGlzRmVhdHVyZUxpbmVSdW5vbihsaW5lLCBmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbikpIHtcbiAgICAgIC8vIHRoZSBsaW5lIGlzIGEgY29udGludWF0aW9uIG9mIHRoZSBhYm92ZSBsaW5lXG4gICAgICBpZiAobGFzdExpbmVXYXNMb2NhdGlvbikge1xuICAgICAgICAvLyB0aGUgbGFzdCBsaW5lIHdhcyBhIGxvY2F0aW9uLCBzbyB0aGUgcnVuLW9uIGxpbmUgaXMgZXhwZWN0ZWQgdG8gYmUgYSBmZWF0dXJlIGxvY2F0aW9uIGFzIHdlbGxcbiAgICAgICAgcGFyc2VGZWF0dXJlTG9jYXRpb24obGluZS50cmltKCkpO1xuICAgICAgICBsYXN0TGluZVdhc0xvY2F0aW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBsYXN0IGxpbmUgd2FzIGEgbm90ZVxuICAgICAgICBpZiAoY3VycmVudEZlYXR1cmVOb3RlKSB7XG4gICAgICAgICAgLy8gYXBwZW5kIHRvIHRoZSBjdXJyZW50RmVhdHVyZU5vdGVcbiAgICAgICAgICBjdXJyZW50RmVhdHVyZU5vdGVbXG4gICAgICAgICAgICBjdXJyZW50RmVhdHVyZU5vdGUubGVuZ3RoIC0gMVxuICAgICAgICAgIF0gKz0gbGluZS50cmltKCkucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMaW5lV2FzTG9jYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmV3IEVsZW1lbnQvUXVhbGlmaWVyIGxpbmVzLiBOb3QgcnVub24gbGluZXMuXG4gICAgICBpZiAoaXNOb3RlKGxpbmUpKSB7XG4gICAgICAgIC8vIGlzIGEgbmV3IEZlYXR1cmUgRWxlbWVudCAoZS5nLiBzb3VyY2UsIENEUykgaW4gdGhlIGZvcm0gb2YgIFwiW1xcc10gS0VZICBTRVFMT0NBVElPTlwiXG4gICAgICAgIC8vIGlzIGEgRmVhdHVyZVF1YWxpZmllciBpbiB0aGUgL0tFWT1cIkJMQUhcIiBmb3JtYXQ7IGNvdWxkIGJlIG11bHRpcGxlIHBlciBFbGVtZW50XG4gICAgICAgIC8vIENoZWNrIHRoYXQgZmVhdHVyZSBkaWQgbm90IGdldCBza2lwcGVkIGZvciBtaXNzaW5nIGxvY2F0aW9uXG4gICAgICAgIGlmIChnZXRDdXJyZW50RmVhdHVyZSgpKSB7XG4gICAgICAgICAgcGFyc2VGZWF0dXJlTm90ZShsaW5lKTtcbiAgICAgICAgICBsYXN0TGluZVdhc0xvY2F0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBsaW5lIGlzIGEgbG9jYXRpb24sIHNvIHdlIG1ha2UgYSBuZXcgZmVhdHVyZSBmcm9tIGl0XG4gICAgICAgIGlmICh2YWwubWF0Y2goL2NvbXBsZW1lbnQvZykpIHtcbiAgICAgICAgICBzdHJhbmQgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJhbmQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RmVhdHVyZSgpO1xuICAgICAgICBsZXQgZmVhdCA9IGdldEN1cnJlbnRGZWF0dXJlKCk7XG4gICAgICAgIGZlYXQudHlwZSA9IGtleTtcbiAgICAgICAgZmVhdC5zdHJhbmQgPSBzdHJhbmQ7XG5cbiAgICAgICAgcGFyc2VGZWF0dXJlTG9jYXRpb24odmFsKTtcbiAgICAgICAgbGFzdExpbmVXYXNMb2NhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV3RmVhdHVyZSgpIHtcbiAgICByZXN1bHQuZmVhdHVyZXMucHVzaCh7XG4gICAgICBub3Rlczoge30sXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vdGUobGluZSkge1xuICAgIGxldCBxdWFsID0gZmFsc2U7XG4gICAgLyogaWYgKGxpbmUuY2hhckF0KDIxKSA9PT0gXCIvXCIpIHsvL1QuSC4gSGFyZCBjb2RlZCBtZXRob2RcbiAgICAgICAgICAgcXVhbCA9IHRydWU7XG4gICAgICAgICB9Ki9cbiAgICBpZiAobGluZS50cmltKCkuY2hhckF0KDApLm1hdGNoKC9cXC8vKSkge1xuICAgICAgLy8gc2VhcmNoZXMgYmFzZWQgb24gbG9va2luZyBmb3IgLyBpbiBiZWdpbm5pbmcgb2YgbGluZVxuICAgICAgcXVhbCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKC9eW1xcc10qXFwvW1xcd10rPVtcXFNdKy8pKSB7XG4gICAgICAvLyBzZWFyY2hlcyBiYXNlZCBvbiBcIiAgIC9rZXk9QkxBSFwiIHJlZ2V4XG4gICAgICBxdWFsID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWw7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZlYXR1cmVMb2NhdGlvbihsb2NTdHIpIHtcbiAgICBsb2NTdHIgPSBsb2NTdHIudHJpbSgpO1xuICAgIGxldCBsb2NBcnIgPSBbXTtcbiAgICBsb2NTdHIucmVwbGFjZSgvKFxcZCspL2csIGZ1bmN0aW9uIChzdHJpbmcsIG1hdGNoKSB7XG4gICAgICBsb2NBcnIucHVzaChtYXRjaCk7XG4gICAgfSk7XG4gICAgbGV0IGZlYXQgPSBnZXRDdXJyZW50RmVhdHVyZSgpO1xuICAgIGZlYXQuc3RhcnQgPSArbG9jQXJyWzBdO1xuICAgIGZlYXQuZW5kID0gbG9jQXJyWzFdID09PSB1bmRlZmluZWQgPyArbG9jQXJyWzBdIDogK2xvY0FyclsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRmVhdHVyZU5vdGUobGluZSkge1xuICAgIGxldCBuZXdMaW5lLCBsaW5lQXJyO1xuXG4gICAgbmV3TGluZSA9IGxpbmUudHJpbSgpO1xuICAgIG5ld0xpbmUgPSBuZXdMaW5lLnJlcGxhY2UoL15cXC98XCIkL2csICcnKTtcbiAgICBsaW5lQXJyID0gbmV3TGluZS5zcGxpdCgvPVwifD0vKTtcblxuICAgIGxldCB2YWwgPSBsaW5lQXJyWzFdO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcXFwvZywgJyAnKTtcblxuICAgICAgaWYgKGxpbmUubWF0Y2goLz1cIi9nKSkge1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXCIuKi9nLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXlxcZCskL2cpKSB7XG4gICAgICAgIHZhbCA9ICt2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXkgPSBsaW5lQXJyWzBdO1xuICAgIGxldCBjdXJyZW50Tm90ZXMgPSBnZXRDdXJyZW50RmVhdHVyZSgpLm5vdGVzO1xuICAgIGlmIChjdXJyZW50Tm90ZXNba2V5XSkge1xuICAgICAgLy8gYXJyYXkgYWxyZWFkeSBleGlzdHMsIHNvIHB1c2ggdmFsdWUgaW50byBpdFxuICAgICAgY3VycmVudE5vdGVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhcnJheSBkb2Vzbid0IGV4aXN0IHlldCwgc28gY3JlYXRlIGl0IGFuZCBwb3B1bGF0ZSBpdCB3aXRoIHRoZSB2YWx1ZVxuICAgICAgY3VycmVudE5vdGVzW2tleV0gPSBbdmFsXTtcbiAgICB9XG4gICAgY3VycmVudEZlYXR1cmVOb3RlID0gY3VycmVudE5vdGVzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lRmllbGROYW1lKGxpbmUpIHtcbiAgICBsZXQgYXJyO1xuICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICAgIGFyciA9IGxpbmUuc3BsaXQoL1tcXHNdKy8pO1xuXG4gICAgcmV0dXJuIGFyclswXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTXVsdGlMaW5lRmllbGQoZk5hbWUsIGxpbmUsIHJlc3VsdEtleSwgcikge1xuICAgIHIgPSByIHx8IHJlc3VsdDtcbiAgICBsZXQgZmllbGRWYWx1ZSA9IHJlbW92ZUZpZWxkTmFtZShmTmFtZSwgbGluZSk7XG4gICAgcltyZXN1bHRLZXldID0gcltyZXN1bHRLZXldID8gYCR7cltyZXN1bHRLZXldfSBgIDogJyc7XG4gICAgcltyZXN1bHRLZXldICs9IGZpZWxkVmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lVmFsKGxpbmUpIHtcbiAgICBsZXQgYXJyO1xuXG4gICAgaWYgKGxpbmUuaW5kZXhPZignPScpIDwgMCkge1xuICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXltcXHNdKltcXFNdK1tcXHNdK3xbXFxzXSskLywgJycpO1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyciA9IGxpbmUuc3BsaXQoLz0vKTtcbiAgICAgIHJldHVybiBhcnJbMV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGxpbmUpIHtcbiAgICBsZXQgaXNLZXkgPSBmYWxzZTtcbiAgICBpZiAobGluZS5zdWJzdHIoMCwgMTApLm1hdGNoKC9eW1xcU10rLykpIHtcbiAgICAgIGlzS2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzS2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTdWJLZXl3b3JkKGxpbmUpIHtcbiAgICBsZXQgaXNTdWJLZXkgPSBmYWxzZTtcbiAgICBpZiAobGluZS5zdWJzdHIoMCwgMTApLm1hdGNoKC9eW1xcc10rW1xcU10rLykpIHtcbiAgICAgIGlzU3ViS2V5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3ViS2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zdFByb2Nlc3NHZW5iYW5rRmVhdHVyZShmZWF0KSB7XG4gICAgaWYgKGZlYXQubm90ZXMubGFiZWwpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMubGFiZWxbMF07XG4gICAgfSBlbHNlIGlmIChmZWF0Lm5vdGVzLmdlbmUpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMuZ2VuZVswXTtcbiAgICB9IGVsc2UgaWYgKGZlYXQubm90ZXMuQXBFaW5mb19sYWJlbCkge1xuICAgICAgZmVhdC5uYW1lID0gZmVhdC5ub3Rlcy5BcEVpbmZvX2xhYmVsWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5uYW1lKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLm5hbWVbMF07XG4gICAgfSBlbHNlIGlmIChmZWF0Lm5vdGVzLm9yZ2FuaXNtKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLm9yZ2FuaXNtWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5sb2N1c190YWcpIHtcbiAgICAgIGZlYXQubmFtZSA9IGZlYXQubm90ZXMubG9jdXNfdGFnWzBdO1xuICAgIH0gZWxzZSBpZiAoZmVhdC5ub3Rlcy5ub3RlKSB7XG4gICAgICBmZWF0Lm5hbWUgPSBmZWF0Lm5vdGVzLm5vdGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXQubmFtZSA9ICdVbnRpdGxlZCBGZWF0dXJlJztcbiAgICB9XG4gICAgZmVhdC5uYW1lID0gdHlwZW9mIGZlYXQubmFtZSA9PT0gJ3N0cmluZycgPyBmZWF0Lm5hbWUgOiBTdHJpbmcoZmVhdC5uYW1lKTtcbiAgICByZXR1cm4gZmVhdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ZlYXR1cmVMaW5lUnVub24obGluZSwgZmVhdHVyZUxvY2F0aW9uSW5kZW50YXRpb24pIHtcbiAgbGV0IGluZGVudGF0aW9uT2ZMaW5lID0gZ2V0TGVuZ3RoT2ZXaGl0ZVNwYWNlQmVmb3JlU3RhcnRPZkxldHRlcnMobGluZSk7XG4gIGlmIChmZWF0dXJlTG9jYXRpb25JbmRlbnRhdGlvbiA9PT0gaW5kZW50YXRpb25PZkxpbmUpIHtcbiAgICAvLyB0aGUgZmVhdHVyZSBsb2NhdGlvbiBpbmRlbnRhdGlvbiBjYWxjdWxhdGVkIHJpZ2h0IGFmdGVyIHRoZSBmZWF0dXJlIHRhZ1xuICAgIC8vIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGxpbmVcbiAgICAvL1xuICAgIC8vIEZFQVRVUkVTICAgICAgICAgICAgIExvY2F0aW9uL1F1YWxpZmllcnNcbiAgICAvLyAgICAgcmVwX29yaWdpbiAgICAgIGNvbXBsZW1lbnQoMTA3NC4uMzMwMilcbiAgICAvLyAwMTIzNCAgPC0tIHRoaXMgaXMgdGhlIGluZGVudGF0aW9uIHdlJ3JlIHRhbGtpbmcgYWJvdXRcbiAgICByZXR1cm4gZmFsc2U7IC8vIHRoZSBsaW5lIGlzIE5PVCBhIHJ1biBvblxuICB9XG5cbiAgbGV0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgaWYgKHRyaW1tZWQuY2hhckF0KDApLm1hdGNoKC9cXC8vKSkge1xuICAgIC8vIHRoZSBmaXJzdCBjaGFyIGluIHRoZSB0cmltbWVkIGxpbmUgY2Fubm90IGJlIGEgL1xuICAgIHJldHVybiBmYWxzZTsgLy8gdGhlIGxpbmUgaXMgTk9UIGEgcnVuIG9uXG4gIH1cbiAgLy8gdGhlIGxpbmUgaXMgYSBydW4gb25cbiAgcmV0dXJuIHRydWU7XG4gIC8vIHJ1bi1vbiBsaW5lIGV4YW1wbGU6XG4gIC8vIEZFQVRVUkVTICAgICAgICAgICAgIExvY2F0aW9uL1F1YWxpZmllcnNcbiAgLy8gICAgIHJlcF9vcmlnaW4gICAgICBjb21wbGVtZW50KDEwNzQuLjMzMDIpXG4gIC8vICAgICAgICAgICAgICAgICAvbGFiZWw9cFNDMTAxKipcbiAgLy8gICAgICAgICAgICAgICAgIC9ub3RlPVwiUkVQX09SSUdJTiBSRVBfT1JJR0lOIHBTQzEwMSogYWthIHBNUFA2LCBnaXZlcyBwbGFzbVxuICAvLyAgICAgICAgICAgICAgICAgaWQgbnVtYmVyIDMgLTQgY29waWVzIHBlciBjZWxsLCBCZ2xJSSBzaXRlIGluIHBTQzEwMSogb3JpIGggPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICBhcyBiZWVuIGRlbGUgdGVkIGJ5IHF1aWNrIGNoYW5nZSBhZ2F0Y1QgY2hhbmdlZCB0byBhZ2F0Y0EgZyA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgIGl2aW5nIHBTQzEwMSogKiBwU0MxMDEqIGFrYSBwTVBQNiwgZ2l2ZXMgcGxhc21pZCBudW1iZXIgMy00IDwtLXJ1bi1vbiBsaW5lIVxuICAvLyAgICAgICAgICAgICAgICAgY29waWVzIHAgZXIgY2VsbCwgQmdsSUkgc2l0ZSBpbiBwU0MxMDEqIG9yaSBoYXMgYmVlbiBkZWxldCAgPC0tcnVuLW9uIGxpbmUhXG4gIC8vICAgICAgICAgICAgICAgICBlZCBieSBxdWljIGsgY2hhbmdlIGFnYXRjVCBjaGFuZ2VkIHRvIGFnYXRjQSBnaXZpbmcgcFNDMTAxKiA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgICogW3BCYlMwYS1SRlBdXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS1ydW4tb24gbGluZSFcbiAgLy8gICAgICAgICAgICAgICAgIC9nZW5lPVwiU0MxMDEqKiBPcmlcIlxuICAvLyAgICAgICAgICAgICAgICAgL25vdGU9XCJwU0MxMDEqIGFrYSBwTVBQNiwgZ2l2ZXMgcGxhc21pZCBudW1iZXIgMy00IGNvcGllcyBwXG4gIC8vICAgICAgICAgICAgICAgICBlciBjZWxsLCBCZ2xJSSBzaXRlIGluIHBTQzEwMSogb3JpIGhhcyBiZWVuIGRlbGV0ZWQgYnkgcXVpXG4gIC8vICAgICAgICAgICAgICAgICBjIGsgY2hhbmdlIGFnYXRjVCBjaGFuZ2VkIHRvIGFnYXRjQSBnaXZpbmcgcFNDMTAxKipcIlxuICAvLyAgICAgICAgICAgICAgICAgL3ZudGlma2V5PVwiMzNcIlxufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGhPZldoaXRlU3BhY2VCZWZvcmVTdGFydE9mTGV0dGVycyhzdHJpbmcpIHtcbiAgbGV0IG1hdGNoID0gL15cXHMqLy5leGVjKHN0cmluZyk7XG4gIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5iYW5rVG9Kc29uO1xuIiwidmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICB1dGlsLmFzc2VydEVxdWFsID0gKHZhbCkgPT4gdmFsO1xuICAgIGZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHsgfVxuICAgIHV0aWwuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgICBmdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuICAgIHV0aWwuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhvYmopLmZpbHRlcigoaykgPT4gdHlwZW9mIG9ialtvYmpba11dICE9PSBcIm51bWJlclwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0VmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2VdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKG9iamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH07XG4gICAgdXRpbC5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdXRpbC5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcbiAgICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgICAgIHJldHVybiBhcnJheVxuICAgICAgICAgICAgLm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKVxuICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgdXRpbC5qb2luVmFsdWVzID0gam9pblZhbHVlcztcbiAgICB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKHV0aWwgfHwgKHV0aWwgPSB7fSkpO1xudmFyIG9iamVjdFV0aWw7XG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcbiAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpcnN0LFxuICAgICAgICAgICAgLi4uc2Vjb25kLCAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICAgICAgICB9O1xuICAgIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbmNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBpc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN5bWJvbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5hcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRhLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmtub3duO1xuICAgIH1cbn07XG5cbmNvbnN0IFpvZElzc3VlQ29kZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwiaW52YWxpZF90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2xpdGVyYWxcIixcbiAgICBcImN1c3RvbVwiLFxuICAgIFwiaW52YWxpZF91bmlvblwiLFxuICAgIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXG4gICAgXCJpbnZhbGlkX2VudW1fdmFsdWVcIixcbiAgICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxuICAgIFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiLFxuICAgIFwiaW52YWxpZF9kYXRlXCIsXG4gICAgXCJpbnZhbGlkX3N0cmluZ1wiLFxuICAgIFwidG9vX3NtYWxsXCIsXG4gICAgXCJ0b29fYmlnXCIsXG4gICAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxuICAgIFwibm90X211bHRpcGxlX29mXCIsXG4gICAgXCJub3RfZmluaXRlXCIsXG5dKTtcbmNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCBcIiQxOlwiKTtcbn07XG5jbGFzcyBab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzc3VlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS51bmlvbkVycm9ycy5tYXAocHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zdCBlcnJvckFycmF5OiBhbnkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCBlcnJvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHRoaXMpO1xuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBab2RFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcblxubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cblxuY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gICAgY29uc3QgbWFwcyA9IGVycm9yTWFwc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiAhIW0pXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB9O1xufTtcbmNvbnN0IEVNUFRZX1BBVEggPSBbXTtcbmZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVNYXAgPSBnZXRFcnJvck1hcCgpO1xuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgLy8gY29udGV4dHVhbCBlcnJvciBtYXAgaXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCwgLy8gdGhlbiBzY2hlbWEtYm91bmQgbWFwIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAsIC8vIHRoZW4gZ2xvYmFsIG92ZXJyaWRlIG1hcFxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAgPT09IGVycm9yTWFwID8gdW5kZWZpbmVkIDogZXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5jb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG52YXIgZXJyb3JVdGlsO1xuKGZ1bmN0aW9uIChlcnJvclV0aWwpIHtcbiAgICBlcnJvclV0aWwuZXJyVG9PYmogPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2UgfSA6IG1lc3NhZ2UgfHwge307XG4gICAgZXJyb3JVdGlsLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xuXG52YXIgX1pvZEVudW1fY2FjaGUsIF9ab2ROYXRpdmVFbnVtX2NhY2hlO1xuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcImludmFsaWRfZW51bV92YWx1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9hID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogcmVxdWlyZWRfZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYiA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGludmFsaWRfdHlwZV9lcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmNsYXNzIFpvZFR5cGUge1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAoY3R4IHx8IHtcbiAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmFzeW5jKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBcIn52YWxpZGF0ZVwiKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogISF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VBc3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChyZXN1bHQpID0+IGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgYXN5bmMgc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWF5YmVBc3luY1Jlc3VsdCA9IHRoaXMuX3BhcnNlKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoaXNBc3luYyhtYXliZUFzeW5jUmVzdWx0KVxuICAgICAgICAgICAgPyBtYXliZUFzeW5jUmVzdWx0XG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShtYXliZUFzeW5jUmVzdWx0KSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZ2V0SXNzdWVQcm9wZXJ0aWVzID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtZXNzYWdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVjayh2YWwpO1xuICAgICAgICAgICAgY29uc3Qgc2V0RXJyb3IgPSAoKSA9PiBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZpbmVtZW50KGNoZWNrLCByZWZpbmVtZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh0eXBlb2YgcmVmaW5lbWVudERhdGEgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHJlZmluZW1lbnREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VwZXJSZWZpbmUocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChyZWZpbmVtZW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKGRhdGEpID0+IHRoaXNbXCJ+dmFsaWRhdGVcIl0oZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgYW5kKGluY29taW5nKSB7XG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0KGRlZikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnJhbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2goZGVmKSB7XG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaXBlKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICAgIHJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBpc09wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UodW5kZWZpbmVkKS5zdWNjZXNzO1xuICAgIH1cbiAgICBpc051bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgICB9XG59XG5jb25zdCBjdWlkUmVnZXggPSAvXmNbXlxccy1dezgsfSQvaTtcbmNvbnN0IGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xuY29uc3QgdWxpZFJlZ2V4ID0gL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC9pO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuY29uc3QgbmFub2lkUmVnZXggPSAvXlthLXowLTlfLV17MjF9JC9pO1xuY29uc3Qgand0UmVnZXggPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvO1xuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjE4MS8xNTUwMTU1XG4vLyBvbGQgdmVyc2lvbjogdG9vIHNsb3csIGRpZG4ndCBzdXBwb3J0IHVuaWNvZGVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XG4vL29sZCBlbWFpbCByZWdleFxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKChbXjw+KClbXFxdLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF0uLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoPyEtKShbXjw+KClbXFxdLiw7Olxcc0BcIl0rXFwuKStbXjw+KClbXFxdLiw7Olxcc0BcIl17MSx9KVteLTw+KClbXFxdLiw7Olxcc0BcIl0kL2k7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFsoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXF0pfChcXFtJUHY2OigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSlcXF0pfChbQS1aYS16MC05XShbQS1aYS16MC05LV0qW0EtWmEtejAtOV0pKihcXC5bQS1aYS16XXsyLH0pKykpJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16QS1aMC05XFwuXFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwvXFw9XFw/XFxeXFxfXFxgXFx7XFx8XFx9XFx+XFwtXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXig/OlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSpcIilAKD86KD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xuY29uc3QgZW1haWxSZWdleCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aMC05XycrXFwtXFwuXSopW0EtWjAtOV8rLV1AKFtBLVowLTldW0EtWjAtOVxcLV0qXFwuKStbQS1aXXsyLH0kL2k7XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16MC05LiEjJCUm4oCZKisvPT9eX2B7fH1+LV0rQFthLXowLTktXSsoPzpcXC5bYS16MC05XFwtXSspKiQvaTtcbi8vIGZyb20gaHR0cHM6Ly90aGVrZXZpbnNjb3R0LmNvbS9lbW9qaXMtaW4tamF2YXNjcmlwdC8jd3JpdGluZy1hLXJlZ3VsYXItZXhwcmVzc2lvblxuY29uc3QgX2Vtb2ppUmVnZXggPSBgXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRgO1xubGV0IGVtb2ppUmVnZXg7XG4vLyBmYXN0ZXIsIHNpbXBsZXIsIHNhZmVyXG5jb25zdCBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xuY29uc3QgaXB2NENpZHJSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xuLy8gY29uc3QgaXB2NlJlZ2V4ID1cbi8vIC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuY29uc3QgaXB2NlJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC87XG5jb25zdCBpcHY2Q2lkclJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxuY29uc3QgYmFzZTY0UmVnZXggPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC87XG4vLyBodHRwczovL2Jhc2U2NC5ndXJ1L3N0YW5kYXJkcy9iYXNlNjR1cmxcbmNvbnN0IGJhc2U2NHVybFJlZ2V4ID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvO1xuLy8gc2ltcGxlXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1gO1xuLy8gbm8gbGVhcCB5ZWFyIHZhbGlkYXRpb25cbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS0oKDBbMTM1NzhdfDEwfDEyKS0zMXwoMFsxMy05XXwxWzAtMl0pLTMwfCgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFcXFxcZHwyXFxcXGQpKWA7XG4vLyB3aXRoIGxlYXAgeWVhciB2YWxpZGF0aW9uXG5jb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpYDtcbmNvbnN0IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICAgIC8vIGxldCByZWdleCA9IGBcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfWA7XG4gICAgbGV0IHJlZ2V4ID0gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGRgO1xuICAgIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgICAgICByZWdleCA9IGAke3JlZ2V4fVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICByZWdleCA9IGAke3JlZ2V4fShcXFxcLlxcXFxkKyk/YDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2V4O1xufVxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxuZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICAgIGNvbnN0IG9wdHMgPSBbXTtcbiAgICBvcHRzLnB1c2goYXJncy5sb2NhbCA/IGBaP2AgOiBgWmApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcbiAgICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKV1Qoand0LCBhbGcpIHtcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gand0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGVjb2RlZC50eXAgfHwgIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEYXRlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gICAgfVxuICAgIGdldCBpc1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDSURSKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gICAgfVxuICAgIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gcGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG5jbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5pdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhZmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8XG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJpbnRcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5fZGVmKS5lcnJvck1hcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGlzc3VlLCBjdHgpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGN0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChfZCA9IGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXMobWFzaykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5b2YoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlzc3VlcyBmcm9tIGRpcnR5IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMYXp5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFbnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyh0eXBlLmVudW0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcCxcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbl9ab2RFbnVtX2NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgX1pvZE5hdGl2ZUVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5fWm9kTmF0aXZlRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiZcbiAgICAgICAgICAgIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2VcbiAgICAgICAgICAgID8gY3R4LmRhdGFcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ3R4LmFkZElzc3VlID0gY2hlY2tDdHguYWRkSXNzdWUuYmluZChjaGVja0N0eCk7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcbiAgICAgICAgICAgIDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNBc3luYyhyZXN1bHQpXG4gICAgICAgICAgICA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpXG4gICAgICAgICAgICA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHBhcmFtcyhkYXRhKVxuICAgICAgICA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8geyBtZXNzYWdlOiBwYXJhbXMgfVxuICAgICAgICAgICAgOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcbiAqXG4gKiBgYGB0c1xuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmZhdGFsKSB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG52YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3QgY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuY29uc3QgTkVWRVIgPSBJTlZBTElEO1xuXG52YXIgeiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgICBzZXRFcnJvck1hcDogc2V0RXJyb3JNYXAsXG4gICAgZ2V0RXJyb3JNYXA6IGdldEVycm9yTWFwLFxuICAgIG1ha2VJc3N1ZTogbWFrZUlzc3VlLFxuICAgIEVNUFRZX1BBVEg6IEVNUFRZX1BBVEgsXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxuICAgIFBhcnNlU3RhdHVzOiBQYXJzZVN0YXR1cyxcbiAgICBJTlZBTElEOiBJTlZBTElELFxuICAgIERJUlRZOiBESVJUWSxcbiAgICBPSzogT0ssXG4gICAgaXNBYm9ydGVkOiBpc0Fib3J0ZWQsXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgIGlzQXN5bmM6IGlzQXN5bmMsXG4gICAgZ2V0IHV0aWwgKCkgeyByZXR1cm4gdXRpbDsgfSxcbiAgICBnZXQgb2JqZWN0VXRpbCAoKSB7IHJldHVybiBvYmplY3RVdGlsOyB9LFxuICAgIFpvZFBhcnNlZFR5cGU6IFpvZFBhcnNlZFR5cGUsXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcbiAgICBab2RUeXBlOiBab2RUeXBlLFxuICAgIGRhdGV0aW1lUmVnZXg6IGRhdGV0aW1lUmVnZXgsXG4gICAgWm9kU3RyaW5nOiBab2RTdHJpbmcsXG4gICAgWm9kTnVtYmVyOiBab2ROdW1iZXIsXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXG4gICAgWm9kQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBab2REYXRlOiBab2REYXRlLFxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxuICAgIFpvZFVuZGVmaW5lZDogWm9kVW5kZWZpbmVkLFxuICAgIFpvZE51bGw6IFpvZE51bGwsXG4gICAgWm9kQW55OiBab2RBbnksXG4gICAgWm9kVW5rbm93bjogWm9kVW5rbm93bixcbiAgICBab2ROZXZlcjogWm9kTmV2ZXIsXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcbiAgICBab2RBcnJheTogWm9kQXJyYXksXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcbiAgICBab2ROYU46IFpvZE5hTixcbiAgICBCUkFORDogQlJBTkQsXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcbiAgICBab2RQaXBlbGluZTogWm9kUGlwZWxpbmUsXG4gICAgWm9kUmVhZG9ubHk6IFpvZFJlYWRvbmx5LFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBjb2VyY2U6IGNvZXJjZSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NUeXBlLFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgICBzZXQ6IHNldFR5cGUsXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIE5FVkVSOiBORVZFUixcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvclxufSk7XG5cbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIGRhdGV0aW1lUmVnZXgsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XG4iLCJpbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuXG5leHBvcnQgY29uc3QgY29vclNjaGVtYSA9IHoub2JqZWN0KHtcbiAgeDogei5udW1iZXIoKSxcbiAgeTogei5udW1iZXIoKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgYW5nbGVTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGRlZ3JlZXM6IHoubnVtYmVyKCksXG4gIGNlbnRlcjogY29vclNjaGVtYSxcbn0pO1xuXG5leHBvcnQgY29uc3QgYW5ub3RhdGlvblR5cGVTY2hlbWEgPSB6LnVuaW9uKFtcbiAgei5saXRlcmFsKFwiQ0RTXCIpLFxuICB6LmxpdGVyYWwoXCJlbmhhbmNlclwiKSxcbiAgei5saXRlcmFsKFwiaW50cm9uXCIpLFxuICB6LmxpdGVyYWwoXCJtaXNjX2ZlYXR1cmVcIiksXG4gIHoubGl0ZXJhbChcInBvbHlBX3NpZ25hbFwiKSxcbiAgei5saXRlcmFsKFwicHJvbW90ZXJcIiksXG4gIHoubGl0ZXJhbChcInByb3RlaW5fYmluZFwiKSxcbiAgei5saXRlcmFsKFwicmVwX29yaWdpblwiKSxcbiAgei5saXRlcmFsKFwiTFRSXCIpLFxuICB6LnN0cmluZygpLFxuXSk7XG5cbmV4cG9ydCBjb25zdCBhbm5vdGF0aW9uU2NoZW1hID0gei5vYmplY3Qoe1xuICB0eXBlOiBhbm5vdGF0aW9uVHlwZVNjaGVtYSxcbiAgZGlyZWN0aW9uOiB6LnVuaW9uKFt6LmxpdGVyYWwoXCJmb3J3YXJkXCIpLCB6LmxpdGVyYWwoXCJyZXZlcnNlXCIpXSksXG4gIHN0YXJ0OiB6Lm51bWJlcigpLFxuICBlbmQ6IHoubnVtYmVyKCksXG4gIGNsYXNzTmFtZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0ZXh0OiB6LnN0cmluZygpLFxuICBvbkNsaWNrOiB6LmZ1bmN0aW9uKCkuYXJncyh6LmFueSgpKS5vcHRpb25hbCgpLCAvLyBjaXJjdWxhciByZWZlcmVuY2Vcbn0pO1xuXG5leHBvcnQgY29uc3Qgc3RhY2tlZEFubm90YXRpb25TY2hlbWEgPSBhbm5vdGF0aW9uU2NoZW1hLmV4dGVuZCh7XG4gIHN0YWNrOiB6Lm51bWJlcigpLFxufSk7XG5cbmV4cG9ydCBjb25zdCBudWNsU2NoZW1hID0gei51bmlvbihbXG4gIHoubGl0ZXJhbChcIkFcIiksXG4gIHoubGl0ZXJhbChcIkNcIiksXG4gIHoubGl0ZXJhbChcIkdcIiksXG4gIHoubGl0ZXJhbChcIlRcIiksXG5dKTtcblxuZXhwb3J0IGNvbnN0IGFhU2NoZW1hID0gei51bmlvbihbXG4gIC8vIEFkZCBhbGwgeW91ciBhbWlubyBhY2lkcyBsaXRlcmFscyBoZXJlXG4gIHoubGl0ZXJhbChcIkFcIiksXG4gIHoubGl0ZXJhbChcIkNcIiksXG4gIHoubGl0ZXJhbChcIkRcIiksXG4gIHoubGl0ZXJhbChcIkVcIiksXG4gIHoubGl0ZXJhbChcIkZcIiksXG4gIHoubGl0ZXJhbChcIkdcIiksXG4gIHoubGl0ZXJhbChcIkhcIiksXG4gIHoubGl0ZXJhbChcIklcIiksXG4gIHoubGl0ZXJhbChcIktcIiksXG4gIHoubGl0ZXJhbChcIkxcIiksXG4gIHoubGl0ZXJhbChcIk1cIiksXG4gIHoubGl0ZXJhbChcIk5cIiksXG4gIHoubGl0ZXJhbChcIlBcIiksXG4gIHoubGl0ZXJhbChcIlFcIiksXG4gIHoubGl0ZXJhbChcIlJcIiksXG4gIHoubGl0ZXJhbChcIlNcIiksXG4gIHoubGl0ZXJhbChcIlRcIiksXG4gIHoubGl0ZXJhbChcIlZcIiksXG4gIHoubGl0ZXJhbChcIldcIiksXG4gIHoubGl0ZXJhbChcIllcIiksXG5dKTtcbmV4cG9ydCBjb25zdCBHYXBTY2hlbWEgPSB6LmxpdGVyYWwoXCItXCIpO1xuZXhwb3J0IGNvbnN0IFN0b3BTY2hlbWEgPSB6LmxpdGVyYWwoXCIqXCIpO1xuZXhwb3J0IGNvbnN0IFNwYWNlU2NoZW1hID0gei5saXRlcmFsKFwiIFwiKTtcbmV4cG9ydCBjb25zdCBVbmtub3duU2NoZW1hID0gei5saXRlcmFsKFwiP1wiKTtcbmV4cG9ydCBjb25zdCBhbm5vdGF0ZWRCYXNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBiYXNlOiB6LnN0cmluZygpLmxlbmd0aCgxKSxcbiAgYW5ub3RhdGlvbnM6IHouYXJyYXkoc3RhY2tlZEFubm90YXRpb25TY2hlbWEpLFxuICBpbmRleDogei5udW1iZXIoKSxcbn0pO1xuXG5leHBvcnQgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2VTY2hlbWEgPSB6LmFycmF5KGFubm90YXRlZEJhc2VTY2hlbWEpO1xuXG5leHBvcnQgY29uc3QgYXJpYWRuZVNlbGVjdGlvblNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc3RhcnQ6IHoubnVtYmVyKCksXG4gIGVuZDogei5udW1iZXIoKSxcbiAgZGlyZWN0aW9uOiB6LnVuaW9uKFt6LmxpdGVyYWwoXCJmb3J3YXJkXCIpLCB6LmxpdGVyYWwoXCJyZXZlcnNlXCIpXSksXG59KTtcbiIsImltcG9ydCBnZW5iYW5rUGFyc2VyLCB7IFBhcnNlZEdlbmJhbmsgfSBmcm9tIFwiZ2VuYmFuay1wYXJzZXJcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgeyBhbm5vdGF0ZWRTZXF1ZW5jZVNjaGVtYSwgYW5ub3RhdGlvblR5cGVTY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWFzXCI7XG5pbXBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uVHlwZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcywgc3RhY2tBbm5zQnlUeXBlIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IEdlbmJhbmtGZWF0dXJlU2NoZW1hID0gei5vYmplY3Qoe1xuICBuYW1lOiB6LnN0cmluZygpLm1pbigxKSxcbiAgc3RhcnQ6IHoubnVtYmVyKCksXG4gIGVuZDogei5udW1iZXIoKSxcbiAgc3RyYW5kOiB6LnVuaW9uKFt6LmxpdGVyYWwoMSksIHoubGl0ZXJhbCgtMSldKSxcbiAgdHlwZTogYW5ub3RhdGlvblR5cGVTY2hlbWEsXG4gIG5vdGVzOiB6LnJlY29yZCh6LmFycmF5KHouc3RyaW5nKCkpKS5vcHRpb25hbCgpLFxufSk7XG5leHBvcnQgdHlwZSBHZW5iYW5rRmVhdHVyZSA9IHouaW5mZXI8dHlwZW9mIEdlbmJhbmtGZWF0dXJlU2NoZW1hPjtcblxuZXhwb3J0IGNvbnN0IGdlbmJhbmtUb0Fubm90YXRlZFNlcXVlbmNlID0gKHtcbiAgZ2VuYmFuayxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiB7XG4gIGdlbmJhbms6IFBhcnNlZEdlbmJhbms7XG4gIGFubm90YXRpb25PbkNsaWNrPzogKGFubm90YXRpb246IEFubm90YXRpb24pID0+IHZvaWQ7XG59KSA9PiB7XG4gIGNvbnN0IGZlYXR1cmVzID0gZ2VuYmFuay5mZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHtcbiAgICByZXR1cm4gR2VuYmFua0ZlYXR1cmVTY2hlbWEucGFyc2UoZmVhdHVyZSk7XG4gIH0pO1xuICBjb25zdCBhbm5vdGF0aW9ucyA9IGdlbmJhbmtGZWF0dXJlc1RvQW5ub3RhdGlvbnMoe1xuICAgIGZlYXR1cmVzLFxuICAgIGFubm90YXRpb25PbkNsaWNrLFxuICB9KTtcbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gc3RhY2tBbm5zQnlUeXBlKGFubm90YXRpb25zKTtcbiAgY29uc3QgeyBzdWNjZXNzZXMsIGZhaWx1cmVzIH0gPSBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyh7XG4gICAgcGF5bG9hZDogZ2VuYmFuay5zZXF1ZW5jZSxcbiAgICBwYXlsb2FkVHlwZTogXCJyYXdcIixcbiAgICBhbm5vdGF0aW9uczogc3RhY2tlZEFubm90YXRpb25zLFxuICB9KTtcbiAgaWYgKGZhaWx1cmVzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBnZW5iYW5rOiAke2ZhaWx1cmVzWzBdfWApO1xuICB9XG4gIGlmIChzdWNjZXNzZXMubGVuZ3RoICE9PSAxIHx8IHN1Y2Nlc3Nlc1swXS5zZXF1ZW5jZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBhbm5vdGF0ZWQgc2VxdWVuY2VgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGVkU2VxdWVuY2U6IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hLnBhcnNlKHN1Y2Nlc3Nlc1swXS5zZXF1ZW5jZXNbMF0pLFxuICAgIGFubm90YXRpb25zLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbmJhbmtGZWF0dXJlc1RvQW5ub3RhdGlvbnMgPSAoe1xuICBmZWF0dXJlcyxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiB7XG4gIGZlYXR1cmVzOiBHZW5iYW5rRmVhdHVyZVtdO1xuICBhbm5vdGF0aW9uT25DbGljaz86IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uKSA9PiB2b2lkO1xufSk6IEFubm90YXRpb25bXSA9PiB7XG4gIHJldHVybiBmZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBbZmVhdHVyZS5zdGFydCwgZmVhdHVyZS5lbmRdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBmZWF0dXJlLnR5cGUsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIGxhYmVsOiBmZWF0dXJlLnR5cGUsXG4gICAgICB0ZXh0OiBmZWF0dXJlLm5hbWUsXG4gICAgICBkaXJlY3Rpb246IGZlYXR1cmUuc3RyYW5kID09PSAxID8gXCJmb3J3YXJkXCIgOiBcInJldmVyc2VcIixcbiAgICAgIGNsYXNzTmFtZTogZ2V0Q2xhc3NOYW1lRnJvbUZlYXR1cmVUeXBlKGZlYXR1cmUudHlwZSksXG4gICAgICBvbkNsaWNrOiBhbm5vdGF0aW9uT25DbGljayxcbiAgICB9O1xuICB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc05hbWVGcm9tRmVhdHVyZVR5cGUoYW5uVHlwZTogQW5ub3RhdGlvblR5cGUpOiBzdHJpbmcge1xuICBjb25zdCBjb21tb24gPVxuICAgIFwiY3Vyc29yLXBvaW50ZXIgb3BhY2l0eS02MCBncm91cC1ob3ZlcjpvcGFjaXR5LTEwMCAhdGV4dC14cyBob3ZlcjpvcGFjaXR5LTEwMCBwb2ludGVyLWV2ZW50cy1hbGwgdGV4dC13aGl0ZSB0ZXh0LWNsaXAgb3ZlcmZsb3ctaGlkZGVuIHdoaXRlc3BhY2Utbm93cmFwXCI7XG4gIGNvbnN0IGNsYXNzTmFtZU1hcDogeyBba2V5OiBBbm5vdGF0aW9uVHlwZV06IHN0cmluZyB9ID0gemlwQXJyYXlzKFxuICAgIFtcbiAgICAgIFwiQ0RTXCIsXG4gICAgICBcImVuaGFuY2VyXCIsXG4gICAgICBcImludHJvblwiLFxuICAgICAgXCJtaXNjX2ZlYXR1cmVcIixcbiAgICAgIFwicG9seUFfc2lnbmFsXCIsXG4gICAgICBcInByb21vdGVyXCIsXG4gICAgICBcInByb3RlaW5fYmluZFwiLFxuICAgICAgXCJyZXBfb3JpZ2luXCIsXG4gICAgICBcIkxUUlwiLFxuICAgICAgXCJzb3VyY2VcIixcbiAgICAgIFwiaW5zZXJ0aW9uXCIsXG4gICAgXSxcbiAgICBbXG4gICAgICBcImJnLXJlZC02MDAgZmlsbC1yZWQtNjAwIHN0cm9rZS1yZWQtNjAwXCIsXG4gICAgICBcImJnLWJsdWUtNjAwIGZpbGwtYmx1ZS02MDAgc3Ryb2tlLWJsdWUtNjAwXCIsXG4gICAgICBcImJnLWdyZWVuLTYwMCBmaWxsLWdyZWVuLTYwMCBzdHJva2UtZ3JlZW4tNjAwXCIsXG4gICAgICBcImJnLXllbGxvdy02MDAgZmlsbC15ZWxsb3ctNjAwIHN0cm9rZS15ZWxsb3ctNjAwXCIsXG4gICAgICBcImJnLW9yYW5nZS02MDAgZmlsbC1vcmFuZ2UtNjAwIHN0cm9rZS1vcmFuZ2UtNjAwXCIsXG4gICAgICBcImJnLXB1cnBsZS02MDAgZmlsbC1wdXJwbGUtNjAwIHN0cm9rZS1wdXJwbGUtNjAwXCIsXG4gICAgICBcImJnLXNreS02MDAgZmlsbC1za3ktNjAwIHN0cm9rZS1za3ktNjAwXCIsXG4gICAgICBcImJnLXRlYWwtNjAwIGZpbGwtdGVhbC02MDAgc3Ryb2tlLXRlYWwtNjAwXCIsXG4gICAgICBcImJnLWdyYXktNjAwIGZpbGwtZ3JheS02MDAgc3Ryb2tlLWdyYXktNjAwXCIsXG4gICAgICBcImJnLXBpbmstNjAwIGZpbGwtcGluay02MDAgc3Ryb2tlLXBpbmstNjAwXCIsXG4gICAgXSxcbiAgKTtcbiAgaWYgKGFublR5cGUgaW4gY2xhc3NOYW1lTWFwKSB7XG4gICAgcmV0dXJuIGAke2NvbW1vbn0gJHtjbGFzc05hbWVNYXBbYW5uVHlwZV0hfWA7XG4gIH1cbiAgcmV0dXJuIGNvbW1vbjtcbn1cblxuZXhwb3J0IGNvbnN0IHppcEFycmF5cyA9IDxUMSwgVDI+KGtleXM6IFQxW10sIHZhbHVlczogVDJbXSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGtleXMubWFwKChrZXk6IFQxLCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IHZhbDogVDIgfCB1bmRlZmluZWQgPSB2YWx1ZXNbaV07XG4gICAgICByZXR1cm4gW2tleSwgdmFsXTtcbiAgICB9KSxcbiAgKSBhcyB7IFQxOiBUMiB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2VuYmFuayA9IChnZW5iYW5rU3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gZ2VuYmFua1BhcnNlcihnZW5iYW5rU3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJpbXBvcnQgZ2VuYmFua1BhcnNlciwgeyBQYXJzZWRHZW5iYW5rIH0gZnJvbSBcImdlbmJhbmstcGFyc2VyXCI7XG5pbXBvcnQgeyBnZW5iYW5rVG9Bbm5vdGF0ZWRTZXF1ZW5jZSB9IGZyb20gXCIuL2dlbmJhbmtVdGlsc1wiO1xuaW1wb3J0IHsgYW5ub3RhdGVkU2VxdWVuY2VTY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWFzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIEFubm90YXRlZFNlcXVlbmNlLFxuICBBbm5vdGF0aW9uLFxuICBBbm5vdGF0aW9uVHlwZSxcbiAgQXJpYWRuZVNlbGVjdGlvbixcbiAgU3RhY2tlZEFubm90YXRpb24sXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRDb21wbGVtZW50ID0gKHNlcXVlbmNlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgY29tcGxlbWVudDoge1xuICAgIFtrZXk6IHN0cmluZ106IFwiQVwiIHwgXCJUXCIgfCBcIkNcIiB8IFwiR1wiIHwgXCJOXCI7XG4gIH0gPSB7XG4gICAgQTogXCJUXCIsXG4gICAgVDogXCJBXCIsXG4gICAgQzogXCJHXCIsXG4gICAgRzogXCJDXCIsXG4gICAgTjogXCJOXCIsXG4gIH07XG4gIHJldHVybiBzZXF1ZW5jZVxuICAgIC5zcGxpdChcIlwiKVxuICAgIC5tYXAoKGJhc2UpID0+IHtcbiAgICAgIGlmIChiYXNlIGluIGNvbXBsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZW1lbnRbYmFzZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbihcIlwiKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSA9ICh7XG4gIHNlcXVlbmNlLFxuICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIG5vVmFsaWRhdGUsXG59OiB7XG4gIHNlcXVlbmNlOiBzdHJpbmc7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogQW5ub3RhdGlvbltdO1xuICBub1ZhbGlkYXRlPzogYm9vbGVhbjtcbn0pOiBBbm5vdGF0ZWRTZXF1ZW5jZSA9PiB7XG4gIC8qIGxvb3AgdGhyb3VnaCBzZXF1ZW5jZSBmaW5kaW5nIGFsbCBhbm5vYXRhdGlvbnMgdGhhdCBhcHBseSB0byBlYWNoIGJhc2UgKi9cbiAgY29uc3QgbWFwRm4gPSAoYmFzZTogc3RyaW5nLCBpZHg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGFubm90YXRpb25zRm9yQmFzZSA9IHN0YWNrZWRBbm5vdGF0aW9ucy5maWx0ZXIoKGFubm90YXRpb24pID0+IHtcbiAgICAgIC8vIGlmIHRoZSBhbm5vdGF0aW9uIHNwYW5zIHRoZSBzZWFtIG9mIHRoZSBwbGFzbWlkXG4gICAgICBpZiAoYW5ub3RhdGlvbi5zdGFydCA+IGFubm90YXRpb24uZW5kKSB7XG4gICAgICAgIGNvbnN0IGlzQmV0d2VlbkFubm90YXRpb25TdGFydEFuZEVuZG9mU2VxdWVuY2UgPVxuICAgICAgICAgIGlkeCA+PSBhbm5vdGF0aW9uLnN0YXJ0ICYmIGlkeCA8PSBzZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzQmV0d2VlblN0YXJ0T2ZTZXF1ZW5jZUFuZEFubm90YXRpb25FbmQgPVxuICAgICAgICAgIGlkeCA+PSAwICYmIGlkeCA8PSBhbm5vdGF0aW9uLmVuZDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBpc0JldHdlZW5Bbm5vdGF0aW9uU3RhcnRBbmRFbmRvZlNlcXVlbmNlIHx8XG4gICAgICAgICAgaXNCZXR3ZWVuU3RhcnRPZlNlcXVlbmNlQW5kQW5ub3RhdGlvbkVuZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVndWxhciBjYXNlXG4gICAgICAgIHJldHVybiBpZHggPj0gYW5ub3RhdGlvbi5zdGFydCAmJiBpZHggPD0gYW5ub3RhdGlvbi5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2UsXG4gICAgICBpbmRleDogaWR4LFxuICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zRm9yQmFzZSxcbiAgICAgIGNvbXBsZW1lbnQ6IGdldENvbXBsZW1lbnQoYmFzZSksXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgcmF3ID0gc2VxdWVuY2VcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKG1hcEZuKVxuICAgIC5maWx0ZXIoKHgpID0+IHguYmFzZSAhPT0gXCIgXCIpOyAvLyByZW1vdmUgcGFkZGluZ1xuICBjb25zdCBhbm5vdGF0ZWRTZXF1ZW5jZSA9IGFubm90YXRlZFNlcXVlbmNlU2NoZW1hLnNhZmVQYXJzZShyYXcpO1xuICBpZiAobm9WYWxpZGF0ZSkge1xuICAgIGlmIChhbm5vdGF0ZWRTZXF1ZW5jZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgY29uc29sZS53YXJuKGFubm90YXRlZFNlcXVlbmNlLmVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhdyBhcyB1bmtub3duIGFzIEFubm90YXRlZFNlcXVlbmNlO1xuICB9XG4gIGlmIChhbm5vdGF0ZWRTZXF1ZW5jZS5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihhbm5vdGF0ZWRTZXF1ZW5jZS5lcnJvci5tZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gYW5ub3RhdGVkU2VxdWVuY2UuZGF0YTtcbn07XG5cbmludGVyZmFjZSBTdGFja2FibGUge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbn1cbi8vIG1vZGlmaWVkIGZyb20gc2Vxdml6XG5leHBvcnQgY29uc3Qgc3RhY2tFbGVtZW50cyA9IDxUIGV4dGVuZHMgU3RhY2thYmxlPihlbGVtZW50czogVFtdKSA9PiB7XG4gIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gdXRpbGl0eSBmdW5jcyBmb3Igc3RhY2tFbGVtZW50c1xuICBjb25zdCBsYXN0ID0gKGFycjogVFtdKTogVCA9PiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICBjb25zdCBmaXJzdCA9IChhcnI6IFRbXSk6IFQgPT4gYXJyWzBdO1xuICBjb25zdCBtYXhJbmRleCA9IGVsZW1lbnRzLm1hcCgoZSkgPT4gZS5lbmQpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYikpO1xuXG4gIGNvbnN0IHN0YWNrOiBUW11bXSA9IFtdO1xuICBlbGVtZW50cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgY29uc3QgaW5zZXJ0SW5kZXggPSBzdGFjay5maW5kSW5kZXgoKGVsZW1zKSA9PiB7XG4gICAgICBpZiAoYS5lbmQgPT09IGEuc3RhcnQpIHtcbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgaW5kZXggYW5kIHRoZXJlZm9yZSBzcGFucyB0aGUgd2hvbGUgYW5kIGdldHMgaXRzIG93biByb3dcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3QoZWxlbXMpLmVuZCA8PSBsYXN0KGVsZW1zKS5zdGFydCkge1xuICAgICAgICAvLyBpZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoaXMgcm93IGNyb3NzZXMgemVybyBpbmRleCBpdCBnZXRzIGl0cyBvd24gcm93XG4gICAgICAgIHJldHVybiBsYXN0KGVsZW1zKS5lbmQgKyBtYXhJbmRleCA8PSBhLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGEuZW5kID4gYS5zdGFydCkge1xuICAgICAgICAvLyB0aGlzIGVsZW1lbnQgZG9lc24ndCBjcm9zcyB0aGUgemVybyBpbmRleCBhbmQgdGhlIGxhc3QgaW4gcm93IGRvZXNuJ3RcbiAgICAgICAgcmV0dXJuIGxhc3QoZWxlbXMpLmVuZCA8PSBhLnN0YXJ0O1xuICAgICAgfVxuICAgICAgLy8gYm90aCB0aGlzIGN1cnIgZWxlbWVudCBhbmQgdGhlIGxhc3QgaW4gdGhlIHJvdyBjcm9zcyB0aGUgemVybyBpbmRleFxuICAgICAgcmV0dXJuIGxhc3QoZWxlbXMpLmVuZCA8IGEuc3RhcnQgJiYgYS5lbmQgPCBmaXJzdChlbGVtcykuc3RhcnQ7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5zZXJ0SW5kZXggPiAtMSkge1xuICAgICAgLy8gaW5zZXJ0IGluIHRoZSByb3cgd2hlcmUgaXQncyB0aGUgbmV3IGhpZ2hlc3RcbiAgICAgIHN0YWNrW2luc2VydEluZGV4XS5wdXNoKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgcm93IGZvciB0aGlzIGVudHJ5XG4gICAgICBzdGFjay5wdXNoKFthXSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0YWNrLm1hcCgocm93KSA9PiByb3cuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpKTtcbn07XG5cbi8vIHJldHVybnMgYW5ub3RhdGlvbnMgd2l0aCB0aGVpciBzdGFjayBpbmRleCBhbmQgbWF4IHN0YWNrIGluZGV4XG5leHBvcnQgY29uc3QgZ2V0U3RhY2tlZEFubm90YXRpb25zID0gKFxuICBhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdLFxuKTogU3RhY2tlZEFubm90YXRpb25bXSA9PiB7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrRWxlbWVudHMoYW5ub3RhdGlvbnMpO1xuICByZXR1cm4gc3RhY2tlZEFubm90YXRpb25zXG4gICAgLm1hcCgocm93LCBpZHgpID0+IHJvdy5tYXAoKGFubm90YXRpb24pID0+ICh7IC4uLmFubm90YXRpb24sIHN0YWNrOiBpZHggfSkpKVxuICAgIC5mbGF0KCk7XG59O1xuZXhwb3J0IGNvbnN0IGJhc2VJblNlbGVjdGlvbiA9ICh7XG4gIGJhc2VJbmRleCxcbiAgc2VsZWN0aW9uLFxuICBzZXF1ZW5jZUxlbmd0aCxcbn06IHtcbiAgYmFzZUluZGV4OiBudW1iZXI7XG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG59KSA9PiB7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uO1xuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiBiYXNlSW5kZXggPT09IHN0YXJ0O1xuICB9XG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIHJldHVybiBpblJhbmdlKGJhc2VJbmRleCwgc3RhcnQsIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gc3BhbnMgc2VhbVxuICAgIHJldHVybiAoXG4gICAgICBpblJhbmdlKGJhc2VJbmRleCwgc3RhcnQsIHNlcXVlbmNlTGVuZ3RoKSB8fCBpblJhbmdlKGJhc2VJbmRleCwgMCwgZW5kKVxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpblJhbmdlID0gKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4ge1xuICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTdWJzZXF1ZW5jZUxlbmd0aCA9IChcbiAgeyBzdGFydCwgZW5kIH06IEFyaWFkbmVTZWxlY3Rpb24sXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4pID0+IHtcbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzZXF1ZW5jZUxlbmd0aCAtIHN0YXJ0ICsgZW5kO1xuICB9XG59O1xuXG5pbnRlcmZhY2UgU3RyaW5nU291cmNlIHtcbiAgcGF5bG9hZFR5cGU6IFwiZ2VuYmFua1wiIHwgXCJmYXN0YVwiIHwgXCJyYXdcIjtcbiAgcGF5bG9hZDogc3RyaW5nO1xuICBhbm5vdGF0aW9ucz86IEFubm90YXRpb25bXTtcbiAgYW5ub3RhdGlvbk9uQ2xpY2s/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIEdlbmJhbmtTb3VyY2Uge1xuICBwYXlsb2FkVHlwZTogXCJwYXJzZWQtZ2VuYmFua1wiO1xuICBwYXlsb2FkOiBQYXJzZWRHZW5iYW5rO1xuICBhbm5vdGF0aW9ucz86IHVuZGVmaW5lZDtcbiAgYW5ub3RhdGlvbk9uQ2xpY2s/OiAoYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4gdm9pZDtcbn1cbnR5cGUgQW55dGhpbmdTb3VyY2UgPSBTdHJpbmdTb3VyY2UgfCBHZW5iYW5rU291cmNlO1xuXG50eXBlIFBhcnNlRXJyb3IgPSB7XG4gIHNvdXJjZTogQW55dGhpbmdTb3VyY2U7XG4gIGVycm9yOiBzdHJpbmc7XG59O1xudHlwZSBQYXJzZVN1Y2Nlc3MgPSB7XG4gIHNvdXJjZTogQW55dGhpbmdTb3VyY2U7XG4gIHNlcXVlbmNlczogQW5ub3RhdGVkU2VxdWVuY2VbXTtcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbn07XG5leHBvcnQgY29uc3QgYW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyA9ICh7XG4gIHBheWxvYWQsXG4gIHBheWxvYWRUeXBlLFxuICBhbm5vdGF0aW9ucyxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiBBbnl0aGluZ1NvdXJjZSk6IHtcbiAgc2VxdWVuY2VzOiBBbm5vdGF0ZWRTZXF1ZW5jZVtdO1xuICBzdGFja2VkQW5ub3RhdGlvbnM6IFN0YWNrZWRBbm5vdGF0aW9uW107XG59ID0+IHtcbiAgY29uc3QgeyBzdWNjZXNzZXMsIGZhaWx1cmVzIH0gPSBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyh7XG4gICAgcGF5bG9hZCxcbiAgICBwYXlsb2FkVHlwZSxcbiAgICBhbm5vdGF0aW9ucyxcbiAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgfSBhcyBBbnl0aGluZ1NvdXJjZSk7XG4gIGlmIChmYWlsdXJlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmFpbFN0cmluZyA9IGZhaWx1cmVzLm1hcCgoZikgPT4gZi5lcnJvcikuam9pbihcIlxcblwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnNlIGZhaWx1cmVzOiAke2ZhaWxTdHJpbmd9YCk7XG4gIH1cbiAgY29uc3Qgc2VxdWVuY2VzID0gc3VjY2Vzc2VzLm1hcCgocykgPT4gcy5zZXF1ZW5jZXMpLmZsYXQoKTtcbiAgY29uc3QgbmV3QW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSA9IHN1Y2Nlc3Nlc1xuICAgIC5tYXAoKHMpID0+IHMuYW5ub3RhdGlvbnMpXG4gICAgLmZsYXQoKTtcbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gZ2V0U3RhY2tlZEFubm90YXRpb25zKG5ld0Fubm90YXRpb25zKTtcbiAgcmV0dXJuIHsgc2VxdWVuY2VzLCBzdGFja2VkQW5ub3RhdGlvbnMgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzYWZlQW55dGhpbmdUb0Fubm90YXRlZFNlcXVlbmNlcyA9ICh7XG4gIHBheWxvYWQsXG4gIHBheWxvYWRUeXBlLFxuICBhbm5vdGF0aW9ucyxcbiAgYW5ub3RhdGlvbk9uQ2xpY2ssXG59OiBBbnl0aGluZ1NvdXJjZSk6IHsgc3VjY2Vzc2VzOiBQYXJzZVN1Y2Nlc3NbXTsgZmFpbHVyZXM6IFBhcnNlRXJyb3JbXSB9ID0+IHtcbiAgY29uc3Qgc3VjY2Vzc2VzOiBQYXJzZVN1Y2Nlc3NbXSA9IFtdO1xuICBjb25zdCBmYWlsdXJlczogUGFyc2VFcnJvcltdID0gW107XG4gIHN3aXRjaCAocGF5bG9hZFR5cGUpIHtcbiAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlcyA9IFtcbiAgICAgICAgICBzdHJpbmdUb0Fubm90YXRlZFNlcXVlbmNlKHtcbiAgICAgICAgICAgIHNlcXVlbmNlOiBwYXlsb2FkLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zID8/IFtdLFxuICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgICAgICBzdWNjZXNzZXMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VxdWVuY2VzOiBzZXF1ZW5jZXMsXG4gICAgICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zID8/IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gcGFyc2UgcmF3IHNlcXVlbmNlOiAke2V9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInBhcnNlZC1nZW5iYW5rXCI6XG4gICAgY2FzZSBcImdlbmJhbmtcIjoge1xuICAgICAgY29uc3QgcGFyc2VkID1cbiAgICAgICAgcGF5bG9hZFR5cGUgPT09IFwicGFyc2VkLWdlbmJhbmtcIiA/IFtwYXlsb2FkXSA6IGdlbmJhbmtQYXJzZXIocGF5bG9hZCk7XG5cbiAgICAgIHBhcnNlZC5mb3JFYWNoKChnZW5iYW5rKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2VxdWVuY2UgPSBnZW5iYW5rVG9Bbm5vdGF0ZWRTZXF1ZW5jZSh7XG4gICAgICAgICAgICBnZW5iYW5rLFxuICAgICAgICAgICAgYW5ub3RhdGlvbk9uQ2xpY2ssXG4gICAgICAgICAgfSkuYW5ub3RhdGVkU2VxdWVuY2U7XG4gICAgICAgICAgc3VjY2Vzc2VzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICB9IGFzIEFueXRoaW5nU291cmNlLFxuICAgICAgICAgICAgc2VxdWVuY2VzOiBbc2VxdWVuY2VdLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IFtdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZmFpbHVyZXMucHVzaCh7XG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgIGFubm90YXRpb25PbkNsaWNrLFxuICAgICAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICAgIH0gYXMgQW55dGhpbmdTb3VyY2UsXG4gICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBwYXJzZSBnZW5iYW5rOiAke2V9YCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZhc3RhXCI6IHtcbiAgICAgIGxldCByZWNvcmRzOiAoRmFzdGFSZWNvcmQgfCBGYXN0cVJlY29yZClbXTtcbiAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gXCJmYXN0YVwiKSB7XG4gICAgICAgIHJlY29yZHMgPSBwYXJzZUZhc3RhKHBheWxvYWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFzdHFcbiAgICAgICAgcmVjb3JkcyA9IHBhcnNlRmFzdHEocGF5bG9hZCk7XG4gICAgICB9XG4gICAgICByZWNvcmRzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IHNhZmVBbnl0aGluZ1RvQW5ub3RhdGVkU2VxdWVuY2VzKHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlY29yZC5zZXF1ZW5jZSxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlOiBcInJhd1wiLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZhaWx1cmVzLnB1c2goLi4ucmVzLmZhaWx1cmVzKTtcbiAgICAgICAgICBzdWNjZXNzZXMucHVzaCguLi5yZXMuc3VjY2Vzc2VzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWx1cmVzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gcGFyc2UgJHtwYXlsb2FkVHlwZX06ICR7ZX1gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBmYWlsdXJlcy5wdXNoKHtcbiAgICAgICAgc291cmNlOiB7XG4gICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICBhbm5vdGF0aW9uT25DbGljayxcbiAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGBVbmtub3duIHBheWxvYWQgdHlwZTogJHtwYXlsb2FkVHlwZX1gLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3NlcyxcbiAgICBmYWlsdXJlcyxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdUb0Fubm90YXRlZFNlcXVlbmNlID0gKHtcbiAgc2VxdWVuY2UsXG4gIGFubm90YXRpb25zLFxufToge1xuICBzZXF1ZW5jZTogc3RyaW5nO1xuICBhbm5vdGF0aW9ucz86IEFubm90YXRpb25bXTtcbn0pOiBBbm5vdGF0ZWRTZXF1ZW5jZSA9PiB7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IGdldFN0YWNrZWRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucyA/PyBbXSk7XG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlID0gZ2V0QW5ub3RhdGVkU2VxdWVuY2Uoe1xuICAgIHNlcXVlbmNlLFxuICAgIHN0YWNrZWRBbm5vdGF0aW9ucyxcbiAgfSk7XG4gIHJldHVybiBhbm5vdGF0ZWRTZXF1ZW5jZTtcbn07XG5cbi8vIERldGVybWluZSBpZiB0d28gYW5ub3RhdGlvbnMgZnJvbSB0aGUgc2FtZSBzZXF1ZW5jZSBvdmVybGFwLlxuZXhwb3J0IGNvbnN0IGFubm90YXRpb25zSGF2ZU92ZXJsYXAgPSAoXG4gIGExOiBBbm5vdGF0aW9uLFxuICBhMjogQW5ub3RhdGlvbixcbiAgbWF4TGVuOiBudW1iZXIsXG4pOiBib29sZWFuID0+IHtcbiAgaWYgKFxuICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICBiYXNlSW5kZXg6IGExLnN0YXJ0LFxuICAgICAgc2VsZWN0aW9uOiBhMixcbiAgICAgIHNlcXVlbmNlTGVuZ3RoOiBtYXhMZW4sXG4gICAgfSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFxuICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICBiYXNlSW5kZXg6IGExLmVuZCxcbiAgICAgIHNlbGVjdGlvbjogYTIsXG4gICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4TGVuLFxuICAgIH0pXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMi5zdGFydCxcbiAgICAgIHNlbGVjdGlvbjogYTEsXG4gICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4TGVuLFxuICAgIH0pXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChcbiAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgYmFzZUluZGV4OiBhMi5lbmQsXG4gICAgICBzZWxlY3Rpb246IGExLFxuICAgICAgc2VxdWVuY2VMZW5ndGg6IG1heExlbixcbiAgICB9KVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBDcmVhdGUgU3RhY2tlZEFubm90YXRpb25zIHN1Y2ggdGhhdCBubyBcInN0YWNrXCIgb3IgbGluZSBvZiBhbm5vdGF0aW9ucyBoYXZlXG4vLyBhbnkgb3ZlcmxhcHBpbmcgYW5ub3RhdGlvbnMuXG5leHBvcnQgY29uc3Qgc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcCA9IChcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXSxcbiAgbWF4TGVuOiBudW1iZXIsXG4pOiBTdGFja2VkQW5ub3RhdGlvbltdID0+IHtcbiAgY29uc3QgYW5ub3RhdGlvbnNCeVN0YWNrID0gW10gYXMgQW5ub3RhdGlvbltdW107XG5cbiAgYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgbGV0IGN1clN0YWNrID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qgc3RhY2tBbm5zID0gYW5ub3RhdGlvbnNCeVN0YWNrW2N1clN0YWNrXTtcbiAgICAgIGlmICghc3RhY2tBbm5zKSB7XG4gICAgICAgIGFubm90YXRpb25zQnlTdGFja1tjdXJTdGFja10gPSBbYW5ub3RhdGlvbl07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IG92ZXJsYXAgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgc3RhY2tlZEFubiBvZiBzdGFja0FubnMpIHtcbiAgICAgICAgaWYgKGFubm90YXRpb25zSGF2ZU92ZXJsYXAoYW5ub3RhdGlvbiwgc3RhY2tlZEFubiwgbWF4TGVuKSkge1xuICAgICAgICAgIG92ZXJsYXAgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybGFwKSB7XG4gICAgICAgIC8vIEEgb3ZlcmxhcCB3YXMgZGV0ZWN0ZWQgc28gdHJ5IHRoZSBuZXh0IGxpbmUuXG4gICAgICAgIGN1clN0YWNrICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBvdmVybGFwcyBkZXRlY3RlZCBvbiB0aGlzIHN0YWNrIHRoZW4gYWRkIHRoZVxuICAgICAgICAvLyBhbm5vdGF0aW9uIHRvIHRoaXMgbGluZS5cbiAgICAgICAgYW5ub3RhdGlvbnNCeVN0YWNrW2N1clN0YWNrXS5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBDb252ZXJ0IGFubm90YXRpb25zIHRvIHN0YWNrZWQgYW5ub3RhdGlvbnNcbiAgY29uc3Qgc3RhY2tlZEFubm90YXRpb25zID0gW10gYXMgU3RhY2tlZEFubm90YXRpb25bXTtcbiAgYW5ub3RhdGlvbnNCeVN0YWNrLmZvckVhY2goKHN0YWNrZWRBbm5zLCBpbmRleCkgPT4ge1xuICAgIHN0YWNrZWRBbm5zLmZvckVhY2goKGFubm90YXRpb24pID0+IHtcbiAgICAgIHN0YWNrZWRBbm5vdGF0aW9ucy5wdXNoKHtcbiAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgc3RhY2s6IGluZGV4LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzdGFja2VkQW5ub3RhdGlvbnM7XG59O1xuXG5leHBvcnQgY29uc3Qgc3RhY2tBbm5zQnlUeXBlID0gKFxuICBhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdLFxuKTogU3RhY2tlZEFubm90YXRpb25bXSA9PiB7XG4gIC8vIGNyZWF0ZSBhIG1hcCBvZiBhbm5vdGF0aW9uIHR5cGUgdG8gbGlzdFxuICBjb25zdCBhbm5vdGF0aW9uTWFwID0gYW5ub3RhdGlvbnMucmVkdWNlKFxuICAgIChhY2M6IHsgW2tleTogQW5ub3RhdGlvblR5cGVdOiBBbm5vdGF0aW9uW10gfSwgYW5ub3RhdGlvbjogQW5ub3RhdGlvbikgPT4ge1xuICAgICAgaWYgKGFjY1thbm5vdGF0aW9uLnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjW2Fubm90YXRpb24udHlwZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGFjY1thbm5vdGF0aW9uLnR5cGVdIS5wdXNoKGFubm90YXRpb24pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9IGFzIHsgW2tleTogQW5ub3RhdGlvblR5cGVdOiBBbm5vdGF0aW9uW10gfSxcbiAgKTtcblxuICBjb25zdCBzdGFja3MgPSBPYmplY3QudmFsdWVzKGFubm90YXRpb25NYXApXG4gICAgLm1hcCgoc3RhY2ssIHN0YWNrSWR4KSA9PiB7XG4gICAgICByZXR1cm4gc3RhY2subWFwKChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlczogU3RhY2tlZEFubm90YXRpb24gPSB7XG4gICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICBzdGFjazogc3RhY2tJZHgsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC5mbGF0KCk7XG5cbiAgcmV0dXJuIHN0YWNrcztcbn07XG5cbmludGVyZmFjZSBGYXN0cVJlY29yZCB7XG4gIGlkOiBzdHJpbmc7XG4gIHNlcXVlbmNlOiBzdHJpbmc7XG4gIG9wdGlvbmFsSWQ6IHN0cmluZztcbiAgcXVhbGl0eTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGYXN0cShkYXRhOiBzdHJpbmcpOiBGYXN0cVJlY29yZFtdIHtcbiAgY29uc3QgbGluZXMgPSBkYXRhLnRyaW0oKS5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgcmVjb3JkczogRmFzdHFSZWNvcmRbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCByZWNvcmQ6IEZhc3RxUmVjb3JkID0ge1xuICAgICAgaWQ6IGxpbmVzW2ldLnN1YnN0cmluZygxKSxcbiAgICAgIHNlcXVlbmNlOiBsaW5lc1tpICsgMV0sXG4gICAgICBvcHRpb25hbElkOiBsaW5lc1tpICsgMl0uc3Vic3RyaW5nKDEpLFxuICAgICAgcXVhbGl0eTogbGluZXNbaSArIDNdLFxuICAgIH07XG5cbiAgICByZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvcmRzO1xufVxuXG5pbnRlcmZhY2UgRmFzdGFSZWNvcmQge1xuICBpZDogc3RyaW5nO1xuICBzZXF1ZW5jZTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGYXN0YShkYXRhOiBzdHJpbmcpOiBGYXN0YVJlY29yZFtdIHtcbiAgY29uc3QgbGluZXMgPSBkYXRhLnRyaW0oKS5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgcmVjb3JkczogRmFzdGFSZWNvcmRbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCByZWNvcmQ6IEZhc3RhUmVjb3JkID0ge1xuICAgICAgaWQ6IGxpbmVzW2ldLnN1YnN0cmluZygxKSxcbiAgICAgIHNlcXVlbmNlOiBsaW5lc1tpICsgMV0sXG4gICAgfTtcblxuICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29yZHM7XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgY29uc3QgdXNlU3RhdGVSZWYgPSA8VD4oaW5pdGlhbFZhbHVlOiBUKSA9PiB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBbc3RhdGUsIGludGVybmFsU2V0U3RhdGVdID0gdXNlU3RhdGU8VD4oaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjaygodmFsdWU6IFQpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIGludGVybmFsU2V0U3RhdGUodmFsdWUpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIHJlZl0gYXMgY29uc3Q7XG59O1xuIiwiaW1wb3J0IHsgZmluZEFuZ2xlRnJvbUNvb3IgfSBmcm9tIFwiQEFyaWFkbmUvQ2lyY3VsYXJWaWV3ZXIvY2lyY3VsYXJVdGlsc1wiO1xuaW1wb3J0IHsgQW5nbGUsIENvb3IgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IGluUmFuZ2UgfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IFJlZk9iamVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZVJlZiB9IGZyb20gXCIuL3VzZVN0YXRlUmVmXCI7XG5cbi8qIHVzZUxpbmVhclNlbGVjdGlvblJlY3QgbWFuYWdlcyB0aGUgc2VsZWN0aW9uIG9mIGEgTGluZWFyU2VsZWN0aW9uIHdpdGhpblxuICogdGhlIExpbmVhclZpZXdlci5cbiAqXG4gKiByZWYgKFJlZk9iamVjdCkgQSByZWZlcmVuY2UgdG8gdGhlIHN2ZyBjb250YWluaW5nIHRoZSBMaW5lYXJTZWxlY3Rpb24uXG4gKiBvbk1vdXNlVXA6IE9wdGlvbmFsIGhhbmRsZXIgd2hlbiB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZVxuICogb25Nb3VzZURvd246IE9wdGlvbmFsIGhhbmRsZXIgd2hlbiB1c2VyIHByZXNzZXMgdGhlIG1vdXNlIG9uIHRoZSBMaW5lYXJTZWxlY3Rpb24uXG4gKiBvbk1vdXNlTW92ZTogT3B0aW9uYWwgaGFuZGxlciB3aGVuIHVzZXIgZHJhZ3MuXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VMaW5lYXJTZWxlY3Rpb25SZWN0ID0gPFxuICBUIGV4dGVuZHMge1xuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOiBET01SZWN0O1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6ICh0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiAoZTogTW91c2VFdmVudCkgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiAoXG4gICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICBsaXN0ZW5lcjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQsXG4gICAgKSA9PiB2b2lkO1xuICB9LFxuPih7XG4gIHJlZixcbiAgb25Nb3VzZVVwLFxuICBvbk1vdXNlRG93bixcbiAgb25Nb3VzZU1vdmUsXG59OiB7XG4gIHJlZjogUmVmT2JqZWN0PFQgfCBudWxsPjtcbiAgb25Nb3VzZVVwPzogKHBheWxvYWQ6IHsgc3RhcnQ6IENvb3I7IGVuZDogQ29vciB9KSA9PiB2b2lkO1xuICBvbk1vdXNlRG93bj86IChwYXlsb2FkOiB7IHN0YXJ0OiBDb29yIH0pID0+IHZvaWQ7XG4gIG9uTW91c2VNb3ZlPzogKHBheWxvYWQ6IHsgc3RhcnQ6IENvb3I7IGVuZDogQ29vciB9KSA9PiB2b2lkO1xufSkgPT4ge1xuICBjb25zdCBbc3RhcnQsIHNldFN0YXJ0LCBzdGFydFJlZl0gPSB1c2VTdGF0ZVJlZjxDb29yIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtlbmQsIHNldEVuZCwgZW5kUmVmXSA9IHVzZVN0YXRlUmVmPENvb3IgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGU8XCJmb3J3YXJkXCIgfCBcInJldmVyc2VcIj4oXCJmb3J3YXJkXCIpO1xuXG4gIGNvbnN0IGFjdGl2ZSA9IHVzZVJlZihmYWxzZSk7XG5cbiAgY29uc3QgX29uTW91c2VEb3duID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGU7XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IHJlZi5jdXJyZW50Py5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgIH07XG4gICAgY29uc3QgeCA9IGNsaWVudFggLSBsZWZ0O1xuICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgIGFjdGl2ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICBzZXRTdGFydCh7IHgsIHkgfSk7XG4gICAgc2V0RW5kKHsgeCwgeSB9KTtcbiAgICBvbk1vdXNlRG93bj8uKHsgc3RhcnQ6IHsgeCwgeSB9IH0pO1xuICB9O1xuICBjb25zdCBfb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgIGFjdGl2ZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKHN0YXJ0UmVmLmN1cnJlbnQgJiYgZW5kUmVmLmN1cnJlbnQpIHtcbiAgICAgIG9uTW91c2VVcD8uKHsgc3RhcnQ6IHN0YXJ0UmVmLmN1cnJlbnQsIGVuZDogZW5kUmVmLmN1cnJlbnQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdGFydCBvciBlbmQgaXMgbnVsbCB3aGVuIG1vdXNldXBcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIG11c3QgdXNlIHJlZnMgaW4gZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG1vc3QgdXAgdG8gZGF0ZSB2YWx1ZXNcbiAgY29uc3QgX29uTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoYWN0aXZlLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgIGNvbnN0IHsgbGVmdCwgdG9wIH0gPSByZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwge1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICB9O1xuICAgICAgY29uc3QgeCA9IGNsaWVudFggLSBsZWZ0O1xuICAgICAgY29uc3QgeSA9IGNsaWVudFkgLSB0b3A7XG4gICAgICBjb25zdCB7IHN0YXJ0WCB9ID0ge1xuICAgICAgICBzdGFydFg6IHN0YXJ0UmVmLmN1cnJlbnQ/LngsXG4gICAgICB9O1xuICAgICAgaWYgKHN0YXJ0WCAmJiBzdGFydFggPiB4KSB7XG4gICAgICAgIHNldERpcmVjdGlvbihcInJldmVyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXREaXJlY3Rpb24oXCJmb3J3YXJkXCIpO1xuICAgICAgfVxuICAgICAgc2V0RW5kKHsgeCwgeSB9KTtcbiAgICAgIGlmIChzdGFydFJlZi5jdXJyZW50ICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIG9uTW91c2VNb3ZlPy4oeyBzdGFydDogc3RhcnRSZWYuY3VycmVudCwgZW5kOiBlbmRSZWYuY3VycmVudCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdGFydCBpcyBudWxsIHdoZW4gbW91c2Vtb3ZlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gcmVmPy5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX29uTW91c2VEb3duKTtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfb25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgICBpZiAod2luZG93KSB7XG4gICAgICAvLyBzdGlsbCB3YW50IHRvIGNhbGwgbW91c2V1cCBpZiBtb3VzZSBsZWF2ZXMgcGFyZW50XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX29uTW91c2VVcCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF9vbk1vdXNlRG93bik7XG4gICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF9vbk1vdXNlTW92ZSk7XG4gICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF9vbk1vdXNlVXApO1xuICAgIH07XG4gIH0sIFtyZWZdKTtcbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uIH07XG59O1xuXG4vLyBmb3IgY2lyY3VsYXIgY29vcmRpbmF0ZXNcbmV4cG9ydCBjb25zdCB1c2VDaXJjdWxhclNlbGVjdGlvblJlY3QgPSAoXG4gIHJlZjogUmVmT2JqZWN0PFNWR1NWR0VsZW1lbnQgfCBudWxsPixcbikgPT4ge1xuICBjb25zdCBbc3RhcnQsIHNldFN0YXJ0LCBzdGFydFJlZl0gPSB1c2VTdGF0ZVJlZjxBbmdsZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZW5kLCBzZXRFbmRdID0gdXNlU3RhdGVSZWY8QW5nbGUgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGU8XG4gICAgXCJjbG9ja3dpc2VcIiB8IFwiY291bnRlcmNsb2Nrd2lzZVwiIHwgbnVsbFxuICA+KG51bGwpO1xuICBjb25zdCBBTkdMRV9ERUxUQV9USFJFU0hPTERfSU5fREVHUkVFUyA9IDI7XG5cbiAgY29uc3QgYWN0aXZlID0gdXNlUmVmKGZhbHNlKTtcblxuICBjb25zdCBvbk1vdXNlRG93biA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwicmVzZXR0aW5nIHN0YXJ0IGFuZCBlbmRcIik7XG4gICAgICBzZXRTdGFydChudWxsKTtcbiAgICAgIHNldEVuZChudWxsKTtcbiAgICAgIHNldERpcmVjdGlvbihudWxsKTtcbiAgICAgIGFjdGl2ZS5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xuICAgICAgY29uc3QgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IHJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgeCA9IGNsaWVudFggLSBsZWZ0O1xuICAgICAgY29uc3QgeSA9IGNsaWVudFkgLSB0b3A7XG4gICAgICBjb25zdCBjZW50ZXIgPSB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0IC8gMiB9O1xuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogeyB4LCB5IH0sIGNlbnRlciB9KTtcbiAgICAgIHNldFN0YXJ0KHtcbiAgICAgICAgZGVncmVlczogc3RhcnRBbmdsZSxcbiAgICAgICAgY2VudGVyLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICBhY3RpdmUuY3VycmVudCA9IGZhbHNlO1xuXG4gICAgc2V0RGlyZWN0aW9uKG51bGwpO1xuICB9O1xuXG4gIGNvbnN0IG9uTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoYWN0aXZlLmN1cnJlbnQgJiYgcmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gZTtcbiAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSByZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHggPSBjbGllbnRYIC0gbGVmdDtcbiAgICAgIGNvbnN0IHkgPSBjbGllbnRZIC0gdG9wO1xuICAgICAgY29uc3QgY2VudGVyID0geyB4OiB3aWR0aCAvIDIsIHk6IGhlaWdodCAvIDIgfTtcbiAgICAgIC8vIGlmIHdlJ3JlIGNsb3NlIHRvIHRoZSBjZW50ZXIsIGRvbid0IHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgIGlmIChcbiAgICAgICAgTWF0aC5zcXJ0KE1hdGgucG93KHggLSBjZW50ZXIueCwgMikgKyBNYXRoLnBvdyh5IC0gY2VudGVyLnksIDIpKSA8XG4gICAgICAgIDAuNCAqICh3aWR0aCAvIDIpXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIndpdGhpbiAwLjUgcmFkaXVzIG9mIGNlbnRlciwgbm90IHVwZGF0aW5nIHNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmRBbmdsZSA9IGZpbmRBbmdsZUZyb21Db29yKHsgY29vcjogeyB4LCB5IH0sIGNlbnRlciB9KTtcbiAgICAgIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydFJlZi5jdXJyZW50LmRlZ3JlZXM7XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlSXNOZWFyU3RhcnRBbmdsZSA9IGluUmFuZ2UoXG4gICAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgICAgc3RhcnRBbmdsZSAtIEFOR0xFX0RFTFRBX1RIUkVTSE9MRF9JTl9ERUdSRUVTLFxuICAgICAgICAgIHN0YXJ0QW5nbGUgKyBBTkdMRV9ERUxUQV9USFJFU0hPTERfSU5fREVHUkVFUyxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlSXNOZWFyU3RhcnRBbmdsZSkge1xuICAgICAgICAgIHNldERpcmVjdGlvbihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0RW5kKHtcbiAgICAgICAgZGVncmVlczogZW5kQW5nbGUsXG4gICAgICAgIGNlbnRlcixcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lRGlyZWN0aW9uKCkge1xuICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBkaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0LmRlZ3JlZXM7XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gZW5kLmRlZ3JlZXM7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICBjb25zdCBndWVzc2VkRGlyZWN0aW9uID0gZGVsdGEgPiAwID8gXCJjbG9ja3dpc2VcIiA6IFwiY291bnRlcmNsb2Nrd2lzZVwiO1xuICAgICAgICBzZXREaXJlY3Rpb24oZ3Vlc3NlZERpcmVjdGlvbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBbc3RhcnQsIGVuZF0sXG4gICk7XG5cbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duKTtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbm9kZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93bik7XG4gICAgICAgIG5vZGU/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUpO1xuICAgICAgICBub2RlPy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgW3JlZi5jdXJyZW50LCBzdGFydCwgZGlyZWN0aW9uXSxcbiAgKTtcbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uIH07XG59O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGNsYXNzTmFtZXMoXG4gIC4uLmNsYXNzZXM6IChzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsIHwgYm9vbGVhbilbXVxuKSB7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbn1cbmV4cG9ydCBjb25zdCBjbiA9IGNsYXNzTmFtZXM7XG4iLCJpbXBvcnQgeyBnZW5BcmMgfSBmcm9tIFwiLi4vY2lyY3VsYXJVdGlsc1wiO1xuaW1wb3J0IHR5cGUgeyBBbm5vdGF0ZWRTZXF1ZW5jZSwgQW5ub3RhdGlvbiwgQ29vciB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgY2xhc3NOYW1lcyB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcbmltcG9ydCB7IGdldFN1YnNlcXVlbmNlTGVuZ3RoIH0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBDaXJjdWxhckFubm90YXRpb24gPSAoe1xuICBzZXF1ZW5jZSxcbiAgYW5ub3RhdGlvbixcbiAgcmFkaXVzLFxuICBjZW50ZXIsXG59OiB7XG4gIHNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGFubm90YXRpb246IEFubm90YXRpb247XG5cbiAgY2VudGVyOiBDb29yO1xufSkgPT4ge1xuICBjb25zdCB7IHg6IGN4LCB5OiBjeSB9ID0gY2VudGVyO1xuICBjb25zdCBhbm5vdGF0aW9uTGVuZ3RoID0gZ2V0U3Vic2VxdWVuY2VMZW5ndGgoYW5ub3RhdGlvbiwgc2VxdWVuY2UubGVuZ3RoKTtcbiAgaWYgKGFubm90YXRpb25MZW5ndGggPiBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEFubm90YXRpb24gJHthbm5vdGF0aW9uLnRleHR9J3MgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiBzZXF1ZW5jZSBsZW5ndGg6ICR7YW5ub3RhdGlvbkxlbmd0aH0gPiAke3NlcXVlbmNlLmxlbmd0aH1gLFxuICAgICk7XG4gIH1cbiAgY29uc3QgYXJjUGF0aCA9IGdlbkFyYyh7XG4gICAgaW5uZXJSYWRpdXM6IHJhZGl1cyxcbiAgICBvdXRlclJhZGl1czogcmFkaXVzICsgNSxcbiAgICBsYXJnZUFyYzogYW5ub3RhdGlvbkxlbmd0aCA+IHNlcXVlbmNlLmxlbmd0aCAvIDIsXG4gICAgbGVuZ3RoOiBhbm5vdGF0aW9uTGVuZ3RoLFxuICAgIHNlcUxlbmd0aDogc2VxdWVuY2UubGVuZ3RoLFxuICAgIG9mZnNldDogYW5ub3RhdGlvbi5zdGFydCxcbiAgICBjZW50ZXI6IHsgeDogY3gsIHk6IGN5IH0sXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGFubm90YXRpb24uY2xhc3NOYW1lKX1cbiAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgYW5ub3RhdGlvbi5vbkNsaWNrPy4oYW5ub3RhdGlvbik7XG4gICAgICB9fVxuICAgID5cbiAgICAgIDxwYXRoIGQ9e2FyY1BhdGh9PlxuICAgICAgICA8dGl0bGU+e2Fubm90YXRpb24udGV4dH08L3RpdGxlPlxuICAgICAgICA8dGV4dD5Bbm5vdGF0aW9uPC90ZXh0PlxuICAgICAgPC9wYXRoPlxuICAgIDwvc3ZnPlxuICApO1xufTtcbiIsImltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB0eXBlIHsgQW5ub3RhdGVkU2VxdWVuY2UsIFN0YWNrZWRBbm5vdGF0aW9uIH0gZnJvbSBcIkBBcmlhZG5lL3R5cGVzXCI7XG5pbXBvcnQgeyBDaXJjdWxhckFubm90YXRpb24gfSBmcm9tIFwiLi9DaXJjdWxhckFubm90YXRpb25cIjtcbmltcG9ydCB7IGNsYW1wU2xpY2UgfSBmcm9tIFwiLi4vY2lyY3VsYXJVdGlsc1wiO1xuXG5leHBvcnQgY29uc3QgQ2lyY3VsYXJBbm5vdGF0aW9uR3V0dGVyID0gKHtcbiAgc3RhY2tlZEFubm90YXRpb25zLFxuICBjeCxcbiAgY3ksXG4gIHJhZGl1cyxcbiAgYW5ub3RhdGVkU2VxdWVuY2UsXG59OiB7XG4gIHN0YWNrZWRBbm5vdGF0aW9uczogU3RhY2tlZEFubm90YXRpb25bXTtcbiAgY3g6IG51bWJlcjtcbiAgY3k6IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGFubm90YXRlZFNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbn0pID0+IHtcbiAgY29uc3QgZ3V0dGVyUmFkaXVzID0gcmFkaXVzICogMC4zO1xuICBjb25zdCBmaXJzdElkeCA9XG4gICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCA/IGFubm90YXRlZFNlcXVlbmNlLmF0KDApIS5pbmRleCA6IDA7XG4gIGNvbnN0IGxhc3RJZHggPVxuICAgIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCA+IDAgPyBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgtMSkhLmluZGV4IDogMDtcbiAgc3RhY2tlZEFubm90YXRpb25zID0gc3RhY2tlZEFubm90YXRpb25zXG4gICAgLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgY29uc3QgY2xhbXBlZEJvdW5kcyA9IGNsYW1wU2xpY2Uoe1xuICAgICAgICBzbGljZTogYW5ub3RhdGlvbixcbiAgICAgICAgZmlyc3RJZHgsXG4gICAgICAgIGxhc3RJZHgsXG4gICAgICB9KTtcbiAgICAgIGlmICghY2xhbXBlZEJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgIHN0YXJ0OiBjbGFtcGVkQm91bmRzLnN0YXJ0LFxuICAgICAgICBlbmQ6IGNsYW1wZWRCb3VuZHMuZW5kLFxuICAgICAgfTtcbiAgICB9KVxuICAgIC5maWx0ZXIoQm9vbGVhbikgYXMgU3RhY2tlZEFubm90YXRpb25bXTsgLy8gZmlsdGVyIGVuc3VyZXMgdGhhdCB0aGUgYXJyYXkgaXMgb2YgdHlwZSBTdGFja2VkQW5ub3RhdGlvbltdXG4gIGNvbnN0IHN0YWNrczogU3RhY2tlZEFubm90YXRpb25bXVtdID0gW107XG4gIHN0YWNrZWRBbm5vdGF0aW9ucy5mb3JFYWNoKChhbm4pID0+IHtcbiAgICBzdGFja3NbYW5uLnN0YWNrXSA9IHN0YWNrc1thbm4uc3RhY2tdIHx8IFtdO1xuICAgIHN0YWNrc1thbm4uc3RhY2tdLnB1c2goYW5uKTtcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Zz5cbiAgICAgIDxjaXJjbGUgY3g9e2N4fSBjeT17Y3l9IHI9e2d1dHRlclJhZGl1c30gZmlsbD1cIm5vbmVcIiBzdHJva2VXaWR0aD17MC44fSAvPjtcbiAgICAgIHtzdGFja3MubWFwKChhbm5vdGF0aW9ucywgc3RhY2tJZHgpID0+IChcbiAgICAgICAgPEZyYWdtZW50IGtleT17YGFubm90YXRpb24tc3RhY2stJHtzdGFja0lkeH1gfT5cbiAgICAgICAgICB7YW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiAoXG4gICAgICAgICAgICA8Q2lyY3VsYXJBbm5vdGF0aW9uXG4gICAgICAgICAgICAgIGtleT17YHN0YWNrLSR7c3RhY2tJZHh9LSR7YW5ub3RhdGlvbi5zdGFydH0tJHthbm5vdGF0aW9uLmVuZH0tJHthbm5vdGF0aW9uLnRleHR9YH1cbiAgICAgICAgICAgICAgYW5ub3RhdGlvbj17YW5ub3RhdGlvbn1cbiAgICAgICAgICAgICAgcmFkaXVzPXtndXR0ZXJSYWRpdXMgKyBzdGFja0lkeCAqIDZ9XG4gICAgICAgICAgICAgIGNlbnRlcj17eyB4OiBjeCwgeTogY3kgfX1cbiAgICAgICAgICAgICAgc2VxdWVuY2U9e2Fubm90YXRlZFNlcXVlbmNlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICkpfVxuICAgIDwvZz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBBbm5vdGF0ZWRTZXF1ZW5jZSB9IGZyb20gXCJAQXJpYWRuZS90eXBlc1wiO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZpbmRDb29yIH0gZnJvbSBcIi4uL2NpcmN1bGFyVXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IENpcmN1bGFySW5kZXggPSAoe1xuICBhbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgY3gsXG4gIGN5LFxuICByYWRpdXMsXG4gIHRpY2tzLFxufToge1xuICBhbm5vdGF0ZWRTZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICB0aWNrczogbnVtYmVyO1xufSkgPT4ge1xuICBjb25zdCBiYXNlc1BlclRpY2sgPSBNYXRoLmZsb29yKGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCAvIHRpY2tzKTtcblxuICBpZiAoYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gNTApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHN2ZyBjbGFzc05hbWU9e2BmaWxsLWN1cnJlbnRgfT5cbiAgICAgICAgPGc+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgICAgcj17cmFkaXVzICogMC43NX1cbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxUaWNrc1xuICAgICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgICAgcmFkaXVzPXtyYWRpdXMgKiAwLjc1fVxuICAgICAgICAgICAgYmFzZXNQZXJUaWNrPXtiYXNlc1BlclRpY2t9XG4gICAgICAgICAgICB0b3RhbEJhc2VzPXthbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGh9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDx0ZXh0PlxuICAgICAge2Fubm90YXRlZFNlcXVlbmNlLm1hcCgoeyBiYXNlOiBsZXR0ZXIgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBmaW5kQ29vcih7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXMgKiAwLjcsXG4gICAgICAgICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICAgICAgICAgIHNlcUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgcm90YXRlRGVncmVlcyA9IChpbmRleCAvIGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aCkgKiAzNjA7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPHRzcGFuXG4gICAgICAgICAgICBrZXk9e2BiYXNlLSR7aW5kZXh9YH1cbiAgICAgICAgICAgIHg9e3h9XG4gICAgICAgICAgICB5PXt5fVxuICAgICAgICAgICAgdHJhbnNmb3JtPXtgcm90YXRlKCR7cm90YXRlRGVncmVlc30gJHt4fSAke3l9KWB9XG4gICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgICAgICAgY29sb3I9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICBmb250U2l6ZT1cIjAuNXJlbVwiXG4gICAgICAgICAgICBmb250V2VpZ2h0PVwidGhpblwiXG4gICAgICAgICAgICBmb250RmFtaWx5PVwiaW5oZXJpdFwiXG4gICAgICAgICAgICBkYXRhLXNlcS1pbmRleD17aW5kZXh9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2xldHRlcn1cbiAgICAgICAgICA8L3RzcGFuPlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC90ZXh0PlxuICApO1xufTtcblxuY29uc3QgVGlja3MgPSAoe1xuICByYWRpdXMsXG4gIGN4LFxuICBjeSxcbiAgYmFzZXNQZXJUaWNrLFxuICB0b3RhbEJhc2VzLFxufToge1xuICByYWRpdXM6IG51bWJlcjtcbiAgY3g6IG51bWJlcjtcbiAgY3k6IG51bWJlcjtcbiAgYmFzZXNQZXJUaWNrOiBudW1iZXI7XG4gIHRvdGFsQmFzZXM6IG51bWJlcjtcbn0pID0+IHtcbiAgY29uc3QgbnVtYmVyT2ZUaWNrcyA9IE1hdGguZmxvb3IodG90YWxCYXNlcyAvIGJhc2VzUGVyVGljayk7XG4gIHJldHVybiAoXG4gICAgPHN2Zz5cbiAgICAgIHtbLi4uQXJyYXkobnVtYmVyT2ZUaWNrcykua2V5cygpXS5tYXAoKGkpID0+IHtcbiAgICAgICAgY29uc3QgeyB4OiB4MSwgeTogeTEgfSA9IGZpbmRDb29yKHtcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICByYWRpdXMsXG4gICAgICAgICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICAgICAgICAgIHNlcUxlbmd0aDogdG90YWxCYXNlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgeDogeDIsIHk6IHkyIH0gPSBmaW5kQ29vcih7XG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXMgKiAxLjEsXG4gICAgICAgICAgY2VudGVyOiB7IHg6IGN4LCB5OiBjeSB9LFxuICAgICAgICAgIHNlcUxlbmd0aDogdG90YWxCYXNlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZURlZ3JlZXMgPSAoaSAvIG51bWJlck9mVGlja3MpICogMzYwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxGcmFnbWVudCBrZXk9e2B0aWNrLSR7aX1gfT5cbiAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgIGlkPXtgdGljay0ke2l9YH1cbiAgICAgICAgICAgICAgeDE9e3gxfVxuICAgICAgICAgICAgICB5MT17eTF9XG4gICAgICAgICAgICAgIHgyPXt4Mn1cbiAgICAgICAgICAgICAgeTI9e3kyfVxuICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17MX1cbiAgICAgICAgICAgICAgb3BhY2l0eT17MC41fVxuICAgICAgICAgICAgICB0cmFuc2Zvcm09e2Byb3RhdGUoJHtyb3RhdGVEZWdyZWVzfSAke2N4fSAke2N5fSlgfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgIHg9e3gyfVxuICAgICAgICAgICAgICB5PXt5MiAtIDR9XG4gICAgICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICBmb250U2l6ZT1cIi44cmVtXCJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgcm90YXRlKCR7cm90YXRlRGVncmVlc30gJHtjeH0gJHtjeX0pYH1cbiAgICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgIG9wYWNpdHk9ezAuNzV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtpICogYmFzZXNQZXJUaWNrfVxuICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICAgICk7XG4gICAgICB9KX1cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyB1c2VDaXJjdWxhclNlbGVjdGlvblJlY3QgfSBmcm9tIFwiQEFyaWFkbmUvaG9va3MvdXNlU2VsZWN0aW9uXCI7XG5pbXBvcnQge1xuICBBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgQW5ub3RhdGlvbixcbiAgQXJpYWRuZVNlbGVjdGlvbixcbn0gZnJvbSBcIkBBcmlhZG5lL3R5cGVzXCI7XG5pbXBvcnQge1xuICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSxcbiAgZ2V0U3RhY2tlZEFubm90YXRpb25zLFxuICBnZXRTdWJzZXF1ZW5jZUxlbmd0aCxcbn0gZnJvbSBcIkBBcmlhZG5lL3V0aWxzXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVzIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0YWNrQW5uc0J5VHlwZSB9IGZyb20gXCIuLlwiO1xuaW1wb3J0IHsgQ2lyY3VsYXJBbm5vdGF0aW9uR3V0dGVyIH0gZnJvbSBcIi4vQ2lyY3VsYXJBbm5vdGF0aW9uc1wiO1xuaW1wb3J0IHsgQ2lyY3VsYXJJbmRleCB9IGZyb20gXCIuL0NpcmN1bGFySW5kZXhcIjtcbmltcG9ydCB7IGNsYW1wU2xpY2UsIGZpbmRJbmRleEZyb21BbmdsZSwgZ2VuQXJjIH0gZnJvbSBcIi4vY2lyY3VsYXJVdGlsc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgc2VxdWVuY2U6IHN0cmluZztcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiB2b2lkO1xuICBjb250YWluZXJDbGFzc05hbWU/OiBzdHJpbmc7XG4gIHN2Z1NpemVQWD86IG51bWJlcjtcbiAgc3ZnUGFkZGluZz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IENpcmN1bGFyVmlld2VyID0gKHtcbiAgc2VxdWVuY2UsXG4gIGFubm90YXRpb25zLFxuICBzZWxlY3Rpb24sXG4gIHNldFNlbGVjdGlvbixcbiAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICBzdmdTaXplUFggPSAzMDAsXG4gIHN2Z1BhZGRpbmcgPSAyMCxcbn06IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY3gsIGN5LCBzaXplWCwgc2l6ZVksIHJhZGl1cyB9ID0ge1xuICAgIGN4OiBzdmdTaXplUFggLyAyLFxuICAgIGN5OiBzdmdTaXplUFggLyAyLFxuICAgIHNpemVYOiBzdmdTaXplUFgsXG4gICAgc2l6ZVk6IHN2Z1NpemVQWCxcbiAgICByYWRpdXM6IChzdmdTaXplUFggLSBzdmdQYWRkaW5nKSAvIDIsXG4gIH07XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHN0YWNrQW5uc0J5VHlwZShhbm5vdGF0aW9ucyk7XG4gIGNvbnN0IGFubm90YXRlZFNlcXVlbmNlID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgcmV0dXJuIGdldEFubm90YXRlZFNlcXVlbmNlKHtcbiAgICAgICAgc2VxdWVuY2UsXG4gICAgICAgIHN0YWNrZWRBbm5vdGF0aW9uczogZ2V0U3RhY2tlZEFubm90YXRpb25zKGFubm90YXRpb25zKSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3NlcXVlbmNlLCBhbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgaWYgKGFubm90YXRlZFNlcXVlbmNlICYmIHNlbGVjdGlvbiAmJiBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlyc3RJZHggPVxuICAgICAgYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoID4gMCA/IGFubm90YXRlZFNlcXVlbmNlLmF0KDApIS5pbmRleCA6IDA7XG4gICAgY29uc3QgbGFzdElkeCA9XG4gICAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGggPiAwID8gYW5ub3RhdGVkU2VxdWVuY2UuYXQoLTEpIS5pbmRleCA6IDA7XG4gICAgc2VsZWN0aW9uID0gY2xhbXBTbGljZSh7IHNsaWNlOiBzZWxlY3Rpb24sIGZpcnN0SWR4LCBsYXN0SWR4IH0pO1xuICB9XG4gIGNvbnN0IHNlbGVjdGlvblJlZiA9IHVzZVJlZjxTVkdTVkdFbGVtZW50PihudWxsKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgXCJmbGV4IHNlbGVjdC1ub25lIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmb250LXRoaW5cIixcbiAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICA+XG4gICAgICA8c3ZnXG4gICAgICAgIHJlZj17c2VsZWN0aW9uUmVmfVxuICAgICAgICB2aWV3Qm94PXtgMCAwICR7c2l6ZVh9ICR7c2l6ZVl9YH1cbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIGZvbnRGYW1pbHk9XCJpbmhlcml0XCJcbiAgICAgICAgZm9udFNpemU9XCJpbmhlcml0XCJcbiAgICAgICAgZm9udFdlaWdodD1cImluaGVyaXRcIlxuICAgICAgICBjbGFzc05hbWU9e2BzdHJva2UtY3VycmVudGB9XG4gICAgICAgIHdpZHRoPXtzaXplWH1cbiAgICAgICAgaGVpZ2h0PXtzaXplWX1cbiAgICAgID5cbiAgICAgICAgPENpcmN1bGFySW5kZXhcbiAgICAgICAgICBjeD17Y3h9XG4gICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgIHJhZGl1cz17cmFkaXVzfVxuICAgICAgICAgIGFubm90YXRlZFNlcXVlbmNlPXthbm5vdGF0ZWRTZXF1ZW5jZX1cbiAgICAgICAgICB0aWNrcz17NH1cbiAgICAgICAgLz5cbiAgICAgICAgPENpcmN1bGFyQW5ub3RhdGlvbkd1dHRlclxuICAgICAgICAgIGFubm90YXRlZFNlcXVlbmNlPXthbm5vdGF0ZWRTZXF1ZW5jZX1cbiAgICAgICAgICBzdGFja2VkQW5ub3RhdGlvbnM9e3N0YWNrZWRBbm5vdGF0aW9uc31cbiAgICAgICAgICBjeD17Y3h9XG4gICAgICAgICAgY3k9e2N5fVxuICAgICAgICAgIHJhZGl1cz17cmFkaXVzfVxuICAgICAgICAvPlxuICAgICAgICA8Q2lyY3VsYXJTZWxlY3Rpb25cbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZT17YW5ub3RhdGVkU2VxdWVuY2V9XG4gICAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgY3g9e2N4fVxuICAgICAgICAgIGN5PXtjeX1cbiAgICAgICAgICByYWRpdXM9e3JhZGl1c31cbiAgICAgICAgICBzZWxlY3Rpb25SZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgICBzZXRTZWxlY3Rpb249e3NldFNlbGVjdGlvbn1cbiAgICAgICAgLz5cblxuICAgICAgICA8dGV4dFxuICAgICAgICAgIHg9e2N4fVxuICAgICAgICAgIHk9e2N5fVxuICAgICAgICAgIHRleHRBbmNob3I9XCJtaWRkbGVcIlxuICAgICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgYWxpZ25tZW50QmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgICAgIGZvbnRTaXplPXtcIjFyZW1cIn1cbiAgICAgICAgPlxuICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGh9IGJwXG4gICAgICAgIDwvdGV4dD5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuY29uc3QgQ2lyY3VsYXJTZWxlY3Rpb24gPSAoe1xuICByYWRpdXMsXG4gIGN4LFxuICBjeSxcbiAgc2VsZWN0aW9uLFxuICBzZWxlY3Rpb25SZWYsXG4gIHNldFNlbGVjdGlvbixcbiAgYW5ub3RhdGVkU2VxdWVuY2UsXG59OiB7XG4gIHJhZGl1czogbnVtYmVyO1xuXG4gIGN4OiBudW1iZXI7XG4gIGN5OiBudW1iZXI7XG4gIHNlbGVjdGlvblJlZjogUmVhY3QuUmVmT2JqZWN0PFNWR1NWR0VsZW1lbnQ+O1xuICBzZXRTZWxlY3Rpb246IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24pID0+IHZvaWQ7XG4gIHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbiB8IG51bGw7XG4gIGFubm90YXRlZFNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbn0pID0+IHtcbiAgLyogQ29sbGVjdCBpbnRlcm5hbCBzZWxlY3Rpb24gZGF0YSBhbmQgcHJvcG9nYXRlIHVwICovXG4gIGNvbnN0IHtcbiAgICBzdGFydDogaW50ZXJuYWxTZWxlY3Rpb25TdGFydCxcbiAgICBlbmQ6IGludGVybmFsU2VsZWN0aW9uRW5kLFxuICAgIGRpcmVjdGlvbjogaW50ZXJuYWxEaXJlY3Rpb24sXG4gIH0gPSB1c2VDaXJjdWxhclNlbGVjdGlvblJlY3Qoc2VsZWN0aW9uUmVmKTtcbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVNlbGVjdGlvblVwKCkge1xuICAgICAgaWYgKFxuICAgICAgICBzZWxlY3Rpb25SZWYuY3VycmVudCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0ICYmXG4gICAgICAgIGludGVybmFsU2VsZWN0aW9uRW5kICYmXG4gICAgICAgIGludGVybmFsRGlyZWN0aW9uXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kSW5kZXhGcm9tQW5nbGUoe1xuICAgICAgICAgIGFuZ2xlOiBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIHNlcUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5kID0gZmluZEluZGV4RnJvbUFuZ2xlKHtcbiAgICAgICAgICBhbmdsZTogaW50ZXJuYWxTZWxlY3Rpb25FbmQsXG4gICAgICAgICAgc2VxTGVuZ3RoOiBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPVxuICAgICAgICAgIGludGVybmFsRGlyZWN0aW9uID09PSBcImNsb2Nrd2lzZVwiID8gXCJmb3J3YXJkXCIgOiBcInJldmVyc2VcIjtcblxuICAgICAgICBjb25zdCBwcmV2TGVuZ3RoID0gc2VsZWN0aW9uXG4gICAgICAgICAgPyBNYXRoLmFicyhzZWxlY3Rpb24uZW5kIC0gc2VsZWN0aW9uLnN0YXJ0KVxuICAgICAgICAgIDogMDtcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gZ2V0U3Vic2VxdWVuY2VMZW5ndGgoXG4gICAgICAgICAgeyBzdGFydCwgZW5kLCBkaXJlY3Rpb24gfSxcbiAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGRlbHRhTGVuZ3RoID0gTWF0aC5hYnMocHJldkxlbmd0aCAtIG5ld0xlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRlbHRhVGhyZXNob2xkID0gTWF0aC5tYXgoMC43ICogYW5ub3RhdGVkU2VxdWVuY2UubGVuZ3RoLCAxMCk7XG4gICAgICAgIGlmIChkZWx0YUxlbmd0aCA+IGRlbHRhVGhyZXNob2xkICYmIHNlbGVjdGlvbikge1xuICAgICAgICAgIC8vIHByZXNlcnZlIGluaXRpYWwgZGlyZWN0aW9uXG4gICAgICAgICAgc2V0U2VsZWN0aW9uKHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBzZWxlY3Rpb24/LmRpcmVjdGlvbixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2ludGVybmFsU2VsZWN0aW9uU3RhcnQsIGludGVybmFsU2VsZWN0aW9uRW5kXSxcbiAgKTtcblxuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiBEaXNwbGF5IHNlbGVjdGlvbiBkYXRhIHRoYXQgaGFzIHRyaWNrbGVkIGRvd24gKi9cbiAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBzZWxlY3Rpb247XG4gIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjZW50ZXIgPSB7IHg6IGN4LCB5OiBjeSB9O1xuICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cztcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSByYWRpdXMgKyAxMDtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0U3Vic2VxdWVuY2VMZW5ndGgoc2VsZWN0aW9uLCBhbm5vdGF0ZWRTZXF1ZW5jZS5sZW5ndGgpO1xuXG4gIGNvbnN0IFtzdGFydElkeCwgZW5kSWR4XSA9IFtcbiAgICBhbm5vdGF0ZWRTZXF1ZW5jZS5hdCgwKT8uaW5kZXgsXG4gICAgYW5ub3RhdGVkU2VxdWVuY2UuYXQoLTEpPy5pbmRleCxcbiAgXTtcbiAgaWYgKHN0YXJ0SWR4ID09PSB1bmRlZmluZWQgfHwgZW5kSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ2lyY3VsYXJWaWV3ZXI6IHNlcXVlbmNlIGhhcyBubyBpbmRpY2VzXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG9mZnNldCA9IHN0YXJ0IC0gc3RhcnRJZHg7XG4gIGNvbnN0IHNlcUxlbmd0aCA9IGFubm90YXRlZFNlcXVlbmNlLmxlbmd0aDtcblxuICBjb25zdCBhcmMgPSBnZW5BcmMoe1xuICAgIGNlbnRlcixcbiAgICBpbm5lclJhZGl1cyxcbiAgICBsYXJnZUFyYzogbGVuZ3RoID4gc2VxTGVuZ3RoIC8gMixcbiAgICBsZW5ndGgsXG4gICAgb2Zmc2V0LFxuICAgIG91dGVyUmFkaXVzLFxuICAgIHNlcUxlbmd0aCxcbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPGc+XG4gICAgICA8cGF0aFxuICAgICAgICBkPXthcmN9XG4gICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgLz5cbiAgICA8L2c+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgZ2V0U3Vic2VxdWVuY2VMZW5ndGggfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQW5ub3RhdGVkU2VxdWVuY2UsIEFubm90YXRpb24sIFN0YWNrZWRBbm5vdGF0aW9uIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZWFyQW5ub3RhdGlvbkd1dHRlclByb3BzIHtcbiAgc3RhY2tlZEFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIGNvbnRhaW5lckNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IExpbmVhckFubm90YXRpb25HdXR0ZXIgPSAoe1xuICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIHNlcXVlbmNlLFxuICBjb250YWluZXJDbGFzc05hbWUsXG59OiBMaW5lYXJBbm5vdGF0aW9uR3V0dGVyUHJvcHMpID0+IHtcbiAgY29uc3Qgc3RhY2tzOiBTdGFja2VkQW5ub3RhdGlvbltdW10gPSBbXTtcbiAgc3RhY2tlZEFubm90YXRpb25zLmZvckVhY2goKGFubikgPT4ge1xuICAgIHN0YWNrc1thbm4uc3RhY2tdID0gc3RhY2tzW2Fubi5zdGFja10gfHwgW107XG4gICAgc3RhY2tzW2Fubi5zdGFja10ucHVzaChhbm4pO1xuICB9KTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgIFwiZ3JpZC1yb3dzLWF1dG8gYmxvY2sgZ3JpZCBncmlkLWNvbHMtMSBnYXAtMVwiLFxuICAgICAgICBjb250YWluZXJDbGFzc05hbWUsXG4gICAgICApfVxuICAgID5cbiAgICAgIHtzdGFja3MubWFwKChhbm5vdGF0aW9ucywgc3RhY2tJZHgpID0+IChcbiAgICAgICAgPGRpdiBrZXk9e2Bhbm5vdGF0aW9uLXN0YWNrLSR7c3RhY2tJZHh9YH0gY2xhc3NOYW1lPVwicmVsYXRpdmUgaC04XCI+XG4gICAgICAgICAge2Fubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKFxuICAgICAgICAgICAgPExpbmVhckFubm90YXRpb25cbiAgICAgICAgICAgICAga2V5PXtgYW5ub3RhdGlvbi0ke2Fubm90YXRpb24udGV4dH0tJHthbm5vdGF0aW9uLnN0YXJ0fS0ke2Fubm90YXRpb24uZW5kfS0ke2Fubm90YXRpb24uZGlyZWN0aW9ufWB9XG4gICAgICAgICAgICAgIGFubm90YXRpb249e2Fubm90YXRpb259XG4gICAgICAgICAgICAgIHNlcXVlbmNlPXtzZXF1ZW5jZX1cbiAgICAgICAgICAgICAgc3RhY2tJZHg9e3N0YWNrSWR4fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5jb25zdCBMaW5lYXJBbm5vdGF0aW9uID0gKHtcbiAgYW5ub3RhdGlvbixcbiAgc2VxdWVuY2UsXG4gIHN0YWNrSWR4LFxufToge1xuICBhbm5vdGF0aW9uOiBBbm5vdGF0aW9uO1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIHN0YWNrSWR4OiBudW1iZXI7XG59KSA9PiB7XG4gIC8qIGlmIHRoZSBhbm5vdGF0aW9uIHNwYW5zIHRoZSBzZWFtLCB3ZSBkcmF3IHR3byBsaW5lcyBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gZW5kLCBhbmQgZnJvbSBzdGFydCB0byBlbmQgKi9cblxuICBjb25zdCBhbm5vdGF0aW9uU3BhbnNTZWFtID0gYW5ub3RhdGlvbi5zdGFydCA+IGFubm90YXRpb24uZW5kO1xuICBpZiAoYW5ub3RhdGlvblNwYW5zU2VhbSkge1xuICAgIHJldHVybiAoXG4gICAgICA8RnJhZ21lbnQ+XG4gICAgICAgIDxMaW5lYXJBbm5vdGF0aW9uXG4gICAgICAgICAgYW5ub3RhdGlvbj17e1xuICAgICAgICAgICAgLi4uYW5ub3RhdGlvbixcbiAgICAgICAgICAgIGVuZDogc2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICBhbm5vdGF0aW9uLm9uQ2xpY2s/Lih7IC4uLmFubm90YXRpb24gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgICAgc2VxdWVuY2U9e3NlcXVlbmNlfVxuICAgICAgICAgIHN0YWNrSWR4PXtzdGFja0lkeH1cbiAgICAgICAgLz5cbiAgICAgICAgPExpbmVhckFubm90YXRpb25cbiAgICAgICAgICBhbm5vdGF0aW9uPXt7XG4gICAgICAgICAgICAuLi5hbm5vdGF0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGFubm90YXRpb24ub25DbGljaz8uKHsgLi4uYW5ub3RhdGlvbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgICBzZXF1ZW5jZT17c2VxdWVuY2V9XG4gICAgICAgICAgc3RhY2tJZHg9e3N0YWNrSWR4fVxuICAgICAgICAvPlxuICAgICAgPC9GcmFnbWVudD5cbiAgICApO1xuICB9XG5cbiAgY29uc3QgYW5ub3RhdGlvblJlY3RhbmdsZVdpZHRoUGVyYyA9XG4gICAgKGdldFN1YnNlcXVlbmNlTGVuZ3RoKGFubm90YXRpb24sIHNlcXVlbmNlLmxlbmd0aCkgLyBzZXF1ZW5jZS5sZW5ndGgpICogMTAwO1xuXG4gIGNvbnN0IHhQZXJjID1cbiAgICAoTWF0aC5taW4oYW5ub3RhdGlvbi5zdGFydCwgYW5ub3RhdGlvbi5lbmQpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgLy8gY2xpcCBwYXRoIHRvIGNyZWF0ZSByZWN0YW5nbGUgd2l0aCBhIHBvaW50IGF0IG9uZSBlbmRcbiAgY29uc3QgZm9yd2FyZENsaXBQYXRoID0gXCJwb2x5Z29uKDAgMCwgOTAlIDAsIDEwMCUgNTAlLCA5MCUgMTAwJSwgMCAxMDAlKVwiO1xuICBjb25zdCByZXZlcnNlQ2xpcFBhdGggPSBcInBvbHlnb24oMCA1MCUsIDEwJSAwLCAxMDAlIDAsIDEwMCUgMTAwJSwgMTAlIDEwMCUpXCI7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPVwiZ3JvdXAgYWJzb2x1dGVcIlxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgbWFyZ2luTGVmdDogYCR7eFBlcmN9JWAsXG4gICAgICAgIHdpZHRoOiBgJHthbm5vdGF0aW9uUmVjdGFuZ2xlV2lkdGhQZXJjfSVgLFxuICAgICAgfX1cbiAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgYW5ub3RhdGlvbi5vbkNsaWNrPy4oYW5ub3RhdGlvbik7XG4gICAgICB9fVxuICAgID5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgIFwicHgtMlwiLFxuICAgICAgICAgIGFubm90YXRpb24uZGlyZWN0aW9uID09PSBcImZvcndhcmRcIiA/IFwidGV4dC1sZWZ0XCIgOiBcInRleHQtcmlnaHRcIixcbiAgICAgICAgICBhbm5vdGF0aW9uLmNsYXNzTmFtZSxcbiAgICAgICAgKX1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBjbGlwUGF0aDpcbiAgICAgICAgICAgIGFubm90YXRpb24uZGlyZWN0aW9uID09PSBcImZvcndhcmRcIlxuICAgICAgICAgICAgICA/IGZvcndhcmRDbGlwUGF0aFxuICAgICAgICAgICAgICA6IHJldmVyc2VDbGlwUGF0aCxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2Fubm90YXRpb24udGV4dH1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgXCJhYnNvbHV0ZSBsZWZ0LTEvMiB6LTEwIGhpZGRlbiAtdHJhbnNsYXRlLXgtMS8yIHRyYW5zbGF0ZS15LTQgZmxleC1jb2wgcm91bmRlZC1tZCBweC0yIHB5LTEgdGV4dC1zbSBncm91cC1ob3ZlcjpmbGV4XCIsXG4gICAgICAgICAgYW5ub3RhdGlvbi5jbGFzc05hbWUsXG4gICAgICAgICl9XG4gICAgICA+XG4gICAgICAgIDxzcGFuPnthbm5vdGF0aW9uLnRleHR9PC9zcGFuPlxuICAgICAgICA8c3Bhbj57YW5ub3RhdGlvbi50eXBlfTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCB7IHVzZUxpbmVhclNlbGVjdGlvblJlY3QgfSBmcm9tIFwiQEFyaWFkbmUvaG9va3MvdXNlU2VsZWN0aW9uXCI7XG5pbXBvcnQgeyBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSwgZ2V0U3Vic2VxdWVuY2VMZW5ndGggfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQW5ub3RhdGVkU2VxdWVuY2UsXG4gIEFyaWFkbmVTZWxlY3Rpb24sXG4gIEFubm90YXRpb24sXG4gIEFubm90YXRlZEJhc2UsXG4gIFN0YWNrZWRBbm5vdGF0aW9uLFxufSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IHN0YWNrQW5ub3RhdGlvbnNOb092ZXJsYXAgfSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IExpbmVhckFubm90YXRpb25HdXR0ZXIgfSBmcm9tIFwiLi9MaW5lYXJBbm5vdGF0aW9uR3V0dGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICBzZXF1ZW5jZXM6IHN0cmluZ1tdO1xuICBhbm5vdGF0aW9uczogQW5ub3RhdGlvbltdO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBzZXRTZWxlY3Rpb246IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsKSA9PiB2b2lkO1xuICBvbkRvdWJsZUNsaWNrPzogKCkgPT4gdm9pZDtcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lPzogKHNlbGVjdGlvbjogQXJpYWRuZVNlbGVjdGlvbikgPT4gc3RyaW5nO1xuICBjb250YWluZXJDbGFzc05hbWU/OiBzdHJpbmc7XG4gIHNlcXVlbmNlQ2xhc3NOYW1lOiAoeyBzZXF1ZW5jZUlkeCB9OiB7IHNlcXVlbmNlSWR4OiBudW1iZXIgfSkgPT4gc3RyaW5nO1xuICBtaXNtYXRjaENsYXNzTmFtZT86IChtaXNtYXRjaGVkQmFzZTogQW5ub3RhdGVkQmFzZSkgPT4gc3RyaW5nO1xuICBzdGFja2luZ0ZuPzogKGFubm90YXRpb25zOiBBbm5vdGF0aW9uW10pID0+IFN0YWNrZWRBbm5vdGF0aW9uW107XG59XG5cbmNvbnN0IE1JU01BVENIX0RJU1RfUEVSQ19USFJFU0hPTEQgPSAwLjAxO1xuXG5leHBvcnQgY29uc3QgTGluZWFyVmlld2VyID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgc2VxdWVuY2VzLFxuICAgIHNlbGVjdGlvbixcbiAgICBhbm5vdGF0aW9ucyxcbiAgICBzZXRTZWxlY3Rpb24sXG4gICAgb25Eb3VibGVDbGljayxcbiAgICBzZWxlY3Rpb25DbGFzc05hbWUsXG4gICAgbWlzbWF0Y2hDbGFzc05hbWUsXG4gICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIHNlcXVlbmNlQ2xhc3NOYW1lLFxuICAgIHN0YWNraW5nRm4sXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBzdGFja2VkQW5ub3RhdGlvbnMgPSB1c2VNZW1vKFxuICAgIGZ1bmN0aW9uIG1lbW9pemUoKSB7XG4gICAgICAvLyBpZiBhIHN0YWNraW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB1c2UgaXQsIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHQgd2hpY2hcbiAgICAgIC8vIHN0YWNrcyBhbm5vdGF0aW9ucyB0byBwcmV2ZW50IG92ZXJsYXAuXG4gICAgICByZXR1cm4gc3RhY2tpbmdGblxuICAgICAgICA/IHN0YWNraW5nRm4oYW5ub3RhdGlvbnMpXG4gICAgICAgIDogc3RhY2tBbm5vdGF0aW9uc05vT3ZlcmxhcChcbiAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgTWF0aC5tYXgoLi4uc2VxdWVuY2VzLm1hcCgoc2VxKSA9PiBzZXEubGVuZ3RoKSksXG4gICAgICAgICAgKTtcbiAgICB9LFxuICAgIFthbm5vdGF0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2VzID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlcy5tYXAoKHNlcXVlbmNlKSA9PlxuICAgICAgICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSh7IHNlcXVlbmNlLCBzdGFja2VkQW5ub3RhdGlvbnMgfSksXG4gICAgICApO1xuICAgIH0sXG4gICAgW3NlcXVlbmNlcywgc3RhY2tlZEFubm90YXRpb25zXSxcbiAgKTtcblxuICBjb25zdCBiYXNlU2VxdWVuY2UgPSBhbm5vdGF0ZWRTZXF1ZW5jZXNbMF07XG4gIGNvbnN0IHNlbGVjdGlvblJlZiA9IHVzZVJlZjxTVkdTVkdFbGVtZW50PihudWxsKTtcblxuICAvLyBjb25zdCBudW1iZXJPZlRpY2tzID0gNTtcbiAgLy8gY29uc3QgYmFzZXNQZXJUaWNrID0gTWF0aC5mbG9vcihzZXF1ZW5jZS5sZW5ndGggLyBudW1iZXJPZlRpY2tzKTtcblxuICBjb25zdCBTVkdfV0lEVEggPSA1MDA7XG4gIGNvbnN0IFNWR19IRUlHSFQgPSBzZXF1ZW5jZXMubGVuZ3RoICogMTAgKyAxMDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjb250YWluZXJDbGFzc05hbWUgfHwgXCJcIn0+XG4gICAgICA8c3ZnXG4gICAgICAgIHJlZj17c2VsZWN0aW9uUmVmfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJzZWxlY3Qtbm9uZSBmb250LXRoaW5cIil9XG4gICAgICAgIG9uRG91YmxlQ2xpY2s9e29uRG91YmxlQ2xpY2t9XG4gICAgICAgIHZpZXdCb3g9e2AwIDAgJHtTVkdfV0lEVEh9ICR7U1ZHX0hFSUdIVH1gfVxuICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICA+XG4gICAgICAgIDxnPlxuICAgICAgICAgIHthbm5vdGF0ZWRTZXF1ZW5jZXMubWFwKChzZXF1ZW5jZSwgaSkgPT4gKFxuICAgICAgICAgICAgPGcga2V5PXtgU2VxdWVuY2UtJHtpfWB9PlxuICAgICAgICAgICAgICA8U2VxdWVuY2VMaW5lXG4gICAgICAgICAgICAgICAgc2VxdWVuY2VDbGFzc05hbWU9e3NlcXVlbmNlQ2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIGJhc2VTZXF1ZW5jZT17c2VxdWVuY2V9XG4gICAgICAgICAgICAgICAgYWxpZ25lZFNlcXVlbmNlcz17YW5ub3RhdGVkU2VxdWVuY2VzLmZpbHRlcigoXywgaikgPT4gaiAhPT0gaSl9XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VJZHg9e2l9XG4gICAgICAgICAgICAgICAgbWlzbWF0Y2hDbGFzc05hbWU9e21pc21hdGNoQ2xhc3NOYW1lfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2c+XG4gICAgICAgIDxMaW5lYXJTZWxlY3Rpb25cbiAgICAgICAgICBzZWxlY3Rpb25DbGFzc05hbWU9e3NlbGVjdGlvbkNsYXNzTmFtZX1cbiAgICAgICAgICBzZWxlY3Rpb25SZWY9e3NlbGVjdGlvblJlZn1cbiAgICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgICAgICBzZXRTZWxlY3Rpb249e3NldFNlbGVjdGlvbn1cbiAgICAgICAgICBzZXF1ZW5jZT17YmFzZVNlcXVlbmNlfVxuICAgICAgICAvPlxuICAgICAgPC9zdmc+XG4gICAgICB7c3RhY2tlZEFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8TGluZWFyQW5ub3RhdGlvbkd1dHRlclxuICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZT1cIlwiXG4gICAgICAgICAgc3RhY2tlZEFubm90YXRpb25zPXtzdGFja2VkQW5ub3RhdGlvbnN9XG4gICAgICAgICAgc2VxdWVuY2U9e2Jhc2VTZXF1ZW5jZX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5pbnRlcmZhY2UgU2VxdWVuY2VMaW5lUHJvcHMge1xuICBiYXNlU2VxdWVuY2U6IEFubm90YXRlZFNlcXVlbmNlO1xuICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICBhbGlnbmVkU2VxdWVuY2VzOiBBbm5vdGF0ZWRTZXF1ZW5jZVtdO1xuICBzZXF1ZW5jZUNsYXNzTmFtZTogKHsgc2VxdWVuY2VJZHggfTogeyBzZXF1ZW5jZUlkeDogbnVtYmVyIH0pID0+IHN0cmluZztcbiAgbWlzbWF0Y2hDbGFzc05hbWU/OiAobWlzbWF0Y2hlZEJhc2U6IEFubm90YXRlZEJhc2UpID0+IHN0cmluZztcbn1cblxuY29uc3QgU2VxdWVuY2VMaW5lID0gKHtcbiAgYmFzZVNlcXVlbmNlLFxuICBzZXF1ZW5jZUlkeCxcbiAgYWxpZ25lZFNlcXVlbmNlcyxcbiAgc2VxdWVuY2VDbGFzc05hbWUsXG4gIG1pc21hdGNoQ2xhc3NOYW1lLFxufTogU2VxdWVuY2VMaW5lUHJvcHMpID0+IHtcbiAgY29uc3Qgc3RhcnQgPSBiYXNlU2VxdWVuY2VbMF0/LmluZGV4O1xuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2VxdWVuY2UgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBiYXNlICR7YmFzZVNlcXVlbmNlfWApO1xuICB9XG4gIGNvbnN0IGVuZCA9IGJhc2VTZXF1ZW5jZVtiYXNlU2VxdWVuY2UubGVuZ3RoIC0gMV0/LmluZGV4O1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcXVlbmNlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYmFzZSAke2Jhc2VTZXF1ZW5jZX1gKTtcbiAgfVxuXG4gIGxldCBtYXhFbmQgPSBlbmQ7XG4gIGFsaWduZWRTZXF1ZW5jZXMuZm9yRWFjaCgoYWxpZ25lZFNlcXVlbmNlKSA9PiB7XG4gICAgY29uc3Qgb3RoZXJFbmQgPSBhbGlnbmVkU2VxdWVuY2UuYXQoYWxpZ25lZFNlcXVlbmNlLmxlbmd0aCAtIDEpPy5pbmRleDtcbiAgICBpZiAob3RoZXJFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgb3RoZXJTZXF1ZW5jZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGJhc2UgJHthbGlnbmVkU2VxdWVuY2V9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyRW5kID4gbWF4RW5kKSB7XG4gICAgICBtYXhFbmQgPSBvdGhlckVuZDtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzdGFydFBlcmMgPSBzdGFydCAvIG1heEVuZDtcbiAgY29uc3QgZW5kUGVyYyA9IGVuZCAvIG1heEVuZDtcblxuICAvLyBtaXNtYXRjaGVzXG4gIGNvbnN0IG1pc21hdGNoZXMgPSBiYXNlU2VxdWVuY2UuZmlsdGVyKChiYXNlKSA9PiB7XG4gICAgY29uc3Qgcm9vdEJhc2UgPSBiYXNlU2VxdWVuY2UuYXQoYmFzZS5pbmRleCk7XG4gICAgcmV0dXJuIHJvb3RCYXNlICYmIHJvb3RCYXNlLmJhc2UgIT09IGJhc2UuYmFzZTtcbiAgfSk7XG4gIG1pc21hdGNoQ2xhc3NOYW1lID1cbiAgICBtaXNtYXRjaENsYXNzTmFtZSA/P1xuICAgIGZ1bmN0aW9uIG1pc21hdGNoQ2xhc3NOYW1lKG1pc21hdGNoOiBBbm5vdGF0ZWRCYXNlKSB7XG4gICAgICBpZiAobWlzbWF0Y2guYmFzZSA9PT0gXCItXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsbC1ibGFjayBzdHJva2UtYmxhY2sgb3BhY2l0eS04MFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiZGFyazpmaWxsLXJlZC02MDAgZGFyazpzdHJva2UtcmVkLTYwMCBmaWxsLXJlZC03MDAgc3Ryb2tlLXJlZC03MDBcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gIGxldCBsYXN0WFBlcmMgPSAtMTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGxpbmVcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwiXCIsIHNlcXVlbmNlQ2xhc3NOYW1lKHsgc2VxdWVuY2VJZHggfSkpfVxuICAgICAgICB4MT17YCR7c3RhcnRQZXJjICogMTAwfSVgfVxuICAgICAgICB5MT17YCR7c2VxdWVuY2VJZHggKiAxMCArIDEwfWB9XG4gICAgICAgIHgyPXtgJHtlbmRQZXJjICogMTAwfSVgfVxuICAgICAgICB5Mj17YCR7c2VxdWVuY2VJZHggKiAxMCArIDEwfWB9XG4gICAgICAgIHN0cm9rZVdpZHRoPXs1fVxuICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICAgIHttaXNtYXRjaGVzLm1hcCgoYmFzZSkgPT4ge1xuICAgICAgICBjb25zdCB4UGVyYyA9IChiYXNlLmluZGV4IC8gbWF4RW5kKSAqIDEwMDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgoMSAvIGJhc2VTZXF1ZW5jZS5sZW5ndGgpICogMTAwLCAwLjAxKTtcbiAgICAgICAgY29uc3QgZGlmZiA9IHhQZXJjIC0gbGFzdFhQZXJjO1xuICAgICAgICBpZiAoZGlmZiA8IE1JU01BVENIX0RJU1RfUEVSQ19USFJFU0hPTEQpIHtcbiAgICAgICAgICAvLyBEaXNwbGF5aW5nIGV2ZXJ5IG1pc21hdGNoIGlzIG5vdCBwYXJ0aWN1bGFybHkgaGVscGZ1bCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBzZWUgdGhlbS4gSGVyZSB3ZSBjaG9vc2UgYSByZWFzb25hYmxlXG4gICAgICAgICAgLy8gdGhyZXNob2xkIGFuZCBvbmx5IGRpc3BsYXkgZWxlbWVudHMgdGhhdCBhcmUgc3VmZmljaWVudGx5IGZhciBhcGFydC5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WFBlcmMgPSB4UGVyYztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8Z1xuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKG1pc21hdGNoQ2xhc3NOYW1lPy4oYmFzZSkgfHwgXCJiZy1yZWQtNDAwXCIpfVxuICAgICAgICAgICAga2V5PXtgc2VxdWVuY2UtJHtzZXF1ZW5jZUlkeH0tbWlzbWF0Y2gtJHtiYXNlLmluZGV4fWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgeDE9e2Ake3hQZXJjIC0gd2lkdGggLyAyfSVgfVxuICAgICAgICAgICAgICB5MT17YCR7c2VxdWVuY2VJZHggKiAxMCArIDEwfWB9XG4gICAgICAgICAgICAgIHgyPXtgJHt4UGVyYyArIHdpZHRoIC8gMn0lYH1cbiAgICAgICAgICAgICAgeTI9e2Ake3NlcXVlbmNlSWR4ICogMTAgKyAxMH1gfVxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17NX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5jb25zdCBMaW5lYXJTZWxlY3Rpb24gPSAoe1xuICBzZWxlY3Rpb24sXG4gIHNlbGVjdGlvblJlZixcbiAgc2V0U2VsZWN0aW9uLFxuICBzZXF1ZW5jZSxcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxufToge1xuICBzZWxlY3Rpb25SZWY6IFJlYWN0LlJlZk9iamVjdDxTVkdTVkdFbGVtZW50PjtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uKSA9PiB2b2lkO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBzZXF1ZW5jZTogQW5ub3RhdGVkU2VxdWVuY2U7XG4gIHNlbGVjdGlvbkNsYXNzTmFtZT86IChzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24pID0+IHN0cmluZztcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0OiBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0LFxuICAgIGVuZDogaW50ZXJuYWxTZWxlY3Rpb25FbmQsXG4gICAgZGlyZWN0aW9uOiBpbnRlcm5hbERpcmVjdGlvbixcbiAgfSA9IHVzZUxpbmVhclNlbGVjdGlvblJlY3QoeyByZWY6IHNlbGVjdGlvblJlZiB9KTtcbiAgdXNlRWZmZWN0KFxuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZVNlbGVjdGlvblVwKCkge1xuICAgICAgaWYgKFxuICAgICAgICBzZWxlY3Rpb25SZWYuY3VycmVudCAmJlxuICAgICAgICBpbnRlcm5hbFNlbGVjdGlvblN0YXJ0ICYmXG4gICAgICAgIGludGVybmFsU2VsZWN0aW9uRW5kXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3ZnV2lkdGggPSBzZWxlY3Rpb25SZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAoaW50ZXJuYWxTZWxlY3Rpb25TdGFydC54IC8gc3ZnV2lkdGgpICogc2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLmZsb29yKFxuICAgICAgICAgIChpbnRlcm5hbFNlbGVjdGlvbkVuZC54IC8gc3ZnV2lkdGgpICogc2VxdWVuY2UubGVuZ3RoLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNob3cgYSB2ZXJ5IHNtYWxsIGZpcnN0IHNlbGVjdGlvbiByZXN1bHQgYXMgc3RhcnQgPT09IGVuZCBiZWNhdXNlIHRoZSB1c2VyIHByb2JhYmx5IGRvZXNuJ3Qgd2FudCB0aGUgZW50aXJlIHNlcXVlbmNlIHRvIGJlIGhpZ2hsaWdodGVkIGV2ZXJ5IHRpbWUgdGhleSBjbGlja1xuICAgICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwgfHwgc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQgKyAxLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBpbnRlcm5hbERpcmVjdGlvbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0U2VsZWN0aW9uKHsgc3RhcnQsIGVuZCwgZGlyZWN0aW9uOiBpbnRlcm5hbERpcmVjdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2ludGVybmFsU2VsZWN0aW9uU3RhcnQsIGludGVybmFsU2VsZWN0aW9uRW5kXSxcbiAgKTtcblxuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyogRGlzcGxheSBzZWxlY3Rpb24gZGF0YSB0aGF0IGhhcyB0cmlja2xlZCBkb3duICovXG4gIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VsZWN0aW9uO1xuXG4gIC8vIGJhc2ljIGNhc2VcbiAgbGV0IGZpcnN0UmVjdFN0YXJ0ID0gKE1hdGgubWluKHN0YXJ0LCBlbmQpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgbGV0IGZpcnN0UmVjdFdpZHRoID1cbiAgICAoZ2V0U3Vic2VxdWVuY2VMZW5ndGgoc2VsZWN0aW9uLCBzZXF1ZW5jZS5sZW5ndGgpIC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgbGV0IHNlY29uZFJlY3RTdGFydCA9IG51bGw7XG4gIGxldCBzZWNvbmRSZWN0V2lkdGggPSBudWxsO1xuXG4gIC8vIFRPRE86IGFic3RyYWN0IHRoaXMgYW5kIGxvZ2ljIGluIExpbmVhckFubm90YXRpb24gaW50byBoZWxwZXIgZnVuY3Rpb25zXG4gIGNvbnN0IHNlbGVjdGlvblNwYW5zU2VhbSA9IHNlbGVjdGlvbi5zdGFydCA+IHNlbGVjdGlvbi5lbmQ7XG5cbiAgLyogaWYgZGlyZWN0aW9uIGlzIGJhY2t3YXJkIGFuZCBlbmQgPiBzdGFydCB3ZSBuZWVkIHRvIHJlbmRlciB0d28gcmVjdGFuZ2xlcyAqL1xuICBpZiAoc2VsZWN0aW9uU3BhbnNTZWFtKSB7XG4gICAgZmlyc3RSZWN0U3RhcnQgPSAwO1xuICAgIGZpcnN0UmVjdFdpZHRoID0gKGVuZCAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gICAgc2Vjb25kUmVjdFN0YXJ0ID0gKHN0YXJ0IC8gc2VxdWVuY2UubGVuZ3RoKSAqIDEwMDtcbiAgICBzZWNvbmRSZWN0V2lkdGggPSAoKHNlcXVlbmNlLmxlbmd0aCAtIHN0YXJ0KSAvIHNlcXVlbmNlLmxlbmd0aCkgKiAxMDA7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxnXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgIFwiZmlsbC1jdXJyZW50IHN0cm9rZS1jdXJyZW50XCIsXG4gICAgICAgIHNlbGVjdGlvbkNsYXNzTmFtZT8uKHNlbGVjdGlvbiksXG4gICAgICApfVxuICAgID5cbiAgICAgIDxyZWN0XG4gICAgICAgIHg9e2Ake2ZpcnN0UmVjdFN0YXJ0fSVgfVxuICAgICAgICB3aWR0aD17YCR7Zmlyc3RSZWN0V2lkdGh9JWB9XG4gICAgICAgIHk9e2AwJWB9XG4gICAgICAgIGhlaWdodD17YDEwMCVgfVxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgZmlsbE9wYWNpdHk9ezAuMn1cbiAgICAgICAgc3Ryb2tlV2lkdGg9ezEuNX1cbiAgICAgIC8+XG4gICAgICB7c2Vjb25kUmVjdFN0YXJ0ICYmIHNlY29uZFJlY3RXaWR0aCAmJiAoXG4gICAgICAgIDxyZWN0XG4gICAgICAgICAgeD17YCR7c2Vjb25kUmVjdFN0YXJ0fSVgfVxuICAgICAgICAgIHdpZHRoPXtgJHtzZWNvbmRSZWN0V2lkdGh9JWB9XG4gICAgICAgICAgeT17YDAlYH1cbiAgICAgICAgICBoZWlnaHQ9e2AxMDAlYH1cbiAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICBmaWxsT3BhY2l0eT17MC4yfVxuICAgICAgICAgIHN0cm9rZVdpZHRoPXsxLjV9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIDwvZz5cbiAgKTtcbn07XG4iLCIvLyBwYWNrYWdlcy9jb3JlL251bWJlci9zcmMvbnVtYmVyLnRzXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgW21pbiwgbWF4XSkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG5leHBvcnQge1xuICBjbGFtcFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL2NvcmUvcHJpbWl0aXZlL3NyYy9wcmltaXRpdmUudHN4XG5mdW5jdGlvbiBjb21wb3NlRXZlbnRIYW5kbGVycyhvcmlnaW5hbEV2ZW50SGFuZGxlciwgb3VyRXZlbnRIYW5kbGVyLCB7IGNoZWNrRm9yRGVmYXVsdFByZXZlbnRlZCA9IHRydWUgfSA9IHt9KSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgIG9yaWdpbmFsRXZlbnRIYW5kbGVyPy4oZXZlbnQpO1xuICAgIGlmIChjaGVja0ZvckRlZmF1bHRQcmV2ZW50ZWQgPT09IGZhbHNlIHx8ICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm4gb3VyRXZlbnRIYW5kbGVyPy4oZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGNvbXBvc2VFdmVudEhhbmRsZXJzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvY29udGV4dC9zcmMvY3JlYXRlQ29udGV4dC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0Mihyb290Q29tcG9uZW50TmFtZSwgZGVmYXVsdENvbnRleHQpIHtcbiAgY29uc3QgQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbnRleHQpO1xuICBjb25zdCBQcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmNvbnRleHQgfSA9IHByb3BzO1xuICAgIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb250ZXh0LCBPYmplY3QudmFsdWVzKGNvbnRleHQpKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlLCBjaGlsZHJlbiB9KTtcbiAgfTtcbiAgUHJvdmlkZXIuZGlzcGxheU5hbWUgPSByb290Q29tcG9uZW50TmFtZSArIFwiUHJvdmlkZXJcIjtcbiAgZnVuY3Rpb24gdXNlQ29udGV4dDIoY29uc3VtZXJOYW1lKSB7XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0O1xuICAgIGlmIChkZWZhdWx0Q29udGV4dCAhPT0gdm9pZCAwKSByZXR1cm4gZGVmYXVsdENvbnRleHQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke2NvbnN1bWVyTmFtZX1cXGAgbXVzdCBiZSB1c2VkIHdpdGhpbiBcXGAke3Jvb3RDb21wb25lbnROYW1lfVxcYGApO1xuICB9XG4gIHJldHVybiBbUHJvdmlkZXIsIHVzZUNvbnRleHQyXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHRTY29wZShzY29wZU5hbWUsIGNyZWF0ZUNvbnRleHRTY29wZURlcHMgPSBbXSkge1xuICBsZXQgZGVmYXVsdENvbnRleHRzID0gW107XG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQzKHJvb3RDb21wb25lbnROYW1lLCBkZWZhdWx0Q29udGV4dCkge1xuICAgIGNvbnN0IEJhc2VDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0Q29udGV4dCk7XG4gICAgY29uc3QgaW5kZXggPSBkZWZhdWx0Q29udGV4dHMubGVuZ3RoO1xuICAgIGRlZmF1bHRDb250ZXh0cyA9IFsuLi5kZWZhdWx0Q29udGV4dHMsIGRlZmF1bHRDb250ZXh0XTtcbiAgICBjb25zdCBQcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgICAgY29uc3QgeyBzY29wZSwgY2hpbGRyZW4sIC4uLmNvbnRleHQgfSA9IHByb3BzO1xuICAgICAgY29uc3QgQ29udGV4dCA9IHNjb3BlPy5bc2NvcGVOYW1lXT8uW2luZGV4XSB8fCBCYXNlQ29udGV4dDtcbiAgICAgIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiBjb250ZXh0LCBPYmplY3QudmFsdWVzKGNvbnRleHQpKTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUsIGNoaWxkcmVuIH0pO1xuICAgIH07XG4gICAgUHJvdmlkZXIuZGlzcGxheU5hbWUgPSByb290Q29tcG9uZW50TmFtZSArIFwiUHJvdmlkZXJcIjtcbiAgICBmdW5jdGlvbiB1c2VDb250ZXh0Mihjb25zdW1lck5hbWUsIHNjb3BlKSB7XG4gICAgICBjb25zdCBDb250ZXh0ID0gc2NvcGU/LltzY29wZU5hbWVdPy5baW5kZXhdIHx8IEJhc2VDb250ZXh0O1xuICAgICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgICBpZiAoY29udGV4dCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgICBpZiAoZGVmYXVsdENvbnRleHQgIT09IHZvaWQgMCkgcmV0dXJuIGRlZmF1bHRDb250ZXh0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke2NvbnN1bWVyTmFtZX1cXGAgbXVzdCBiZSB1c2VkIHdpdGhpbiBcXGAke3Jvb3RDb21wb25lbnROYW1lfVxcYGApO1xuICAgIH1cbiAgICByZXR1cm4gW1Byb3ZpZGVyLCB1c2VDb250ZXh0Ml07XG4gIH1cbiAgY29uc3QgY3JlYXRlU2NvcGUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2NvcGVDb250ZXh0cyA9IGRlZmF1bHRDb250ZXh0cy5tYXAoKGRlZmF1bHRDb250ZXh0KSA9PiB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0Q29udGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNjb3BlKHNjb3BlKSB7XG4gICAgICBjb25zdCBjb250ZXh0cyA9IHNjb3BlPy5bc2NvcGVOYW1lXSB8fCBzY29wZUNvbnRleHRzO1xuICAgICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oXG4gICAgICAgICgpID0+ICh7IFtgX19zY29wZSR7c2NvcGVOYW1lfWBdOiB7IC4uLnNjb3BlLCBbc2NvcGVOYW1lXTogY29udGV4dHMgfSB9KSxcbiAgICAgICAgW3Njb3BlLCBjb250ZXh0c11cbiAgICAgICk7XG4gICAgfTtcbiAgfTtcbiAgY3JlYXRlU2NvcGUuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICByZXR1cm4gW2NyZWF0ZUNvbnRleHQzLCBjb21wb3NlQ29udGV4dFNjb3BlcyhjcmVhdGVTY29wZSwgLi4uY3JlYXRlQ29udGV4dFNjb3BlRGVwcyldO1xufVxuZnVuY3Rpb24gY29tcG9zZUNvbnRleHRTY29wZXMoLi4uc2NvcGVzKSB7XG4gIGNvbnN0IGJhc2VTY29wZSA9IHNjb3Blc1swXTtcbiAgaWYgKHNjb3Blcy5sZW5ndGggPT09IDEpIHJldHVybiBiYXNlU2NvcGU7XG4gIGNvbnN0IGNyZWF0ZVNjb3BlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlSG9va3MgPSBzY29wZXMubWFwKChjcmVhdGVTY29wZTIpID0+ICh7XG4gICAgICB1c2VTY29wZTogY3JlYXRlU2NvcGUyKCksXG4gICAgICBzY29wZU5hbWU6IGNyZWF0ZVNjb3BlMi5zY29wZU5hbWVcbiAgICB9KSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZUNvbXBvc2VkU2NvcGVzKG92ZXJyaWRlU2NvcGVzKSB7XG4gICAgICBjb25zdCBuZXh0U2NvcGVzID0gc2NvcGVIb29rcy5yZWR1Y2UoKG5leHRTY29wZXMyLCB7IHVzZVNjb3BlLCBzY29wZU5hbWUgfSkgPT4ge1xuICAgICAgICBjb25zdCBzY29wZVByb3BzID0gdXNlU2NvcGUob3ZlcnJpZGVTY29wZXMpO1xuICAgICAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBzY29wZVByb3BzW2BfX3Njb3BlJHtzY29wZU5hbWV9YF07XG4gICAgICAgIHJldHVybiB7IC4uLm5leHRTY29wZXMyLCAuLi5jdXJyZW50U2NvcGUgfTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7IFtgX19zY29wZSR7YmFzZVNjb3BlLnNjb3BlTmFtZX1gXTogbmV4dFNjb3BlcyB9KSwgW25leHRTY29wZXNdKTtcbiAgICB9O1xuICB9O1xuICBjcmVhdGVTY29wZS5zY29wZU5hbWUgPSBiYXNlU2NvcGUuc2NvcGVOYW1lO1xuICByZXR1cm4gY3JlYXRlU2NvcGU7XG59XG5leHBvcnQge1xuICBjcmVhdGVDb250ZXh0MiBhcyBjcmVhdGVDb250ZXh0LFxuICBjcmVhdGVDb250ZXh0U2NvcGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9jb21wb3NlLXJlZnMvc3JjL2NvbXBvc2VSZWZzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBzZXRSZWYocmVmLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHJlZih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdm9pZCAwKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICBsZXQgaGFzQ2xlYW51cCA9IGZhbHNlO1xuICAgIGNvbnN0IGNsZWFudXBzID0gcmVmcy5tYXAoKHJlZikgPT4ge1xuICAgICAgY29uc3QgY2xlYW51cCA9IHNldFJlZihyZWYsIG5vZGUpO1xuICAgICAgaWYgKCFoYXNDbGVhbnVwICYmIHR5cGVvZiBjbGVhbnVwID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBoYXNDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0pO1xuICAgIGlmIChoYXNDbGVhbnVwKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsZWFudXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2xlYW51cCA9IGNsZWFudXBzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0UmVmKHJlZnNbaV0sIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VDb21wb3NlZFJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soY29tcG9zZVJlZnMoLi4ucmVmcyksIHJlZnMpO1xufVxuZXhwb3J0IHtcbiAgY29tcG9zZVJlZnMsXG4gIHVzZUNvbXBvc2VkUmVmc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3Nsb3Qvc3JjL3Nsb3QudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNvbXBvc2VSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MiwganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2xvdCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgY2hpbGRyZW5BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICBjb25zdCBzbG90dGFibGUgPSBjaGlsZHJlbkFycmF5LmZpbmQoaXNTbG90dGFibGUpO1xuICBpZiAoc2xvdHRhYmxlKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IHNsb3R0YWJsZS5wcm9wcy5jaGlsZHJlbjtcbiAgICBjb25zdCBuZXdDaGlsZHJlbiA9IGNoaWxkcmVuQXJyYXkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkID09PSBzbG90dGFibGUpIHtcbiAgICAgICAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KG5ld0VsZW1lbnQpID4gMSkgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLm9ubHkobnVsbCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXdFbGVtZW50KSA/IG5ld0VsZW1lbnQucHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3RDbG9uZSwgeyAuLi5zbG90UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbjogUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV3RWxlbWVudCkgPyBSZWFjdC5jbG9uZUVsZW1lbnQobmV3RWxlbWVudCwgdm9pZCAwLCBuZXdDaGlsZHJlbikgOiBudWxsIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3RDbG9uZSwgeyAuLi5zbG90UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbiB9KTtcbn0pO1xuU2xvdC5kaXNwbGF5TmFtZSA9IFwiU2xvdFwiO1xudmFyIFNsb3RDbG9uZSA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4uc2xvdFByb3BzIH0gPSBwcm9wcztcbiAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuUmVmID0gZ2V0RWxlbWVudFJlZihjaGlsZHJlbik7XG4gICAgY29uc3QgcHJvcHMyID0gbWVyZ2VQcm9wcyhzbG90UHJvcHMsIGNoaWxkcmVuLnByb3BzKTtcbiAgICBpZiAoY2hpbGRyZW4udHlwZSAhPT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgIHByb3BzMi5yZWYgPSBmb3J3YXJkZWRSZWYgPyBjb21wb3NlUmVmcyhmb3J3YXJkZWRSZWYsIGNoaWxkcmVuUmVmKSA6IGNoaWxkcmVuUmVmO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCBwcm9wczIpO1xuICB9XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPiAxID8gUmVhY3QuQ2hpbGRyZW4ub25seShudWxsKSA6IG51bGw7XG59KTtcblNsb3RDbG9uZS5kaXNwbGF5TmFtZSA9IFwiU2xvdENsb25lXCI7XG52YXIgU2xvdHRhYmxlID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudDIsIHsgY2hpbGRyZW4gfSk7XG59O1xuZnVuY3Rpb24gaXNTbG90dGFibGUoY2hpbGQpIHtcbiAgcmV0dXJuIFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSAmJiBjaGlsZC50eXBlID09PSBTbG90dGFibGU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKHNsb3RQcm9wcywgY2hpbGRQcm9wcykge1xuICBjb25zdCBvdmVycmlkZVByb3BzID0geyAuLi5jaGlsZFByb3BzIH07XG4gIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gY2hpbGRQcm9wcykge1xuICAgIGNvbnN0IHNsb3RQcm9wVmFsdWUgPSBzbG90UHJvcHNbcHJvcE5hbWVdO1xuICAgIGNvbnN0IGNoaWxkUHJvcFZhbHVlID0gY2hpbGRQcm9wc1twcm9wTmFtZV07XG4gICAgY29uc3QgaXNIYW5kbGVyID0gL15vbltBLVpdLy50ZXN0KHByb3BOYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVyKSB7XG4gICAgICBpZiAoc2xvdFByb3BWYWx1ZSAmJiBjaGlsZFByb3BWYWx1ZSkge1xuICAgICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY2hpbGRQcm9wVmFsdWUoLi4uYXJncyk7XG4gICAgICAgICAgc2xvdFByb3BWYWx1ZSguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdFByb3BWYWx1ZSkge1xuICAgICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IHNsb3RQcm9wVmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IHsgLi4uc2xvdFByb3BWYWx1ZSwgLi4uY2hpbGRQcm9wVmFsdWUgfTtcbiAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSBcImNsYXNzTmFtZVwiKSB7XG4gICAgICBvdmVycmlkZVByb3BzW3Byb3BOYW1lXSA9IFtzbG90UHJvcFZhbHVlLCBjaGlsZFByb3BWYWx1ZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyAuLi5zbG90UHJvcHMsIC4uLm92ZXJyaWRlUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRSZWYoZWxlbWVudCkge1xuICBsZXQgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50LnByb3BzLCBcInJlZlwiKT8uZ2V0O1xuICBsZXQgbWF5V2FybiA9IGdldHRlciAmJiBcImlzUmVhY3RXYXJuaW5nXCIgaW4gZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZztcbiAgaWYgKG1heVdhcm4pIHtcbiAgICByZXR1cm4gZWxlbWVudC5yZWY7XG4gIH1cbiAgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlbGVtZW50LCBcInJlZlwiKT8uZ2V0O1xuICBtYXlXYXJuID0gZ2V0dGVyICYmIFwiaXNSZWFjdFdhcm5pbmdcIiBpbiBnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nO1xuICBpZiAobWF5V2Fybikge1xuICAgIHJldHVybiBlbGVtZW50LnByb3BzLnJlZjtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wcm9wcy5yZWYgfHwgZWxlbWVudC5yZWY7XG59XG52YXIgUm9vdCA9IFNsb3Q7XG5leHBvcnQge1xuICBSb290LFxuICBTbG90LFxuICBTbG90dGFibGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvY29sbGVjdGlvbi9zcmMvY29sbGVjdGlvbi50c3hcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29udGV4dFwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNsb3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihuYW1lKSB7XG4gIGNvbnN0IFBST1ZJREVSX05BTUUgPSBuYW1lICsgXCJDb2xsZWN0aW9uUHJvdmlkZXJcIjtcbiAgY29uc3QgW2NyZWF0ZUNvbGxlY3Rpb25Db250ZXh0LCBjcmVhdGVDb2xsZWN0aW9uU2NvcGVdID0gY3JlYXRlQ29udGV4dFNjb3BlKFBST1ZJREVSX05BTUUpO1xuICBjb25zdCBbQ29sbGVjdGlvblByb3ZpZGVySW1wbCwgdXNlQ29sbGVjdGlvbkNvbnRleHRdID0gY3JlYXRlQ29sbGVjdGlvbkNvbnRleHQoXG4gICAgUFJPVklERVJfTkFNRSxcbiAgICB7IGNvbGxlY3Rpb25SZWY6IHsgY3VycmVudDogbnVsbCB9LCBpdGVtTWFwOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIH1cbiAgKTtcbiAgY29uc3QgQ29sbGVjdGlvblByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBzY29wZSwgY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpdGVtTWFwID0gUmVhY3QudXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLmN1cnJlbnQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvblByb3ZpZGVySW1wbCwgeyBzY29wZSwgaXRlbU1hcCwgY29sbGVjdGlvblJlZjogcmVmLCBjaGlsZHJlbiB9KTtcbiAgfTtcbiAgQ29sbGVjdGlvblByb3ZpZGVyLmRpc3BsYXlOYW1lID0gUFJPVklERVJfTkFNRTtcbiAgY29uc3QgQ09MTEVDVElPTl9TTE9UX05BTUUgPSBuYW1lICsgXCJDb2xsZWN0aW9uU2xvdFwiO1xuICBjb25zdCBDb2xsZWN0aW9uU2xvdCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb2xsZWN0aW9uQ29udGV4dChDT0xMRUNUSU9OX1NMT1RfTkFNRSwgc2NvcGUpO1xuICAgICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgY29udGV4dC5jb2xsZWN0aW9uUmVmKTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3QsIHsgcmVmOiBjb21wb3NlZFJlZnMsIGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgKTtcbiAgQ29sbGVjdGlvblNsb3QuZGlzcGxheU5hbWUgPSBDT0xMRUNUSU9OX1NMT1RfTkFNRTtcbiAgY29uc3QgSVRFTV9TTE9UX05BTUUgPSBuYW1lICsgXCJDb2xsZWN0aW9uSXRlbVNsb3RcIjtcbiAgY29uc3QgSVRFTV9EQVRBX0FUVFIgPSBcImRhdGEtcmFkaXgtY29sbGVjdGlvbi1pdGVtXCI7XG4gIGNvbnN0IENvbGxlY3Rpb25JdGVtU2xvdCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICAgIGNvbnN0IHsgc2NvcGUsIGNoaWxkcmVuLCAuLi5pdGVtRGF0YSB9ID0gcHJvcHM7XG4gICAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCByZWYpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHVzZUNvbGxlY3Rpb25Db250ZXh0KElURU1fU0xPVF9OQU1FLCBzY29wZSk7XG4gICAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb250ZXh0Lml0ZW1NYXAuc2V0KHJlZiwgeyByZWYsIC4uLml0ZW1EYXRhIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdm9pZCBjb250ZXh0Lml0ZW1NYXAuZGVsZXRlKHJlZik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNsb3QsIHsgLi4ueyBbSVRFTV9EQVRBX0FUVFJdOiBcIlwiIH0sIHJlZjogY29tcG9zZWRSZWZzLCBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICk7XG4gIENvbGxlY3Rpb25JdGVtU2xvdC5kaXNwbGF5TmFtZSA9IElURU1fU0xPVF9OQU1FO1xuICBmdW5jdGlvbiB1c2VDb2xsZWN0aW9uKHNjb3BlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbGxlY3Rpb25Db250ZXh0KG5hbWUgKyBcIkNvbGxlY3Rpb25Db25zdW1lclwiLCBzY29wZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICBjb25zdCBjb2xsZWN0aW9uTm9kZSA9IGNvbnRleHQuY29sbGVjdGlvblJlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjb2xsZWN0aW9uTm9kZSkgcmV0dXJuIFtdO1xuICAgICAgY29uc3Qgb3JkZXJlZE5vZGVzID0gQXJyYXkuZnJvbShjb2xsZWN0aW9uTm9kZS5xdWVyeVNlbGVjdG9yQWxsKGBbJHtJVEVNX0RBVEFfQVRUUn1dYCkpO1xuICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKGNvbnRleHQuaXRlbU1hcC52YWx1ZXMoKSk7XG4gICAgICBjb25zdCBvcmRlcmVkSXRlbXMgPSBpdGVtcy5zb3J0KFxuICAgICAgICAoYSwgYikgPT4gb3JkZXJlZE5vZGVzLmluZGV4T2YoYS5yZWYuY3VycmVudCkgLSBvcmRlcmVkTm9kZXMuaW5kZXhPZihiLnJlZi5jdXJyZW50KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBvcmRlcmVkSXRlbXM7XG4gICAgfSwgW2NvbnRleHQuY29sbGVjdGlvblJlZiwgY29udGV4dC5pdGVtTWFwXSk7XG4gICAgcmV0dXJuIGdldEl0ZW1zO1xuICB9XG4gIHJldHVybiBbXG4gICAgeyBQcm92aWRlcjogQ29sbGVjdGlvblByb3ZpZGVyLCBTbG90OiBDb2xsZWN0aW9uU2xvdCwgSXRlbVNsb3Q6IENvbGxlY3Rpb25JdGVtU2xvdCB9LFxuICAgIHVzZUNvbGxlY3Rpb24sXG4gICAgY3JlYXRlQ29sbGVjdGlvblNjb3BlXG4gIF07XG59XG5leHBvcnQge1xuICBjcmVhdGVDb2xsZWN0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvZGlyZWN0aW9uL3NyYy9EaXJlY3Rpb24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIERpcmVjdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG52YXIgRGlyZWN0aW9uUHJvdmlkZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBkaXIsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRGlyZWN0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGlyLCBjaGlsZHJlbiB9KTtcbn07XG5mdW5jdGlvbiB1c2VEaXJlY3Rpb24obG9jYWxEaXIpIHtcbiAgY29uc3QgZ2xvYmFsRGlyID0gUmVhY3QudXNlQ29udGV4dChEaXJlY3Rpb25Db250ZXh0KTtcbiAgcmV0dXJuIGxvY2FsRGlyIHx8IGdsb2JhbERpciB8fCBcImx0clwiO1xufVxudmFyIFByb3ZpZGVyID0gRGlyZWN0aW9uUHJvdmlkZXI7XG5leHBvcnQge1xuICBEaXJlY3Rpb25Qcm92aWRlcixcbiAgUHJvdmlkZXIsXG4gIHVzZURpcmVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3ByaW1pdGl2ZS9zcmMvcHJpbWl0aXZlLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyBTbG90IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1zbG90XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBOT0RFUyA9IFtcbiAgXCJhXCIsXG4gIFwiYnV0dG9uXCIsXG4gIFwiZGl2XCIsXG4gIFwiZm9ybVwiLFxuICBcImgyXCIsXG4gIFwiaDNcIixcbiAgXCJpbWdcIixcbiAgXCJpbnB1dFwiLFxuICBcImxhYmVsXCIsXG4gIFwibGlcIixcbiAgXCJuYXZcIixcbiAgXCJvbFwiLFxuICBcInBcIixcbiAgXCJzcGFuXCIsXG4gIFwic3ZnXCIsXG4gIFwidWxcIlxuXTtcbnZhciBQcmltaXRpdmUgPSBOT0RFUy5yZWR1Y2UoKHByaW1pdGl2ZSwgbm9kZSkgPT4ge1xuICBjb25zdCBOb2RlID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgYXNDaGlsZCwgLi4ucHJpbWl0aXZlUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IENvbXAgPSBhc0NoaWxkID8gU2xvdCA6IG5vZGU7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvd1tTeW1ib2wuZm9yKFwicmFkaXgtdWlcIildID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29tcCwgeyAuLi5wcmltaXRpdmVQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSk7XG4gIH0pO1xuICBOb2RlLmRpc3BsYXlOYW1lID0gYFByaW1pdGl2ZS4ke25vZGV9YDtcbiAgcmV0dXJuIHsgLi4ucHJpbWl0aXZlLCBbbm9kZV06IE5vZGUgfTtcbn0sIHt9KTtcbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudCh0YXJnZXQsIGV2ZW50KSB7XG4gIGlmICh0YXJnZXQpIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCkpO1xufVxudmFyIFJvb3QgPSBQcmltaXRpdmU7XG5leHBvcnQge1xuICBQcmltaXRpdmUsXG4gIFJvb3QsXG4gIGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3VzZS1jYWxsYmFjay1yZWYvc3JjL3VzZUNhbGxiYWNrUmVmLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VDYWxsYmFja1JlZihjYWxsYmFjaykge1xuICBjb25zdCBjYWxsYmFja1JlZiA9IFJlYWN0LnVzZVJlZihjYWxsYmFjayk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKC4uLmFyZ3MpID0+IGNhbGxiYWNrUmVmLmN1cnJlbnQ/LiguLi5hcmdzKSwgW10pO1xufVxuZXhwb3J0IHtcbiAgdXNlQ2FsbGJhY2tSZWZcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtZXNjYXBlLWtleWRvd24vc3JjL3VzZUVzY2FwZUtleWRvd24udHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5mdW5jdGlvbiB1c2VFc2NhcGVLZXlkb3duKG9uRXNjYXBlS2V5RG93blByb3AsIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzPy5kb2N1bWVudCkge1xuICBjb25zdCBvbkVzY2FwZUtleURvd24gPSB1c2VDYWxsYmFja1JlZihvbkVzY2FwZUtleURvd25Qcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIG9uRXNjYXBlS2V5RG93bihldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKCkgPT4gb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gIH0sIFtvbkVzY2FwZUtleURvd24sIG93bmVyRG9jdW1lbnRdKTtcbn1cbmV4cG9ydCB7XG4gIHVzZUVzY2FwZUtleWRvd25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJcInVzZSBjbGllbnRcIjtcblxuLy8gcGFja2FnZXMvcmVhY3QvZGlzbWlzc2FibGUtbGF5ZXIvc3JjL2Rpc21pc3NhYmxlLWxheWVyLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjb21wb3NlRXZlbnRIYW5kbGVycyB9IGZyb20gXCJAcmFkaXgtdWkvcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyBQcmltaXRpdmUsIGRpc3BhdGNoRGlzY3JldGVDdXN0b21FdmVudCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VDb21wb3NlZFJlZnMgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWNvbXBvc2UtcmVmc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2tSZWYgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1jYWxsYmFjay1yZWZcIjtcbmltcG9ydCB7IHVzZUVzY2FwZUtleWRvd24gfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1lc2NhcGUta2V5ZG93blwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRElTTUlTU0FCTEVfTEFZRVJfTkFNRSA9IFwiRGlzbWlzc2FibGVMYXllclwiO1xudmFyIENPTlRFWFRfVVBEQVRFID0gXCJkaXNtaXNzYWJsZUxheWVyLnVwZGF0ZVwiO1xudmFyIFBPSU5URVJfRE9XTl9PVVRTSURFID0gXCJkaXNtaXNzYWJsZUxheWVyLnBvaW50ZXJEb3duT3V0c2lkZVwiO1xudmFyIEZPQ1VTX09VVFNJREUgPSBcImRpc21pc3NhYmxlTGF5ZXIuZm9jdXNPdXRzaWRlXCI7XG52YXIgb3JpZ2luYWxCb2R5UG9pbnRlckV2ZW50cztcbnZhciBEaXNtaXNzYWJsZUxheWVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBsYXllcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gIGxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBicmFuY2hlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxufSk7XG52YXIgRGlzbWlzc2FibGVMYXllciA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGlzYWJsZU91dHNpZGVQb2ludGVyRXZlbnRzID0gZmFsc2UsXG4gICAgICBvbkVzY2FwZUtleURvd24sXG4gICAgICBvblBvaW50ZXJEb3duT3V0c2lkZSxcbiAgICAgIG9uRm9jdXNPdXRzaWRlLFxuICAgICAgb25JbnRlcmFjdE91dHNpZGUsXG4gICAgICBvbkRpc21pc3MsXG4gICAgICAuLi5sYXllclByb3BzXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERpc21pc3NhYmxlTGF5ZXJDb250ZXh0KTtcbiAgICBjb25zdCBbbm9kZSwgc2V0Tm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gbm9kZT8ub3duZXJEb2N1bWVudCA/PyBnbG9iYWxUaGlzPy5kb2N1bWVudDtcbiAgICBjb25zdCBbLCBmb3JjZV0gPSBSZWFjdC51c2VTdGF0ZSh7fSk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgKG5vZGUyKSA9PiBzZXROb2RlKG5vZGUyKSk7XG4gICAgY29uc3QgbGF5ZXJzID0gQXJyYXkuZnJvbShjb250ZXh0LmxheWVycyk7XG4gICAgY29uc3QgW2hpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkXSA9IFsuLi5jb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkXS5zbGljZSgtMSk7XG4gICAgY29uc3QgaGlnaGVzdExheWVyV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWRJbmRleCA9IGxheWVycy5pbmRleE9mKGhpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkKTtcbiAgICBjb25zdCBpbmRleCA9IG5vZGUgPyBsYXllcnMuaW5kZXhPZihub2RlKSA6IC0xO1xuICAgIGNvbnN0IGlzQm9keVBvaW50ZXJFdmVudHNEaXNhYmxlZCA9IGNvbnRleHQubGF5ZXJzV2l0aE91dHNpZGVQb2ludGVyRXZlbnRzRGlzYWJsZWQuc2l6ZSA+IDA7XG4gICAgY29uc3QgaXNQb2ludGVyRXZlbnRzRW5hYmxlZCA9IGluZGV4ID49IGhpZ2hlc3RMYXllcldpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkSW5kZXg7XG4gICAgY29uc3QgcG9pbnRlckRvd25PdXRzaWRlID0gdXNlUG9pbnRlckRvd25PdXRzaWRlKChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgaXNQb2ludGVyRG93bk9uQnJhbmNoID0gWy4uLmNvbnRleHQuYnJhbmNoZXNdLnNvbWUoKGJyYW5jaCkgPT4gYnJhbmNoLmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgaWYgKCFpc1BvaW50ZXJFdmVudHNFbmFibGVkIHx8IGlzUG9pbnRlckRvd25PbkJyYW5jaCkgcmV0dXJuO1xuICAgICAgb25Qb2ludGVyRG93bk91dHNpZGU/LihldmVudCk7XG4gICAgICBvbkludGVyYWN0T3V0c2lkZT8uKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgb25EaXNtaXNzPy4oKTtcbiAgICB9LCBvd25lckRvY3VtZW50KTtcbiAgICBjb25zdCBmb2N1c091dHNpZGUgPSB1c2VGb2N1c091dHNpZGUoKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5CcmFuY2ggPSBbLi4uY29udGV4dC5icmFuY2hlc10uc29tZSgoYnJhbmNoKSA9PiBicmFuY2guY29udGFpbnModGFyZ2V0KSk7XG4gICAgICBpZiAoaXNGb2N1c0luQnJhbmNoKSByZXR1cm47XG4gICAgICBvbkZvY3VzT3V0c2lkZT8uKGV2ZW50KTtcbiAgICAgIG9uSW50ZXJhY3RPdXRzaWRlPy4oZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSBvbkRpc21pc3M/LigpO1xuICAgIH0sIG93bmVyRG9jdW1lbnQpO1xuICAgIHVzZUVzY2FwZUtleWRvd24oKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBpc0hpZ2hlc3RMYXllciA9IGluZGV4ID09PSBjb250ZXh0LmxheWVycy5zaXplIC0gMTtcbiAgICAgIGlmICghaXNIaWdoZXN0TGF5ZXIpIHJldHVybjtcbiAgICAgIG9uRXNjYXBlS2V5RG93bj8uKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiBvbkRpc21pc3MpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25EaXNtaXNzKCk7XG4gICAgICB9XG4gICAgfSwgb3duZXJEb2N1bWVudCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgICAgaWYgKGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cykge1xuICAgICAgICBpZiAoY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5zaXplID09PSAwKSB7XG4gICAgICAgICAgb3JpZ2luYWxCb2R5UG9pbnRlckV2ZW50cyA9IG93bmVyRG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzO1xuICAgICAgICAgIG93bmVyRG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5sYXllcnNXaXRoT3V0c2lkZVBvaW50ZXJFdmVudHNEaXNhYmxlZC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxheWVycy5hZGQobm9kZSk7XG4gICAgICBkaXNwYXRjaFVwZGF0ZSgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cyAmJiBjb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkLnNpemUgPT09IDEpIHtcbiAgICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9IG9yaWdpbmFsQm9keVBvaW50ZXJFdmVudHM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW25vZGUsIG93bmVyRG9jdW1lbnQsIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50cywgY29udGV4dF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgY29udGV4dC5sYXllcnMuZGVsZXRlKG5vZGUpO1xuICAgICAgICBjb250ZXh0LmxheWVyc1dpdGhPdXRzaWRlUG9pbnRlckV2ZW50c0Rpc2FibGVkLmRlbGV0ZShub2RlKTtcbiAgICAgICAgZGlzcGF0Y2hVcGRhdGUoKTtcbiAgICAgIH07XG4gICAgfSwgW25vZGUsIGNvbnRleHRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKCkgPT4gZm9yY2Uoe30pO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihDT05URVhUX1VQREFURSwgaGFuZGxlVXBkYXRlKTtcbiAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKENPTlRFWFRfVVBEQVRFLCBoYW5kbGVVcGRhdGUpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICB7XG4gICAgICAgIC4uLmxheWVyUHJvcHMsXG4gICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGlzQm9keVBvaW50ZXJFdmVudHNEaXNhYmxlZCA/IGlzUG9pbnRlckV2ZW50c0VuYWJsZWQgPyBcImF1dG9cIiA6IFwibm9uZVwiIDogdm9pZCAwLFxuICAgICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXNDYXB0dXJlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhwcm9wcy5vbkZvY3VzQ2FwdHVyZSwgZm9jdXNPdXRzaWRlLm9uRm9jdXNDYXB0dXJlKSxcbiAgICAgICAgb25CbHVyQ2FwdHVyZTogY29tcG9zZUV2ZW50SGFuZGxlcnMocHJvcHMub25CbHVyQ2FwdHVyZSwgZm9jdXNPdXRzaWRlLm9uQmx1ckNhcHR1cmUpLFxuICAgICAgICBvblBvaW50ZXJEb3duQ2FwdHVyZTogY29tcG9zZUV2ZW50SGFuZGxlcnMoXG4gICAgICAgICAgcHJvcHMub25Qb2ludGVyRG93bkNhcHR1cmUsXG4gICAgICAgICAgcG9pbnRlckRvd25PdXRzaWRlLm9uUG9pbnRlckRvd25DYXB0dXJlXG4gICAgICAgIClcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuRGlzbWlzc2FibGVMYXllci5kaXNwbGF5TmFtZSA9IERJU01JU1NBQkxFX0xBWUVSX05BTUU7XG52YXIgQlJBTkNIX05BTUUgPSBcIkRpc21pc3NhYmxlTGF5ZXJCcmFuY2hcIjtcbnZhciBEaXNtaXNzYWJsZUxheWVyQnJhbmNoID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEaXNtaXNzYWJsZUxheWVyQ29udGV4dCk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbnRleHQuYnJhbmNoZXMuYWRkKG5vZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29udGV4dC5icmFuY2hlcy5kZWxldGUobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2NvbnRleHQuYnJhbmNoZXNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyAuLi5wcm9wcywgcmVmOiBjb21wb3NlZFJlZnMgfSk7XG59KTtcbkRpc21pc3NhYmxlTGF5ZXJCcmFuY2guZGlzcGxheU5hbWUgPSBCUkFOQ0hfTkFNRTtcbmZ1bmN0aW9uIHVzZVBvaW50ZXJEb3duT3V0c2lkZShvblBvaW50ZXJEb3duT3V0c2lkZSwgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXM/LmRvY3VtZW50KSB7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJEb3duT3V0c2lkZSA9IHVzZUNhbGxiYWNrUmVmKG9uUG9pbnRlckRvd25PdXRzaWRlKTtcbiAgY29uc3QgaXNQb2ludGVySW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlQ2xpY2tSZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVQb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAmJiAhaXNQb2ludGVySW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbGV0IGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaGFuZGxlQW5kRGlzcGF0Y2hDdXN0b21FdmVudChcbiAgICAgICAgICAgIFBPSU5URVJfRE9XTl9PVVRTSURFLFxuICAgICAgICAgICAgaGFuZGxlUG9pbnRlckRvd25PdXRzaWRlLFxuICAgICAgICAgICAgZXZlbnREZXRhaWwsXG4gICAgICAgICAgICB7IGRpc2NyZXRlOiB0cnVlIH1cbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlQW5kRGlzcGF0Y2hQb2ludGVyRG93bk91dHNpZGVFdmVudCA9IGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyO1xuICAgICAgICBjb25zdCBldmVudERldGFpbCA9IHsgb3JpZ2luYWxFdmVudDogZXZlbnQgfTtcbiAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGlja1JlZi5jdXJyZW50KTtcbiAgICAgICAgICBoYW5kbGVDbGlja1JlZi5jdXJyZW50ID0gaGFuZGxlQW5kRGlzcGF0Y2hQb2ludGVyRG93bk91dHNpZGVFdmVudDI7XG4gICAgICAgICAgb3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2tSZWYuY3VycmVudCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZUFuZERpc3BhdGNoUG9pbnRlckRvd25PdXRzaWRlRXZlbnQyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaXNQb2ludGVySW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IHRpbWVySWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICBvd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGlja1JlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbb3duZXJEb2N1bWVudCwgaGFuZGxlUG9pbnRlckRvd25PdXRzaWRlXSk7XG4gIHJldHVybiB7XG4gICAgLy8gZW5zdXJlcyB3ZSBjaGVjayBSZWFjdCBjb21wb25lbnQgdHJlZSAobm90IGp1c3QgRE9NIHRyZWUpXG4gICAgb25Qb2ludGVyRG93bkNhcHR1cmU6ICgpID0+IGlzUG9pbnRlckluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gdHJ1ZVxuICB9O1xufVxuZnVuY3Rpb24gdXNlRm9jdXNPdXRzaWRlKG9uRm9jdXNPdXRzaWRlLCBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcz8uZG9jdW1lbnQpIHtcbiAgY29uc3QgaGFuZGxlRm9jdXNPdXRzaWRlID0gdXNlQ2FsbGJhY2tSZWYob25Gb2N1c091dHNpZGUpO1xuICBjb25zdCBpc0ZvY3VzSW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAmJiAhaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50RGV0YWlsID0geyBvcmlnaW5hbEV2ZW50OiBldmVudCB9O1xuICAgICAgICBoYW5kbGVBbmREaXNwYXRjaEN1c3RvbUV2ZW50KEZPQ1VTX09VVFNJREUsIGhhbmRsZUZvY3VzT3V0c2lkZSwgZXZlbnREZXRhaWwsIHtcbiAgICAgICAgICBkaXNjcmV0ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBvd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGhhbmRsZUZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4gb3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBoYW5kbGVGb2N1cyk7XG4gIH0sIFtvd25lckRvY3VtZW50LCBoYW5kbGVGb2N1c091dHNpZGVdKTtcbiAgcmV0dXJuIHtcbiAgICBvbkZvY3VzQ2FwdHVyZTogKCkgPT4gaXNGb2N1c0luc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gdHJ1ZSxcbiAgICBvbkJsdXJDYXB0dXJlOiAoKSA9PiBpc0ZvY3VzSW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hVcGRhdGUoKSB7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KENPTlRFWFRfVVBEQVRFKTtcbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBoYW5kbGVBbmREaXNwYXRjaEN1c3RvbUV2ZW50KG5hbWUsIGhhbmRsZXIsIGRldGFpbCwgeyBkaXNjcmV0ZSB9KSB7XG4gIGNvbnN0IHRhcmdldCA9IGRldGFpbC5vcmlnaW5hbEV2ZW50LnRhcmdldDtcbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogdHJ1ZSwgZGV0YWlsIH0pO1xuICBpZiAoaGFuZGxlcikgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICBpZiAoZGlzY3JldGUpIHtcbiAgICBkaXNwYXRjaERpc2NyZXRlQ3VzdG9tRXZlbnQodGFyZ2V0LCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG52YXIgUm9vdCA9IERpc21pc3NhYmxlTGF5ZXI7XG52YXIgQnJhbmNoID0gRGlzbWlzc2FibGVMYXllckJyYW5jaDtcbmV4cG9ydCB7XG4gIEJyYW5jaCxcbiAgRGlzbWlzc2FibGVMYXllcixcbiAgRGlzbWlzc2FibGVMYXllckJyYW5jaCxcbiAgUm9vdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9mb2N1cy1ndWFyZHMvc3JjL0ZvY3VzR3VhcmRzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG52YXIgY291bnQgPSAwO1xuZnVuY3Rpb24gRm9jdXNHdWFyZHMocHJvcHMpIHtcbiAgdXNlRm9jdXNHdWFyZHMoKTtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuZnVuY3Rpb24gdXNlRm9jdXNHdWFyZHMoKSB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWRnZUd1YXJkcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1yYWRpeC1mb2N1cy1ndWFyZF1cIik7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVkZ2VHdWFyZHNbMF0gPz8gY3JlYXRlRm9jdXNHdWFyZCgpKTtcbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLCBlZGdlR3VhcmRzWzFdID8/IGNyZWF0ZUZvY3VzR3VhcmQoKSk7XG4gICAgY291bnQrKztcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1yYWRpeC1mb2N1cy1ndWFyZF1cIikuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5yZW1vdmUoKSk7XG4gICAgICB9XG4gICAgICBjb3VudC0tO1xuICAgIH07XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvY3VzR3VhcmQoKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJhZGl4LWZvY3VzLWd1YXJkXCIsIFwiXCIpO1xuICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gXCJub25lXCI7XG4gIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgUm9vdCA9IEZvY3VzR3VhcmRzO1xuZXhwb3J0IHtcbiAgRm9jdXNHdWFyZHMsXG4gIFJvb3QsXG4gIHVzZUZvY3VzR3VhcmRzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L2ZvY3VzLXNjb3BlL3NyYy9mb2N1cy1zY29wZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNhbGxiYWNrLXJlZlwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQVVUT0ZPQ1VTX09OX01PVU5UID0gXCJmb2N1c1Njb3BlLmF1dG9Gb2N1c09uTW91bnRcIjtcbnZhciBBVVRPRk9DVVNfT05fVU5NT1VOVCA9IFwiZm9jdXNTY29wZS5hdXRvRm9jdXNPblVubW91bnRcIjtcbnZhciBFVkVOVF9PUFRJT05TID0geyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogdHJ1ZSB9O1xudmFyIEZPQ1VTX1NDT1BFX05BTUUgPSBcIkZvY3VzU2NvcGVcIjtcbnZhciBGb2N1c1Njb3BlID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgbG9vcCA9IGZhbHNlLFxuICAgIHRyYXBwZWQgPSBmYWxzZSxcbiAgICBvbk1vdW50QXV0b0ZvY3VzOiBvbk1vdW50QXV0b0ZvY3VzUHJvcCxcbiAgICBvblVubW91bnRBdXRvRm9jdXM6IG9uVW5tb3VudEF1dG9Gb2N1c1Byb3AsXG4gICAgLi4uc2NvcGVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtjb250YWluZXIsIHNldENvbnRhaW5lcl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgb25Nb3VudEF1dG9Gb2N1cyA9IHVzZUNhbGxiYWNrUmVmKG9uTW91bnRBdXRvRm9jdXNQcm9wKTtcbiAgY29uc3Qgb25Vbm1vdW50QXV0b0ZvY3VzID0gdXNlQ2FsbGJhY2tSZWYob25Vbm1vdW50QXV0b0ZvY3VzUHJvcCk7XG4gIGNvbnN0IGxhc3RGb2N1c2VkRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgKG5vZGUpID0+IHNldENvbnRhaW5lcihub2RlKSk7XG4gIGNvbnN0IGZvY3VzU2NvcGUgPSBSZWFjdC51c2VSZWYoe1xuICAgIHBhdXNlZDogZmFsc2UsXG4gICAgcGF1c2UoKSB7XG4gICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfSxcbiAgICByZXN1bWUoKSB7XG4gICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSkuY3VycmVudDtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhcHBlZCkge1xuICAgICAgbGV0IGhhbmRsZUZvY3VzSW4yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGZvY3VzU2NvcGUucGF1c2VkIHx8ICFjb250YWluZXIpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICBsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCA9IHRhcmdldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb2N1cyhsYXN0Rm9jdXNlZEVsZW1lbnRSZWYuY3VycmVudCwgeyBzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGhhbmRsZUZvY3VzT3V0MiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChmb2N1c1Njb3BlLnBhdXNlZCB8fCAhY29udGFpbmVyKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICBpZiAocmVsYXRlZFRhcmdldCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgIGZvY3VzKGxhc3RGb2N1c2VkRWxlbWVudFJlZi5jdXJyZW50LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgaGFuZGxlTXV0YXRpb25zMiA9IGZ1bmN0aW9uKG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChmb2N1c2VkRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoID4gMCkgZm9jdXMoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBoYW5kbGVGb2N1c0luID0gaGFuZGxlRm9jdXNJbjIsIGhhbmRsZUZvY3VzT3V0ID0gaGFuZGxlRm9jdXNPdXQyLCBoYW5kbGVNdXRhdGlvbnMgPSBoYW5kbGVNdXRhdGlvbnMyO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgaGFuZGxlRm9jdXNJbjIpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGhhbmRsZUZvY3VzT3V0Mik7XG4gICAgICBjb25zdCBtdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zMik7XG4gICAgICBpZiAoY29udGFpbmVyKSBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGhhbmRsZUZvY3VzSW4yKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGhhbmRsZUZvY3VzT3V0Mik7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt0cmFwcGVkLCBjb250YWluZXIsIGZvY3VzU2NvcGUucGF1c2VkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgZm9jdXNTY29wZXNTdGFjay5hZGQoZm9jdXNTY29wZSk7XG4gICAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgY29uc3QgaGFzRm9jdXNlZENhbmRpZGF0ZSA9IGNvbnRhaW5lci5jb250YWlucyhwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgaWYgKCFoYXNGb2N1c2VkQ2FuZGlkYXRlKSB7XG4gICAgICAgIGNvbnN0IG1vdW50RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoQVVUT0ZPQ1VTX09OX01PVU5ULCBFVkVOVF9PUFRJT05TKTtcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoQVVUT0ZPQ1VTX09OX01PVU5ULCBvbk1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobW91bnRFdmVudCk7XG4gICAgICAgIGlmICghbW91bnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgZm9jdXNGaXJzdChyZW1vdmVMaW5rcyhnZXRUYWJiYWJsZUNhbmRpZGF0ZXMoY29udGFpbmVyKSksIHsgc2VsZWN0OiB0cnVlIH0pO1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZvY3VzKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihBVVRPRk9DVVNfT05fTU9VTlQsIG9uTW91bnRBdXRvRm9jdXMpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCB1bm1vdW50RXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoQVVUT0ZPQ1VTX09OX1VOTU9VTlQsIEVWRU5UX09QVElPTlMpO1xuICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKEFVVE9GT0NVU19PTl9VTk1PVU5ULCBvblVubW91bnRBdXRvRm9jdXMpO1xuICAgICAgICAgIGNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KHVubW91bnRFdmVudCk7XG4gICAgICAgICAgaWYgKCF1bm1vdW50RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgZm9jdXMocHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID8/IGRvY3VtZW50LmJvZHksIHsgc2VsZWN0OiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihBVVRPRk9DVVNfT05fVU5NT1VOVCwgb25Vbm1vdW50QXV0b0ZvY3VzKTtcbiAgICAgICAgICBmb2N1c1Njb3Blc1N0YWNrLnJlbW92ZShmb2N1c1Njb3BlKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2NvbnRhaW5lciwgb25Nb3VudEF1dG9Gb2N1cywgb25Vbm1vdW50QXV0b0ZvY3VzLCBmb2N1c1Njb3BlXSk7XG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghbG9vcCAmJiAhdHJhcHBlZCkgcmV0dXJuO1xuICAgICAgaWYgKGZvY3VzU2NvcGUucGF1c2VkKSByZXR1cm47XG4gICAgICBjb25zdCBpc1RhYktleSA9IGV2ZW50LmtleSA9PT0gXCJUYWJcIiAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5O1xuICAgICAgY29uc3QgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGlzVGFiS2V5ICYmIGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcjIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICBjb25zdCBbZmlyc3QsIGxhc3RdID0gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIyKTtcbiAgICAgICAgY29uc3QgaGFzVGFiYmFibGVFbGVtZW50c0luc2lkZSA9IGZpcnN0ICYmIGxhc3Q7XG4gICAgICAgIGlmICghaGFzVGFiYmFibGVFbGVtZW50c0luc2lkZSkge1xuICAgICAgICAgIGlmIChmb2N1c2VkRWxlbWVudCA9PT0gY29udGFpbmVyMikgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzZWRFbGVtZW50ID09PSBsYXN0KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGxvb3ApIGZvY3VzKGZpcnN0LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzZWRFbGVtZW50ID09PSBmaXJzdCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChsb29wKSBmb2N1cyhsYXN0LCB7IHNlbGVjdDogdHJ1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtsb29wLCB0cmFwcGVkLCBmb2N1c1Njb3BlLnBhdXNlZF1cbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyB0YWJJbmRleDogLTEsIC4uLnNjb3BlUHJvcHMsIHJlZjogY29tcG9zZWRSZWZzLCBvbktleURvd246IGhhbmRsZUtleURvd24gfSk7XG59KTtcbkZvY3VzU2NvcGUuZGlzcGxheU5hbWUgPSBGT0NVU19TQ09QRV9OQU1FO1xuZnVuY3Rpb24gZm9jdXNGaXJzdChjYW5kaWRhdGVzLCB7IHNlbGVjdCA9IGZhbHNlIH0gPSB7fSkge1xuICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgZm9jdXMoY2FuZGlkYXRlLCB7IHNlbGVjdCB9KTtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KSByZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhYmJhYmxlRWRnZXMoY29udGFpbmVyKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBnZXRUYWJiYWJsZUNhbmRpZGF0ZXMoY29udGFpbmVyKTtcbiAgY29uc3QgZmlyc3QgPSBmaW5kVmlzaWJsZShjYW5kaWRhdGVzLCBjb250YWluZXIpO1xuICBjb25zdCBsYXN0ID0gZmluZFZpc2libGUoY2FuZGlkYXRlcy5yZXZlcnNlKCksIGNvbnRhaW5lcik7XG4gIHJldHVybiBbZmlyc3QsIGxhc3RdO1xufVxuZnVuY3Rpb24gZ2V0VGFiYmFibGVDYW5kaWRhdGVzKGNvbnRhaW5lcikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGNvbnRhaW5lciwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHtcbiAgICBhY2NlcHROb2RlOiAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgaXNIaWRkZW5JbnB1dCA9IG5vZGUudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIG5vZGUudHlwZSA9PT0gXCJoaWRkZW5cIjtcbiAgICAgIGlmIChub2RlLmRpc2FibGVkIHx8IG5vZGUuaGlkZGVuIHx8IGlzSGlkZGVuSW5wdXQpIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgcmV0dXJuIG5vZGUudGFiSW5kZXggPj0gMCA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuICB9KTtcbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSBub2Rlcy5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGZpbmRWaXNpYmxlKGVsZW1lbnRzLCBjb250YWluZXIpIHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKCFpc0hpZGRlbihlbGVtZW50LCB7IHVwVG86IGNvbnRhaW5lciB9KSkgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSGlkZGVuKG5vZGUsIHsgdXBUbyB9KSB7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHJldHVybiB0cnVlO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmICh1cFRvICE9PSB2b2lkIDAgJiYgbm9kZSA9PT0gdXBUbykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgPT09IFwibm9uZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0YWJsZUlucHV0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIFwic2VsZWN0XCIgaW4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGZvY3VzKGVsZW1lbnQsIHsgc2VsZWN0ID0gZmFsc2UgfSA9IHt9KSB7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuZm9jdXMpIHtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgIGlmIChlbGVtZW50ICE9PSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgJiYgaXNTZWxlY3RhYmxlSW5wdXQoZWxlbWVudCkgJiYgc2VsZWN0KVxuICAgICAgZWxlbWVudC5zZWxlY3QoKTtcbiAgfVxufVxudmFyIGZvY3VzU2NvcGVzU3RhY2sgPSBjcmVhdGVGb2N1c1Njb3Blc1N0YWNrKCk7XG5mdW5jdGlvbiBjcmVhdGVGb2N1c1Njb3Blc1N0YWNrKCkge1xuICBsZXQgc3RhY2sgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBhZGQoZm9jdXNTY29wZSkge1xuICAgICAgY29uc3QgYWN0aXZlRm9jdXNTY29wZSA9IHN0YWNrWzBdO1xuICAgICAgaWYgKGZvY3VzU2NvcGUgIT09IGFjdGl2ZUZvY3VzU2NvcGUpIHtcbiAgICAgICAgYWN0aXZlRm9jdXNTY29wZT8ucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrID0gYXJyYXlSZW1vdmUoc3RhY2ssIGZvY3VzU2NvcGUpO1xuICAgICAgc3RhY2sudW5zaGlmdChmb2N1c1Njb3BlKTtcbiAgICB9LFxuICAgIHJlbW92ZShmb2N1c1Njb3BlKSB7XG4gICAgICBzdGFjayA9IGFycmF5UmVtb3ZlKHN0YWNrLCBmb2N1c1Njb3BlKTtcbiAgICAgIHN0YWNrWzBdPy5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhcnJheVJlbW92ZShhcnJheSwgaXRlbSkge1xuICBjb25zdCB1cGRhdGVkQXJyYXkgPSBbLi4uYXJyYXldO1xuICBjb25zdCBpbmRleCA9IHVwZGF0ZWRBcnJheS5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdXBkYXRlZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpbmtzKGl0ZW1zKSB7XG4gIHJldHVybiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udGFnTmFtZSAhPT0gXCJBXCIpO1xufVxudmFyIFJvb3QgPSBGb2N1c1Njb3BlO1xuZXhwb3J0IHtcbiAgRm9jdXNTY29wZSxcbiAgUm9vdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3VzZS1sYXlvdXQtZWZmZWN0L3NyYy91c2VMYXlvdXRFZmZlY3QudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VMYXlvdXRFZmZlY3QyID0gQm9vbGVhbihnbG9iYWxUaGlzPy5kb2N1bWVudCkgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiAoKSA9PiB7XG59O1xuZXhwb3J0IHtcbiAgdXNlTGF5b3V0RWZmZWN0MiBhcyB1c2VMYXlvdXRFZmZlY3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9pZC9zcmMvaWQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbnZhciB1c2VSZWFjdElkID0gUmVhY3RbXCJ1c2VJZFwiLnRvU3RyaW5nKCldIHx8ICgoKSA9PiB2b2lkIDApO1xudmFyIGNvdW50ID0gMDtcbmZ1bmN0aW9uIHVzZUlkKGRldGVybWluaXN0aWNJZCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKHVzZVJlYWN0SWQoKSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkZXRlcm1pbmlzdGljSWQpIHNldElkKChyZWFjdElkKSA9PiByZWFjdElkID8/IFN0cmluZyhjb3VudCsrKSk7XG4gIH0sIFtkZXRlcm1pbmlzdGljSWRdKTtcbiAgcmV0dXJuIGRldGVybWluaXN0aWNJZCB8fCAoaWQgPyBgcmFkaXgtJHtpZH1gIDogXCJcIik7XG59XG5leHBvcnQge1xuICB1c2VJZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8qKlxuICogQ3VzdG9tIHBvc2l0aW9uaW5nIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3ZpcnR1YWwtZWxlbWVudHNcbiAqL1xuXG5jb25zdCBzaWRlcyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5jb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsICdlbmQnXTtcbmNvbnN0IHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1swXSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1sxXSksIFtdKTtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSB2ID0+ICh7XG4gIHg6IHYsXG4gIHk6IHZcbn0pO1xuY29uc3Qgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gY2xhbXAoc3RhcnQsIHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIG1heChzdGFydCwgbWluKHZhbHVlLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHZhbHVlLCBwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd5JyA6ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiBnZXRPcHBvc2l0ZUF4aXMoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSk7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpIHtcbiAgaWYgKHJ0bCA9PT0gdm9pZCAwKSB7XG4gICAgcnRsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IGFsaWdubWVudEF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiBbbWFpbkFsaWdubWVudFNpZGUsIGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKV07XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBhbGlnbm1lbnQgPT4gb3Bwb3NpdGVBbGlnbm1lbnRNYXBbYWxpZ25tZW50XSk7XG59XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgY29uc3QgbHIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgY29uc3QgcmwgPSBbJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgY29uc3QgdGIgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgY29uc3QgYnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybCA6IGxyO1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsciA6IHJsO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGIgOiBidDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiIsImltcG9ydCB7IGdldFNpZGVBeGlzLCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBeGlzTGVuZ3RoLCBnZXRTaWRlLCBnZXRBbGlnbm1lbnQsIGV2YWx1YXRlLCBnZXRQYWRkaW5nT2JqZWN0LCByZWN0VG9DbGllbnRSZWN0LCBtaW4sIGNsYW1wLCBwbGFjZW1lbnRzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIHNpZGVzLCBtYXgsIGdldE9wcG9zaXRlQXhpcyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5leHBvcnQgeyByZWN0VG9DbGllbnRSZWN0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09ICd5JztcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBjb21tb25BbGlnbiA9IHJlZmVyZW5jZVthbGlnbkxlbmd0aF0gLyAyIC0gZmxvYXRpbmdbYWxpZ25MZW5ndGhdIC8gMjtcbiAgbGV0IGNvb3JkcztcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlbmQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZXhwb3J0IGRvZXMgbm90IGhhdmUgYW55IGBwbGF0Zm9ybWAgaW50ZXJmYWNlIGxvZ2ljLiBZb3Ugd2lsbCBuZWVkIHRvXG4gKiB3cml0ZSBvbmUgZm9yIHRoZSBwbGF0Zm9ybSB5b3UgYXJlIHVzaW5nIEZsb2F0aW5nIFVJIHdpdGguXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IGFzeW5jIChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm1cbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgdmFsaWRNaWRkbGV3YXJlID0gbWlkZGxld2FyZS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRNaWRkbGV3YXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpXTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBuZXh0WCxcbiAgICAgIHk6IG5leHRZLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc2V0XG4gICAgfSA9IGF3YWl0IGZuKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0ge1xuICAgICAgLi4ubWlkZGxld2FyZURhdGEsXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgLi4ubWlkZGxld2FyZURhdGFbbmFtZV0sXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG4gICAgICBpZiAodHlwZW9mIHJlc2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVzZXQucGxhY2VtZW50KSB7XG4gICAgICAgICAgc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2V0LnJlY3RzKSB7XG4gICAgICAgICAgcmVjdHMgPSByZXNldC5yZWN0cyA9PT0gdHJ1ZSA/IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBmbG9hdGluZyxcbiAgICAgICAgICAgIHN0cmF0ZWd5XG4gICAgICAgICAgfSkgOiByZXNldC5yZWN0cztcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoLFxuICAgIGhlaWdodDogcmVjdHMuZmxvYXRpbmcuaGVpZ2h0XG4gIH0gOiByZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBvZmZzZXRTY2FsZSA9IChhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkpID8gKGF3YWl0IChwbGF0Zm9ybS5nZXRTY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0U2NhbGUob2Zmc2V0UGFyZW50KSkpIHx8IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfSA6IHtcbiAgICB4OiAxLFxuICAgIHk6IDFcbiAgfTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgYm90dG9tOiAoZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSAvIG9mZnNldFNjYWxlLnksXG4gICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwbGFjZW1lbnQsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtaWRkbGV3YXJlRGF0YVxuICAgIH0gPSBzdGF0ZTtcbiAgICAvLyBTaW5jZSBgZWxlbWVudGAgaXMgcmVxdWlyZWQsIHdlIGRvbid0IFBhcnRpYWw8PiB0aGUgdHlwZS5cbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50LFxuICAgICAgcGFkZGluZyA9IDBcbiAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpIHx8IHt9O1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzWUF4aXMgPSBheGlzID09PSAneSc7XG4gICAgY29uc3QgbWluUHJvcCA9IGlzWUF4aXMgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gaXNZQXhpcyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBjbGllbnRQcm9wID0gaXNZQXhpcyA/ICdjbGllbnRIZWlnaHQnIDogJ2NsaWVudFdpZHRoJztcbiAgICBjb25zdCBlbmREaWZmID0gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gKyByZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBjb29yZHNbYXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGNvb3Jkc1theGlzXSAtIHJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgICBjb25zdCBhcnJvd09mZnNldFBhcmVudCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50KSk7XG4gICAgbGV0IGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGFycm93T2Zmc2V0UGFyZW50W2NsaWVudFByb3BdIDogMDtcblxuICAgIC8vIERPTSBwbGF0Zm9ybSBjYW4gcmV0dXJuIGB3aW5kb3dgIGFzIHRoZSBgb2Zmc2V0UGFyZW50YC5cbiAgICBpZiAoIWNsaWVudFNpemUgfHwgIShhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoYXJyb3dPZmZzZXRQYXJlbnQpKSkpIHtcbiAgICAgIGNsaWVudFNpemUgPSBlbGVtZW50cy5mbG9hdGluZ1tjbGllbnRQcm9wXSB8fCByZWN0cy5mbG9hdGluZ1tsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAgIC8vIElmIHRoZSBwYWRkaW5nIGlzIGxhcmdlIGVub3VnaCB0aGF0IGl0IGNhdXNlcyB0aGUgYXJyb3cgdG8gbm8gbG9uZ2VyIGJlXG4gICAgLy8gY2VudGVyZWQsIG1vZGlmeSB0aGUgcGFkZGluZyBzbyB0aGF0IGl0IGlzIGNlbnRlcmVkLlxuICAgIGNvbnN0IGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiAtIDE7XG4gICAgY29uc3QgbWluUGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21pblByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWF4UHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzLlxuICAgIGNvbnN0IG1pbiQxID0gbWluUGFkZGluZztcbiAgICBjb25zdCBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLSBtYXhQYWRkaW5nO1xuICAgIGNvbnN0IGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gICAgY29uc3Qgb2Zmc2V0ID0gY2xhbXAobWluJDEsIGNlbnRlciwgbWF4KTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGwgZW5vdWdoIHRoYXQgdGhlIGFycm93J3MgcGFkZGluZyBjYXVzZXMgaXQgdG9cbiAgICAvLyB0byBwb2ludCB0byBub3RoaW5nIGZvciBhbiBhbGlnbmVkIHBsYWNlbWVudCwgYWRqdXN0IHRoZSBvZmZzZXQgb2YgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCBpdHNlbGYuIFRvIGVuc3VyZSBgc2hpZnQoKWAgY29udGludWVzIHRvIHRha2UgYWN0aW9uLFxuICAgIC8vIGEgc2luZ2xlIHJlc2V0IGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgaXMgdHJ1ZS5cbiAgICBjb25zdCBzaG91bGRBZGRPZmZzZXQgPSAhbWlkZGxld2FyZURhdGEuYXJyb3cgJiYgZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT0gbnVsbCAmJiBjZW50ZXIgIT09IG9mZnNldCAmJiByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSAvIDIgLSAoY2VudGVyIDwgbWluJDEgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZykgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgPCAwO1xuICAgIGNvbnN0IGFsaWdubWVudE9mZnNldCA9IHNob3VsZEFkZE9mZnNldCA/IGNlbnRlciA8IG1pbiQxID8gY2VudGVyIC0gbWluJDEgOiBjZW50ZXIgLSBtYXggOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSArIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0IC0gYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgICAuLi4oc2hvdWxkQWRkT2Zmc2V0ICYmIHtcbiAgICAgICAgICBhbGlnbm1lbnRPZmZzZXRcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZXNldDogc2hvdWxkQWRkT2Zmc2V0XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykge1xuICBjb25zdCBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50ID0gYWxpZ25tZW50ID8gWy4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCksIC4uLmFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgIT09IGFsaWdubWVudCldIDogYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRTaWRlKHBsYWNlbWVudCkgPT09IHBsYWNlbWVudCk7XG4gIHJldHVybiBhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50LmZpbHRlcihwbGFjZW1lbnQgPT4ge1xuICAgIGlmIChhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50IHx8IChhdXRvQWxpZ25tZW50ID8gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSAhPT0gcGxhY2VtZW50IDogZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXV0b1BsYWNlbWVudCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX3BsYWNlbWVudHNUaGF0Rml0T25FO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyxcbiAgICAgICAgYXV0b0FsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHMkMSA9IGFsaWdubWVudCAhPT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRQbGFjZW1lbnRzID09PSBwbGFjZW1lbnRzID8gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQgfHwgbnVsbCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIDogYWxsb3dlZFBsYWNlbWVudHM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkYXV0b1AgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QLmluZGV4KSB8fCAwO1xuICAgICAgY29uc3QgY3VycmVudFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXhdO1xuICAgICAgaWYgKGN1cnJlbnRQbGFjZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlnbm1lbnRTaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpO1xuXG4gICAgICAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZS5cbiAgICAgIGlmIChwbGFjZW1lbnQgIT09IGN1cnJlbnRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnRzJDFbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3dzID0gW292ZXJmbG93W2dldFNpZGUoY3VycmVudFBsYWNlbWVudCldLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1swXV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzFdXV07XG4gICAgICBjb25zdCBhbGxPdmVyZmxvd3MgPSBbLi4uKCgoX21pZGRsZXdhcmVEYXRhJGF1dG9QMiA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AyLm92ZXJmbG93cykgfHwgW10pLCB7XG4gICAgICAgIHBsYWNlbWVudDogY3VycmVudFBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzOiBjdXJyZW50T3ZlcmZsb3dzXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICAgIC8vIFRoZXJlIGFyZSBtb3JlIHBsYWNlbWVudHMgdG8gY2hlY2suXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UgPSBhbGxPdmVyZmxvd3MubWFwKGQgPT4ge1xuICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQoZC5wbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gW2QucGxhY2VtZW50LCBhbGlnbm1lbnQgJiYgY3Jvc3NBeGlzID9cbiAgICAgICAgLy8gQ2hlY2sgYWxvbmcgdGhlIG1haW5BeGlzIGFuZCBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBkLm92ZXJmbG93cy5zbGljZSgwLCAyKS5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICsgdiwgMCkgOlxuICAgICAgICAvLyBDaGVjayBvbmx5IHRoZSBtYWluQXhpcy5cbiAgICAgICAgZC5vdmVyZmxvd3NbMF0sIGQub3ZlcmZsb3dzXTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSA9IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZS5maWx0ZXIoZCA9PiBkWzJdLnNsaWNlKDAsXG4gICAgICAvLyBBbGlnbmVkIHBsYWNlbWVudHMgc2hvdWxkIG5vdCBjaGVjayB0aGVpciBvcHBvc2l0ZSBjcm9zc0F4aXNcbiAgICAgIC8vIHNpZGUuXG4gICAgICBnZXRBbGlnbm1lbnQoZFswXSkgPyAyIDogMykuZXZlcnkodiA9PiB2IDw9IDApKTtcbiAgICAgIGNvbnN0IHJlc2V0UGxhY2VtZW50ID0gKChfcGxhY2VtZW50c1RoYXRGaXRPbkUgPSBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1RoYXRGaXRPbkVbMF0pIHx8IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZVswXVswXTtcbiAgICAgIGlmIChyZXNldFBsYWNlbWVudCAhPT0gcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZsaXAnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWUsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gJ2Jlc3RGaXQnLFxuICAgICAgICBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gJ25vbmUnLFxuICAgICAgICBmbGlwQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gICAgICAvLyBJZiBhIHJlc2V0IGJ5IHRoZSBhcnJvdyB3YXMgY2F1c2VkIGR1ZSB0byBhbiBhbGlnbm1lbnQgb2Zmc2V0IGJlaW5nXG4gICAgICAvLyBhZGRlZCwgd2Ugc2hvdWxkIHNraXAgYW55IGxvZ2ljIG5vdyBzaW5jZSBgZmxpcCgpYCBoYXMgYWxyZWFkeSBkb25lIGl0c1xuICAgICAgLy8gd29yay5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjU0OSNpc3N1ZWNvbW1lbnQtMTcxOTYwMTY0M1xuICAgICAgaWYgKChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsU2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhpbml0aWFsUGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9IGdldFNpZGUoaW5pdGlhbFBsYWNlbWVudCkgPT09IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICBjb25zdCBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcEFsaWdubWVudCA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZFBsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09ICdub25lJztcbiAgICAgIGlmICghc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzICYmIGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyMiA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSAneSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50LFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgY29uc3QgbWFpbkF4aXNNdWx0aSA9IFsnbGVmdCcsICd0b3AnXS5pbmNsdWRlcyhzaWRlKSA/IC0xIDogMTtcbiAgY29uc3QgY3Jvc3NBeGlzTXVsdGkgPSBydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgY29uc3QgcmF3VmFsdWUgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZS5tYWluQXhpcyB8fCAwLFxuICAgIGNyb3NzQXhpczogcmF3VmFsdWUuY3Jvc3NBeGlzIHx8IDAsXG4gICAgYWxpZ25tZW50QXhpczogcmF3VmFsdWUuYWxpZ25tZW50QXhpc1xuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5LFxuICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfc3RhdGUkbWlkZGxld2FyZURhdGEsIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gbWluKGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IG1pbih3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV0sIG1heGltdW1DbGlwcGluZ1dpZHRoKTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEuZW5hYmxlZC54KSB7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEyLmVuYWJsZWQueSkge1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iLCJmdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBNb2NrZWQgbm9kZXMgaW4gdGVzdGluZyBlbnZpcm9ubWVudHMgbWF5IG5vdCBiZSBpbnN0YW5jZXMgb2YgTm9kZS4gQnlcbiAgLy8gcmV0dXJuaW5nIGAjZG9jdW1lbnRgIGFuIGluZmluaXRlIGxvb3Agd29uJ3Qgb2NjdXIuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjMxN1xuICByZXR1cm4gJyNkb2N1bWVudCc7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgfHwgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIChfcmVmID0gKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWYuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuTm9kZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KHZhbHVlKSB7XG4gIGlmICghaGFzV2luZG93KCkgfHwgdHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVsnaW5saW5lJywgJ2NvbnRlbnRzJ10uaW5jbHVkZXMoZGlzcGxheSk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNUb3BMYXllcihlbGVtZW50KSB7XG4gIHJldHVybiBbJzpwb3BvdmVyLW9wZW4nLCAnOm1vZGFsJ10uc29tZShzZWxlY3RvciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudE9yQ3NzKSB7XG4gIGNvbnN0IHdlYmtpdCA9IGlzV2ViS2l0KCk7XG4gIGNvbnN0IGNzcyA9IGlzRWxlbWVudChlbGVtZW50T3JDc3MpID8gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50T3JDc3MpIDogZWxlbWVudE9yQ3NzO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdHJhbnNmb3Jtcy0yLyNpbmRpdmlkdWFsLXRyYW5zZm9ybXNcbiAgcmV0dXJuIFsndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAncGVyc3BlY3RpdmUnXS5zb21lKHZhbHVlID0+IGNzc1t2YWx1ZV0gPyBjc3NbdmFsdWVdICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgKGNzcy5jb250YWluZXJUeXBlID8gY3NzLmNvbnRhaW5lclR5cGUgIT09ICdub3JtYWwnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgWyd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlJywgJ3NjYWxlJywgJ3JvdGF0ZScsICdwZXJzcGVjdGl2ZScsICdmaWx0ZXInXS5zb21lKHZhbHVlID0+IChjc3Mud2lsbENoYW5nZSB8fCAnJykuaW5jbHVkZXModmFsdWUpKSB8fCBbJ3BhaW50JywgJ2xheW91dCcsICdzdHJpY3QnLCAnY29udGVudCddLnNvbWUodmFsdWUgPT4gKGNzcy5jb250YWluIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoaXNUb3BMYXllcihjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIGlmICh0eXBlb2YgQ1NTID09PSAndW5kZWZpbmVkJyB8fCAhQ1NTLnN1cHBvcnRzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBDU1Muc3VwcG9ydHMoJy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyJywgJ25vbmUnKTtcbn1cbmZ1bmN0aW9uIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9XG4gIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICBub2RlLmFzc2lnbmVkU2xvdCB8fFxuICAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgbm9kZS5wYXJlbnROb2RlIHx8XG4gIC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gIGlzU2hhZG93Um9vdChub2RlKSAmJiBub2RlLmhvc3QgfHxcbiAgLy8gRmFsbGJhY2suXG4gIGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudCA/IG5vZGUub3duZXJEb2N1bWVudC5ib2R5IDogbm9kZS5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBpZiAodHJhdmVyc2VJZnJhbWVzID09PSB2b2lkIDApIHtcbiAgICB0cmF2ZXJzZUlmcmFtZXMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudDIgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50Mi5ib2R5KTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQod2luKTtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSwgZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKGZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQod2luKSB7XG4gIHJldHVybiB3aW4ucGFyZW50ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih3aW4ucGFyZW50KSA/IHdpbi5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBnZXRDb250YWluaW5nQmxvY2ssIGdldERvY3VtZW50RWxlbWVudCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNUb3BMYXllciwgaXNXZWJLaXQgfTtcbiIsImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGRldGVjdE92ZXJmbG93IGFzIGRldGVjdE92ZXJmbG93JDEsIG9mZnNldCBhcyBvZmZzZXQkMSwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgaGlkZSBhcyBoaWRlJDEsIGFycm93IGFzIGFycm93JDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmltcG9ydCB7IHJvdW5kLCBjcmVhdGVDb29yZHMsIG1heCwgbWluLCBmbG9vciB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5pbXBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBpc0hUTUxFbGVtZW50LCBpc0VsZW1lbnQsIGdldFdpbmRvdywgaXNXZWJLaXQsIGdldEZyYW1lRWxlbWVudCwgZ2V0Tm9kZVNjcm9sbCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBpc1RvcExheWVyLCBnZXROb2RlTmFtZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzQ29udGFpbmluZ0Jsb2NrLCBpc1RhYmxlRWxlbWVudCwgZ2V0Q29udGFpbmluZ0Jsb2NrIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5leHBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudFdpbiA9IHdpbjtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB3aGlsZSAoY3VycmVudElGcmFtZSAmJiBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0V2luICE9PSBjdXJyZW50V2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudFdpbiA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKTtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG4vLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4vLyBpbmNvcnJlY3QgZm9yIFJUTC5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCwgcmVjdCkge1xuICBjb25zdCBsZWZ0U2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGxlZnRTY3JvbGw7XG4gIH1cbiAgcmV0dXJuIHJlY3QubGVmdCArIGxlZnRTY3JvbGw7XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIGlnbm9yZVNjcm9sbGJhclgpIHtcbiAgaWYgKGlnbm9yZVNjcm9sbGJhclggPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZVNjcm9sbGJhclggPSBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sUmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IGh0bWxSZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIChpZ25vcmVTY3JvbGxiYXJYID8gMCA6XG4gIC8vIFJUTCA8Ym9keT4gc2Nyb2xsYmFyLlxuICBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCwgaHRtbFJlY3QpKTtcbiAgY29uc3QgeSA9IGh0bWxSZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3A7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogZmFsc2U7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgY29uc3QgaHRtbE9mZnNldCA9IGRvY3VtZW50RWxlbWVudCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQgPyBnZXRIVE1MT2Zmc2V0KGRvY3VtZW50RWxlbWVudCwgc2Nyb2xsLCB0cnVlKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCArIGh0bWxPZmZzZXQueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnkgKyBodG1sT2Zmc2V0LnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG4vLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlLlxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICBjb25zdCB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5LnNjcm9sbFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkuY2xpZW50SGVpZ2h0KTtcbiAgbGV0IHggPSAtc2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXNjcm9sbC5zY3JvbGxUb3A7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5LmNsaWVudFdpZHRoKSAtIHdpZHRoO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgY29uc3QgdmlzdWFsVmlld3BvcnRCYXNlZCA9IGlzV2ViS2l0KCk7XG4gICAgaWYgKCF2aXN1YWxWaWV3cG9ydEJhc2VkIHx8IHZpc3VhbFZpZXdwb3J0QmFzZWQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8vIFJldHVybnMgdGhlIGlubmVyIGNsaWVudCByZWN0LCBzdWJ0cmFjdGluZyBzY3JvbGxiYXJzIGlmIHByZXNlbnQuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgY29uc3Qgc2NhbGUgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0U2NhbGUoZWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjYWxlLng7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NhbGUueTtcbiAgY29uc3QgeCA9IGxlZnQgKiBzY2FsZS54O1xuICBjb25zdCB5ID0gdG9wICogc2NhbGUueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpIHtcbiAgbGV0IHJlY3Q7XG4gIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgcmVjdCA9IGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSk7XG4gIH0gZWxzZSBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ2RvY3VtZW50Jykge1xuICAgIHJlY3QgPSBnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgfSBlbHNlIGlmIChpc0VsZW1lbnQoY2xpcHBpbmdBbmNlc3RvcikpIHtcbiAgICByZWN0ID0gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpO1xuICAgIHJlY3QgPSB7XG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnksXG4gICAgICB3aWR0aDogY2xpcHBpbmdBbmNlc3Rvci53aWR0aCxcbiAgICAgIGhlaWdodDogY2xpcHBpbmdBbmNlc3Rvci5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBpc1RvcExheWVyKGVsZW1lbnQpID8gW10gOiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIC8vIElmIHRoZSA8Ym9keT4gc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgKGUuZy4gUlRMIHN5c3RlbXMpLiBVc2VcbiAgICAgIC8vIEZpcmVmb3ggd2l0aCBsYXlvdXQuc2Nyb2xsYmFyLnNpZGUgPSAzIGluIGFib3V0OmNvbmZpZyB0byB0ZXN0IHRoaXMuXG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCAtIGh0bWxPZmZzZXQueDtcbiAgY29uc3QgeSA9IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSAtIGh0bWxPZmZzZXQueTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYyc7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocG9seWZpbGwpIHtcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIH1cbiAgbGV0IHJhd09mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gIC8vIEZpcmVmb3ggcmV0dXJucyB0aGUgPGh0bWw+IGVsZW1lbnQgYXMgdGhlIG9mZnNldFBhcmVudCBpZiBpdCdzIG5vbi1zdGF0aWMsXG4gIC8vIHdoaWxlIENocm9tZSBhbmQgU2FmYXJpIHJldHVybiB0aGUgPGJvZHk+IGVsZW1lbnQuIFRoZSA8Ym9keT4gZWxlbWVudCBtdXN0XG4gIC8vIGJlIHVzZWQgdG8gcGVyZm9ybSB0aGUgY29ycmVjdCBjYWxjdWxhdGlvbnMgZXZlbiBpZiB0aGUgPGh0bWw+IGVsZW1lbnQgaXNcbiAgLy8gbm9uLXN0YXRpYy5cbiAgaWYgKGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSA9PT0gcmF3T2Zmc2V0UGFyZW50KSB7XG4gICAgcmF3T2Zmc2V0UGFyZW50ID0gcmF3T2Zmc2V0UGFyZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuICByZXR1cm4gcmF3T2Zmc2V0UGFyZW50O1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKGlzVG9wTGF5ZXIoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIGxldCBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIHdoaWxlIChzdmdPZmZzZXRQYXJlbnQgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KHN2Z09mZnNldFBhcmVudCkgJiYgIWlzU3RhdGljUG9zaXRpb25lZChzdmdPZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBzdmdPZmZzZXRQYXJlbnQ7XG4gICAgICB9XG4gICAgICBzdmdPZmZzZXRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKHN2Z09mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aW47XG4gIH1cbiAgbGV0IG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpO1xuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgaXNMYXN0VHJhdmVyc2FibGVOb2RlKG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpIHtcbiAgICByZXR1cm4gd2luO1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbjtcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgY29uc3QgZmxvYXRpbmdEaW1lbnNpb25zID0gYXdhaXQgZ2V0RGltZW5zaW9uc0ZuKGRhdGEuZmxvYXRpbmcpO1xuICByZXR1cm4ge1xuICAgIHJlZmVyZW5jZTogZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZGF0YS5yZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGRhdGEuZmxvYXRpbmcpLCBkYXRhLnN0cmF0ZWd5KSxcbiAgICBmbG9hdGluZzoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZmxvYXRpbmdEaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBmbG9hdGluZ0RpbWVuc2lvbnMuaGVpZ2h0XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gaXNSVEwoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnO1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldEVsZW1lbnRSZWN0cyxcbiAgZ2V0Q2xpZW50UmVjdHMsXG4gIGdldERpbWVuc2lvbnMsXG4gIGdldFNjYWxlLFxuICBpc0VsZW1lbnQsXG4gIGlzUlRMXG59O1xuXG5mdW5jdGlvbiByZWN0c0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEud2lkdGggPT09IGIud2lkdGggJiYgYS5oZWlnaHQgPT09IGIuaGVpZ2h0O1xufVxuXG4vLyBodHRwczovL3NhbXRob3IuYXUvMjAyMS9vYnNlcnZpbmctZG9tL1xuZnVuY3Rpb24gb2JzZXJ2ZU1vdmUoZWxlbWVudCwgb25Nb3ZlKSB7XG4gIGxldCBpbyA9IG51bGw7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGNvbnN0IHJvb3QgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgdmFyIF9pbztcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAoX2lvID0gaW8pID09IG51bGwgfHwgX2lvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbjtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIG9uTW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zZXRUb3AgPSBmbG9vcih0b3ApO1xuICAgIGNvbnN0IGluc2V0UmlnaHQgPSBmbG9vcihyb290LmNsaWVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCkpO1xuICAgIGNvbnN0IGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSk7XG4gICAgY29uc3QgaW5zZXRMZWZ0ID0gZmxvb3IobGVmdCk7XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IC1pbnNldFRvcCArIFwicHggXCIgKyAtaW5zZXRSaWdodCArIFwicHggXCIgKyAtaW5zZXRCb3R0b20gKyBcInB4IFwiICsgLWluc2V0TGVmdCArIFwicHhcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbWF4KDAsIG1pbigxLCB0aHJlc2hvbGQpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgaXNGaXJzdFVwZGF0ZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF0aW8pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGNsaXBwZWQsIHRoZSByYXRpbyBpcyAwLiBUaHJvdHRsZSB0aGUgcmVmcmVzaFxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiB1cGRhdGVzLlxuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaChmYWxzZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmF0aW8gPT09IDEgJiYgIXJlY3RzQXJlRXF1YWwoZWxlbWVudFJlY3RGb3JSb290TWFyZ2luLCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSkge1xuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZXZlbiB0aG91Z2ggdGhlIHJhdGlvIGlzIHJlcG9ydGVkIGFzIDEsIHRoZVxuICAgICAgICAvLyBlbGVtZW50IGlzIG5vdCBhY3R1YWxseSBmdWxseSB3aXRoaW4gdGhlIEludGVyc2VjdGlvbk9ic2VydmVyJ3Mgcm9vdFxuICAgICAgICAvLyBhcmVhIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiB1bmRlciBwZXJmb3JtYW5jZSBjb25zdHJhaW50cy4gVGhpcyBtYXlcbiAgICAgICAgLy8gYmUgYSBidWcgaW4gdGhlIGJyb3dzZXIncyBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbi4gVG9cbiAgICAgICAgLy8gd29yayBhcm91bmQgdGhpcywgd2UgY29tcGFyZSB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIHJlY3Qgbm93IHdpdGhcbiAgICAgICAgLy8gd2hhdCBpdCB3YXMgYXQgdGhlIHRpbWUgd2UgY3JlYXRlZCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuIElmIHRoZXlcbiAgICAgICAgLy8gYXJlIG5vdCBlcXVhbCB0aGVuIHRoZSBlbGVtZW50IG1vdmVkLCBzbyB3ZSByZWZyZXNoLlxuICAgICAgICByZWZyZXNoKCk7XG4gICAgICB9XG4gICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBhIGBkb2N1bWVudGAgYXMgdGhlIHJvb3QgYW5kIHdpbGwgdGhyb3cgYW5cbiAgICAvLyBlcnJvci5cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IHJvb3Qub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlvLm9ic2VydmUoZWxlbWVudCk7XG4gIH1cbiAgcmVmcmVzaCh0cnVlKTtcbiAgcmV0dXJuIGNsZWFudXA7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIG5lY2Vzc2FyeS5cbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG1vdW50ZWQgb24gdGhlIERPTSBvclxuICogdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQHJldHVybnMgY2xlYW51cCBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBpbnZva2VkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9yIGhpZGRlbiBmcm9tIHRoZSBzY3JlZW4uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbCA9IHRydWUsXG4gICAgYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgbGF5b3V0U2hpZnQgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLihyZWZlcmVuY2VFbCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZUVsKSA6IFtdKSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMTtcbiAgbGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgaWYgKGVsZW1lbnRSZXNpemUpIHtcbiAgICByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfcmVmID0+IHtcbiAgICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgICAgaWYgKGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdXBkYXRlIGxvb3BzIHdoZW4gdXNpbmcgdGhlIGBzaXplYCBtaWRkbGV3YXJlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3NDBcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVvYnNlcnZlRnJhbWUpO1xuICAgICAgICByZW9ic2VydmVGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9yZXNpemVPYnNlcnZlcjtcbiAgICAgICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAhcmVjdHNBcmVFcXVhbChwcmV2UmVmUmVjdCwgbmV4dFJlZlJlY3QpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5jb25zdCBkZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93JDE7XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IG9mZnNldCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGF1dG9QbGFjZW1lbnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gc2hpZnQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSBmbGlwJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IHNpemUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBoaWRlJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gYXJyb3ckMTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gaW5saW5lJDE7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBsaW1pdFNoaWZ0JDE7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBwbGFjZSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICogbmV4dCB0byBhIGdpdmVuIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSAocmVmZXJlbmNlLCBmbG9hdGluZywgb3B0aW9ucykgPT4ge1xuICAvLyBUaGlzIGNhY2hlcyB0aGUgZXhwZW5zaXZlIGBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnNgIGZ1bmN0aW9uIHNvIHRoYXRcbiAgLy8gbXVsdGlwbGUgbGlmZWN5Y2xlIHJlc2V0cyByZS11c2UgdGhlIHNhbWUgcmVzdWx0LiBJdCBvbmx5IGxpdmVzIGZvciBhXG4gIC8vIHNpbmdsZSBjYWxsLiBJZiBvdGhlciBmdW5jdGlvbnMgYmVjb21lIGV4cGVuc2l2ZSwgd2UgY2FuIGFkZCB0aGVtIGFzIHdlbGwuXG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH07XG4iLCJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24sIGFycm93IGFzIGFycm93JDIsIG9mZnNldCBhcyBvZmZzZXQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIGhpZGUgYXMgaGlkZSQxLCBpbmxpbmUgYXMgaW5saW5lJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCB7IGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGdldE92ZXJmbG93QW5jZXN0b3JzLCBwbGF0Zm9ybSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgaW5kZXggPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vLyBGb3JrIG9mIGBmYXN0LWRlZXAtZXF1YWxgIHRoYXQgb25seSBkb2VzIHRoZSBjb21wYXJpc29ucyB3ZSBuZWVkIGFuZCBjb21wYXJlc1xuLy8gZnVuY3Rpb25zXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IGxlbmd0aDtcbiAgbGV0IGk7XG4gIGxldCBrZXlzO1xuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gJ19vd25lcicgJiYgYS4kJHR5cGVvZikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbmZ1bmN0aW9uIGdldERQUihlbGVtZW50KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGNvbnN0IHdpbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xufVxuXG5mdW5jdGlvbiByb3VuZEJ5RFBSKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRwciA9IGdldERQUihlbGVtZW50KTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkcHIpIC8gZHByO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlOiBleHRlcm5hbFJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nOiBleHRlcm5hbEZsb2F0aW5nXG4gICAgfSA9IHt9LFxuICAgIHRyYW5zZm9ybSA9IHRydWUsXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQsXG4gICAgb3BlblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBzdHJhdGVneSxcbiAgICBwbGFjZW1lbnQsXG4gICAgbWlkZGxld2FyZURhdGE6IHt9LFxuICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IFtsYXRlc3RNaWRkbGV3YXJlLCBzZXRMYXRlc3RNaWRkbGV3YXJlXSA9IFJlYWN0LnVzZVN0YXRlKG1pZGRsZXdhcmUpO1xuICBpZiAoIWRlZXBFcXVhbChsYXRlc3RNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKSkge1xuICAgIHNldExhdGVzdE1pZGRsZXdhcmUobWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgW19yZWZlcmVuY2UsIF9zZXRSZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtfZmxvYXRpbmcsIF9zZXRGbG9hdGluZ10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IHJlZmVyZW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICByZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRGbG9hdGluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSBmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICBmbG9hdGluZ1JlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRGbG9hdGluZyhub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSBleHRlcm5hbFJlZmVyZW5jZSB8fCBfcmVmZXJlbmNlO1xuICBjb25zdCBmbG9hdGluZ0VsID0gZXh0ZXJuYWxGbG9hdGluZyB8fCBfZmxvYXRpbmc7XG4gIGNvbnN0IHJlZmVyZW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZmxvYXRpbmdSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoZGF0YSk7XG4gIGNvbnN0IGhhc1doaWxlRWxlbWVudHNNb3VudGVkID0gd2hpbGVFbGVtZW50c01vdW50ZWQgIT0gbnVsbDtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZTogbGF0ZXN0TWlkZGxld2FyZVxuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbmZpZy5wbGF0Zm9ybSA9IHBsYXRmb3JtUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2VSZWYuY3VycmVudCwgZmxvYXRpbmdSZWYuY3VycmVudCwgY29uZmlnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIC8vIFRoZSBmbG9hdGluZyBlbGVtZW50J3MgcG9zaXRpb24gbWF5IGJlIHJlY29tcHV0ZWQgd2hpbGUgaXQncyBjbG9zZWRcbiAgICAgICAgLy8gYnV0IHN0aWxsIG1vdW50ZWQgKHN1Y2ggYXMgd2hlbiB0cmFuc2l0aW9uaW5nIG91dCkuIFRvIGVuc3VyZVxuICAgICAgICAvLyBgaXNQb3NpdGlvbmVkYCB3aWxsIGJlIGBmYWxzZWAgaW5pdGlhbGx5IG9uIHRoZSBuZXh0IG9wZW4sIGF2b2lkXG4gICAgICAgIC8vIHNldHRpbmcgaXQgdG8gYHRydWVgIHdoZW4gYG9wZW4gPT09IGZhbHNlYCAobXVzdCBiZSBzcGVjaWZpZWQpLlxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IG9wZW5SZWYuY3VycmVudCAhPT0gZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgIWRlZXBFcXVhbChkYXRhUmVmLmN1cnJlbnQsIGZ1bGxEYXRhKSkge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQgPSBmdWxsRGF0YTtcbiAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBzZXREYXRhKGZ1bGxEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtsYXRlc3RNaWRkbGV3YXJlLCBwbGFjZW1lbnQsIHN0cmF0ZWd5LCBwbGF0Zm9ybVJlZiwgb3BlblJlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4gPT09IGZhbHNlICYmIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQpIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgIHNldERhdGEoZGF0YSA9PiAoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChyZWZlcmVuY2VFbCkgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSByZWZlcmVuY2VFbDtcbiAgICBpZiAoZmxvYXRpbmdFbCkgZmxvYXRpbmdSZWYuY3VycmVudCA9IGZsb2F0aW5nRWw7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmIGZsb2F0aW5nRWwpIHtcbiAgICAgIGlmICh3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KHJlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUpO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9LCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSwgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYsIGhhc1doaWxlRWxlbWVudHNNb3VudGVkXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VSZWYsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nUmVmLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRGbG9hdGluZ1xuICB9KSwgW3NldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VFbCxcbiAgICBmbG9hdGluZzogZmxvYXRpbmdFbFxuICB9KSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsXSk7XG4gIGNvbnN0IGZsb2F0aW5nU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGlmICghZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3R5bGVzO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS54KTtcbiAgICBjb25zdCB5ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS55KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3R5bGVzLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIsXG4gICAgICAgIC4uLihnZXREUFIoZWxlbWVudHMuZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybSdcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5XG4gICAgfTtcbiAgfSwgW3N0cmF0ZWd5LCB0cmFuc2Zvcm0sIGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngsIGRhdGEueV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdTdHlsZXNcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIGVsZW1lbnRzLCBmbG9hdGluZ1N0eWxlc10pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3ckMSA9IG9wdGlvbnMgPT4ge1xuICBmdW5jdGlvbiBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY3VycmVudCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHBhZGRpbmdcbiAgICAgIH0gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMoc3RhdGUpIDogb3B0aW9ucztcbiAgICAgIGlmIChlbGVtZW50ICYmIGlzUmVmKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFycm93JDIoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcGFkZGluZ1xuICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLm9mZnNldCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uc2hpZnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5saW1pdFNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmZsaXAkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNpemUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uYXV0b1BsYWNlbWVudCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5oaWRlJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5pbmxpbmUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmFycm93JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUsIHVzZUZsb2F0aW5nIH07XG4iLCIvLyBwYWNrYWdlcy9yZWFjdC9hcnJvdy9zcmMvYXJyb3cudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFByaW1pdGl2ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtcHJpbWl0aXZlXCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBOQU1FID0gXCJBcnJvd1wiO1xudmFyIEFycm93ID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCB3aWR0aCA9IDEwLCBoZWlnaHQgPSA1LCAuLi5hcnJvd1Byb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgUHJpbWl0aXZlLnN2ZyxcbiAgICB7XG4gICAgICAuLi5hcnJvd1Byb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHZpZXdCb3g6IFwiMCAwIDMwIDEwXCIsXG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIixcbiAgICAgIGNoaWxkcmVuOiBwcm9wcy5hc0NoaWxkID8gY2hpbGRyZW4gOiAvKiBAX19QVVJFX18gKi8ganN4KFwicG9seWdvblwiLCB7IHBvaW50czogXCIwLDAgMzAsMCAxNSwxMFwiIH0pXG4gICAgfVxuICApO1xufSk7XG5BcnJvdy5kaXNwbGF5TmFtZSA9IE5BTUU7XG52YXIgUm9vdCA9IEFycm93O1xuZXhwb3J0IHtcbiAgQXJyb3csXG4gIFJvb3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2Utc2l6ZS9zcmMvdXNlU2l6ZS50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtbGF5b3V0LWVmZmVjdFwiO1xuZnVuY3Rpb24gdXNlU2l6ZShlbGVtZW50KSB7XG4gIGNvbnN0IFtzaXplLCBzZXRTaXplXSA9IFJlYWN0LnVzZVN0YXRlKHZvaWQgMCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHNldFNpemUoeyB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCB9KTtcbiAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICBpZiAoXCJib3JkZXJCb3hTaXplXCIgaW4gZW50cnkpIHtcbiAgICAgICAgICBjb25zdCBib3JkZXJTaXplRW50cnkgPSBlbnRyeVtcImJvcmRlckJveFNpemVcIl07XG4gICAgICAgICAgY29uc3QgYm9yZGVyU2l6ZSA9IEFycmF5LmlzQXJyYXkoYm9yZGVyU2l6ZUVudHJ5KSA/IGJvcmRlclNpemVFbnRyeVswXSA6IGJvcmRlclNpemVFbnRyeTtcbiAgICAgICAgICB3aWR0aCA9IGJvcmRlclNpemVbXCJpbmxpbmVTaXplXCJdO1xuICAgICAgICAgIGhlaWdodCA9IGJvcmRlclNpemVbXCJibG9ja1NpemVcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHNldFNpemUoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgfSk7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgIHJldHVybiAoKSA9PiByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNpemUodm9pZCAwKTtcbiAgICB9XG4gIH0sIFtlbGVtZW50XSk7XG4gIHJldHVybiBzaXplO1xufVxuZXhwb3J0IHtcbiAgdXNlU2l6ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9wb3BwZXIvc3JjL3BvcHBlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgdXNlRmxvYXRpbmcsXG4gIGF1dG9VcGRhdGUsXG4gIG9mZnNldCxcbiAgc2hpZnQsXG4gIGxpbWl0U2hpZnQsXG4gIGhpZGUsXG4gIGFycm93IGFzIGZsb2F0aW5nVUlhcnJvdyxcbiAgZmxpcCxcbiAgc2l6ZVxufSBmcm9tIFwiQGZsb2F0aW5nLXVpL3JlYWN0LWRvbVwiO1xuaW1wb3J0ICogYXMgQXJyb3dQcmltaXRpdmUgZnJvbSBcIkByYWRpeC11aS9yZWFjdC1hcnJvd1wiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29udGV4dFwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VTaXplIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2Utc2l6ZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU0lERV9PUFRJT05TID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdO1xudmFyIEFMSUdOX09QVElPTlMgPSBbXCJzdGFydFwiLCBcImNlbnRlclwiLCBcImVuZFwiXTtcbnZhciBQT1BQRVJfTkFNRSA9IFwiUG9wcGVyXCI7XG52YXIgW2NyZWF0ZVBvcHBlckNvbnRleHQsIGNyZWF0ZVBvcHBlclNjb3BlXSA9IGNyZWF0ZUNvbnRleHRTY29wZShQT1BQRVJfTkFNRSk7XG52YXIgW1BvcHBlclByb3ZpZGVyLCB1c2VQb3BwZXJDb250ZXh0XSA9IGNyZWF0ZVBvcHBlckNvbnRleHQoUE9QUEVSX05BTUUpO1xudmFyIFBvcHBlciA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IF9fc2NvcGVQb3BwZXIsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3QgW2FuY2hvciwgc2V0QW5jaG9yXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQb3BwZXJQcm92aWRlciwgeyBzY29wZTogX19zY29wZVBvcHBlciwgYW5jaG9yLCBvbkFuY2hvckNoYW5nZTogc2V0QW5jaG9yLCBjaGlsZHJlbiB9KTtcbn07XG5Qb3BwZXIuZGlzcGxheU5hbWUgPSBQT1BQRVJfTkFNRTtcbnZhciBBTkNIT1JfTkFNRSA9IFwiUG9wcGVyQW5jaG9yXCI7XG52YXIgUG9wcGVyQW5jaG9yID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVQb3BwZXIsIHZpcnR1YWxSZWYsIC4uLmFuY2hvclByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlUG9wcGVyQ29udGV4dChBTkNIT1JfTkFNRSwgX19zY29wZVBvcHBlcik7XG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHJlZik7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnRleHQub25BbmNob3JDaGFuZ2UodmlydHVhbFJlZj8uY3VycmVudCB8fCByZWYuY3VycmVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpcnR1YWxSZWYgPyBudWxsIDogLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IC4uLmFuY2hvclByb3BzLCByZWY6IGNvbXBvc2VkUmVmcyB9KTtcbiAgfVxuKTtcblBvcHBlckFuY2hvci5kaXNwbGF5TmFtZSA9IEFOQ0hPUl9OQU1FO1xudmFyIENPTlRFTlRfTkFNRSA9IFwiUG9wcGVyQ29udGVudFwiO1xudmFyIFtQb3BwZXJDb250ZW50UHJvdmlkZXIsIHVzZUNvbnRlbnRDb250ZXh0XSA9IGNyZWF0ZVBvcHBlckNvbnRleHQoQ09OVEVOVF9OQU1FKTtcbnZhciBQb3BwZXJDb250ZW50ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBfX3Njb3BlUG9wcGVyLFxuICAgICAgc2lkZSA9IFwiYm90dG9tXCIsXG4gICAgICBzaWRlT2Zmc2V0ID0gMCxcbiAgICAgIGFsaWduID0gXCJjZW50ZXJcIixcbiAgICAgIGFsaWduT2Zmc2V0ID0gMCxcbiAgICAgIGFycm93UGFkZGluZyA9IDAsXG4gICAgICBhdm9pZENvbGxpc2lvbnMgPSB0cnVlLFxuICAgICAgY29sbGlzaW9uQm91bmRhcnkgPSBbXSxcbiAgICAgIGNvbGxpc2lvblBhZGRpbmc6IGNvbGxpc2lvblBhZGRpbmdQcm9wID0gMCxcbiAgICAgIHN0aWNreSA9IFwicGFydGlhbFwiLFxuICAgICAgaGlkZVdoZW5EZXRhY2hlZCA9IGZhbHNlLFxuICAgICAgdXBkYXRlUG9zaXRpb25TdHJhdGVneSA9IFwib3B0aW1pemVkXCIsXG4gICAgICBvblBsYWNlZCxcbiAgICAgIC4uLmNvbnRlbnRQcm9wc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlUG9wcGVyQ29udGV4dChDT05URU5UX05BTUUsIF9fc2NvcGVQb3BwZXIpO1xuICAgIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlKSA9PiBzZXRDb250ZW50KG5vZGUpKTtcbiAgICBjb25zdCBbYXJyb3csIHNldEFycm93XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGFycm93U2l6ZSA9IHVzZVNpemUoYXJyb3cpO1xuICAgIGNvbnN0IGFycm93V2lkdGggPSBhcnJvd1NpemU/LndpZHRoID8/IDA7XG4gICAgY29uc3QgYXJyb3dIZWlnaHQgPSBhcnJvd1NpemU/LmhlaWdodCA/PyAwO1xuICAgIGNvbnN0IGRlc2lyZWRQbGFjZW1lbnQgPSBzaWRlICsgKGFsaWduICE9PSBcImNlbnRlclwiID8gXCItXCIgKyBhbGlnbiA6IFwiXCIpO1xuICAgIGNvbnN0IGNvbGxpc2lvblBhZGRpbmcgPSB0eXBlb2YgY29sbGlzaW9uUGFkZGluZ1Byb3AgPT09IFwibnVtYmVyXCIgPyBjb2xsaXNpb25QYWRkaW5nUHJvcCA6IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCAuLi5jb2xsaXNpb25QYWRkaW5nUHJvcCB9O1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gQXJyYXkuaXNBcnJheShjb2xsaXNpb25Cb3VuZGFyeSkgPyBjb2xsaXNpb25Cb3VuZGFyeSA6IFtjb2xsaXNpb25Cb3VuZGFyeV07XG4gICAgY29uc3QgaGFzRXhwbGljaXRCb3VuZGFyaWVzID0gYm91bmRhcnkubGVuZ3RoID4gMDtcbiAgICBjb25zdCBkZXRlY3RPdmVyZmxvd09wdGlvbnMgPSB7XG4gICAgICBwYWRkaW5nOiBjb2xsaXNpb25QYWRkaW5nLFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LmZpbHRlcihpc05vdE51bGwpLFxuICAgICAgLy8gd2l0aCBgc3RyYXRlZ3k6ICdmaXhlZCdgLCB0aGlzIGlzIHRoZSBvbmx5IHdheSB0byBnZXQgaXQgdG8gcmVzcGVjdCBib3VuZGFyaWVzXG4gICAgICBhbHRCb3VuZGFyeTogaGFzRXhwbGljaXRCb3VuZGFyaWVzXG4gICAgfTtcbiAgICBjb25zdCB7IHJlZnMsIGZsb2F0aW5nU3R5bGVzLCBwbGFjZW1lbnQsIGlzUG9zaXRpb25lZCwgbWlkZGxld2FyZURhdGEgfSA9IHVzZUZsb2F0aW5nKHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gYGZpeGVkYCBzdHJhdGVneSBzbyB1c2VycyBkb24ndCBoYXZlIHRvIHBpY2sgYW5kIHdlIGFsc28gYXZvaWQgZm9jdXMgc2Nyb2xsIGlzc3Vlc1xuICAgICAgc3RyYXRlZ3k6IFwiZml4ZWRcIixcbiAgICAgIHBsYWNlbWVudDogZGVzaXJlZFBsYWNlbWVudCxcbiAgICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gYXV0b1VwZGF0ZSguLi5hcmdzLCB7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWU6IHVwZGF0ZVBvc2l0aW9uU3RyYXRlZ3kgPT09IFwiYWx3YXlzXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgICAgfSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogY29udGV4dC5hbmNob3JcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgIG9mZnNldCh7IG1haW5BeGlzOiBzaWRlT2Zmc2V0ICsgYXJyb3dIZWlnaHQsIGFsaWdubWVudEF4aXM6IGFsaWduT2Zmc2V0IH0pLFxuICAgICAgICBhdm9pZENvbGxpc2lvbnMgJiYgc2hpZnQoe1xuICAgICAgICAgIG1haW5BeGlzOiB0cnVlLFxuICAgICAgICAgIGNyb3NzQXhpczogZmFsc2UsXG4gICAgICAgICAgbGltaXRlcjogc3RpY2t5ID09PSBcInBhcnRpYWxcIiA/IGxpbWl0U2hpZnQoKSA6IHZvaWQgMCxcbiAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgICAgfSksXG4gICAgICAgIGF2b2lkQ29sbGlzaW9ucyAmJiBmbGlwKHsgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIH0pLFxuICAgICAgICBzaXplKHtcbiAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgYXBwbHk6ICh7IGVsZW1lbnRzLCByZWN0cywgYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoOiBhbmNob3JXaWR0aCwgaGVpZ2h0OiBhbmNob3JIZWlnaHQgfSA9IHJlY3RzLnJlZmVyZW5jZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTdHlsZSA9IGVsZW1lbnRzLmZsb2F0aW5nLnN0eWxlO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLXdpZHRoXCIsIGAke2F2YWlsYWJsZVdpZHRofXB4YCk7XG4gICAgICAgICAgICBjb250ZW50U3R5bGUuc2V0UHJvcGVydHkoXCItLXJhZGl4LXBvcHBlci1hdmFpbGFibGUtaGVpZ2h0XCIsIGAke2F2YWlsYWJsZUhlaWdodH1weGApO1xuICAgICAgICAgICAgY29udGVudFN0eWxlLnNldFByb3BlcnR5KFwiLS1yYWRpeC1wb3BwZXItYW5jaG9yLXdpZHRoXCIsIGAke2FuY2hvcldpZHRofXB4YCk7XG4gICAgICAgICAgICBjb250ZW50U3R5bGUuc2V0UHJvcGVydHkoXCItLXJhZGl4LXBvcHBlci1hbmNob3ItaGVpZ2h0XCIsIGAke2FuY2hvckhlaWdodH1weGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGFycm93ICYmIGZsb2F0aW5nVUlhcnJvdyh7IGVsZW1lbnQ6IGFycm93LCBwYWRkaW5nOiBhcnJvd1BhZGRpbmcgfSksXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbih7IGFycm93V2lkdGgsIGFycm93SGVpZ2h0IH0pLFxuICAgICAgICBoaWRlV2hlbkRldGFjaGVkICYmIGhpZGUoeyBzdHJhdGVneTogXCJyZWZlcmVuY2VIaWRkZW5cIiwgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIH0pXG4gICAgICBdXG4gICAgfSk7XG4gICAgY29uc3QgW3BsYWNlZFNpZGUsIHBsYWNlZEFsaWduXSA9IGdldFNpZGVBbmRBbGlnbkZyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBoYW5kbGVQbGFjZWQgPSB1c2VDYWxsYmFja1JlZihvblBsYWNlZCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc1Bvc2l0aW9uZWQpIHtcbiAgICAgICAgaGFuZGxlUGxhY2VkPy4oKTtcbiAgICAgIH1cbiAgICB9LCBbaXNQb3NpdGlvbmVkLCBoYW5kbGVQbGFjZWRdKTtcbiAgICBjb25zdCBhcnJvd1ggPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueDtcbiAgICBjb25zdCBhcnJvd1kgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueTtcbiAgICBjb25zdCBjYW5ub3RDZW50ZXJBcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93Py5jZW50ZXJPZmZzZXQgIT09IDA7XG4gICAgY29uc3QgW2NvbnRlbnRaSW5kZXgsIHNldENvbnRlbnRaSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGNvbnRlbnQpIHNldENvbnRlbnRaSW5kZXgod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudCkuekluZGV4KTtcbiAgICB9LCBbY29udGVudF0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiByZWZzLnNldEZsb2F0aW5nLFxuICAgICAgICBcImRhdGEtcmFkaXgtcG9wcGVyLWNvbnRlbnQtd3JhcHBlclwiOiBcIlwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIC4uLmZsb2F0aW5nU3R5bGVzLFxuICAgICAgICAgIHRyYW5zZm9ybTogaXNQb3NpdGlvbmVkID8gZmxvYXRpbmdTdHlsZXMudHJhbnNmb3JtIDogXCJ0cmFuc2xhdGUoMCwgLTIwMCUpXCIsXG4gICAgICAgICAgLy8ga2VlcCBvZmYgdGhlIHBhZ2Ugd2hlbiBtZWFzdXJpbmdcbiAgICAgICAgICBtaW5XaWR0aDogXCJtYXgtY29udGVudFwiLFxuICAgICAgICAgIHpJbmRleDogY29udGVudFpJbmRleCxcbiAgICAgICAgICBbXCItLXJhZGl4LXBvcHBlci10cmFuc2Zvcm0tb3JpZ2luXCJdOiBbXG4gICAgICAgICAgICBtaWRkbGV3YXJlRGF0YS50cmFuc2Zvcm1PcmlnaW4/LngsXG4gICAgICAgICAgICBtaWRkbGV3YXJlRGF0YS50cmFuc2Zvcm1PcmlnaW4/LnlcbiAgICAgICAgICBdLmpvaW4oXCIgXCIpLFxuICAgICAgICAgIC8vIGhpZGUgdGhlIGNvbnRlbnQgaWYgdXNpbmcgdGhlIGhpZGUgbWlkZGxld2FyZSBhbmQgc2hvdWxkIGJlIGhpZGRlblxuICAgICAgICAgIC8vIHNldCB2aXNpYmlsaXR5IHRvIGhpZGRlbiBhbmQgZGlzYWJsZSBwb2ludGVyIGV2ZW50cyBzbyB0aGUgVUkgYmVoYXZlc1xuICAgICAgICAgIC8vIGFzIGlmIHRoZSBQb3BwZXJDb250ZW50IGlzbid0IHRoZXJlIGF0IGFsbFxuICAgICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLmhpZGU/LnJlZmVyZW5jZUhpZGRlbiAmJiB7XG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpcjogcHJvcHMuZGlyLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICBQb3BwZXJDb250ZW50UHJvdmlkZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2NvcGU6IF9fc2NvcGVQb3BwZXIsXG4gICAgICAgICAgICBwbGFjZWRTaWRlLFxuICAgICAgICAgICAgb25BcnJvd0NoYW5nZTogc2V0QXJyb3csXG4gICAgICAgICAgICBhcnJvd1gsXG4gICAgICAgICAgICBhcnJvd1ksXG4gICAgICAgICAgICBzaG91bGRIaWRlQXJyb3c6IGNhbm5vdENlbnRlckFycm93LFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgIFByaW1pdGl2ZS5kaXYsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImRhdGEtc2lkZVwiOiBwbGFjZWRTaWRlLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1hbGlnblwiOiBwbGFjZWRBbGlnbixcbiAgICAgICAgICAgICAgICAuLi5jb250ZW50UHJvcHMsXG4gICAgICAgICAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBQb3BwZXJDb250ZW50IGhhc24ndCBiZWVuIHBsYWNlZCB5ZXQgKG5vdCBhbGwgbWVhc3VyZW1lbnRzIGRvbmUpXG4gICAgICAgICAgICAgICAgICAvLyB3ZSBwcmV2ZW50IGFuaW1hdGlvbnMgc28gdGhhdCB1c2VycydzIGFuaW1hdGlvbiBkb24ndCBraWNrIGluIHRvbyBlYXJseSByZWZlcnJpbmcgd3Jvbmcgc2lkZXNcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogIWlzUG9zaXRpb25lZCA/IFwibm9uZVwiIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblBvcHBlckNvbnRlbnQuZGlzcGxheU5hbWUgPSBDT05URU5UX05BTUU7XG52YXIgQVJST1dfTkFNRSA9IFwiUG9wcGVyQXJyb3dcIjtcbnZhciBPUFBPU0lURV9TSURFID0ge1xuICB0b3A6IFwiYm90dG9tXCIsXG4gIHJpZ2h0OiBcImxlZnRcIixcbiAgYm90dG9tOiBcInRvcFwiLFxuICBsZWZ0OiBcInJpZ2h0XCJcbn07XG52YXIgUG9wcGVyQXJyb3cgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcHBlckFycm93Mihwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGNvbnN0IHsgX19zY29wZVBvcHBlciwgLi4uYXJyb3dQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlQ29udGVudENvbnRleHQoQVJST1dfTkFNRSwgX19zY29wZVBvcHBlcik7XG4gIGNvbnN0IGJhc2VTaWRlID0gT1BQT1NJVEVfU0lERVtjb250ZW50Q29udGV4dC5wbGFjZWRTaWRlXTtcbiAgcmV0dXJuIChcbiAgICAvLyB3ZSBoYXZlIHRvIHVzZSBhbiBleHRyYSB3cmFwcGVyIGJlY2F1c2UgYFJlc2l6ZU9ic2VydmVyYCAodXNlZCBieSBgdXNlU2l6ZWApXG4gICAgLy8gZG9lc24ndCByZXBvcnQgc2l6ZSBhcyB3ZSdkIGV4cGVjdCBvbiBTVkcgZWxlbWVudHMuXG4gICAgLy8gaXQgcmVwb3J0cyB0aGVpciBib3VuZGluZyBib3ggd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIGxhcmdlc3QgcGF0aCBpbnNpZGUgdGhlIFNWRy5cbiAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgXCJzcGFuXCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogY29udGVudENvbnRleHQub25BcnJvd0NoYW5nZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIGxlZnQ6IGNvbnRlbnRDb250ZXh0LmFycm93WCxcbiAgICAgICAgICB0b3A6IGNvbnRlbnRDb250ZXh0LmFycm93WSxcbiAgICAgICAgICBbYmFzZVNpZGVdOiAwLFxuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjoge1xuICAgICAgICAgICAgdG9wOiBcIlwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiMCAwXCIsXG4gICAgICAgICAgICBib3R0b206IFwiY2VudGVyIDBcIixcbiAgICAgICAgICAgIGxlZnQ6IFwiMTAwJSAwXCJcbiAgICAgICAgICB9W2NvbnRlbnRDb250ZXh0LnBsYWNlZFNpZGVdLFxuICAgICAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICAgICAgdG9wOiBcInRyYW5zbGF0ZVkoMTAwJSlcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcInRyYW5zbGF0ZVkoNTAlKSByb3RhdGUoOTBkZWcpIHRyYW5zbGF0ZVgoLTUwJSlcIixcbiAgICAgICAgICAgIGJvdHRvbTogYHJvdGF0ZSgxODBkZWcpYCxcbiAgICAgICAgICAgIGxlZnQ6IFwidHJhbnNsYXRlWSg1MCUpIHJvdGF0ZSgtOTBkZWcpIHRyYW5zbGF0ZVgoNTAlKVwiXG4gICAgICAgICAgfVtjb250ZW50Q29udGV4dC5wbGFjZWRTaWRlXSxcbiAgICAgICAgICB2aXNpYmlsaXR5OiBjb250ZW50Q29udGV4dC5zaG91bGRIaWRlQXJyb3cgPyBcImhpZGRlblwiIDogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIEFycm93UHJpbWl0aXZlLlJvb3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uYXJyb3dQcm9wcyxcbiAgICAgICAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgLi4uYXJyb3dQcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgLy8gZW5zdXJlcyB0aGUgZWxlbWVudCBjYW4gYmUgbWVhc3VyZWQgY29ycmVjdGx5IChtb3N0bHkgZm9yIGlmIFNWRylcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKVxuICApO1xufSk7XG5Qb3BwZXJBcnJvdy5kaXNwbGF5TmFtZSA9IEFSUk9XX05BTUU7XG5mdW5jdGlvbiBpc05vdE51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsO1xufVxudmFyIHRyYW5zZm9ybU9yaWdpbiA9IChvcHRpb25zKSA9PiAoe1xuICBuYW1lOiBcInRyYW5zZm9ybU9yaWdpblwiLFxuICBvcHRpb25zLFxuICBmbihkYXRhKSB7XG4gICAgY29uc3QgeyBwbGFjZW1lbnQsIHJlY3RzLCBtaWRkbGV3YXJlRGF0YSB9ID0gZGF0YTtcbiAgICBjb25zdCBjYW5ub3RDZW50ZXJBcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93Py5jZW50ZXJPZmZzZXQgIT09IDA7XG4gICAgY29uc3QgaXNBcnJvd0hpZGRlbiA9IGNhbm5vdENlbnRlckFycm93O1xuICAgIGNvbnN0IGFycm93V2lkdGggPSBpc0Fycm93SGlkZGVuID8gMCA6IG9wdGlvbnMuYXJyb3dXaWR0aDtcbiAgICBjb25zdCBhcnJvd0hlaWdodCA9IGlzQXJyb3dIaWRkZW4gPyAwIDogb3B0aW9ucy5hcnJvd0hlaWdodDtcbiAgICBjb25zdCBbcGxhY2VkU2lkZSwgcGxhY2VkQWxpZ25dID0gZ2V0U2lkZUFuZEFsaWduRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICAgIGNvbnN0IG5vQXJyb3dBbGlnbiA9IHsgc3RhcnQ6IFwiMCVcIiwgY2VudGVyOiBcIjUwJVwiLCBlbmQ6IFwiMTAwJVwiIH1bcGxhY2VkQWxpZ25dO1xuICAgIGNvbnN0IGFycm93WENlbnRlciA9IChtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueCA/PyAwKSArIGFycm93V2lkdGggLyAyO1xuICAgIGNvbnN0IGFycm93WUNlbnRlciA9IChtaWRkbGV3YXJlRGF0YS5hcnJvdz8ueSA/PyAwKSArIGFycm93SGVpZ2h0IC8gMjtcbiAgICBsZXQgeCA9IFwiXCI7XG4gICAgbGV0IHkgPSBcIlwiO1xuICAgIGlmIChwbGFjZWRTaWRlID09PSBcImJvdHRvbVwiKSB7XG4gICAgICB4ID0gaXNBcnJvd0hpZGRlbiA/IG5vQXJyb3dBbGlnbiA6IGAke2Fycm93WENlbnRlcn1weGA7XG4gICAgICB5ID0gYCR7LWFycm93SGVpZ2h0fXB4YDtcbiAgICB9IGVsc2UgaWYgKHBsYWNlZFNpZGUgPT09IFwidG9wXCIpIHtcbiAgICAgIHggPSBpc0Fycm93SGlkZGVuID8gbm9BcnJvd0FsaWduIDogYCR7YXJyb3dYQ2VudGVyfXB4YDtcbiAgICAgIHkgPSBgJHtyZWN0cy5mbG9hdGluZy5oZWlnaHQgKyBhcnJvd0hlaWdodH1weGA7XG4gICAgfSBlbHNlIGlmIChwbGFjZWRTaWRlID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIHggPSBgJHstYXJyb3dIZWlnaHR9cHhgO1xuICAgICAgeSA9IGlzQXJyb3dIaWRkZW4gPyBub0Fycm93QWxpZ24gOiBgJHthcnJvd1lDZW50ZXJ9cHhgO1xuICAgIH0gZWxzZSBpZiAocGxhY2VkU2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHggPSBgJHtyZWN0cy5mbG9hdGluZy53aWR0aCArIGFycm93SGVpZ2h0fXB4YDtcbiAgICAgIHkgPSBpc0Fycm93SGlkZGVuID8gbm9BcnJvd0FsaWduIDogYCR7YXJyb3dZQ2VudGVyfXB4YDtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogeyB4LCB5IH0gfTtcbiAgfVxufSk7XG5mdW5jdGlvbiBnZXRTaWRlQW5kQWxpZ25Gcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICBjb25zdCBbc2lkZSwgYWxpZ24gPSBcImNlbnRlclwiXSA9IHBsYWNlbWVudC5zcGxpdChcIi1cIik7XG4gIHJldHVybiBbc2lkZSwgYWxpZ25dO1xufVxudmFyIFJvb3QyID0gUG9wcGVyO1xudmFyIEFuY2hvciA9IFBvcHBlckFuY2hvcjtcbnZhciBDb250ZW50ID0gUG9wcGVyQ29udGVudDtcbnZhciBBcnJvdyA9IFBvcHBlckFycm93O1xuZXhwb3J0IHtcbiAgQUxJR05fT1BUSU9OUyxcbiAgQW5jaG9yLFxuICBBcnJvdyxcbiAgQ29udGVudCxcbiAgUG9wcGVyLFxuICBQb3BwZXJBbmNob3IsXG4gIFBvcHBlckFycm93LFxuICBQb3BwZXJDb250ZW50LFxuICBSb290MiBhcyBSb290LFxuICBTSURFX09QVElPTlMsXG4gIGNyZWF0ZVBvcHBlclNjb3BlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L3BvcnRhbC9zcmMvcG9ydGFsLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFBPUlRBTF9OQU1FID0gXCJQb3J0YWxcIjtcbnZhciBQb3J0YWwgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHsgY29udGFpbmVyOiBjb250YWluZXJQcm9wLCAuLi5wb3J0YWxQcm9wcyB9ID0gcHJvcHM7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHNldE1vdW50ZWQodHJ1ZSksIFtdKTtcbiAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUHJvcCB8fCBtb3VudGVkICYmIGdsb2JhbFRoaXM/LmRvY3VtZW50Py5ib2R5O1xuICByZXR1cm4gY29udGFpbmVyID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLmRpdiwgeyAuLi5wb3J0YWxQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSksIGNvbnRhaW5lcikgOiBudWxsO1xufSk7XG5Qb3J0YWwuZGlzcGxheU5hbWUgPSBQT1JUQUxfTkFNRTtcbnZhciBSb290ID0gUG9ydGFsO1xuZXhwb3J0IHtcbiAgUG9ydGFsLFxuICBSb290XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLy8gcGFja2FnZXMvcmVhY3QvdXNlLWNvbnRyb2xsYWJsZS1zdGF0ZS9zcmMvdXNlQ29udHJvbGxhYmxlU3RhdGUudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5mdW5jdGlvbiB1c2VDb250cm9sbGFibGVTdGF0ZSh7XG4gIHByb3AsXG4gIGRlZmF1bHRQcm9wLFxuICBvbkNoYW5nZSA9ICgpID0+IHtcbiAgfVxufSkge1xuICBjb25zdCBbdW5jb250cm9sbGVkUHJvcCwgc2V0VW5jb250cm9sbGVkUHJvcF0gPSB1c2VVbmNvbnRyb2xsZWRTdGF0ZSh7IGRlZmF1bHRQcm9wLCBvbkNoYW5nZSB9KTtcbiAgY29uc3QgaXNDb250cm9sbGVkID0gcHJvcCAhPT0gdm9pZCAwO1xuICBjb25zdCB2YWx1ZSA9IGlzQ29udHJvbGxlZCA/IHByb3AgOiB1bmNvbnRyb2xsZWRQcm9wO1xuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFja1JlZihvbkNoYW5nZSk7XG4gIGNvbnN0IHNldFZhbHVlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5leHRWYWx1ZSkgPT4ge1xuICAgICAgaWYgKGlzQ29udHJvbGxlZCkge1xuICAgICAgICBjb25zdCBzZXR0ZXIgPSBuZXh0VmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHR5cGVvZiBuZXh0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHNldHRlcihwcm9wKSA6IG5leHRWYWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlMiAhPT0gcHJvcCkgaGFuZGxlQ2hhbmdlKHZhbHVlMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRVbmNvbnRyb2xsZWRQcm9wKG5leHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbaXNDb250cm9sbGVkLCBwcm9wLCBzZXRVbmNvbnRyb2xsZWRQcm9wLCBoYW5kbGVDaGFuZ2VdXG4gICk7XG4gIHJldHVybiBbdmFsdWUsIHNldFZhbHVlXTtcbn1cbmZ1bmN0aW9uIHVzZVVuY29udHJvbGxlZFN0YXRlKHtcbiAgZGVmYXVsdFByb3AsXG4gIG9uQ2hhbmdlXG59KSB7XG4gIGNvbnN0IHVuY29udHJvbGxlZFN0YXRlID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFByb3ApO1xuICBjb25zdCBbdmFsdWVdID0gdW5jb250cm9sbGVkU3RhdGU7XG4gIGNvbnN0IHByZXZWYWx1ZVJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrUmVmKG9uQ2hhbmdlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJldlZhbHVlUmVmLmN1cnJlbnQgIT09IHZhbHVlKSB7XG4gICAgICBoYW5kbGVDaGFuZ2UodmFsdWUpO1xuICAgICAgcHJldlZhbHVlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIFt2YWx1ZSwgcHJldlZhbHVlUmVmLCBoYW5kbGVDaGFuZ2VdKTtcbiAgcmV0dXJuIHVuY29udHJvbGxlZFN0YXRlO1xufVxuZXhwb3J0IHtcbiAgdXNlQ29udHJvbGxhYmxlU3RhdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBwYWNrYWdlcy9yZWFjdC91c2UtcHJldmlvdXMvc3JjL3VzZVByZXZpb3VzLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoeyB2YWx1ZSwgcHJldmlvdXM6IHZhbHVlIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50LnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmVmLmN1cnJlbnQucHJldmlvdXMgPSByZWYuY3VycmVudC52YWx1ZTtcbiAgICAgIHJlZi5jdXJyZW50LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudC5wcmV2aW91cztcbiAgfSwgW3ZhbHVlXSk7XG59XG5leHBvcnQge1xuICB1c2VQcmV2aW91c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8vIHBhY2thZ2VzL3JlYWN0L3Zpc3VhbGx5LWhpZGRlbi9zcmMvdmlzdWFsbHktaGlkZGVuLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXByaW1pdGl2ZVwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTkFNRSA9IFwiVmlzdWFsbHlIaWRkZW5cIjtcbnZhciBWaXN1YWxseUhpZGRlbiA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuc3BhbixcbiAgICAgIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9zY3NzL21peGlucy9fdmlzdWFsbHktaGlkZGVuLnNjc3NcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICBtYXJnaW46IC0xLFxuICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgIGNsaXA6IFwicmVjdCgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsXG4gICAgICAgICAgLi4ucHJvcHMuc3R5bGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5WaXN1YWxseUhpZGRlbi5kaXNwbGF5TmFtZSA9IE5BTUU7XG52YXIgUm9vdCA9IFZpc3VhbGx5SGlkZGVuO1xuZXhwb3J0IHtcbiAgUm9vdCxcbiAgVmlzdWFsbHlIaWRkZW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgZ2V0RGVmYXVsdFBhcmVudCA9IGZ1bmN0aW9uIChvcmlnaW5hbFRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc2FtcGxlVGFyZ2V0ID0gQXJyYXkuaXNBcnJheShvcmlnaW5hbFRhcmdldCkgPyBvcmlnaW5hbFRhcmdldFswXSA6IG9yaWdpbmFsVGFyZ2V0O1xuICAgIHJldHVybiBzYW1wbGVUYXJnZXQub3duZXJEb2N1bWVudC5ib2R5O1xufTtcbnZhciBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciB1bmNvbnRyb2xsZWROb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgbWFya2VyTWFwID0ge307XG52YXIgbG9ja0NvdW50ID0gMDtcbnZhciB1bndyYXBIb3N0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5ob3N0IHx8IHVud3JhcEhvc3Qobm9kZS5wYXJlbnROb2RlKSk7XG59O1xudmFyIGNvcnJlY3RUYXJnZXRzID0gZnVuY3Rpb24gKHBhcmVudCwgdGFyZ2V0cykge1xuICAgIHJldHVybiB0YXJnZXRzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAocGFyZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvcnJlY3RlZFRhcmdldCA9IHVud3JhcEhvc3QodGFyZ2V0KTtcbiAgICAgICAgaWYgKGNvcnJlY3RlZFRhcmdldCAmJiBwYXJlbnQuY29udGFpbnMoY29ycmVjdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZFRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKCdhcmlhLWhpZGRlbicsIHRhcmdldCwgJ2luIG5vdCBjb250YWluZWQgaW5zaWRlJywgcGFyZW50LCAnLiBEb2luZyBub3RoaW5nJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIEJvb2xlYW4oeCk7IH0pO1xufTtcbi8qKlxuICogTWFya3MgZXZlcnl0aGluZyBleGNlcHQgZ2l2ZW4gbm9kZShvciBub2RlcykgYXMgYXJpYS1oaWRkZW5cbiAqIEBwYXJhbSB7RWxlbWVudCB8IEVsZW1lbnRbXX0gb3JpZ2luYWxUYXJnZXQgLSBlbGVtZW50cyB0byBrZWVwIG9uIHRoZSBwYWdlXG4gKiBAcGFyYW0gW3BhcmVudE5vZGVdIC0gdG9wIGVsZW1lbnQsIGRlZmF1bHRzIHRvIGRvY3VtZW50LmJvZHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWFya2VyTmFtZV0gLSBhIHNwZWNpYWwgYXR0cmlidXRlIHRvIG1hcmsgZXZlcnkgbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IFtjb250cm9sQXR0cmlidXRlXSAtIGh0bWwgQXR0cmlidXRlIHRvIGNvbnRyb2xcbiAqIEByZXR1cm4ge1VuZG99IHVuZG8gY29tbWFuZFxuICovXG52YXIgYXBwbHlBdHRyaWJ1dGVUb090aGVycyA9IGZ1bmN0aW9uIChvcmlnaW5hbFRhcmdldCwgcGFyZW50Tm9kZSwgbWFya2VyTmFtZSwgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXRzID0gY29ycmVjdFRhcmdldHMocGFyZW50Tm9kZSwgQXJyYXkuaXNBcnJheShvcmlnaW5hbFRhcmdldCkgPyBvcmlnaW5hbFRhcmdldCA6IFtvcmlnaW5hbFRhcmdldF0pO1xuICAgIGlmICghbWFya2VyTWFwW21hcmtlck5hbWVdKSB7XG4gICAgICAgIG1hcmtlck1hcFttYXJrZXJOYW1lXSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHZhciBtYXJrZXJDb3VudGVyID0gbWFya2VyTWFwW21hcmtlck5hbWVdO1xuICAgIHZhciBoaWRkZW5Ob2RlcyA9IFtdO1xuICAgIHZhciBlbGVtZW50c1RvS2VlcCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZWxlbWVudHNUb1N0b3AgPSBuZXcgU2V0KHRhcmdldHMpO1xuICAgIHZhciBrZWVwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmICghZWwgfHwgZWxlbWVudHNUb0tlZXAuaGFzKGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzVG9LZWVwLmFkZChlbCk7XG4gICAgICAgIGtlZXAoZWwucGFyZW50Tm9kZSk7XG4gICAgfTtcbiAgICB0YXJnZXRzLmZvckVhY2goa2VlcCk7XG4gICAgdmFyIGRlZXAgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIGlmICghcGFyZW50IHx8IGVsZW1lbnRzVG9TdG9wLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChwYXJlbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHNUb0tlZXAuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgZGVlcChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlck1hcC5zZXQobm9kZSwgY291bnRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ291bnRlci5zZXQobm9kZSwgbWFya2VyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5Ob2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlclZhbHVlID09PSAxICYmIGFscmVhZHlIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY29udHJvbGxlZE5vZGVzLnNldChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyVmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG1hcmtlck5hbWUsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FyaWEtaGlkZGVuOiBjYW5ub3Qgb3BlcmF0ZSBvbiAnLCBub2RlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZGVlcChwYXJlbnROb2RlKTtcbiAgICBlbGVtZW50c1RvS2VlcC5jbGVhcigpO1xuICAgIGxvY2tDb3VudCsrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGRlbk5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjb3VudGVyVmFsdWUgPSBjb3VudGVyTWFwLmdldChub2RlKSAtIDE7XG4gICAgICAgICAgICB2YXIgbWFya2VyVmFsdWUgPSBtYXJrZXJDb3VudGVyLmdldChub2RlKSAtIDE7XG4gICAgICAgICAgICBjb3VudGVyTWFwLnNldChub2RlLCBjb3VudGVyVmFsdWUpO1xuICAgICAgICAgICAgbWFya2VyQ291bnRlci5zZXQobm9kZSwgbWFya2VyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFjb3VudGVyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVuY29udHJvbGxlZE5vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5jb250cm9sbGVkTm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG1hcmtlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbG9ja0NvdW50LS07XG4gICAgICAgIGlmICghbG9ja0NvdW50KSB7XG4gICAgICAgICAgICAvLyBjbGVhclxuICAgICAgICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIHVuY29udHJvbGxlZE5vZGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIG1hcmtlck1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vKipcbiAqIE1hcmtzIGV2ZXJ5dGhpbmcgZXhjZXB0IGdpdmVuIG5vZGUob3Igbm9kZXMpIGFzIGFyaWEtaGlkZGVuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBFbGVtZW50W119IG9yaWdpbmFsVGFyZ2V0IC0gZWxlbWVudHMgdG8ga2VlcCBvbiB0aGUgcGFnZVxuICogQHBhcmFtIFtwYXJlbnROb2RlXSAtIHRvcCBlbGVtZW50LCBkZWZhdWx0cyB0byBkb2N1bWVudC5ib2R5XG4gKiBAcGFyYW0ge1N0cmluZ30gW21hcmtlck5hbWVdIC0gYSBzcGVjaWFsIGF0dHJpYnV0ZSB0byBtYXJrIGV2ZXJ5IG5vZGVcbiAqIEByZXR1cm4ge1VuZG99IHVuZG8gY29tbWFuZFxuICovXG5leHBvcnQgdmFyIGhpZGVPdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpIHtcbiAgICBpZiAobWFya2VyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcmtlck5hbWUgPSAnZGF0YS1hcmlhLWhpZGRlbic7IH1cbiAgICB2YXIgdGFyZ2V0cyA9IEFycmF5LmZyb20oQXJyYXkuaXNBcnJheShvcmlnaW5hbFRhcmdldCkgPyBvcmlnaW5hbFRhcmdldCA6IFtvcmlnaW5hbFRhcmdldF0pO1xuICAgIHZhciBhY3RpdmVQYXJlbnROb2RlID0gcGFyZW50Tm9kZSB8fCBnZXREZWZhdWx0UGFyZW50KG9yaWdpbmFsVGFyZ2V0KTtcbiAgICBpZiAoIWFjdGl2ZVBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgfVxuICAgIC8vIHdlIHNob3VsZCBub3QgaGlkZSBhcmlhTGl2ZSBlbGVtZW50cyAtIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvYXJpYS1oaWRkZW4vaXNzdWVzLzEwXG4gICAgdGFyZ2V0cy5wdXNoLmFwcGx5KHRhcmdldHMsIEFycmF5LmZyb20oYWN0aXZlUGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1saXZlXScpKSk7XG4gICAgcmV0dXJuIGFwcGx5QXR0cmlidXRlVG9PdGhlcnModGFyZ2V0cywgYWN0aXZlUGFyZW50Tm9kZSwgbWFya2VyTmFtZSwgJ2FyaWEtaGlkZGVuJyk7XG59O1xuLyoqXG4gKiBNYXJrcyBldmVyeXRoaW5nIGV4Y2VwdCBnaXZlbiBub2RlKG9yIG5vZGVzKSBhcyBpbmVydFxuICogQHBhcmFtIHtFbGVtZW50IHwgRWxlbWVudFtdfSBvcmlnaW5hbFRhcmdldCAtIGVsZW1lbnRzIHRvIGtlZXAgb24gdGhlIHBhZ2VcbiAqIEBwYXJhbSBbcGFyZW50Tm9kZV0gLSB0b3AgZWxlbWVudCwgZGVmYXVsdHMgdG8gZG9jdW1lbnQuYm9keVxuICogQHBhcmFtIHtTdHJpbmd9IFttYXJrZXJOYW1lXSAtIGEgc3BlY2lhbCBhdHRyaWJ1dGUgdG8gbWFyayBldmVyeSBub2RlXG4gKiBAcmV0dXJuIHtVbmRvfSB1bmRvIGNvbW1hbmRcbiAqL1xuZXhwb3J0IHZhciBpbmVydE90aGVycyA9IGZ1bmN0aW9uIChvcmlnaW5hbFRhcmdldCwgcGFyZW50Tm9kZSwgbWFya2VyTmFtZSkge1xuICAgIGlmIChtYXJrZXJOYW1lID09PSB2b2lkIDApIHsgbWFya2VyTmFtZSA9ICdkYXRhLWluZXJ0LWVkJzsgfVxuICAgIHZhciBhY3RpdmVQYXJlbnROb2RlID0gcGFyZW50Tm9kZSB8fCBnZXREZWZhdWx0UGFyZW50KG9yaWdpbmFsVGFyZ2V0KTtcbiAgICBpZiAoIWFjdGl2ZVBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgfVxuICAgIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKG9yaWdpbmFsVGFyZ2V0LCBhY3RpdmVQYXJlbnROb2RlLCBtYXJrZXJOYW1lLCAnaW5lcnQnKTtcbn07XG4vKipcbiAqIEByZXR1cm5zIGlmIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBpbmVydFxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSW5lcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpO1xufTtcbi8qKlxuICogQXV0b21hdGljIGZ1bmN0aW9uIHRvIFwic3VwcHJlc3NcIiBET00gZWxlbWVudHMgLSBfaGlkZV8gb3IgX2luZXJ0XyBpbiB0aGUgYmVzdCBwb3NzaWJsZSB3YXlcbiAqIEBwYXJhbSB7RWxlbWVudCB8IEVsZW1lbnRbXX0gb3JpZ2luYWxUYXJnZXQgLSBlbGVtZW50cyB0byBrZWVwIG9uIHRoZSBwYWdlXG4gKiBAcGFyYW0gW3BhcmVudE5vZGVdIC0gdG9wIGVsZW1lbnQsIGRlZmF1bHRzIHRvIGRvY3VtZW50LmJvZHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWFya2VyTmFtZV0gLSBhIHNwZWNpYWwgYXR0cmlidXRlIHRvIG1hcmsgZXZlcnkgbm9kZVxuICogQHJldHVybiB7VW5kb30gdW5kbyBjb21tYW5kXG4gKi9cbmV4cG9ydCB2YXIgc3VwcHJlc3NPdGhlcnMgPSBmdW5jdGlvbiAob3JpZ2luYWxUYXJnZXQsIHBhcmVudE5vZGUsIG1hcmtlck5hbWUpIHtcbiAgICBpZiAobWFya2VyTmFtZSA9PT0gdm9pZCAwKSB7IG1hcmtlck5hbWUgPSAnZGF0YS1zdXBwcmVzc2VkJzsgfVxuICAgIHJldHVybiAoc3VwcG9ydHNJbmVydCgpID8gaW5lcnRPdGhlcnMgOiBoaWRlT3RoZXJzKShvcmlnaW5hbFRhcmdldCwgcGFyZW50Tm9kZSwgbWFya2VyTmFtZSk7XG59O1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbnZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgYXIgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgIHJldHVybiBhcjtcbiAgfTtcbiAgcmV0dXJuIG93bktleXMobyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgIGlmIChhc3luYykgaW5uZXIgPSBkaXNwb3NlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRyeSB7IGlubmVyLmNhbGwodGhpcyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9IH07XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIHZhciByLCBzID0gMDtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG4gICAgICAgIGlmIChyLmRpc3Bvc2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gci5kaXNwb3NlLmNhbGwoci52YWx1ZSk7XG4gICAgICAgICAgaWYgKHIuYXN5bmMpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgfD0gMTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzID09PSAxKSByZXR1cm4gZW52Lmhhc0Vycm9yID8gUHJvbWlzZS5yZWplY3QoZW52LmVycm9yKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiICYmIC9eXFwuXFwuP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuKHRzeCkkfCgoPzpcXC5kKT8pKCg/OlxcLlteLi9dKz8pPylcXC4oW2NtXT8pdHMkL2ksIGZ1bmN0aW9uIChtLCB0c3gsIGQsIGV4dCwgY20pIHtcbiAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX2VzRGVjb3JhdGUsXG4gIF9fcnVuSW5pdGlhbGl6ZXJzLFxuICBfX3Byb3BLZXksXG4gIF9fc2V0RnVuY3Rpb25OYW1lLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbiAgX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXG59O1xuIiwiZXhwb3J0IHZhciB6ZXJvUmlnaHRDbGFzc05hbWUgPSAncmlnaHQtc2Nyb2xsLWJhci1wb3NpdGlvbic7XG5leHBvcnQgdmFyIGZ1bGxXaWR0aENsYXNzTmFtZSA9ICd3aWR0aC1iZWZvcmUtc2Nyb2xsLWJhcic7XG5leHBvcnQgdmFyIG5vU2Nyb2xsYmFyc0NsYXNzTmFtZSA9ICd3aXRoLXNjcm9sbC1iYXJzLWhpZGRlbic7XG4vKipcbiAqIE5hbWUgb2YgYSBDU1MgdmFyaWFibGUgY29udGFpbmluZyB0aGUgYW1vdW50IG9mIFwiaGlkZGVuXCIgc2Nyb2xsYmFyXG4gKiAhIG1pZ2h0IGJlIHVuZGVmaW5lZCAhIHVzZSB3aWxsIGZhbGxiYWNrIVxuICovXG5leHBvcnQgdmFyIHJlbW92ZWRCYXJTaXplVmFyaWFibGUgPSAnLS1yZW1vdmVkLWJvZHktc2Nyb2xsLWJhci1zaXplJztcbiIsIi8qKlxuICogQXNzaWducyBhIHZhbHVlIGZvciBhIGdpdmVuIHJlZiwgbm8gbWF0dGVyIG9mIHRoZSByZWYgZm9ybWF0XG4gKiBAcGFyYW0ge1JlZk9iamVjdH0gcmVmIC0gYSBjYWxsYmFjayBmdW5jdGlvbiBvciByZWYgb2JqZWN0XG4gKiBAcGFyYW0gdmFsdWUgLSBhIG5ldyB2YWx1ZVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS91c2UtY2FsbGJhY2stcmVmI2Fzc2lnbnJlZlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlZk9iamVjdCA9IHVzZVJlZigpO1xuICogY29uc3QgcmVmRm4gPSAocmVmKSA9PiB7Li4uLn1cbiAqXG4gKiBhc3NpZ25SZWYocmVmT2JqZWN0LCBcInJlZlZhbHVlXCIpO1xuICogYXNzaWduUmVmKHJlZkZuLCBcInJlZlZhbHVlXCIpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduUmVmKHJlZiwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbiIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBjcmVhdGVzIGEgTXV0YWJsZVJlZiB3aXRoIHJlZiBjaGFuZ2UgY2FsbGJhY2tcbiAqIEBwYXJhbSBpbml0aWFsVmFsdWUgLSBpbml0aWFsIHJlZiB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBhIGNhbGxiYWNrIHRvIHJ1biB3aGVuIHZhbHVlIGNoYW5nZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcmVmID0gdXNlQ2FsbGJhY2tSZWYoMCwgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4gY29uc29sZS5sb2cob2xkVmFsdWUsICctPicsIG5ld1ZhbHVlKTtcbiAqIHJlZi5jdXJyZW50ID0gMTtcbiAqIC8vIHByaW50cyAwIC0+IDFcbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCN1c2VyZWZcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS91c2UtY2FsbGJhY2stcmVmI3VzZWNhbGxiYWNrcmVmLS0tdG8tcmVwbGFjZS1yZWFjdHVzZXJlZlxuICogQHJldHVybnMge011dGFibGVSZWZPYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFja1JlZihpbml0aWFsVmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlZiA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIC8vIHZhbHVlXG4gICAgICAgIHZhbHVlOiBpbml0aWFsVmFsdWUsXG4gICAgICAgIC8vIGxhc3QgY2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAvLyBcIm1lbW9pemVkXCIgcHVibGljIGludGVyZmFjZVxuICAgICAgICBmYWNhZGU6IHtcbiAgICAgICAgICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWYudmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IGN1cnJlbnQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5jYWxsYmFjayh2YWx1ZSwgbGFzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTsgfSlbMF07XG4gICAgLy8gdXBkYXRlIGNhbGxiYWNrXG4gICAgcmVmLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHJlZi5mYWNhZGU7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ25SZWYgfSBmcm9tICcuL2Fzc2lnblJlZic7XG5pbXBvcnQgeyB1c2VDYWxsYmFja1JlZiB9IGZyb20gJy4vdXNlUmVmJztcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgY3VycmVudFZhbHVlcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIE1lcmdlcyB0d28gb3IgbW9yZSByZWZzIHRvZ2V0aGVyIHByb3ZpZGluZyBhIHNpbmdsZSBpbnRlcmZhY2UgdG8gc2V0IHRoZWlyIHZhbHVlXG4gKiBAcGFyYW0ge1JlZk9iamVjdHxSZWZ9IHJlZnNcbiAqIEByZXR1cm5zIHtNdXRhYmxlUmVmT2JqZWN0fSAtIGEgbmV3IHJlZiwgd2hpY2ggdHJhbnNsYXRlcyBhbGwgY2hhbmdlcyB0byB7cmVmc31cbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZVJlZnN9IGEgdmVyc2lvbiB3aXRob3V0IGJ1aXQtaW4gbWVtb2l6YXRpb25cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS91c2UtY2FsbGJhY2stcmVmI3VzZW1lcmdlcmVmc1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IENvbXBvbmVudCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAqICAgY29uc3Qgb3duUmVmID0gdXNlUmVmKCk7XG4gKiAgIGNvbnN0IGRvbVJlZiA9IHVzZU1lcmdlUmVmcyhbcmVmLCBvd25SZWZdKTsgLy8g8J+RiCBtZXJnZSB0b2dldGhlclxuICogICByZXR1cm4gPGRpdiByZWY9e2RvbVJlZn0+Li4uPC9kaXY+XG4gKiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcywgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2tSZWYoZGVmYXVsdFZhbHVlIHx8IG51bGwsIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIGFzc2lnblJlZihyZWYsIG5ld1ZhbHVlKTsgfSk7XG4gICAgfSk7XG4gICAgLy8gaGFuZGxlIHJlZnMgY2hhbmdlcyAtIGFkZGVkIG9yIHJlbW92ZWRcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gY3VycmVudFZhbHVlcy5nZXQoY2FsbGJhY2tSZWYpO1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UmVmc18xID0gbmV3IFNldChvbGRWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgbmV4dFJlZnNfMSA9IG5ldyBTZXQocmVmcyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudF8xID0gY2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHByZXZSZWZzXzEuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0UmVmc18xLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnblJlZihyZWYsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dFJlZnNfMS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZSZWZzXzEuaGFzKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduUmVmKHJlZiwgY3VycmVudF8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VmFsdWVzLnNldChjYWxsYmFja1JlZiwgcmVmcyk7XG4gICAgfSwgW3JlZnNdKTtcbiAgICByZXR1cm4gY2FsbGJhY2tSZWY7XG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuZnVuY3Rpb24gSXRvSShhKSB7XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBpbm5lckNyZWF0ZU1lZGl1bShkZWZhdWx0cywgbWlkZGxld2FyZSkge1xuICAgIGlmIChtaWRkbGV3YXJlID09PSB2b2lkIDApIHsgbWlkZGxld2FyZSA9IEl0b0k7IH1cbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIGFzc2lnbmVkID0gZmFsc2U7XG4gICAgdmFyIG1lZGl1bSA9IHtcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFzc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWRlY2FyOiBjb3VsZCBub3QgYHJlYWRgIGZyb20gYW4gYGFzc2lnbmVkYCBtZWRpdW0uIGByZWFkYCBjb3VsZCBiZSB1c2VkIG9ubHkgd2l0aCBgdXNlTWVkaXVtYC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZU1lZGl1bTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbWlkZGxld2FyZShkYXRhLCBhc3NpZ25lZCk7XG4gICAgICAgICAgICBidWZmZXIucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gaXRlbTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhc3NpZ25TeW5jTWVkaXVtOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNicyA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBjYnMuZm9yRWFjaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIgPSB7XG4gICAgICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGNiKHgpOyB9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYXNzaWduTWVkaXVtOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGFzc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBwZW5kaW5nUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNicyA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBjYnMuZm9yRWFjaChjYik7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1F1ZXVlID0gYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4ZWN1dGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2JzID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGNicy5mb3JFYWNoKGNiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3ljbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGV4ZWN1dGVRdWV1ZSk7IH07XG4gICAgICAgICAgICBjeWNsZSgpO1xuICAgICAgICAgICAgYnVmZmVyID0ge1xuICAgICAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKHgpO1xuICAgICAgICAgICAgICAgICAgICBjeWNsZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdRdWV1ZSA9IHBlbmRpbmdRdWV1ZS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBtZWRpdW07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWVkaXVtKGRlZmF1bHRzLCBtaWRkbGV3YXJlKSB7XG4gICAgaWYgKG1pZGRsZXdhcmUgPT09IHZvaWQgMCkgeyBtaWRkbGV3YXJlID0gSXRvSTsgfVxuICAgIHJldHVybiBpbm5lckNyZWF0ZU1lZGl1bShkZWZhdWx0cywgbWlkZGxld2FyZSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNpZGVjYXJNZWRpdW0ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG1lZGl1bSA9IGlubmVyQ3JlYXRlTWVkaXVtKG51bGwpO1xuICAgIG1lZGl1bS5vcHRpb25zID0gX19hc3NpZ24oeyBhc3luYzogdHJ1ZSwgc3NyOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gbWVkaXVtO1xufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xudmFyIFNpZGVDYXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgc2lkZUNhciA9IF9hLnNpZGVDYXIsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInNpZGVDYXJcIl0pO1xuICAgIGlmICghc2lkZUNhcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZGVjYXI6IHBsZWFzZSBwcm92aWRlIGBzaWRlQ2FyYCBwcm9wZXJ0eSB0byBpbXBvcnQgdGhlIHJpZ2h0IGNhcicpO1xuICAgIH1cbiAgICB2YXIgVGFyZ2V0ID0gc2lkZUNhci5yZWFkKCk7XG4gICAgaWYgKCFUYXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWRlY2FyIG1lZGl1bSBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGFyZ2V0LCBfX2Fzc2lnbih7fSwgcmVzdCkpO1xufTtcblNpZGVDYXIuaXNTaWRlQ2FyRXhwb3J0ID0gdHJ1ZTtcbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRTaWRlY2FyKG1lZGl1bSwgZXhwb3J0ZWQpIHtcbiAgICBtZWRpdW0udXNlTWVkaXVtKGV4cG9ydGVkKTtcbiAgICByZXR1cm4gU2lkZUNhcjtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVNpZGVjYXJNZWRpdW0gfSBmcm9tICd1c2Utc2lkZWNhcic7XG5leHBvcnQgdmFyIGVmZmVjdENhciA9IGNyZWF0ZVNpZGVjYXJNZWRpdW0oKTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZ1bGxXaWR0aENsYXNzTmFtZSwgemVyb1JpZ2h0Q2xhc3NOYW1lIH0gZnJvbSAncmVhY3QtcmVtb3ZlLXNjcm9sbC1iYXIvY29uc3RhbnRzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJ3VzZS1jYWxsYmFjay1yZWYnO1xuaW1wb3J0IHsgZWZmZWN0Q2FyIH0gZnJvbSAnLi9tZWRpdW0nO1xudmFyIG5vdGhpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xufTtcbi8qKlxuICogUmVtb3ZlcyBzY3JvbGxiYXIgZnJvbSB0aGUgcGFnZSBhbmQgY29udGFpbiB0aGUgc2Nyb2xsIHdpdGhpbiB0aGUgTG9ja1xuICovXG52YXIgUmVtb3ZlU2Nyb2xsID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHBhcmVudFJlZikge1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoe1xuICAgICAgICBvblNjcm9sbENhcHR1cmU6IG5vdGhpbmcsXG4gICAgICAgIG9uV2hlZWxDYXB0dXJlOiBub3RoaW5nLFxuICAgICAgICBvblRvdWNoTW92ZUNhcHR1cmU6IG5vdGhpbmcsXG4gICAgfSksIGNhbGxiYWNrcyA9IF9hWzBdLCBzZXRDYWxsYmFja3MgPSBfYVsxXTtcbiAgICB2YXIgZm9yd2FyZFByb3BzID0gcHJvcHMuZm9yd2FyZFByb3BzLCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsIHJlbW92ZVNjcm9sbEJhciA9IHByb3BzLnJlbW92ZVNjcm9sbEJhciwgZW5hYmxlZCA9IHByb3BzLmVuYWJsZWQsIHNoYXJkcyA9IHByb3BzLnNoYXJkcywgc2lkZUNhciA9IHByb3BzLnNpZGVDYXIsIG5vSXNvbGF0aW9uID0gcHJvcHMubm9Jc29sYXRpb24sIGluZXJ0ID0gcHJvcHMuaW5lcnQsIGFsbG93UGluY2hab29tID0gcHJvcHMuYWxsb3dQaW5jaFpvb20sIF9iID0gcHJvcHMuYXMsIENvbnRhaW5lciA9IF9iID09PSB2b2lkIDAgPyAnZGl2JyA6IF9iLCBnYXBNb2RlID0gcHJvcHMuZ2FwTW9kZSwgcmVzdCA9IF9fcmVzdChwcm9wcywgW1wiZm9yd2FyZFByb3BzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJyZW1vdmVTY3JvbGxCYXJcIiwgXCJlbmFibGVkXCIsIFwic2hhcmRzXCIsIFwic2lkZUNhclwiLCBcIm5vSXNvbGF0aW9uXCIsIFwiaW5lcnRcIiwgXCJhbGxvd1BpbmNoWm9vbVwiLCBcImFzXCIsIFwiZ2FwTW9kZVwiXSk7XG4gICAgdmFyIFNpZGVDYXIgPSBzaWRlQ2FyO1xuICAgIHZhciBjb250YWluZXJSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgcGFyZW50UmVmXSk7XG4gICAgdmFyIGNvbnRhaW5lclByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3QpLCBjYWxsYmFja3MpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgZW5hYmxlZCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlQ2FyLCB7IHNpZGVDYXI6IGVmZmVjdENhciwgcmVtb3ZlU2Nyb2xsQmFyOiByZW1vdmVTY3JvbGxCYXIsIHNoYXJkczogc2hhcmRzLCBub0lzb2xhdGlvbjogbm9Jc29sYXRpb24sIGluZXJ0OiBpbmVydCwgc2V0Q2FsbGJhY2tzOiBzZXRDYWxsYmFja3MsIGFsbG93UGluY2hab29tOiAhIWFsbG93UGluY2hab29tLCBsb2NrUmVmOiByZWYsIGdhcE1vZGU6IGdhcE1vZGUgfSkpLFxuICAgICAgICBmb3J3YXJkUHJvcHMgPyAoUmVhY3QuY2xvbmVFbGVtZW50KFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGFpbmVyUHJvcHMpLCB7IHJlZjogY29udGFpbmVyUmVmIH0pKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250YWluZXIsIF9fYXNzaWduKHt9LCBjb250YWluZXJQcm9wcywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgcmVmOiBjb250YWluZXJSZWYgfSksIGNoaWxkcmVuKSkpKTtcbn0pO1xuUmVtb3ZlU2Nyb2xsLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHJlbW92ZVNjcm9sbEJhcjogdHJ1ZSxcbiAgICBpbmVydDogZmFsc2UsXG59O1xuUmVtb3ZlU2Nyb2xsLmNsYXNzTmFtZXMgPSB7XG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGhDbGFzc05hbWUsXG4gICAgemVyb1JpZ2h0OiB6ZXJvUmlnaHRDbGFzc05hbWUsXG59O1xuZXhwb3J0IHsgUmVtb3ZlU2Nyb2xsIH07XG4iLCJ2YXIgY3VycmVudE5vbmNlO1xuZXhwb3J0IHZhciBzZXROb25jZSA9IGZ1bmN0aW9uIChub25jZSkge1xuICAgIGN1cnJlbnROb25jZSA9IG5vbmNlO1xufTtcbmV4cG9ydCB2YXIgZ2V0Tm9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGN1cnJlbnROb25jZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudE5vbmNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuIiwiaW1wb3J0IHsgZ2V0Tm9uY2UgfSBmcm9tICdnZXQtbm9uY2UnO1xuZnVuY3Rpb24gbWFrZVN0eWxlVGFnKCkge1xuICAgIGlmICghZG9jdW1lbnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHRhZy50eXBlID0gJ3RleHQvY3NzJztcbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIGlmIChub25jZSkge1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbn1cbmZ1bmN0aW9uIGluamVjdFN0eWxlcyh0YWcsIGNzcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0YWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydFN0eWxlVGFnKHRhZykge1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQodGFnKTtcbn1cbmV4cG9ydCB2YXIgc3R5bGVzaGVldFNpbmdsZXRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlciA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZXNoZWV0ID0gbWFrZVN0eWxlVGFnKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdFN0eWxlcyhzdHlsZXNoZWV0LCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFN0eWxlVGFnKHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgICAgICBpZiAoIWNvdW50ZXIgJiYgc3R5bGVzaGVldCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQucGFyZW50Tm9kZSAmJiBzdHlsZXNoZWV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVzaGVldCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdHlsZXNoZWV0U2luZ2xldG9uIH0gZnJvbSAnLi9zaW5nbGV0b24nO1xuLyoqXG4gKiBjcmVhdGVzIGEgaG9vayB0byBjb250cm9sIHN0eWxlIHNpbmdsZXRvblxuICogQHNlZSB7QGxpbmsgc3R5bGVTaW5nbGV0b259IGZvciBhIHNhZmVyIGNvbXBvbmVudCB2ZXJzaW9uXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCB1c2VTdHlsZSA9IHN0eWxlSG9va1NpbmdsZXRvbigpO1xuICogLy8vXG4gKiB1c2VTdHlsZSgnYm9keSB7IG92ZXJmbG93OiBoaWRkZW59Jyk7XG4gKi9cbmV4cG9ydCB2YXIgc3R5bGVIb29rU2luZ2xldG9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaGVldCA9IHN0eWxlc2hlZXRTaW5nbGV0b24oKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0eWxlcywgaXNEeW5hbWljKSB7XG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaGVldC5hZGQoc3R5bGVzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2hlZXQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbc3R5bGVzICYmIGlzRHluYW1pY10pO1xuICAgIH07XG59O1xuIiwiaW1wb3J0IHsgc3R5bGVIb29rU2luZ2xldG9uIH0gZnJvbSAnLi9ob29rJztcbi8qKlxuICogY3JlYXRlIGEgQ29tcG9uZW50IHRvIGFkZCBzdHlsZXMgb24gZGVtYW5kXG4gKiAtIHN0eWxlcyBhcmUgYWRkZWQgd2hlbiBmaXJzdCBpbnN0YW5jZSBpcyBtb3VudGVkXG4gKiAtIHN0eWxlcyBhcmUgcmVtb3ZlZCB3aGVuIHRoZSBsYXN0IGluc3RhbmNlIGlzIHVubW91bnRlZFxuICogLSBjaGFuZ2luZyBzdHlsZXMgaW4gcnVudGltZSBkb2VzIG5vdGhpbmcgdW5sZXNzIGR5bmFtaWMgaXMgc2V0LiBCdXQgd2l0aCBtdWx0aXBsZSBjb21wb25lbnRzIHRoYXQgY2FuIGxlYWQgdG8gdGhlIHVuZGVmaW5lZCBiZWhhdmlvclxuICovXG5leHBvcnQgdmFyIHN0eWxlU2luZ2xldG9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VTdHlsZSA9IHN0eWxlSG9va1NpbmdsZXRvbigpO1xuICAgIHZhciBTaGVldCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3R5bGVzID0gX2Euc3R5bGVzLCBkeW5hbWljID0gX2EuZHluYW1pYztcbiAgICAgICAgdXNlU3R5bGUoc3R5bGVzLCBkeW5hbWljKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2hlZXQ7XG59O1xuIiwiZXhwb3J0IHZhciB6ZXJvR2FwID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGdhcDogMCxcbn07XG52YXIgcGFyc2UgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcGFyc2VJbnQoeCB8fCAnJywgMTApIHx8IDA7IH07XG52YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGdhcE1vZGUpIHtcbiAgICB2YXIgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgICB2YXIgbGVmdCA9IGNzW2dhcE1vZGUgPT09ICdwYWRkaW5nJyA/ICdwYWRkaW5nTGVmdCcgOiAnbWFyZ2luTGVmdCddO1xuICAgIHZhciB0b3AgPSBjc1tnYXBNb2RlID09PSAncGFkZGluZycgPyAncGFkZGluZ1RvcCcgOiAnbWFyZ2luVG9wJ107XG4gICAgdmFyIHJpZ2h0ID0gY3NbZ2FwTW9kZSA9PT0gJ3BhZGRpbmcnID8gJ3BhZGRpbmdSaWdodCcgOiAnbWFyZ2luUmlnaHQnXTtcbiAgICByZXR1cm4gW3BhcnNlKGxlZnQpLCBwYXJzZSh0b3ApLCBwYXJzZShyaWdodCldO1xufTtcbmV4cG9ydCB2YXIgZ2V0R2FwV2lkdGggPSBmdW5jdGlvbiAoZ2FwTW9kZSkge1xuICAgIGlmIChnYXBNb2RlID09PSB2b2lkIDApIHsgZ2FwTW9kZSA9ICdtYXJnaW4nOyB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB6ZXJvR2FwO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldChnYXBNb2RlKTtcbiAgICB2YXIgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICB2YXIgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBvZmZzZXRzWzBdLFxuICAgICAgICB0b3A6IG9mZnNldHNbMV0sXG4gICAgICAgIHJpZ2h0OiBvZmZzZXRzWzJdLFxuICAgICAgICBnYXA6IE1hdGgubWF4KDAsIHdpbmRvd1dpZHRoIC0gZG9jdW1lbnRXaWR0aCArIG9mZnNldHNbMl0gLSBvZmZzZXRzWzBdKSxcbiAgICB9O1xufTtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0eWxlU2luZ2xldG9uIH0gZnJvbSAncmVhY3Qtc3R5bGUtc2luZ2xldG9uJztcbmltcG9ydCB7IGZ1bGxXaWR0aENsYXNzTmFtZSwgemVyb1JpZ2h0Q2xhc3NOYW1lLCBub1Njcm9sbGJhcnNDbGFzc05hbWUsIHJlbW92ZWRCYXJTaXplVmFyaWFibGUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRHYXBXaWR0aCB9IGZyb20gJy4vdXRpbHMnO1xudmFyIFN0eWxlID0gc3R5bGVTaW5nbGV0b24oKTtcbmV4cG9ydCB2YXIgbG9ja0F0dHJpYnV0ZSA9ICdkYXRhLXNjcm9sbC1sb2NrZWQnO1xuLy8gaW1wb3J0YW50IHRpcCAtIG9uY2Ugd2UgbWVhc3VyZSBzY3JvbGxCYXIgd2lkdGggYW5kIHJlbW92ZSB0aGVtXG4vLyB3ZSBjb3VsZCBub3QgcmVwZWF0IHRoaXMgb3BlcmF0aW9uXG4vLyB0aHVzIHdlIGFyZSB1c2luZyBzdHlsZS1zaW5nbGV0b24gLSBvbmx5IHRoZSBmaXJzdCBcInlldCBjb3JyZWN0XCIgc3R5bGUgd2lsbCBiZSBhcHBsaWVkLlxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIChfYSwgYWxsb3dSZWxhdGl2ZSwgZ2FwTW9kZSwgaW1wb3J0YW50KSB7XG4gICAgdmFyIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGdhcCA9IF9hLmdhcDtcbiAgICBpZiAoZ2FwTW9kZSA9PT0gdm9pZCAwKSB7IGdhcE1vZGUgPSAnbWFyZ2luJzsgfVxuICAgIHJldHVybiBcIlxcbiAgLlwiLmNvbmNhdChub1Njcm9sbGJhcnNDbGFzc05hbWUsIFwiIHtcXG4gICBvdmVyZmxvdzogaGlkZGVuIFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gICBwYWRkaW5nLXJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICB9XFxuICBib2R5W1wiKS5jb25jYXQobG9ja0F0dHJpYnV0ZSwgXCJdIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbiBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3I6IGNvbnRhaW47XFxuICAgIFwiKS5jb25jYXQoW1xuICAgICAgICBhbGxvd1JlbGF0aXZlICYmIFwicG9zaXRpb246IHJlbGF0aXZlIFwiLmNvbmNhdChpbXBvcnRhbnQsIFwiO1wiKSxcbiAgICAgICAgZ2FwTW9kZSA9PT0gJ21hcmdpbicgJiZcbiAgICAgICAgICAgIFwiXFxuICAgIHBhZGRpbmctbGVmdDogXCIuY29uY2F0KGxlZnQsIFwicHg7XFxuICAgIHBhZGRpbmctdG9wOiBcIikuY29uY2F0KHRvcCwgXCJweDtcXG4gICAgcGFkZGluZy1yaWdodDogXCIpLmNvbmNhdChyaWdodCwgXCJweDtcXG4gICAgbWFyZ2luLWxlZnQ6MDtcXG4gICAgbWFyZ2luLXRvcDowO1xcbiAgICBtYXJnaW4tcmlnaHQ6IFwiKS5jb25jYXQoZ2FwLCBcInB4IFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gICAgXCIpLFxuICAgICAgICBnYXBNb2RlID09PSAncGFkZGluZycgJiYgXCJwYWRkaW5nLXJpZ2h0OiBcIi5jb25jYXQoZ2FwLCBcInB4IFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcIiksXG4gICAgXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKCcnKSwgXCJcXG4gIH1cXG4gIFxcbiAgLlwiKS5jb25jYXQoemVyb1JpZ2h0Q2xhc3NOYW1lLCBcIiB7XFxuICAgIHJpZ2h0OiBcIikuY29uY2F0KGdhcCwgXCJweCBcIikuY29uY2F0KGltcG9ydGFudCwgXCI7XFxuICB9XFxuICBcXG4gIC5cIikuY29uY2F0KGZ1bGxXaWR0aENsYXNzTmFtZSwgXCIge1xcbiAgICBtYXJnaW4tcmlnaHQ6IFwiKS5jb25jYXQoZ2FwLCBcInB4IFwiKS5jb25jYXQoaW1wb3J0YW50LCBcIjtcXG4gIH1cXG4gIFxcbiAgLlwiKS5jb25jYXQoemVyb1JpZ2h0Q2xhc3NOYW1lLCBcIiAuXCIpLmNvbmNhdCh6ZXJvUmlnaHRDbGFzc05hbWUsIFwiIHtcXG4gICAgcmlnaHQ6IDAgXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgXFxuICAuXCIpLmNvbmNhdChmdWxsV2lkdGhDbGFzc05hbWUsIFwiIC5cIikuY29uY2F0KGZ1bGxXaWR0aENsYXNzTmFtZSwgXCIge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAgXCIpLmNvbmNhdChpbXBvcnRhbnQsIFwiO1xcbiAgfVxcbiAgXFxuICBib2R5W1wiKS5jb25jYXQobG9ja0F0dHJpYnV0ZSwgXCJdIHtcXG4gICAgXCIpLmNvbmNhdChyZW1vdmVkQmFyU2l6ZVZhcmlhYmxlLCBcIjogXCIpLmNvbmNhdChnYXAsIFwicHg7XFxuICB9XFxuXCIpO1xufTtcbnZhciBnZXRDdXJyZW50VXNlQ291bnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY291bnRlciA9IHBhcnNlSW50KGRvY3VtZW50LmJvZHkuZ2V0QXR0cmlidXRlKGxvY2tBdHRyaWJ1dGUpIHx8ICcwJywgMTApO1xuICAgIHJldHVybiBpc0Zpbml0ZShjb3VudGVyKSA/IGNvdW50ZXIgOiAwO1xufTtcbmV4cG9ydCB2YXIgdXNlTG9ja0F0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShsb2NrQXR0cmlidXRlLCAoZ2V0Q3VycmVudFVzZUNvdW50ZXIoKSArIDEpLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld0NvdW50ZXIgPSBnZXRDdXJyZW50VXNlQ291bnRlcigpIC0gMTtcbiAgICAgICAgICAgIGlmIChuZXdDb3VudGVyIDw9IDApIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZShsb2NrQXR0cmlidXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2V0QXR0cmlidXRlKGxvY2tBdHRyaWJ1dGUsIG5ld0NvdW50ZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufTtcbi8qKlxuICogUmVtb3ZlcyBwYWdlIHNjcm9sbGJhciBhbmQgYmxvY2tzIHBhZ2Ugc2Nyb2xsIHdoZW4gbW91bnRlZFxuICovXG5leHBvcnQgdmFyIFJlbW92ZVNjcm9sbEJhciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBub1JlbGF0aXZlID0gX2Eubm9SZWxhdGl2ZSwgbm9JbXBvcnRhbnQgPSBfYS5ub0ltcG9ydGFudCwgX2IgPSBfYS5nYXBNb2RlLCBnYXBNb2RlID0gX2IgPT09IHZvaWQgMCA/ICdtYXJnaW4nIDogX2I7XG4gICAgdXNlTG9ja0F0dHJpYnV0ZSgpO1xuICAgIC8qXG4gICAgIGdhcCB3aWxsIGJlIG1lYXN1cmVkIG9uIGV2ZXJ5IGNvbXBvbmVudCBtb3VudFxuICAgICBob3dldmVyIGl0IHdpbGwgYmUgdXNlZCBvbmx5IGJ5IHRoZSBcImZpcnN0XCIgaW52b2NhdGlvblxuICAgICBkdWUgdG8gc2luZ2xldG9uIG5hdHVyZSBvZiA8U3R5bGVcbiAgICAgKi9cbiAgICB2YXIgZ2FwID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRHYXBXaWR0aChnYXBNb2RlKTsgfSwgW2dhcE1vZGVdKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTdHlsZSwgeyBzdHlsZXM6IGdldFN0eWxlcyhnYXAsICFub1JlbGF0aXZlLCBnYXBNb2RlLCAhbm9JbXBvcnRhbnQgPyAnIWltcG9ydGFudCcgOiAnJykgfSk7XG59O1xuIiwidmFyIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgdmFyIG5vblBhc3NpdmUgPSBwYXNzaXZlU3VwcG9ydGVkID8geyBwYXNzaXZlOiBmYWxzZSB9IDogZmFsc2U7XG4iLCJ2YXIgYWx3YXlzQ29udGFpbnNTY3JvbGwgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIHRleHRhcmVhIHdpbGwgYWx3YXlzIF9jb250YWluXyBzY3JvbGwgaW5zaWRlIHNlbGYuIEl0IG9ubHkgY2FuIGJlIGhpZGRlblxuICAgIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdURVhUQVJFQSc7XG59O1xudmFyIGVsZW1lbnRDYW5CZVNjcm9sbGVkID0gZnVuY3Rpb24gKG5vZGUsIG92ZXJmbG93KSB7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIHJldHVybiAoXG4gICAgLy8gbm90LW5vdC1zY3JvbGxhYmxlXG4gICAgc3R5bGVzW292ZXJmbG93XSAhPT0gJ2hpZGRlbicgJiZcbiAgICAgICAgLy8gY29udGFpbnMgc2Nyb2xsIGluc2lkZSBzZWxmXG4gICAgICAgICEoc3R5bGVzLm92ZXJmbG93WSA9PT0gc3R5bGVzLm92ZXJmbG93WCAmJiAhYWx3YXlzQ29udGFpbnNTY3JvbGwobm9kZSkgJiYgc3R5bGVzW292ZXJmbG93XSA9PT0gJ3Zpc2libGUnKSk7XG59O1xudmFyIGVsZW1lbnRDb3VsZEJlVlNjcm9sbGVkID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGVsZW1lbnRDYW5CZVNjcm9sbGVkKG5vZGUsICdvdmVyZmxvd1knKTsgfTtcbnZhciBlbGVtZW50Q291bGRCZUhTY3JvbGxlZCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBlbGVtZW50Q2FuQmVTY3JvbGxlZChub2RlLCAnb3ZlcmZsb3dYJyk7IH07XG5leHBvcnQgdmFyIGxvY2F0aW9uQ291bGRCZVNjcm9sbGVkID0gZnVuY3Rpb24gKGF4aXMsIG5vZGUpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XG4gICAgZG8ge1xuICAgICAgICAvLyBTa2lwIG92ZXIgc2hhZG93IHJvb3RcbiAgICAgICAgaWYgKHR5cGVvZiBTaGFkb3dSb290ICE9PSAndW5kZWZpbmVkJyAmJiBjdXJyZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNTY3JvbGxhYmxlID0gZWxlbWVudENvdWxkQmVTY3JvbGxlZChheGlzLCBjdXJyZW50KTtcbiAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0U2Nyb2xsVmFyaWFibGVzKGF4aXMsIGN1cnJlbnQpLCBzY3JvbGxIZWlnaHQgPSBfYVsxXSwgY2xpZW50SGVpZ2h0ID0gX2FbMl07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsSGVpZ2h0ID4gY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IG93bmVyRG9jdW1lbnQuYm9keSk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBnZXRWU2Nyb2xsVmFyaWFibGVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IF9hLnNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0ID0gX2Euc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgPSBfYS5jbGllbnRIZWlnaHQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2Nyb2xsVG9wLFxuICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgIGNsaWVudEhlaWdodCxcbiAgICBdO1xufTtcbnZhciBnZXRIU2Nyb2xsVmFyaWFibGVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNjcm9sbExlZnQgPSBfYS5zY3JvbGxMZWZ0LCBzY3JvbGxXaWR0aCA9IF9hLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aCA9IF9hLmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFdpZHRoLFxuICAgICAgICBjbGllbnRXaWR0aCxcbiAgICBdO1xufTtcbnZhciBlbGVtZW50Q291bGRCZVNjcm9sbGVkID0gZnVuY3Rpb24gKGF4aXMsIG5vZGUpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3YnID8gZWxlbWVudENvdWxkQmVWU2Nyb2xsZWQobm9kZSkgOiBlbGVtZW50Q291bGRCZUhTY3JvbGxlZChub2RlKTtcbn07XG52YXIgZ2V0U2Nyb2xsVmFyaWFibGVzID0gZnVuY3Rpb24gKGF4aXMsIG5vZGUpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3YnID8gZ2V0VlNjcm9sbFZhcmlhYmxlcyhub2RlKSA6IGdldEhTY3JvbGxWYXJpYWJsZXMobm9kZSk7XG59O1xudmFyIGdldERpcmVjdGlvbkZhY3RvciA9IGZ1bmN0aW9uIChheGlzLCBkaXJlY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCdzIGRpcmVjdGlvbiBpcyBydGwgKHJpZ2h0LXRvLWxlZnQpLCB0aGVuIHNjcm9sbExlZnQgaXMgMCB3aGVuIHRoZSBzY3JvbGxiYXIgaXMgYXQgaXRzIHJpZ2h0bW9zdCBwb3NpdGlvbixcbiAgICAgKiBhbmQgdGhlbiBpbmNyZWFzaW5nbHkgbmVnYXRpdmUgYXMgeW91IHNjcm9sbCB0b3dhcmRzIHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zY3JvbGxMZWZ0XG4gICAgICovXG4gICAgcmV0dXJuIGF4aXMgPT09ICdoJyAmJiBkaXJlY3Rpb24gPT09ICdydGwnID8gLTEgOiAxO1xufTtcbmV4cG9ydCB2YXIgaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gKGF4aXMsIGVuZFRhcmdldCwgZXZlbnQsIHNvdXJjZURlbHRhLCBub092ZXJzY3JvbGwpIHtcbiAgICB2YXIgZGlyZWN0aW9uRmFjdG9yID0gZ2V0RGlyZWN0aW9uRmFjdG9yKGF4aXMsIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVuZFRhcmdldCkuZGlyZWN0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb25GYWN0b3IgKiBzb3VyY2VEZWx0YTtcbiAgICAvLyBmaW5kIHNjcm9sbGFibGUgdGFyZ2V0XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgdGFyZ2V0SW5Mb2NrID0gZW5kVGFyZ2V0LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgdmFyIHNob3VsZENhbmNlbFNjcm9sbCA9IGZhbHNlO1xuICAgIHZhciBpc0RlbHRhUG9zaXRpdmUgPSBkZWx0YSA+IDA7XG4gICAgdmFyIGF2YWlsYWJsZVNjcm9sbCA9IDA7XG4gICAgdmFyIGF2YWlsYWJsZVNjcm9sbFRvcCA9IDA7XG4gICAgZG8ge1xuICAgICAgICB2YXIgX2EgPSBnZXRTY3JvbGxWYXJpYWJsZXMoYXhpcywgdGFyZ2V0KSwgcG9zaXRpb24gPSBfYVswXSwgc2Nyb2xsXzEgPSBfYVsxXSwgY2FwYWNpdHkgPSBfYVsyXTtcbiAgICAgICAgdmFyIGVsZW1lbnRTY3JvbGwgPSBzY3JvbGxfMSAtIGNhcGFjaXR5IC0gZGlyZWN0aW9uRmFjdG9yICogcG9zaXRpb247XG4gICAgICAgIGlmIChwb3NpdGlvbiB8fCBlbGVtZW50U2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudENvdWxkQmVTY3JvbGxlZChheGlzLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlU2Nyb2xsICs9IGVsZW1lbnRTY3JvbGw7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlU2Nyb2xsVG9wICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoXG4gICAgLy8gcG9ydGFsZWQgY29udGVudFxuICAgICghdGFyZ2V0SW5Mb2NrICYmIHRhcmdldCAhPT0gZG9jdW1lbnQuYm9keSkgfHxcbiAgICAgICAgLy8gc2VsZiBjb250ZW50XG4gICAgICAgICh0YXJnZXRJbkxvY2sgJiYgKGVuZFRhcmdldC5jb250YWlucyh0YXJnZXQpIHx8IGVuZFRhcmdldCA9PT0gdGFyZ2V0KSkpO1xuICAgIC8vIGhhbmRsZSBlcHNpbG9uIGFyb3VuZCAwIChub24gc3RhbmRhcmQgem9vbSBsZXZlbHMpXG4gICAgaWYgKGlzRGVsdGFQb3NpdGl2ZSAmJlxuICAgICAgICAoKG5vT3ZlcnNjcm9sbCAmJiBNYXRoLmFicyhhdmFpbGFibGVTY3JvbGwpIDwgMSkgfHwgKCFub092ZXJzY3JvbGwgJiYgZGVsdGEgPiBhdmFpbGFibGVTY3JvbGwpKSkge1xuICAgICAgICBzaG91bGRDYW5jZWxTY3JvbGwgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNEZWx0YVBvc2l0aXZlICYmXG4gICAgICAgICgobm9PdmVyc2Nyb2xsICYmIE1hdGguYWJzKGF2YWlsYWJsZVNjcm9sbFRvcCkgPCAxKSB8fCAoIW5vT3ZlcnNjcm9sbCAmJiAtZGVsdGEgPiBhdmFpbGFibGVTY3JvbGxUb3ApKSkge1xuICAgICAgICBzaG91bGRDYW5jZWxTY3JvbGwgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkQ2FuY2VsU2Nyb2xsO1xufTtcbiIsImltcG9ydCB7IF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlbW92ZVNjcm9sbEJhciB9IGZyb20gJ3JlYWN0LXJlbW92ZS1zY3JvbGwtYmFyJztcbmltcG9ydCB7IHN0eWxlU2luZ2xldG9uIH0gZnJvbSAncmVhY3Qtc3R5bGUtc2luZ2xldG9uJztcbmltcG9ydCB7IG5vblBhc3NpdmUgfSBmcm9tICcuL2FnZ3Jlc2l2ZUNhcHR1cmUnO1xuaW1wb3J0IHsgaGFuZGxlU2Nyb2xsLCBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZCB9IGZyb20gJy4vaGFuZGxlU2Nyb2xsJztcbmV4cG9ydCB2YXIgZ2V0VG91Y2hYWSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2hhbmdlZFRvdWNoZXMnIGluIGV2ZW50ID8gW2V2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFldIDogWzAsIDBdO1xufTtcbmV4cG9ydCB2YXIgZ2V0RGVsdGFYWSA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gW2V2ZW50LmRlbHRhWCwgZXZlbnQuZGVsdGFZXTsgfTtcbnZhciBleHRyYWN0UmVmID0gZnVuY3Rpb24gKHJlZikge1xuICAgIHJldHVybiByZWYgJiYgJ2N1cnJlbnQnIGluIHJlZiA/IHJlZi5jdXJyZW50IDogcmVmO1xufTtcbnZhciBkZWx0YUNvbXBhcmUgPSBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geFswXSA9PT0geVswXSAmJiB4WzFdID09PSB5WzFdOyB9O1xudmFyIGdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIFwiXFxuICAuYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQsIFwiIHtwb2ludGVyLWV2ZW50czogbm9uZTt9XFxuICAuYWxsb3ctaW50ZXJhY3Rpdml0eS1cIikuY29uY2F0KGlkLCBcIiB7cG9pbnRlci1ldmVudHM6IGFsbDt9XFxuXCIpOyB9O1xudmFyIGlkQ291bnRlciA9IDA7XG52YXIgbG9ja1N0YWNrID0gW107XG5leHBvcnQgZnVuY3Rpb24gUmVtb3ZlU2Nyb2xsU2lkZUNhcihwcm9wcykge1xuICAgIHZhciBzaG91bGRQcmV2ZW50UXVldWUgPSBSZWFjdC51c2VSZWYoW10pO1xuICAgIHZhciB0b3VjaFN0YXJ0UmVmID0gUmVhY3QudXNlUmVmKFswLCAwXSk7XG4gICAgdmFyIGFjdGl2ZUF4aXMgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgaWQgPSBSZWFjdC51c2VTdGF0ZShpZENvdW50ZXIrKylbMF07XG4gICAgdmFyIFN0eWxlID0gUmVhY3QudXNlU3RhdGUoc3R5bGVTaW5nbGV0b24pWzBdO1xuICAgIHZhciBsYXN0UHJvcHMgPSBSZWFjdC51c2VSZWYocHJvcHMpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxhc3RQcm9wcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgfSwgW3Byb3BzXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BzLmluZXJ0KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJibG9jay1pbnRlcmFjdGl2aXR5LVwiLmNvbmNhdChpZCkpO1xuICAgICAgICAgICAgdmFyIGFsbG93XzEgPSBfX3NwcmVhZEFycmF5KFtwcm9wcy5sb2NrUmVmLmN1cnJlbnRdLCAocHJvcHMuc2hhcmRzIHx8IFtdKS5tYXAoZXh0cmFjdFJlZiksIHRydWUpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIGFsbG93XzEuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoXCJhbGxvdy1pbnRlcmFjdGl2aXR5LVwiLmNvbmNhdChpZCkpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiYmxvY2staW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgICAgICBhbGxvd18xLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKFwiYWxsb3ctaW50ZXJhY3Rpdml0eS1cIi5jb25jYXQoaWQpKTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9LCBbcHJvcHMuaW5lcnQsIHByb3BzLmxvY2tSZWYuY3VycmVudCwgcHJvcHMuc2hhcmRzXSk7XG4gICAgdmFyIHNob3VsZENhbmNlbEV2ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50LCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKCgndG91Y2hlcycgaW4gZXZlbnQgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpIHx8IChldmVudC50eXBlID09PSAnd2hlZWwnICYmIGV2ZW50LmN0cmxLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gIWxhc3RQcm9wcy5jdXJyZW50LmFsbG93UGluY2hab29tO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3VjaCA9IGdldFRvdWNoWFkoZXZlbnQpO1xuICAgICAgICB2YXIgdG91Y2hTdGFydCA9IHRvdWNoU3RhcnRSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGRlbHRhWCA9ICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogdG91Y2hTdGFydFswXSAtIHRvdWNoWzBdO1xuICAgICAgICB2YXIgZGVsdGFZID0gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiB0b3VjaFN0YXJ0WzFdIC0gdG91Y2hbMV07XG4gICAgICAgIHZhciBjdXJyZW50QXhpcztcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIG1vdmVEaXJlY3Rpb24gPSBNYXRoLmFicyhkZWx0YVgpID4gTWF0aC5hYnMoZGVsdGFZKSA/ICdoJyA6ICd2JztcbiAgICAgICAgLy8gYWxsb3cgaG9yaXpvbnRhbCB0b3VjaCBtb3ZlIG9uIFJhbmdlIGlucHV0cy4gVGhleSB3aWxsIG5vdCBjYXVzZSBhbnkgc2Nyb2xsXG4gICAgICAgIGlmICgndG91Y2hlcycgaW4gZXZlbnQgJiYgbW92ZURpcmVjdGlvbiA9PT0gJ2gnICYmIHRhcmdldC50eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24gPSBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZChtb3ZlRGlyZWN0aW9uLCB0YXJnZXQpO1xuICAgICAgICBpZiAoIWNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5CZVNjcm9sbGVkSW5NYWluRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjdXJyZW50QXhpcyA9IG1vdmVEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50QXhpcyA9IG1vdmVEaXJlY3Rpb24gPT09ICd2JyA/ICdoJyA6ICd2JztcbiAgICAgICAgICAgIGNhbkJlU2Nyb2xsZWRJbk1haW5EaXJlY3Rpb24gPSBsb2NhdGlvbkNvdWxkQmVTY3JvbGxlZChtb3ZlRGlyZWN0aW9uLCB0YXJnZXQpO1xuICAgICAgICAgICAgLy8gb3RoZXIgYXhpcyBtaWdodCBiZSBub3Qgc2Nyb2xsYWJsZVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuQmVTY3JvbGxlZEluTWFpbkRpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWN0aXZlQXhpcy5jdXJyZW50ICYmICdjaGFuZ2VkVG91Y2hlcycgaW4gZXZlbnQgJiYgKGRlbHRhWCB8fCBkZWx0YVkpKSB7XG4gICAgICAgICAgICBhY3RpdmVBeGlzLmN1cnJlbnQgPSBjdXJyZW50QXhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRBeGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FuY2VsaW5nQXhpcyA9IGFjdGl2ZUF4aXMuY3VycmVudCB8fCBjdXJyZW50QXhpcztcbiAgICAgICAgcmV0dXJuIGhhbmRsZVNjcm9sbChjYW5jZWxpbmdBeGlzLCBwYXJlbnQsIGV2ZW50LCBjYW5jZWxpbmdBeGlzID09PSAnaCcgPyBkZWx0YVggOiBkZWx0YVksIHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChfZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gX2V2ZW50O1xuICAgICAgICBpZiAoIWxvY2tTdGFjay5sZW5ndGggfHwgbG9ja1N0YWNrW2xvY2tTdGFjay5sZW5ndGggLSAxXSAhPT0gU3R5bGUpIHtcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgbGFzdCBhY3RpdmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsdGEgPSAnZGVsdGFZJyBpbiBldmVudCA/IGdldERlbHRhWFkoZXZlbnQpIDogZ2V0VG91Y2hYWShldmVudCk7XG4gICAgICAgIHZhciBzb3VyY2VFdmVudCA9IHNob3VsZFByZXZlbnRRdWV1ZS5jdXJyZW50LmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5uYW1lID09PSBldmVudC50eXBlICYmIChlLnRhcmdldCA9PT0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnRhcmdldCA9PT0gZS5zaGFkb3dQYXJlbnQpICYmIGRlbHRhQ29tcGFyZShlLmRlbHRhLCBkZWx0YSk7IH0pWzBdO1xuICAgICAgICAvLyBzZWxmIGV2ZW50LCBhbmQgc2hvdWxkIGJlIGNhbmNlbGVkXG4gICAgICAgIGlmIChzb3VyY2VFdmVudCAmJiBzb3VyY2VFdmVudC5zaG91bGQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdXRzaWRlIG9yIHNoYXJkIGV2ZW50XG4gICAgICAgIGlmICghc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzaGFyZE5vZGVzID0gKGxhc3RQcm9wcy5jdXJyZW50LnNoYXJkcyB8fCBbXSlcbiAgICAgICAgICAgICAgICAubWFwKGV4dHJhY3RSZWYpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuY29udGFpbnMoZXZlbnQudGFyZ2V0KTsgfSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkU3RvcCA9IHNoYXJkTm9kZXMubGVuZ3RoID4gMCA/IHNob3VsZENhbmNlbEV2ZW50KGV2ZW50LCBzaGFyZE5vZGVzWzBdKSA6ICFsYXN0UHJvcHMuY3VycmVudC5ub0lzb2xhdGlvbjtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIHNob3VsZENhbmNlbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuYW1lLCBkZWx0YSwgdGFyZ2V0LCBzaG91bGQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0geyBuYW1lOiBuYW1lLCBkZWx0YTogZGVsdGEsIHRhcmdldDogdGFyZ2V0LCBzaG91bGQ6IHNob3VsZCwgc2hhZG93UGFyZW50OiBnZXRPdXRlcm1vc3RTaGFkb3dQYXJlbnQodGFyZ2V0KSB9O1xuICAgICAgICBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudC5wdXNoKGV2ZW50KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaG91bGRQcmV2ZW50UXVldWUuY3VycmVudCA9IHNob3VsZFByZXZlbnRRdWV1ZS5jdXJyZW50LmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZSAhPT0gZXZlbnQ7IH0pO1xuICAgICAgICB9LCAxKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNjcm9sbFRvdWNoU3RhcnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdG91Y2hTdGFydFJlZi5jdXJyZW50ID0gZ2V0VG91Y2hYWShldmVudCk7XG4gICAgICAgIGFjdGl2ZUF4aXMuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNjcm9sbFdoZWVsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNob3VsZENhbmNlbChldmVudC50eXBlLCBnZXREZWx0YVhZKGV2ZW50KSwgZXZlbnQudGFyZ2V0LCBzaG91bGRDYW5jZWxFdmVudChldmVudCwgcHJvcHMubG9ja1JlZi5jdXJyZW50KSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBzY3JvbGxUb3VjaE1vdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc2hvdWxkQ2FuY2VsKGV2ZW50LnR5cGUsIGdldFRvdWNoWFkoZXZlbnQpLCBldmVudC50YXJnZXQsIHNob3VsZENhbmNlbEV2ZW50KGV2ZW50LCBwcm9wcy5sb2NrUmVmLmN1cnJlbnQpKTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9ja1N0YWNrLnB1c2goU3R5bGUpO1xuICAgICAgICBwcm9wcy5zZXRDYWxsYmFja3Moe1xuICAgICAgICAgICAgb25TY3JvbGxDYXB0dXJlOiBzY3JvbGxXaGVlbCxcbiAgICAgICAgICAgIG9uV2hlZWxDYXB0dXJlOiBzY3JvbGxXaGVlbCxcbiAgICAgICAgICAgIG9uVG91Y2hNb3ZlQ2FwdHVyZTogc2Nyb2xsVG91Y2hNb3ZlLFxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBzaG91bGRQcmV2ZW50LCBub25QYXNzaXZlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBzY3JvbGxUb3VjaFN0YXJ0LCBub25QYXNzaXZlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvY2tTdGFjayA9IGxvY2tTdGFjay5maWx0ZXIoZnVuY3Rpb24gKGluc3QpIHsgcmV0dXJuIGluc3QgIT09IFN0eWxlOyB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgc2hvdWxkUHJldmVudCwgbm9uUGFzc2l2ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBzaG91bGRQcmV2ZW50LCBub25QYXNzaXZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBzY3JvbGxUb3VjaFN0YXJ0LCBub25QYXNzaXZlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJlbW92ZVNjcm9sbEJhciA9IHByb3BzLnJlbW92ZVNjcm9sbEJhciwgaW5lcnQgPSBwcm9wcy5pbmVydDtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGluZXJ0ID8gUmVhY3QuY3JlYXRlRWxlbWVudChTdHlsZSwgeyBzdHlsZXM6IGdlbmVyYXRlU3R5bGUoaWQpIH0pIDogbnVsbCxcbiAgICAgICAgcmVtb3ZlU2Nyb2xsQmFyID8gUmVhY3QuY3JlYXRlRWxlbWVudChSZW1vdmVTY3JvbGxCYXIsIHsgZ2FwTW9kZTogcHJvcHMuZ2FwTW9kZSB9KSA6IG51bGwpKTtcbn1cbmZ1bmN0aW9uIGdldE91dGVybW9zdFNoYWRvd1BhcmVudChub2RlKSB7XG4gICAgdmFyIHNoYWRvd1BhcmVudCA9IG51bGw7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICBzaGFkb3dQYXJlbnQgPSBub2RlLmhvc3Q7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3dQYXJlbnQ7XG59XG4iLCJpbXBvcnQgeyBleHBvcnRTaWRlY2FyIH0gZnJvbSAndXNlLXNpZGVjYXInO1xuaW1wb3J0IHsgUmVtb3ZlU2Nyb2xsU2lkZUNhciB9IGZyb20gJy4vU2lkZUVmZmVjdCc7XG5pbXBvcnQgeyBlZmZlY3RDYXIgfSBmcm9tICcuL21lZGl1bSc7XG5leHBvcnQgZGVmYXVsdCBleHBvcnRTaWRlY2FyKGVmZmVjdENhciwgUmVtb3ZlU2Nyb2xsU2lkZUNhcik7XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVtb3ZlU2Nyb2xsIH0gZnJvbSAnLi9VSSc7XG5pbXBvcnQgU2lkZUNhciBmcm9tICcuL3NpZGVjYXInO1xudmFyIFJlYWN0UmVtb3ZlU2Nyb2xsID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtb3ZlU2Nyb2xsLCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgcmVmOiByZWYsIHNpZGVDYXI6IFNpZGVDYXIgfSkpKTsgfSk7XG5SZWFjdFJlbW92ZVNjcm9sbC5jbGFzc05hbWVzID0gUmVtb3ZlU2Nyb2xsLmNsYXNzTmFtZXM7XG5leHBvcnQgZGVmYXVsdCBSZWFjdFJlbW92ZVNjcm9sbDtcbiIsIlwidXNlIGNsaWVudFwiO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9zZWxlY3Qvc3JjL3NlbGVjdC50c3hcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tIFwiQHJhZGl4LXVpL251bWJlclwiO1xuaW1wb3J0IHsgY29tcG9zZUV2ZW50SGFuZGxlcnMgfSBmcm9tIFwiQHJhZGl4LXVpL3ByaW1pdGl2ZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29sbGVjdGlvbiB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29sbGVjdGlvblwiO1xuaW1wb3J0IHsgdXNlQ29tcG9zZWRSZWZzIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1jb21wb3NlLXJlZnNcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHRTY29wZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtY29udGV4dFwiO1xuaW1wb3J0IHsgdXNlRGlyZWN0aW9uIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1kaXJlY3Rpb25cIjtcbmltcG9ydCB7IERpc21pc3NhYmxlTGF5ZXIgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWRpc21pc3NhYmxlLWxheWVyXCI7XG5pbXBvcnQgeyB1c2VGb2N1c0d1YXJkcyB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtZm9jdXMtZ3VhcmRzXCI7XG5pbXBvcnQgeyBGb2N1c1Njb3BlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1mb2N1cy1zY29wZVwiO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LWlkXCI7XG5pbXBvcnQgKiBhcyBQb3BwZXJQcmltaXRpdmUgZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wb3BwZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcHBlclNjb3BlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wb3BwZXJcIjtcbmltcG9ydCB7IFBvcnRhbCBhcyBQb3J0YWxQcmltaXRpdmUgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXBvcnRhbFwiO1xuaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC1wcmltaXRpdmVcIjtcbmltcG9ydCB7IFNsb3QgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXNsb3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrUmVmIH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtY2FsbGJhY2stcmVmXCI7XG5pbXBvcnQgeyB1c2VDb250cm9sbGFibGVTdGF0ZSB9IGZyb20gXCJAcmFkaXgtdWkvcmVhY3QtdXNlLWNvbnRyb2xsYWJsZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByYWRpeC11aS9yZWFjdC11c2UtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlUHJldmlvdXMgfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXVzZS1wcmV2aW91c1wiO1xuaW1wb3J0IHsgVmlzdWFsbHlIaWRkZW4gfSBmcm9tIFwiQHJhZGl4LXVpL3JlYWN0LXZpc3VhbGx5LWhpZGRlblwiO1xuaW1wb3J0IHsgaGlkZU90aGVycyB9IGZyb20gXCJhcmlhLWhpZGRlblwiO1xuaW1wb3J0IHsgUmVtb3ZlU2Nyb2xsIH0gZnJvbSBcInJlYWN0LXJlbW92ZS1zY3JvbGxcIjtcbmltcG9ydCB7IEZyYWdtZW50LCBqc3gsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBPUEVOX0tFWVMgPSBbXCIgXCIsIFwiRW50ZXJcIiwgXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCJdO1xudmFyIFNFTEVDVElPTl9LRVlTID0gW1wiIFwiLCBcIkVudGVyXCJdO1xudmFyIFNFTEVDVF9OQU1FID0gXCJTZWxlY3RcIjtcbnZhciBbQ29sbGVjdGlvbiwgdXNlQ29sbGVjdGlvbiwgY3JlYXRlQ29sbGVjdGlvblNjb3BlXSA9IGNyZWF0ZUNvbGxlY3Rpb24oU0VMRUNUX05BTUUpO1xudmFyIFtjcmVhdGVTZWxlY3RDb250ZXh0LCBjcmVhdGVTZWxlY3RTY29wZV0gPSBjcmVhdGVDb250ZXh0U2NvcGUoU0VMRUNUX05BTUUsIFtcbiAgY3JlYXRlQ29sbGVjdGlvblNjb3BlLFxuICBjcmVhdGVQb3BwZXJTY29wZVxuXSk7XG52YXIgdXNlUG9wcGVyU2NvcGUgPSBjcmVhdGVQb3BwZXJTY29wZSgpO1xudmFyIFtTZWxlY3RQcm92aWRlciwgdXNlU2VsZWN0Q29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KFNFTEVDVF9OQU1FKTtcbnZhciBbU2VsZWN0TmF0aXZlT3B0aW9uc1Byb3ZpZGVyLCB1c2VTZWxlY3ROYXRpdmVPcHRpb25zQ29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KFNFTEVDVF9OQU1FKTtcbnZhciBTZWxlY3QgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgY2hpbGRyZW4sXG4gICAgb3Blbjogb3BlblByb3AsXG4gICAgZGVmYXVsdE9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIHZhbHVlOiB2YWx1ZVByb3AsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIG9uVmFsdWVDaGFuZ2UsXG4gICAgZGlyLFxuICAgIG5hbWUsXG4gICAgYXV0b0NvbXBsZXRlLFxuICAgIGRpc2FibGVkLFxuICAgIHJlcXVpcmVkLFxuICAgIGZvcm1cbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBbdHJpZ2dlciwgc2V0VHJpZ2dlcl0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW3ZhbHVlTm9kZSwgc2V0VmFsdWVOb2RlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbdmFsdWVOb2RlSGFzQ2hpbGRyZW4sIHNldFZhbHVlTm9kZUhhc0NoaWxkcmVuXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgZGlyZWN0aW9uID0gdXNlRGlyZWN0aW9uKGRpcik7XG4gIGNvbnN0IFtvcGVuID0gZmFsc2UsIHNldE9wZW5dID0gdXNlQ29udHJvbGxhYmxlU3RhdGUoe1xuICAgIHByb3A6IG9wZW5Qcm9wLFxuICAgIGRlZmF1bHRQcm9wOiBkZWZhdWx0T3BlbixcbiAgICBvbkNoYW5nZTogb25PcGVuQ2hhbmdlXG4gIH0pO1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZUNvbnRyb2xsYWJsZVN0YXRlKHtcbiAgICBwcm9wOiB2YWx1ZVByb3AsXG4gICAgZGVmYXVsdFByb3A6IGRlZmF1bHRWYWx1ZSxcbiAgICBvbkNoYW5nZTogb25WYWx1ZUNoYW5nZVxuICB9KTtcbiAgY29uc3QgdHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc0Zvcm1Db250cm9sID0gdHJpZ2dlciA/IGZvcm0gfHwgISF0cmlnZ2VyLmNsb3Nlc3QoXCJmb3JtXCIpIDogdHJ1ZTtcbiAgY29uc3QgW25hdGl2ZU9wdGlvbnNTZXQsIHNldE5hdGl2ZU9wdGlvbnNTZXRdID0gUmVhY3QudXNlU3RhdGUoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIGNvbnN0IG5hdGl2ZVNlbGVjdEtleSA9IEFycmF5LmZyb20obmF0aXZlT3B0aW9uc1NldCkubWFwKChvcHRpb24pID0+IG9wdGlvbi5wcm9wcy52YWx1ZSkuam9pbihcIjtcIik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFBvcHBlclByaW1pdGl2ZS5Sb290LCB7IC4uLnBvcHBlclNjb3BlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgU2VsZWN0UHJvdmlkZXIsXG4gICAge1xuICAgICAgcmVxdWlyZWQsXG4gICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICBvblRyaWdnZXJDaGFuZ2U6IHNldFRyaWdnZXIsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBvblZhbHVlTm9kZUNoYW5nZTogc2V0VmFsdWVOb2RlLFxuICAgICAgdmFsdWVOb2RlSGFzQ2hpbGRyZW4sXG4gICAgICBvblZhbHVlTm9kZUhhc0NoaWxkcmVuQ2hhbmdlOiBzZXRWYWx1ZU5vZGVIYXNDaGlsZHJlbixcbiAgICAgIGNvbnRlbnRJZDogdXNlSWQoKSxcbiAgICAgIHZhbHVlLFxuICAgICAgb25WYWx1ZUNoYW5nZTogc2V0VmFsdWUsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlOiBzZXRPcGVuLFxuICAgICAgZGlyOiBkaXJlY3Rpb24sXG4gICAgICB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvbi5Qcm92aWRlciwgeyBzY29wZTogX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgU2VsZWN0TmF0aXZlT3B0aW9uc1Byb3ZpZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNjb3BlOiBwcm9wcy5fX3Njb3BlU2VsZWN0LFxuICAgICAgICAgICAgb25OYXRpdmVPcHRpb25BZGQ6IFJlYWN0LnVzZUNhbGxiYWNrKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgc2V0TmF0aXZlT3B0aW9uc1NldCgocHJldikgPT4gbmV3IFNldChwcmV2KS5hZGQob3B0aW9uKSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBvbk5hdGl2ZU9wdGlvblJlbW92ZTogUmVhY3QudXNlQ2FsbGJhY2soKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICBzZXROYXRpdmVPcHRpb25zU2V0KChwcmV2KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uc1NldCA9IG5ldyBTZXQocHJldik7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1NldC5kZWxldGUob3B0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uc1NldDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KSxcbiAgICAgICAgaXNGb3JtQ29udHJvbCA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICAgIEJ1YmJsZVNlbGVjdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdXRvQ29tcGxldGUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAoZXZlbnQpID0+IHNldFZhbHVlKGV2ZW50LnRhcmdldC52YWx1ZSksXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB2YWx1ZSA9PT0gdm9pZCAwID8gLyogQF9fUFVSRV9fICovIGpzeChcIm9wdGlvblwiLCB7IHZhbHVlOiBcIlwiIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbShuYXRpdmVPcHRpb25zU2V0KVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlU2VsZWN0S2V5XG4gICAgICAgICkgOiBudWxsXG4gICAgICBdXG4gICAgfVxuICApIH0pO1xufTtcblNlbGVjdC5kaXNwbGF5TmFtZSA9IFNFTEVDVF9OQU1FO1xudmFyIFRSSUdHRVJfTkFNRSA9IFwiU2VsZWN0VHJpZ2dlclwiO1xudmFyIFNlbGVjdFRyaWdnZXIgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgZGlzYWJsZWQgPSBmYWxzZSwgLi4udHJpZ2dlclByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KFRSSUdHRVJfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGNvbnRleHQuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgY29udGV4dC5vblRyaWdnZXJDaGFuZ2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gdXNlQ29sbGVjdGlvbihfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZihcInRvdWNoXCIpO1xuICAgIGNvbnN0IFtzZWFyY2hSZWYsIGhhbmRsZVR5cGVhaGVhZFNlYXJjaCwgcmVzZXRUeXBlYWhlYWRdID0gdXNlVHlwZWFoZWFkU2VhcmNoKChzZWFyY2gpID0+IHtcbiAgICAgIGNvbnN0IGVuYWJsZWRJdGVtcyA9IGdldEl0ZW1zKCkuZmlsdGVyKChpdGVtKSA9PiAhaXRlbS5kaXNhYmxlZCk7XG4gICAgICBjb25zdCBjdXJyZW50SXRlbSA9IGVuYWJsZWRJdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLnZhbHVlID09PSBjb250ZXh0LnZhbHVlKTtcbiAgICAgIGNvbnN0IG5leHRJdGVtID0gZmluZE5leHRJdGVtKGVuYWJsZWRJdGVtcywgc2VhcmNoLCBjdXJyZW50SXRlbSk7XG4gICAgICBpZiAobmV4dEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0Lm9uVmFsdWVDaGFuZ2UobmV4dEl0ZW0udmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZU9wZW4gPSAocG9pbnRlckV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzRGlzYWJsZWQpIHtcbiAgICAgICAgY29udGV4dC5vbk9wZW5DaGFuZ2UodHJ1ZSk7XG4gICAgICAgIHJlc2V0VHlwZWFoZWFkKCk7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQudHJpZ2dlclBvaW50ZXJEb3duUG9zUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZChwb2ludGVyRXZlbnQucGFnZVgpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQocG9pbnRlckV2ZW50LnBhZ2VZKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUG9wcGVyUHJpbWl0aXZlLkFuY2hvciwgeyBhc0NoaWxkOiB0cnVlLCAuLi5wb3BwZXJTY29wZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQcmltaXRpdmUuYnV0dG9uLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICByb2xlOiBcImNvbWJvYm94XCIsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBjb250ZXh0LmNvbnRlbnRJZCxcbiAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IGNvbnRleHQub3BlbixcbiAgICAgICAgXCJhcmlhLXJlcXVpcmVkXCI6IGNvbnRleHQucmVxdWlyZWQsXG4gICAgICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJub25lXCIsXG4gICAgICAgIGRpcjogY29udGV4dC5kaXIsXG4gICAgICAgIFwiZGF0YS1zdGF0ZVwiOiBjb250ZXh0Lm9wZW4gPyBcIm9wZW5cIiA6IFwiY2xvc2VkXCIsXG4gICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICBcImRhdGEtZGlzYWJsZWRcIjogaXNEaXNhYmxlZCA/IFwiXCIgOiB2b2lkIDAsXG4gICAgICAgIFwiZGF0YS1wbGFjZWhvbGRlclwiOiBzaG91bGRTaG93UGxhY2Vob2xkZXIoY29udGV4dC52YWx1ZSkgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICAuLi50cmlnZ2VyUHJvcHMsXG4gICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICBvbkNsaWNrOiBjb21wb3NlRXZlbnRIYW5kbGVycyh0cmlnZ2VyUHJvcHMub25DbGljaywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldC5mb2N1cygpO1xuICAgICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ICE9PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG9uUG9pbnRlckRvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKHRyaWdnZXJQcm9wcy5vblBvaW50ZXJEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmICh0YXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAwICYmIGV2ZW50LmN0cmxLZXkgPT09IGZhbHNlICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBvbktleURvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKHRyaWdnZXJQcm9wcy5vbktleURvd24sIChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlzVHlwaW5nQWhlYWQgPSBzZWFyY2hSZWYuY3VycmVudCAhPT0gXCJcIjtcbiAgICAgICAgICBjb25zdCBpc01vZGlmaWVyS2V5ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleTtcbiAgICAgICAgICBpZiAoIWlzTW9kaWZpZXJLZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSkgaGFuZGxlVHlwZWFoZWFkU2VhcmNoKGV2ZW50LmtleSk7XG4gICAgICAgICAgaWYgKGlzVHlwaW5nQWhlYWQgJiYgZXZlbnQua2V5ID09PSBcIiBcIikgcmV0dXJuO1xuICAgICAgICAgIGlmIChPUEVOX0tFWVMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgaGFuZGxlT3BlbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKSB9KTtcbiAgfVxuKTtcblNlbGVjdFRyaWdnZXIuZGlzcGxheU5hbWUgPSBUUklHR0VSX05BTUU7XG52YXIgVkFMVUVfTkFNRSA9IFwiU2VsZWN0VmFsdWVcIjtcbnZhciBTZWxlY3RWYWx1ZSA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBjbGFzc05hbWUsIHN0eWxlLCBjaGlsZHJlbiwgcGxhY2Vob2xkZXIgPSBcIlwiLCAuLi52YWx1ZVByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChWQUxVRV9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCB7IG9uVmFsdWVOb2RlSGFzQ2hpbGRyZW5DaGFuZ2UgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgaGFzQ2hpbGRyZW4gPSBjaGlsZHJlbiAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGNvbnRleHQub25WYWx1ZU5vZGVDaGFuZ2UpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBvblZhbHVlTm9kZUhhc0NoaWxkcmVuQ2hhbmdlKGhhc0NoaWxkcmVuKTtcbiAgICB9LCBbb25WYWx1ZU5vZGVIYXNDaGlsZHJlbkNoYW5nZSwgaGFzQ2hpbGRyZW5dKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFByaW1pdGl2ZS5zcGFuLFxuICAgICAge1xuICAgICAgICAuLi52YWx1ZVByb3BzLFxuICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgc3R5bGU6IHsgcG9pbnRlckV2ZW50czogXCJub25lXCIgfSxcbiAgICAgICAgY2hpbGRyZW46IHNob3VsZFNob3dQbGFjZWhvbGRlcihjb250ZXh0LnZhbHVlKSA/IC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IHBsYWNlaG9sZGVyIH0pIDogY2hpbGRyZW5cbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuU2VsZWN0VmFsdWUuZGlzcGxheU5hbWUgPSBWQUxVRV9OQU1FO1xudmFyIElDT05fTkFNRSA9IFwiU2VsZWN0SWNvblwiO1xudmFyIFNlbGVjdEljb24gPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgY2hpbGRyZW4sIC4uLmljb25Qcm9wcyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLnNwYW4sIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCAuLi5pY29uUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmLCBjaGlsZHJlbjogY2hpbGRyZW4gfHwgXCJcXHUyNUJDXCIgfSk7XG4gIH1cbik7XG5TZWxlY3RJY29uLmRpc3BsYXlOYW1lID0gSUNPTl9OQU1FO1xudmFyIFBPUlRBTF9OQU1FID0gXCJTZWxlY3RQb3J0YWxcIjtcbnZhciBTZWxlY3RQb3J0YWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFsUHJpbWl0aXZlLCB7IGFzQ2hpbGQ6IHRydWUsIC4uLnByb3BzIH0pO1xufTtcblNlbGVjdFBvcnRhbC5kaXNwbGF5TmFtZSA9IFBPUlRBTF9OQU1FO1xudmFyIENPTlRFTlRfTkFNRSA9IFwiU2VsZWN0Q29udGVudFwiO1xudmFyIFNlbGVjdENvbnRlbnQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgW2ZyYWdtZW50LCBzZXRGcmFnbWVudF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBzZXRGcmFnbWVudChuZXcgRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKCFjb250ZXh0Lm9wZW4pIHtcbiAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudDtcbiAgICAgIHJldHVybiBmcmFnID8gUmVhY3RET00uY3JlYXRlUG9ydGFsKFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFNlbGVjdENvbnRlbnRQcm92aWRlciwgeyBzY29wZTogcHJvcHMuX19zY29wZVNlbGVjdCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvbi5TbG90LCB7IHNjb3BlOiBwcm9wcy5fX3Njb3BlU2VsZWN0LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSB9KSB9KSxcbiAgICAgICAgZnJhZ1xuICAgICAgKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNlbGVjdENvbnRlbnRJbXBsLCB7IC4uLnByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KTtcbiAgfVxuKTtcblNlbGVjdENvbnRlbnQuZGlzcGxheU5hbWUgPSBDT05URU5UX05BTUU7XG52YXIgQ09OVEVOVF9NQVJHSU4gPSAxMDtcbnZhciBbU2VsZWN0Q29udGVudFByb3ZpZGVyLCB1c2VTZWxlY3RDb250ZW50Q29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KENPTlRFTlRfTkFNRSk7XG52YXIgQ09OVEVOVF9JTVBMX05BTUUgPSBcIlNlbGVjdENvbnRlbnRJbXBsXCI7XG52YXIgU2VsZWN0Q29udGVudEltcGwgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF9fc2NvcGVTZWxlY3QsXG4gICAgICBwb3NpdGlvbiA9IFwiaXRlbS1hbGlnbmVkXCIsXG4gICAgICBvbkNsb3NlQXV0b0ZvY3VzLFxuICAgICAgb25Fc2NhcGVLZXlEb3duLFxuICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUsXG4gICAgICAvL1xuICAgICAgLy8gUG9wcGVyQ29udGVudCBwcm9wc1xuICAgICAgc2lkZSxcbiAgICAgIHNpZGVPZmZzZXQsXG4gICAgICBhbGlnbixcbiAgICAgIGFsaWduT2Zmc2V0LFxuICAgICAgYXJyb3dQYWRkaW5nLFxuICAgICAgY29sbGlzaW9uQm91bmRhcnksXG4gICAgICBjb2xsaXNpb25QYWRkaW5nLFxuICAgICAgc3RpY2t5LFxuICAgICAgaGlkZVdoZW5EZXRhY2hlZCxcbiAgICAgIGF2b2lkQ29sbGlzaW9ucyxcbiAgICAgIC8vXG4gICAgICAuLi5jb250ZW50UHJvcHNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoQ09OVEVOVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbdmlld3BvcnQsIHNldFZpZXdwb3J0XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIChub2RlKSA9PiBzZXRDb250ZW50KG5vZGUpKTtcbiAgICBjb25zdCBbc2VsZWN0ZWRJdGVtLCBzZXRTZWxlY3RlZEl0ZW1dID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3NlbGVjdGVkSXRlbVRleHQsIHNldFNlbGVjdGVkSXRlbVRleHRdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgW2lzUG9zaXRpb25lZCwgc2V0SXNQb3NpdGlvbmVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBmaXJzdFZhbGlkSXRlbUZvdW5kUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKGNvbnRlbnQpIHJldHVybiBoaWRlT3RoZXJzKGNvbnRlbnQpO1xuICAgIH0sIFtjb250ZW50XSk7XG4gICAgdXNlRm9jdXNHdWFyZHMoKTtcbiAgICBjb25zdCBmb2N1c0ZpcnN0ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAoY2FuZGlkYXRlcykgPT4ge1xuICAgICAgICBjb25zdCBbZmlyc3RJdGVtLCAuLi5yZXN0SXRlbXNdID0gZ2V0SXRlbXMoKS5tYXAoKGl0ZW0pID0+IGl0ZW0ucmVmLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCBbbGFzdEl0ZW1dID0gcmVzdEl0ZW1zLnNsaWNlKC0xKTtcbiAgICAgICAgY29uc3QgUFJFVklPVVNMWV9GT0NVU0VEX0VMRU1FTlQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gUFJFVklPVVNMWV9GT0NVU0VEX0VMRU1FTlQpIHJldHVybjtcbiAgICAgICAgICBjYW5kaWRhdGU/LnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwibmVhcmVzdFwiIH0pO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUgPT09IGZpcnN0SXRlbSAmJiB2aWV3cG9ydCkgdmlld3BvcnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlID09PSBsYXN0SXRlbSAmJiB2aWV3cG9ydCkgdmlld3BvcnQuc2Nyb2xsVG9wID0gdmlld3BvcnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIGNhbmRpZGF0ZT8uZm9jdXMoKTtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gUFJFVklPVVNMWV9GT0NVU0VEX0VMRU1FTlQpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtnZXRJdGVtcywgdmlld3BvcnRdXG4gICAgKTtcbiAgICBjb25zdCBmb2N1c1NlbGVjdGVkSXRlbSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKCkgPT4gZm9jdXNGaXJzdChbc2VsZWN0ZWRJdGVtLCBjb250ZW50XSksXG4gICAgICBbZm9jdXNGaXJzdCwgc2VsZWN0ZWRJdGVtLCBjb250ZW50XVxuICAgICk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChpc1Bvc2l0aW9uZWQpIHtcbiAgICAgICAgZm9jdXNTZWxlY3RlZEl0ZW0oKTtcbiAgICAgIH1cbiAgICB9LCBbaXNQb3NpdGlvbmVkLCBmb2N1c1NlbGVjdGVkSXRlbV0pO1xuICAgIGNvbnN0IHsgb25PcGVuQ2hhbmdlLCB0cmlnZ2VyUG9pbnRlckRvd25Qb3NSZWYgfSA9IGNvbnRleHQ7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIGxldCBwb2ludGVyTW92ZURlbHRhID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcG9pbnRlck1vdmVEZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguYWJzKE1hdGgucm91bmQoZXZlbnQucGFnZVgpIC0gKHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50Py54ID8/IDApKSxcbiAgICAgICAgICAgIHk6IE1hdGguYWJzKE1hdGgucm91bmQoZXZlbnQucGFnZVkpIC0gKHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50Py55ID8/IDApKVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVBvaW50ZXJVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChwb2ludGVyTW92ZURlbHRhLnggPD0gMTAgJiYgcG9pbnRlck1vdmVEZWx0YS55IDw9IDEwKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgIHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRyaWdnZXJQb2ludGVyRG93blBvc1JlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGhhbmRsZVBvaW50ZXJVcCwgeyBjYXB0dXJlOiB0cnVlLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGhhbmRsZVBvaW50ZXJVcCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIFtjb250ZW50LCBvbk9wZW5DaGFuZ2UsIHRyaWdnZXJQb2ludGVyRG93blBvc1JlZl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBjbG9zZSA9ICgpID0+IG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgY2xvc2UpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY2xvc2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGNsb3NlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY2xvc2UpO1xuICAgICAgfTtcbiAgICB9LCBbb25PcGVuQ2hhbmdlXSk7XG4gICAgY29uc3QgW3NlYXJjaFJlZiwgaGFuZGxlVHlwZWFoZWFkU2VhcmNoXSA9IHVzZVR5cGVhaGVhZFNlYXJjaCgoc2VhcmNoKSA9PiB7XG4gICAgICBjb25zdCBlbmFibGVkSXRlbXMgPSBnZXRJdGVtcygpLmZpbHRlcigoaXRlbSkgPT4gIWl0ZW0uZGlzYWJsZWQpO1xuICAgICAgY29uc3QgY3VycmVudEl0ZW0gPSBlbmFibGVkSXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5yZWYuY3VycmVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICBjb25zdCBuZXh0SXRlbSA9IGZpbmROZXh0SXRlbShlbmFibGVkSXRlbXMsIHNlYXJjaCwgY3VycmVudEl0ZW0pO1xuICAgICAgaWYgKG5leHRJdGVtKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbmV4dEl0ZW0ucmVmLmN1cnJlbnQuZm9jdXMoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaXRlbVJlZkNhbGxiYWNrID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAobm9kZSwgdmFsdWUsIGRpc2FibGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RWYWxpZEl0ZW0gPSAhZmlyc3RWYWxpZEl0ZW1Gb3VuZFJlZi5jdXJyZW50ICYmICFkaXNhYmxlZDtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZEl0ZW0gPSBjb250ZXh0LnZhbHVlICE9PSB2b2lkIDAgJiYgY29udGV4dC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkSXRlbSB8fCBpc0ZpcnN0VmFsaWRJdGVtKSB7XG4gICAgICAgICAgc2V0U2VsZWN0ZWRJdGVtKG5vZGUpO1xuICAgICAgICAgIGlmIChpc0ZpcnN0VmFsaWRJdGVtKSBmaXJzdFZhbGlkSXRlbUZvdW5kUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2NvbnRleHQudmFsdWVdXG4gICAgKTtcbiAgICBjb25zdCBoYW5kbGVJdGVtTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBjb250ZW50Py5mb2N1cygpLCBbY29udGVudF0pO1xuICAgIGNvbnN0IGl0ZW1UZXh0UmVmQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIChub2RlLCB2YWx1ZSwgZGlzYWJsZWQpID0+IHtcbiAgICAgICAgY29uc3QgaXNGaXJzdFZhbGlkSXRlbSA9ICFmaXJzdFZhbGlkSXRlbUZvdW5kUmVmLmN1cnJlbnQgJiYgIWRpc2FibGVkO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkSXRlbSA9IGNvbnRleHQudmFsdWUgIT09IHZvaWQgMCAmJiBjb250ZXh0LnZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWRJdGVtIHx8IGlzRmlyc3RWYWxpZEl0ZW0pIHtcbiAgICAgICAgICBzZXRTZWxlY3RlZEl0ZW1UZXh0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2NvbnRleHQudmFsdWVdXG4gICAgKTtcbiAgICBjb25zdCBTZWxlY3RQb3NpdGlvbiA9IHBvc2l0aW9uID09PSBcInBvcHBlclwiID8gU2VsZWN0UG9wcGVyUG9zaXRpb24gOiBTZWxlY3RJdGVtQWxpZ25lZFBvc2l0aW9uO1xuICAgIGNvbnN0IHBvcHBlckNvbnRlbnRQcm9wcyA9IFNlbGVjdFBvc2l0aW9uID09PSBTZWxlY3RQb3BwZXJQb3NpdGlvbiA/IHtcbiAgICAgIHNpZGUsXG4gICAgICBzaWRlT2Zmc2V0LFxuICAgICAgYWxpZ24sXG4gICAgICBhbGlnbk9mZnNldCxcbiAgICAgIGFycm93UGFkZGluZyxcbiAgICAgIGNvbGxpc2lvbkJvdW5kYXJ5LFxuICAgICAgY29sbGlzaW9uUGFkZGluZyxcbiAgICAgIHN0aWNreSxcbiAgICAgIGhpZGVXaGVuRGV0YWNoZWQsXG4gICAgICBhdm9pZENvbGxpc2lvbnNcbiAgICB9IDoge307XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBTZWxlY3RDb250ZW50UHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBfX3Njb3BlU2VsZWN0LFxuICAgICAgICBjb250ZW50LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZTogc2V0Vmlld3BvcnQsXG4gICAgICAgIGl0ZW1SZWZDYWxsYmFjayxcbiAgICAgICAgc2VsZWN0ZWRJdGVtLFxuICAgICAgICBvbkl0ZW1MZWF2ZTogaGFuZGxlSXRlbUxlYXZlLFxuICAgICAgICBpdGVtVGV4dFJlZkNhbGxiYWNrLFxuICAgICAgICBmb2N1c1NlbGVjdGVkSXRlbSxcbiAgICAgICAgc2VsZWN0ZWRJdGVtVGV4dCxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGlzUG9zaXRpb25lZCxcbiAgICAgICAgc2VhcmNoUmVmLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSZW1vdmVTY3JvbGwsIHsgYXM6IFNsb3QsIGFsbG93UGluY2hab29tOiB0cnVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICBGb2N1c1Njb3BlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFzQ2hpbGQ6IHRydWUsXG4gICAgICAgICAgICB0cmFwcGVkOiBjb250ZXh0Lm9wZW4sXG4gICAgICAgICAgICBvbk1vdW50QXV0b0ZvY3VzOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblVubW91bnRBdXRvRm9jdXM6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQ2xvc2VBdXRvRm9jdXMsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICBjb250ZXh0LnRyaWdnZXI/LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgIERpc21pc3NhYmxlTGF5ZXIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhc0NoaWxkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVPdXRzaWRlUG9pbnRlckV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvbkVzY2FwZUtleURvd24sXG4gICAgICAgICAgICAgICAgb25Qb2ludGVyRG93bk91dHNpZGUsXG4gICAgICAgICAgICAgICAgb25Gb2N1c091dHNpZGU6IChldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgICAgICAgICBvbkRpc21pc3M6ICgpID0+IGNvbnRleHQub25PcGVuQ2hhbmdlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgICAgIFNlbGVjdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNvbnRleHQuY29udGVudElkLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtc3RhdGVcIjogY29udGV4dC5vcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwiLFxuICAgICAgICAgICAgICAgICAgICBkaXI6IGNvbnRleHQuZGlyLFxuICAgICAgICAgICAgICAgICAgICBvbkNvbnRleHRNZW51OiAoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucG9wcGVyQ29udGVudFByb3BzLFxuICAgICAgICAgICAgICAgICAgICBvblBsYWNlZDogKCkgPT4gc2V0SXNQb3NpdGlvbmVkKHRydWUpLFxuICAgICAgICAgICAgICAgICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmbGV4IGxheW91dCBzbyB3ZSBjYW4gcGxhY2UgdGhlIHNjcm9sbCBidXR0b25zIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgb3V0bGluZSBieSBkZWZhdWx0IGFzIHRoZSBjb250ZW50IE1BWSBnZXQgZm9jdXNlZFxuICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRQcm9wcy5zdHlsZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKGNvbnRlbnRQcm9wcy5vbktleURvd24sIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTW9kaWZpZXJLZXkgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5O1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGlmaWVyS2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT09IDEpIGhhbmRsZVR5cGVhaGVhZFNlYXJjaChldmVudC5rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChbXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCIsIFwiSG9tZVwiLCBcIkVuZFwiXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdldEl0ZW1zKCkuZmlsdGVyKChpdGVtKSA9PiAhaXRlbS5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlTm9kZXMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0ucmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFtcIkFycm93VXBcIiwgXCJFbmRcIl0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVOb2RlcyA9IGNhbmRpZGF0ZU5vZGVzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFtcIkFycm93VXBcIiwgXCJBcnJvd0Rvd25cIl0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY2FuZGlkYXRlTm9kZXMuaW5kZXhPZihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZU5vZGVzID0gY2FuZGlkYXRlTm9kZXMuc2xpY2UoY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGZvY3VzRmlyc3QoY2FuZGlkYXRlTm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5TZWxlY3RDb250ZW50SW1wbC5kaXNwbGF5TmFtZSA9IENPTlRFTlRfSU1QTF9OQU1FO1xudmFyIElURU1fQUxJR05FRF9QT1NJVElPTl9OQU1FID0gXCJTZWxlY3RJdGVtQWxpZ25lZFBvc2l0aW9uXCI7XG52YXIgU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBvblBsYWNlZCwgLi4ucG9wcGVyUHJvcHMgfSA9IHByb3BzO1xuICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChDT05URU5UX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCBjb250ZW50Q29udGV4dCA9IHVzZVNlbGVjdENvbnRlbnRDb250ZXh0KENPTlRFTlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IFtjb250ZW50V3JhcHBlciwgc2V0Q29udGVudFdyYXBwZXJdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoZm9yd2FyZGVkUmVmLCAobm9kZSkgPT4gc2V0Q29udGVudChub2RlKSk7XG4gIGNvbnN0IGdldEl0ZW1zID0gdXNlQ29sbGVjdGlvbihfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3Qgc2hvdWxkRXhwYW5kT25TY3JvbGxSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBzaG91bGRSZXBvc2l0aW9uUmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCB7IHZpZXdwb3J0LCBzZWxlY3RlZEl0ZW0sIHNlbGVjdGVkSXRlbVRleHQsIGZvY3VzU2VsZWN0ZWRJdGVtIH0gPSBjb250ZW50Q29udGV4dDtcbiAgY29uc3QgcG9zaXRpb24gPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGNvbnRleHQudHJpZ2dlciAmJiBjb250ZXh0LnZhbHVlTm9kZSAmJiBjb250ZW50V3JhcHBlciAmJiBjb250ZW50ICYmIHZpZXdwb3J0ICYmIHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW1UZXh0KSB7XG4gICAgICBjb25zdCB0cmlnZ2VyUmVjdCA9IGNvbnRleHQudHJpZ2dlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHZhbHVlTm9kZVJlY3QgPSBjb250ZXh0LnZhbHVlTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGl0ZW1UZXh0UmVjdCA9IHNlbGVjdGVkSXRlbVRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoY29udGV4dC5kaXIgIT09IFwicnRsXCIpIHtcbiAgICAgICAgY29uc3QgaXRlbVRleHRPZmZzZXQgPSBpdGVtVGV4dFJlY3QubGVmdCAtIGNvbnRlbnRSZWN0LmxlZnQ7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB2YWx1ZU5vZGVSZWN0LmxlZnQgLSBpdGVtVGV4dE9mZnNldDtcbiAgICAgICAgY29uc3QgbGVmdERlbHRhID0gdHJpZ2dlclJlY3QubGVmdCAtIGxlZnQ7XG4gICAgICAgIGNvbnN0IG1pbkNvbnRlbnRXaWR0aCA9IHRyaWdnZXJSZWN0LndpZHRoICsgbGVmdERlbHRhO1xuICAgICAgICBjb25zdCBjb250ZW50V2lkdGggPSBNYXRoLm1heChtaW5Db250ZW50V2lkdGgsIGNvbnRlbnRSZWN0LndpZHRoKTtcbiAgICAgICAgY29uc3QgcmlnaHRFZGdlID0gd2luZG93LmlubmVyV2lkdGggLSBDT05URU5UX01BUkdJTjtcbiAgICAgICAgY29uc3QgY2xhbXBlZExlZnQgPSBjbGFtcChsZWZ0LCBbXG4gICAgICAgICAgQ09OVEVOVF9NQVJHSU4sXG4gICAgICAgICAgLy8gUHJldmVudHMgdGhlIGNvbnRlbnQgZnJvbSBnb2luZyBvZmYgdGhlIHN0YXJ0aW5nIGVkZ2Ugb2YgdGhlXG4gICAgICAgICAgLy8gdmlld3BvcnQuIEl0IG1heSBzdGlsbCBnbyBvZmYgdGhlIGVuZGluZyBlZGdlLCBidXQgdGhpcyBjYW4gYmVcbiAgICAgICAgICAvLyBjb250cm9sbGVkIGJ5IHRoZSB1c2VyIHNpbmNlIHRoZXkgbWF5IHdhbnQgdG8gbWFuYWdlIG92ZXJmbG93IGluIGFcbiAgICAgICAgICAvLyBzcGVjaWZpYyB3YXkuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JhZGl4LXVpL3ByaW1pdGl2ZXMvaXNzdWVzLzIwNDlcbiAgICAgICAgICBNYXRoLm1heChDT05URU5UX01BUkdJTiwgcmlnaHRFZGdlIC0gY29udGVudFdpZHRoKVxuICAgICAgICBdKTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUubWluV2lkdGggPSBtaW5Db250ZW50V2lkdGggKyBcInB4XCI7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmxlZnQgPSBjbGFtcGVkTGVmdCArIFwicHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGl0ZW1UZXh0T2Zmc2V0ID0gY29udGVudFJlY3QucmlnaHQgLSBpdGVtVGV4dFJlY3QucmlnaHQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSB2YWx1ZU5vZGVSZWN0LnJpZ2h0IC0gaXRlbVRleHRPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0RGVsdGEgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIHRyaWdnZXJSZWN0LnJpZ2h0IC0gcmlnaHQ7XG4gICAgICAgIGNvbnN0IG1pbkNvbnRlbnRXaWR0aCA9IHRyaWdnZXJSZWN0LndpZHRoICsgcmlnaHREZWx0YTtcbiAgICAgICAgY29uc3QgY29udGVudFdpZHRoID0gTWF0aC5tYXgobWluQ29udGVudFdpZHRoLCBjb250ZW50UmVjdC53aWR0aCk7XG4gICAgICAgIGNvbnN0IGxlZnRFZGdlID0gd2luZG93LmlubmVyV2lkdGggLSBDT05URU5UX01BUkdJTjtcbiAgICAgICAgY29uc3QgY2xhbXBlZFJpZ2h0ID0gY2xhbXAocmlnaHQsIFtcbiAgICAgICAgICBDT05URU5UX01BUkdJTixcbiAgICAgICAgICBNYXRoLm1heChDT05URU5UX01BUkdJTiwgbGVmdEVkZ2UgLSBjb250ZW50V2lkdGgpXG4gICAgICAgIF0pO1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5taW5XaWR0aCA9IG1pbkNvbnRlbnRXaWR0aCArIFwicHhcIjtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUucmlnaHQgPSBjbGFtcGVkUmlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGdldEl0ZW1zKCk7XG4gICAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBDT05URU5UX01BUkdJTiAqIDI7XG4gICAgICBjb25zdCBpdGVtc0hlaWdodCA9IHZpZXdwb3J0LnNjcm9sbEhlaWdodDtcbiAgICAgIGNvbnN0IGNvbnRlbnRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50KTtcbiAgICAgIGNvbnN0IGNvbnRlbnRCb3JkZXJUb3BXaWR0aCA9IHBhcnNlSW50KGNvbnRlbnRTdHlsZXMuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgICAgIGNvbnN0IGNvbnRlbnRQYWRkaW5nVG9wID0gcGFyc2VJbnQoY29udGVudFN0eWxlcy5wYWRkaW5nVG9wLCAxMCk7XG4gICAgICBjb25zdCBjb250ZW50Qm9yZGVyQm90dG9tV2lkdGggPSBwYXJzZUludChjb250ZW50U3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoLCAxMCk7XG4gICAgICBjb25zdCBjb250ZW50UGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KGNvbnRlbnRTdHlsZXMucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgICAgY29uc3QgZnVsbENvbnRlbnRIZWlnaHQgPSBjb250ZW50Qm9yZGVyVG9wV2lkdGggKyBjb250ZW50UGFkZGluZ1RvcCArIGl0ZW1zSGVpZ2h0ICsgY29udGVudFBhZGRpbmdCb3R0b20gKyBjb250ZW50Qm9yZGVyQm90dG9tV2lkdGg7XG4gICAgICBjb25zdCBtaW5Db250ZW50SGVpZ2h0ID0gTWF0aC5taW4oc2VsZWN0ZWRJdGVtLm9mZnNldEhlaWdodCAqIDUsIGZ1bGxDb250ZW50SGVpZ2h0KTtcbiAgICAgIGNvbnN0IHZpZXdwb3J0U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlld3BvcnQpO1xuICAgICAgY29uc3Qgdmlld3BvcnRQYWRkaW5nVG9wID0gcGFyc2VJbnQodmlld3BvcnRTdHlsZXMucGFkZGluZ1RvcCwgMTApO1xuICAgICAgY29uc3Qgdmlld3BvcnRQYWRkaW5nQm90dG9tID0gcGFyc2VJbnQodmlld3BvcnRTdHlsZXMucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgICAgY29uc3QgdG9wRWRnZVRvVHJpZ2dlck1pZGRsZSA9IHRyaWdnZXJSZWN0LnRvcCArIHRyaWdnZXJSZWN0LmhlaWdodCAvIDIgLSBDT05URU5UX01BUkdJTjtcbiAgICAgIGNvbnN0IHRyaWdnZXJNaWRkbGVUb0JvdHRvbUVkZ2UgPSBhdmFpbGFibGVIZWlnaHQgLSB0b3BFZGdlVG9UcmlnZ2VyTWlkZGxlO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtSGFsZkhlaWdodCA9IHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgY29uc3QgaXRlbU9mZnNldE1pZGRsZSA9IHNlbGVjdGVkSXRlbS5vZmZzZXRUb3AgKyBzZWxlY3RlZEl0ZW1IYWxmSGVpZ2h0O1xuICAgICAgY29uc3QgY29udGVudFRvcFRvSXRlbU1pZGRsZSA9IGNvbnRlbnRCb3JkZXJUb3BXaWR0aCArIGNvbnRlbnRQYWRkaW5nVG9wICsgaXRlbU9mZnNldE1pZGRsZTtcbiAgICAgIGNvbnN0IGl0ZW1NaWRkbGVUb0NvbnRlbnRCb3R0b20gPSBmdWxsQ29udGVudEhlaWdodCAtIGNvbnRlbnRUb3BUb0l0ZW1NaWRkbGU7XG4gICAgICBjb25zdCB3aWxsQWxpZ25XaXRob3V0VG9wT3ZlcmZsb3cgPSBjb250ZW50VG9wVG9JdGVtTWlkZGxlIDw9IHRvcEVkZ2VUb1RyaWdnZXJNaWRkbGU7XG4gICAgICBpZiAod2lsbEFsaWduV2l0aG91dFRvcE92ZXJmbG93KSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdEl0ZW0gPSBpdGVtcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkSXRlbSA9PT0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0ucmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmJvdHRvbSA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0T2Zmc2V0Qm90dG9tID0gY29udGVudC5jbGllbnRIZWlnaHQgLSB2aWV3cG9ydC5vZmZzZXRUb3AgLSB2aWV3cG9ydC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNsYW1wZWRUcmlnZ2VyTWlkZGxlVG9Cb3R0b21FZGdlID0gTWF0aC5tYXgoXG4gICAgICAgICAgdHJpZ2dlck1pZGRsZVRvQm90dG9tRWRnZSxcbiAgICAgICAgICBzZWxlY3RlZEl0ZW1IYWxmSGVpZ2h0ICsgLy8gdmlld3BvcnQgbWlnaHQgaGF2ZSBwYWRkaW5nIGJvdHRvbSwgaW5jbHVkZSBpdCB0byBhdm9pZCBhIHNjcm9sbGFibGUgdmlld3BvcnRcbiAgICAgICAgICAoaXNMYXN0SXRlbSA/IHZpZXdwb3J0UGFkZGluZ0JvdHRvbSA6IDApICsgdmlld3BvcnRPZmZzZXRCb3R0b20gKyBjb250ZW50Qm9yZGVyQm90dG9tV2lkdGhcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY29udGVudFRvcFRvSXRlbU1pZGRsZSArIGNsYW1wZWRUcmlnZ2VyTWlkZGxlVG9Cb3R0b21FZGdlO1xuICAgICAgICBjb250ZW50V3JhcHBlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpc0ZpcnN0SXRlbSA9IGl0ZW1zLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRJdGVtID09PSBpdGVtc1swXS5yZWYuY3VycmVudDtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgY29uc3QgY2xhbXBlZFRvcEVkZ2VUb1RyaWdnZXJNaWRkbGUgPSBNYXRoLm1heChcbiAgICAgICAgICB0b3BFZGdlVG9UcmlnZ2VyTWlkZGxlLFxuICAgICAgICAgIGNvbnRlbnRCb3JkZXJUb3BXaWR0aCArIHZpZXdwb3J0Lm9mZnNldFRvcCArIC8vIHZpZXdwb3J0IG1pZ2h0IGhhdmUgcGFkZGluZyB0b3AsIGluY2x1ZGUgaXQgdG8gYXZvaWQgYSBzY3JvbGxhYmxlIHZpZXdwb3J0XG4gICAgICAgICAgKGlzRmlyc3RJdGVtID8gdmlld3BvcnRQYWRkaW5nVG9wIDogMCkgKyBzZWxlY3RlZEl0ZW1IYWxmSGVpZ2h0XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGNsYW1wZWRUb3BFZGdlVG9UcmlnZ2VyTWlkZGxlICsgaXRlbU1pZGRsZVRvQ29udGVudEJvdHRvbTtcbiAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB2aWV3cG9ydC5zY3JvbGxUb3AgPSBjb250ZW50VG9wVG9JdGVtTWlkZGxlIC0gdG9wRWRnZVRvVHJpZ2dlck1pZGRsZSArIHZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1hcmdpbiA9IGAke0NPTlRFTlRfTUFSR0lOfXB4IDBgO1xuICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUubWluSGVpZ2h0ID0gbWluQ29udGVudEhlaWdodCArIFwicHhcIjtcbiAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLm1heEhlaWdodCA9IGF2YWlsYWJsZUhlaWdodCArIFwicHhcIjtcbiAgICAgIG9uUGxhY2VkPy4oKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBzaG91bGRFeHBhbmRPblNjcm9sbFJlZi5jdXJyZW50ID0gdHJ1ZSk7XG4gICAgfVxuICB9LCBbXG4gICAgZ2V0SXRlbXMsXG4gICAgY29udGV4dC50cmlnZ2VyLFxuICAgIGNvbnRleHQudmFsdWVOb2RlLFxuICAgIGNvbnRlbnRXcmFwcGVyLFxuICAgIGNvbnRlbnQsXG4gICAgdmlld3BvcnQsXG4gICAgc2VsZWN0ZWRJdGVtLFxuICAgIHNlbGVjdGVkSXRlbVRleHQsXG4gICAgY29udGV4dC5kaXIsXG4gICAgb25QbGFjZWRcbiAgXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiBwb3NpdGlvbigpLCBbcG9zaXRpb25dKTtcbiAgY29uc3QgW2NvbnRlbnRaSW5kZXgsIHNldENvbnRlbnRaSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29udGVudCkgc2V0Q29udGVudFpJbmRleCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50KS56SW5kZXgpO1xuICB9LCBbY29udGVudF0pO1xuICBjb25zdCBoYW5kbGVTY3JvbGxCdXR0b25DaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUgJiYgc2hvdWxkUmVwb3NpdGlvblJlZi5jdXJyZW50ID09PSB0cnVlKSB7XG4gICAgICAgIHBvc2l0aW9uKCk7XG4gICAgICAgIGZvY3VzU2VsZWN0ZWRJdGVtPy4oKTtcbiAgICAgICAgc2hvdWxkUmVwb3NpdGlvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcG9zaXRpb24sIGZvY3VzU2VsZWN0ZWRJdGVtXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTZWxlY3RWaWV3cG9ydFByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHNjb3BlOiBfX3Njb3BlU2VsZWN0LFxuICAgICAgY29udGVudFdyYXBwZXIsXG4gICAgICBzaG91bGRFeHBhbmRPblNjcm9sbFJlZixcbiAgICAgIG9uU2Nyb2xsQnV0dG9uQ2hhbmdlOiBoYW5kbGVTY3JvbGxCdXR0b25DaGFuZ2UsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogc2V0Q29udGVudFdyYXBwZXIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgICAgICB6SW5kZXg6IGNvbnRlbnRaSW5kZXhcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgUHJpbWl0aXZlLmRpdixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4ucG9wcGVyUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgZ2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRlbnQsIGl0IGluY2x1ZGVzIGJvcmRlcnMuIElmIHdlIHdlcmUgdG8gc2V0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGhlaWdodCB3aXRob3V0IGhhdmluZyBgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdgIGl0IHdvdWxkIGJlIHRvbyBiaWcuXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgY29udGVudCBkb2Vzbid0IGdldCB0YWxsZXIgdGhhbiB0aGUgd3JhcHBlclxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgLi4ucG9wcGVyUHJvcHMuc3R5bGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgKTtcbn0pO1xuU2VsZWN0SXRlbUFsaWduZWRQb3NpdGlvbi5kaXNwbGF5TmFtZSA9IElURU1fQUxJR05FRF9QT1NJVElPTl9OQU1FO1xudmFyIFBPUFBFUl9QT1NJVElPTl9OQU1FID0gXCJTZWxlY3RQb3BwZXJQb3NpdGlvblwiO1xudmFyIFNlbGVjdFBvcHBlclBvc2l0aW9uID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgX19zY29wZVNlbGVjdCxcbiAgICBhbGlnbiA9IFwic3RhcnRcIixcbiAgICBjb2xsaXNpb25QYWRkaW5nID0gQ09OVEVOVF9NQVJHSU4sXG4gICAgLi4ucG9wcGVyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3BwZXJTY29wZSA9IHVzZVBvcHBlclNjb3BlKF9fc2NvcGVTZWxlY3QpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBQb3BwZXJQcmltaXRpdmUuQ29udGVudCxcbiAgICB7XG4gICAgICAuLi5wb3BwZXJTY29wZSxcbiAgICAgIC4uLnBvcHBlclByb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICBhbGlnbixcbiAgICAgIGNvbGxpc2lvblBhZGRpbmcsXG4gICAgICBzdHlsZToge1xuICAgICAgICAvLyBFbnN1cmUgYm9yZGVyLWJveCBmb3IgZmxvYXRpbmctdWkgY2FsY3VsYXRpb25zXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIC4uLnBvcHBlclByb3BzLnN0eWxlLFxuICAgICAgICAvLyByZS1uYW1lc3BhY2UgZXhwb3NlZCBjb250ZW50IGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgICAgIC4uLntcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LWNvbnRlbnQtdHJhbnNmb3JtLW9yaWdpblwiOiBcInZhcigtLXJhZGl4LXBvcHBlci10cmFuc2Zvcm0tb3JpZ2luKVwiLFxuICAgICAgICAgIFwiLS1yYWRpeC1zZWxlY3QtY29udGVudC1hdmFpbGFibGUtd2lkdGhcIjogXCJ2YXIoLS1yYWRpeC1wb3BwZXItYXZhaWxhYmxlLXdpZHRoKVwiLFxuICAgICAgICAgIFwiLS1yYWRpeC1zZWxlY3QtY29udGVudC1hdmFpbGFibGUtaGVpZ2h0XCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWF2YWlsYWJsZS1oZWlnaHQpXCIsXG4gICAgICAgICAgXCItLXJhZGl4LXNlbGVjdC10cmlnZ2VyLXdpZHRoXCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWFuY2hvci13aWR0aClcIixcbiAgICAgICAgICBcIi0tcmFkaXgtc2VsZWN0LXRyaWdnZXItaGVpZ2h0XCI6IFwidmFyKC0tcmFkaXgtcG9wcGVyLWFuY2hvci1oZWlnaHQpXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbn0pO1xuU2VsZWN0UG9wcGVyUG9zaXRpb24uZGlzcGxheU5hbWUgPSBQT1BQRVJfUE9TSVRJT05fTkFNRTtcbnZhciBbU2VsZWN0Vmlld3BvcnRQcm92aWRlciwgdXNlU2VsZWN0Vmlld3BvcnRDb250ZXh0XSA9IGNyZWF0ZVNlbGVjdENvbnRleHQoQ09OVEVOVF9OQU1FLCB7fSk7XG52YXIgVklFV1BPUlRfTkFNRSA9IFwiU2VsZWN0Vmlld3BvcnRcIjtcbnZhciBTZWxlY3RWaWV3cG9ydCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBub25jZSwgLi4udmlld3BvcnRQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChWSUVXUE9SVF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCB2aWV3cG9ydENvbnRleHQgPSB1c2VTZWxlY3RWaWV3cG9ydENvbnRleHQoVklFV1BPUlRfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgY29udGVudENvbnRleHQub25WaWV3cG9ydENoYW5nZSk7XG4gICAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFwic3R5bGVcIixcbiAgICAgICAge1xuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IGBbZGF0YS1yYWRpeC1zZWxlY3Qtdmlld3BvcnRde3Njcm9sbGJhci13aWR0aDpub25lOy1tcy1vdmVyZmxvdy1zdHlsZTpub25lOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO31bZGF0YS1yYWRpeC1zZWxlY3Qtdmlld3BvcnRdOjotd2Via2l0LXNjcm9sbGJhcntkaXNwbGF5Om5vbmV9YFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbm9uY2VcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29sbGVjdGlvbi5TbG90LCB7IHNjb3BlOiBfX3Njb3BlU2VsZWN0LCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgUHJpbWl0aXZlLmRpdixcbiAgICAgICAge1xuICAgICAgICAgIFwiZGF0YS1yYWRpeC1zZWxlY3Qtdmlld3BvcnRcIjogXCJcIixcbiAgICAgICAgICByb2xlOiBcInByZXNlbnRhdGlvblwiLFxuICAgICAgICAgIC4uLnZpZXdwb3J0UHJvcHMsXG4gICAgICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC8vIHdlIHVzZSBwb3NpdGlvbjogJ3JlbGF0aXZlJyBoZXJlIG9uIHRoZSBgdmlld3BvcnRgIHNvIHRoYXQgd2hlbiB3ZSBjYWxsXG4gICAgICAgICAgICAvLyBgc2VsZWN0ZWRJdGVtLm9mZnNldFRvcGAgaW4gY2FsY3VsYXRpb25zLCB0aGUgb2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgLy8gKGluZGVwZW5kZW50IG9mIHRoZSBzY3JvbGxVcEJ1dHRvbikuXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgIC8vIFZpZXdwb3J0IHNob3VsZCBvbmx5IGJlIHNjcm9sbGFibGUgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIC8vIFRoaXMgd29uJ3Qgd29yayBpbiB2ZXJ0aWNhbCB3cml0aW5nIG1vZGVzLCBzbyB3ZSdsbCBuZWVkIHRvXG4gICAgICAgICAgICAvLyByZXZpc2l0IHRoaXMgaWYvd2hlbiB0aGF0IGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9ibG9nL3ZlcnRpY2FsLWZvcm0tY29udHJvbHNcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICAgICAgICAuLi52aWV3cG9ydFByb3BzLnN0eWxlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblNjcm9sbDogY29tcG9zZUV2ZW50SGFuZGxlcnModmlld3BvcnRQcm9wcy5vblNjcm9sbCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRlbnRXcmFwcGVyLCBzaG91bGRFeHBhbmRPblNjcm9sbFJlZiB9ID0gdmlld3BvcnRDb250ZXh0O1xuICAgICAgICAgICAgaWYgKHNob3VsZEV4cGFuZE9uU2Nyb2xsUmVmPy5jdXJyZW50ICYmIGNvbnRlbnRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjcm9sbGVkQnkgPSBNYXRoLmFicyhwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgLSB2aWV3cG9ydC5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgICBpZiAoc2Nyb2xsZWRCeSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBDT05URU5UX01BUkdJTiAqIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgY3NzTWluSGVpZ2h0ID0gcGFyc2VGbG9hdChjb250ZW50V3JhcHBlci5zdHlsZS5taW5IZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzc0hlaWdodCA9IHBhcnNlRmxvYXQoY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gTWF0aC5tYXgoY3NzTWluSGVpZ2h0LCBjc3NIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2SGVpZ2h0IDwgYXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SGVpZ2h0ID0gcHJldkhlaWdodCArIHNjcm9sbGVkQnk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjbGFtcGVkTmV4dEhlaWdodCA9IE1hdGgubWluKGF2YWlsYWJsZUhlaWdodCwgbmV4dEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHREaWZmID0gbmV4dEhlaWdodCAtIGNsYW1wZWROZXh0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gY2xhbXBlZE5leHRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGVudFdyYXBwZXIuc3R5bGUuYm90dG9tID09PSBcIjBweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0LnNjcm9sbFRvcCA9IGhlaWdodERpZmYgPiAwID8gaGVpZ2h0RGlmZiA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJmbGV4LWVuZFwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gdmlld3BvcnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICkgfSlcbiAgICBdIH0pO1xuICB9XG4pO1xuU2VsZWN0Vmlld3BvcnQuZGlzcGxheU5hbWUgPSBWSUVXUE9SVF9OQU1FO1xudmFyIEdST1VQX05BTUUgPSBcIlNlbGVjdEdyb3VwXCI7XG52YXIgW1NlbGVjdEdyb3VwQ29udGV4dFByb3ZpZGVyLCB1c2VTZWxlY3RHcm91cENvbnRleHRdID0gY3JlYXRlU2VsZWN0Q29udGV4dChHUk9VUF9OQU1FKTtcbnZhciBTZWxlY3RHcm91cCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCAuLi5ncm91cFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBncm91cElkID0gdXNlSWQoKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RHcm91cENvbnRleHRQcm92aWRlciwgeyBzY29wZTogX19zY29wZVNlbGVjdCwgaWQ6IGdyb3VwSWQsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgcm9sZTogXCJncm91cFwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBncm91cElkLCAuLi5ncm91cFByb3BzLCByZWY6IGZvcndhcmRlZFJlZiB9KSB9KTtcbiAgfVxuKTtcblNlbGVjdEdyb3VwLmRpc3BsYXlOYW1lID0gR1JPVVBfTkFNRTtcbnZhciBMQUJFTF9OQU1FID0gXCJTZWxlY3RMYWJlbFwiO1xudmFyIFNlbGVjdExhYmVsID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLmxhYmVsUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGdyb3VwQ29udGV4dCA9IHVzZVNlbGVjdEdyb3VwQ29udGV4dChMQUJFTF9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuZGl2LCB7IGlkOiBncm91cENvbnRleHQuaWQsIC4uLmxhYmVsUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pO1xuICB9XG4pO1xuU2VsZWN0TGFiZWwuZGlzcGxheU5hbWUgPSBMQUJFTF9OQU1FO1xudmFyIElURU1fTkFNRSA9IFwiU2VsZWN0SXRlbVwiO1xudmFyIFtTZWxlY3RJdGVtQ29udGV4dFByb3ZpZGVyLCB1c2VTZWxlY3RJdGVtQ29udGV4dF0gPSBjcmVhdGVTZWxlY3RDb250ZXh0KElURU1fTkFNRSk7XG52YXIgU2VsZWN0SXRlbSA9IFJlYWN0LmZvcndhcmRSZWYoXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX19zY29wZVNlbGVjdCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgIHRleHRWYWx1ZTogdGV4dFZhbHVlUHJvcCxcbiAgICAgIC4uLml0ZW1Qcm9wc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU2VsZWN0Q29udGV4dChJVEVNX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoSVRFTV9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gY29udGV4dC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgY29uc3QgW3RleHRWYWx1ZSwgc2V0VGV4dFZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKHRleHRWYWx1ZVByb3AgPz8gXCJcIik7XG4gICAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoXG4gICAgICBmb3J3YXJkZWRSZWYsXG4gICAgICAobm9kZSkgPT4gY29udGVudENvbnRleHQuaXRlbVJlZkNhbGxiYWNrPy4obm9kZSwgdmFsdWUsIGRpc2FibGVkKVxuICAgICk7XG4gICAgY29uc3QgdGV4dElkID0gdXNlSWQoKTtcbiAgICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZihcInRvdWNoXCIpO1xuICAgIGNvbnN0IGhhbmRsZVNlbGVjdCA9ICgpID0+IHtcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgY29udGV4dC5vblZhbHVlQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgY29udGV4dC5vbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQSA8U2VsZWN0Lkl0ZW0gLz4gbXVzdCBoYXZlIGEgdmFsdWUgcHJvcCB0aGF0IGlzIG5vdCBhbiBlbXB0eSBzdHJpbmcuIFRoaXMgaXMgYmVjYXVzZSB0aGUgU2VsZWN0IHZhbHVlIGNhbiBiZSBzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBzZWxlY3Rpb24gYW5kIHNob3cgdGhlIHBsYWNlaG9sZGVyLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFNlbGVjdEl0ZW1Db250ZXh0UHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBfX3Njb3BlU2VsZWN0LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIHRleHRJZCxcbiAgICAgICAgaXNTZWxlY3RlZCxcbiAgICAgICAgb25JdGVtVGV4dENoYW5nZTogUmVhY3QudXNlQ2FsbGJhY2soKG5vZGUpID0+IHtcbiAgICAgICAgICBzZXRUZXh0VmFsdWUoKHByZXZUZXh0VmFsdWUpID0+IHByZXZUZXh0VmFsdWUgfHwgKG5vZGU/LnRleHRDb250ZW50ID8/IFwiXCIpLnRyaW0oKSk7XG4gICAgICAgIH0sIFtdKSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgQ29sbGVjdGlvbi5JdGVtU2xvdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY29wZTogX19zY29wZVNlbGVjdCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICB0ZXh0VmFsdWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgUHJpbWl0aXZlLmRpdixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJvbGU6IFwib3B0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogdGV4dElkLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1oaWdobGlnaHRlZFwiOiBpc0ZvY3VzZWQgPyBcIlwiIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBpc1NlbGVjdGVkICYmIGlzRm9jdXNlZCxcbiAgICAgICAgICAgICAgICBcImRhdGEtc3RhdGVcIjogaXNTZWxlY3RlZCA/IFwiY2hlY2tlZFwiIDogXCJ1bmNoZWNrZWRcIixcbiAgICAgICAgICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/IFwiXCIgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdGFiSW5kZXg6IGRpc2FibGVkID8gdm9pZCAwIDogLTEsXG4gICAgICAgICAgICAgICAgLi4uaXRlbVByb3BzLFxuICAgICAgICAgICAgICAgIHJlZjogY29tcG9zZWRSZWZzLFxuICAgICAgICAgICAgICAgIG9uRm9jdXM6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vbkZvY3VzLCAoKSA9PiBzZXRJc0ZvY3VzZWQodHJ1ZSkpLFxuICAgICAgICAgICAgICAgIG9uQmx1cjogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uQmx1ciwgKCkgPT4gc2V0SXNGb2N1c2VkKGZhbHNlKSksXG4gICAgICAgICAgICAgICAgb25DbGljazogY29tcG9zZUV2ZW50SGFuZGxlcnMoaXRlbVByb3BzLm9uQ2xpY2ssICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ICE9PSBcIm1vdXNlXCIpIGhhbmRsZVNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlclVwOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyVXAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSBcIm1vdXNlXCIpIGhhbmRsZVNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG9uUG9pbnRlckRvd246IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vblBvaW50ZXJEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvblBvaW50ZXJNb3ZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25Qb2ludGVyTW92ZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudENvbnRleHQub25JdGVtTGVhdmU/LigpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSBcIm1vdXNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb25Qb2ludGVyTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKGl0ZW1Qcm9wcy5vblBvaW50ZXJMZWF2ZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Q29udGV4dC5vbkl0ZW1MZWF2ZT8uKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb25LZXlEb3duOiBjb21wb3NlRXZlbnRIYW5kbGVycyhpdGVtUHJvcHMub25LZXlEb3duLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVHlwaW5nQWhlYWQgPSBjb250ZW50Q29udGV4dC5zZWFyY2hSZWY/LmN1cnJlbnQgIT09IFwiXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNUeXBpbmdBaGVhZCAmJiBldmVudC5rZXkgPT09IFwiIFwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICBpZiAoU0VMRUNUSU9OX0tFWVMuaW5jbHVkZXMoZXZlbnQua2V5KSkgaGFuZGxlU2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIiBcIikgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcblNlbGVjdEl0ZW0uZGlzcGxheU5hbWUgPSBJVEVNX05BTUU7XG52YXIgSVRFTV9URVhUX05BTUUgPSBcIlNlbGVjdEl0ZW1UZXh0XCI7XG52YXIgU2VsZWN0SXRlbVRleHQgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgY2xhc3NOYW1lLCBzdHlsZSwgLi4uaXRlbVRleHRQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGNvbnRlbnRDb250ZXh0ID0gdXNlU2VsZWN0Q29udGVudENvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IGl0ZW1Db250ZXh0ID0gdXNlU2VsZWN0SXRlbUNvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IG5hdGl2ZU9wdGlvbnNDb250ZXh0ID0gdXNlU2VsZWN0TmF0aXZlT3B0aW9uc0NvbnRleHQoSVRFTV9URVhUX05BTUUsIF9fc2NvcGVTZWxlY3QpO1xuICAgIGNvbnN0IFtpdGVtVGV4dE5vZGUsIHNldEl0ZW1UZXh0Tm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjb21wb3NlZFJlZnMgPSB1c2VDb21wb3NlZFJlZnMoXG4gICAgICBmb3J3YXJkZWRSZWYsXG4gICAgICAobm9kZSkgPT4gc2V0SXRlbVRleHROb2RlKG5vZGUpLFxuICAgICAgaXRlbUNvbnRleHQub25JdGVtVGV4dENoYW5nZSxcbiAgICAgIChub2RlKSA9PiBjb250ZW50Q29udGV4dC5pdGVtVGV4dFJlZkNhbGxiYWNrPy4obm9kZSwgaXRlbUNvbnRleHQudmFsdWUsIGl0ZW1Db250ZXh0LmRpc2FibGVkKVxuICAgICk7XG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBpdGVtVGV4dE5vZGU/LnRleHRDb250ZW50O1xuICAgIGNvbnN0IG5hdGl2ZU9wdGlvbiA9IFJlYWN0LnVzZU1lbW8oXG4gICAgICAoKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwib3B0aW9uXCIsIHsgdmFsdWU6IGl0ZW1Db250ZXh0LnZhbHVlLCBkaXNhYmxlZDogaXRlbUNvbnRleHQuZGlzYWJsZWQsIGNoaWxkcmVuOiB0ZXh0Q29udGVudCB9LCBpdGVtQ29udGV4dC52YWx1ZSksXG4gICAgICBbaXRlbUNvbnRleHQuZGlzYWJsZWQsIGl0ZW1Db250ZXh0LnZhbHVlLCB0ZXh0Q29udGVudF1cbiAgICApO1xuICAgIGNvbnN0IHsgb25OYXRpdmVPcHRpb25BZGQsIG9uTmF0aXZlT3B0aW9uUmVtb3ZlIH0gPSBuYXRpdmVPcHRpb25zQ29udGV4dDtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgb25OYXRpdmVPcHRpb25BZGQobmF0aXZlT3B0aW9uKTtcbiAgICAgIHJldHVybiAoKSA9PiBvbk5hdGl2ZU9wdGlvblJlbW92ZShuYXRpdmVPcHRpb24pO1xuICAgIH0sIFtvbk5hdGl2ZU9wdGlvbkFkZCwgb25OYXRpdmVPcHRpb25SZW1vdmUsIG5hdGl2ZU9wdGlvbl0pO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChQcmltaXRpdmUuc3BhbiwgeyBpZDogaXRlbUNvbnRleHQudGV4dElkLCAuLi5pdGVtVGV4dFByb3BzLCByZWY6IGNvbXBvc2VkUmVmcyB9KSxcbiAgICAgIGl0ZW1Db250ZXh0LmlzU2VsZWN0ZWQgJiYgY29udGV4dC52YWx1ZU5vZGUgJiYgIWNvbnRleHQudmFsdWVOb2RlSGFzQ2hpbGRyZW4gPyBSZWFjdERPTS5jcmVhdGVQb3J0YWwoaXRlbVRleHRQcm9wcy5jaGlsZHJlbiwgY29udGV4dC52YWx1ZU5vZGUpIDogbnVsbFxuICAgIF0gfSk7XG4gIH1cbik7XG5TZWxlY3RJdGVtVGV4dC5kaXNwbGF5TmFtZSA9IElURU1fVEVYVF9OQU1FO1xudmFyIElURU1fSU5ESUNBVE9SX05BTUUgPSBcIlNlbGVjdEl0ZW1JbmRpY2F0b3JcIjtcbnZhciBTZWxlY3RJdGVtSW5kaWNhdG9yID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLml0ZW1JbmRpY2F0b3JQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXRlbUNvbnRleHQgPSB1c2VTZWxlY3RJdGVtQ29udGV4dChJVEVNX0lORElDQVRPUl9OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICByZXR1cm4gaXRlbUNvbnRleHQuaXNTZWxlY3RlZCA/IC8qIEBfX1BVUkVfXyAqLyBqc3goUHJpbWl0aXZlLnNwYW4sIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCAuLi5pdGVtSW5kaWNhdG9yUHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pIDogbnVsbDtcbiAgfVxuKTtcblNlbGVjdEl0ZW1JbmRpY2F0b3IuZGlzcGxheU5hbWUgPSBJVEVNX0lORElDQVRPUl9OQU1FO1xudmFyIFNDUk9MTF9VUF9CVVRUT05fTkFNRSA9IFwiU2VsZWN0U2Nyb2xsVXBCdXR0b25cIjtcbnZhciBTZWxlY3RTY3JvbGxVcEJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChTQ1JPTExfVVBfQlVUVE9OX05BTUUsIHByb3BzLl9fc2NvcGVTZWxlY3QpO1xuICBjb25zdCB2aWV3cG9ydENvbnRleHQgPSB1c2VTZWxlY3RWaWV3cG9ydENvbnRleHQoU0NST0xMX1VQX0JVVFRPTl9OQU1FLCBwcm9wcy5fX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgW2NhblNjcm9sbFVwLCBzZXRDYW5TY3JvbGxVcF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGNvbXBvc2VkUmVmcyA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIHZpZXdwb3J0Q29udGV4dC5vblNjcm9sbEJ1dHRvbkNoYW5nZSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRlbnRDb250ZXh0LnZpZXdwb3J0ICYmIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZCkge1xuICAgICAgbGV0IGhhbmRsZVNjcm9sbDIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgY2FuU2Nyb2xsVXAyID0gdmlld3BvcnQuc2Nyb2xsVG9wID4gMDtcbiAgICAgICAgc2V0Q2FuU2Nyb2xsVXAoY2FuU2Nyb2xsVXAyKTtcbiAgICAgIH07XG4gICAgICB2YXIgaGFuZGxlU2Nyb2xsID0gaGFuZGxlU2Nyb2xsMjtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gY29udGVudENvbnRleHQudmlld3BvcnQ7XG4gICAgICBoYW5kbGVTY3JvbGwyKCk7XG4gICAgICB2aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbDIpO1xuICAgICAgcmV0dXJuICgpID0+IHZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsMik7XG4gICAgfVxuICB9LCBbY29udGVudENvbnRleHQudmlld3BvcnQsIGNvbnRlbnRDb250ZXh0LmlzUG9zaXRpb25lZF0pO1xuICByZXR1cm4gY2FuU2Nyb2xsVXAgPyAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFNlbGVjdFNjcm9sbEJ1dHRvbkltcGwsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IGNvbXBvc2VkUmVmcyxcbiAgICAgIG9uQXV0b1Njcm9sbDogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHZpZXdwb3J0LCBzZWxlY3RlZEl0ZW0gfSA9IGNvbnRlbnRDb250ZXh0O1xuICAgICAgICBpZiAodmlld3BvcnQgJiYgc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgdmlld3BvcnQuc2Nyb2xsVG9wID0gdmlld3BvcnQuc2Nyb2xsVG9wIC0gc2VsZWN0ZWRJdGVtLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKSA6IG51bGw7XG59KTtcblNlbGVjdFNjcm9sbFVwQnV0dG9uLmRpc3BsYXlOYW1lID0gU0NST0xMX1VQX0JVVFRPTl9OQU1FO1xudmFyIFNDUk9MTF9ET1dOX0JVVFRPTl9OQU1FID0gXCJTZWxlY3RTY3JvbGxEb3duQnV0dG9uXCI7XG52YXIgU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChTQ1JPTExfRE9XTl9CVVRUT05fTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IHZpZXdwb3J0Q29udGV4dCA9IHVzZVNlbGVjdFZpZXdwb3J0Q29udGV4dChTQ1JPTExfRE9XTl9CVVRUT05fTkFNRSwgcHJvcHMuX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IFtjYW5TY3JvbGxEb3duLCBzZXRDYW5TY3JvbGxEb3duXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgdmlld3BvcnRDb250ZXh0Lm9uU2Nyb2xsQnV0dG9uQ2hhbmdlKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29udGVudENvbnRleHQudmlld3BvcnQgJiYgY29udGVudENvbnRleHQuaXNQb3NpdGlvbmVkKSB7XG4gICAgICBsZXQgaGFuZGxlU2Nyb2xsMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSB2aWV3cG9ydC5zY3JvbGxIZWlnaHQgLSB2aWV3cG9ydC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNhblNjcm9sbERvd24yID0gTWF0aC5jZWlsKHZpZXdwb3J0LnNjcm9sbFRvcCkgPCBtYXhTY3JvbGw7XG4gICAgICAgIHNldENhblNjcm9sbERvd24oY2FuU2Nyb2xsRG93bjIpO1xuICAgICAgfTtcbiAgICAgIHZhciBoYW5kbGVTY3JvbGwgPSBoYW5kbGVTY3JvbGwyO1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSBjb250ZW50Q29udGV4dC52aWV3cG9ydDtcbiAgICAgIGhhbmRsZVNjcm9sbDIoKTtcbiAgICAgIHZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsMik7XG4gICAgICByZXR1cm4gKCkgPT4gdmlld3BvcnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwyKTtcbiAgICB9XG4gIH0sIFtjb250ZW50Q29udGV4dC52aWV3cG9ydCwgY29udGVudENvbnRleHQuaXNQb3NpdGlvbmVkXSk7XG4gIHJldHVybiBjYW5TY3JvbGxEb3duID8gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBTZWxlY3RTY3JvbGxCdXR0b25JbXBsLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiBjb21wb3NlZFJlZnMsXG4gICAgICBvbkF1dG9TY3JvbGw6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyB2aWV3cG9ydCwgc2VsZWN0ZWRJdGVtIH0gPSBjb250ZW50Q29udGV4dDtcbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgIHZpZXdwb3J0LnNjcm9sbFRvcCA9IHZpZXdwb3J0LnNjcm9sbFRvcCArIHNlbGVjdGVkSXRlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsO1xufSk7XG5TZWxlY3RTY3JvbGxEb3duQnV0dG9uLmRpc3BsYXlOYW1lID0gU0NST0xMX0RPV05fQlVUVE9OX05BTUU7XG52YXIgU2VsZWN0U2Nyb2xsQnV0dG9uSW1wbCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgeyBfX3Njb3BlU2VsZWN0LCBvbkF1dG9TY3JvbGwsIC4uLnNjcm9sbEluZGljYXRvclByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChcIlNlbGVjdFNjcm9sbEJ1dHRvblwiLCBfX3Njb3BlU2VsZWN0KTtcbiAgY29uc3QgYXV0b1Njcm9sbFRpbWVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBnZXRJdGVtcyA9IHVzZUNvbGxlY3Rpb24oX19zY29wZVNlbGVjdCk7XG4gIGNvbnN0IGNsZWFyQXV0b1Njcm9sbFRpbWVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhdXRvU2Nyb2xsVGltZXJSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBjbGVhckF1dG9TY3JvbGxUaW1lcigpO1xuICB9LCBbY2xlYXJBdXRvU2Nyb2xsVGltZXJdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0SXRlbXMoKS5maW5kKChpdGVtKSA9PiBpdGVtLnJlZi5jdXJyZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICBhY3RpdmVJdGVtPy5yZWYuY3VycmVudD8uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogXCJuZWFyZXN0XCIgfSk7XG4gIH0sIFtnZXRJdGVtc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBQcmltaXRpdmUuZGl2LFxuICAgIHtcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICAgIC4uLnNjcm9sbEluZGljYXRvclByb3BzLFxuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICBzdHlsZTogeyBmbGV4U2hyaW5rOiAwLCAuLi5zY3JvbGxJbmRpY2F0b3JQcm9wcy5zdHlsZSB9LFxuICAgICAgb25Qb2ludGVyRG93bjogY29tcG9zZUV2ZW50SGFuZGxlcnMoc2Nyb2xsSW5kaWNhdG9yUHJvcHMub25Qb2ludGVyRG93biwgKCkgPT4ge1xuICAgICAgICBpZiAoYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsVGltZXJSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRJbnRlcnZhbChvbkF1dG9TY3JvbGwsIDUwKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBvblBvaW50ZXJNb3ZlOiBjb21wb3NlRXZlbnRIYW5kbGVycyhzY3JvbGxJbmRpY2F0b3JQcm9wcy5vblBvaW50ZXJNb3ZlLCAoKSA9PiB7XG4gICAgICAgIGNvbnRlbnRDb250ZXh0Lm9uSXRlbUxlYXZlPy4oKTtcbiAgICAgICAgaWYgKGF1dG9TY3JvbGxUaW1lclJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbFRpbWVyUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwob25BdXRvU2Nyb2xsLCA1MCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgb25Qb2ludGVyTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKHNjcm9sbEluZGljYXRvclByb3BzLm9uUG9pbnRlckxlYXZlLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyQXV0b1Njcm9sbFRpbWVyKCk7XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn0pO1xudmFyIFNFUEFSQVRPUl9OQU1FID0gXCJTZWxlY3RTZXBhcmF0b3JcIjtcbnZhciBTZWxlY3RTZXBhcmF0b3IgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgX19zY29wZVNlbGVjdCwgLi4uc2VwYXJhdG9yUHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFByaW1pdGl2ZS5kaXYsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCAuLi5zZXBhcmF0b3JQcm9wcywgcmVmOiBmb3J3YXJkZWRSZWYgfSk7XG4gIH1cbik7XG5TZWxlY3RTZXBhcmF0b3IuZGlzcGxheU5hbWUgPSBTRVBBUkFUT1JfTkFNRTtcbnZhciBBUlJPV19OQU1FID0gXCJTZWxlY3RBcnJvd1wiO1xudmFyIFNlbGVjdEFycm93ID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCB7IF9fc2NvcGVTZWxlY3QsIC4uLmFycm93UHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHBvcHBlclNjb3BlID0gdXNlUG9wcGVyU2NvcGUoX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVNlbGVjdENvbnRleHQoQVJST1dfTkFNRSwgX19zY29wZVNlbGVjdCk7XG4gICAgY29uc3QgY29udGVudENvbnRleHQgPSB1c2VTZWxlY3RDb250ZW50Q29udGV4dChBUlJPV19OQU1FLCBfX3Njb3BlU2VsZWN0KTtcbiAgICByZXR1cm4gY29udGV4dC5vcGVuICYmIGNvbnRlbnRDb250ZXh0LnBvc2l0aW9uID09PSBcInBvcHBlclwiID8gLyogQF9fUFVSRV9fICovIGpzeChQb3BwZXJQcmltaXRpdmUuQXJyb3csIHsgLi4ucG9wcGVyU2NvcGUsIC4uLmFycm93UHJvcHMsIHJlZjogZm9yd2FyZGVkUmVmIH0pIDogbnVsbDtcbiAgfVxuKTtcblNlbGVjdEFycm93LmRpc3BsYXlOYW1lID0gQVJST1dfTkFNRTtcbmZ1bmN0aW9uIHNob3VsZFNob3dQbGFjZWhvbGRlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHZvaWQgMDtcbn1cbnZhciBCdWJibGVTZWxlY3QgPSBSZWFjdC5mb3J3YXJkUmVmKFxuICAocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgdmFsdWUsIC4uLnNlbGVjdFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29tcG9zZWRSZWZzID0gdXNlQ29tcG9zZWRSZWZzKGZvcndhcmRlZFJlZiwgcmVmKTtcbiAgICBjb25zdCBwcmV2VmFsdWUgPSB1c2VQcmV2aW91cyh2YWx1ZSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdCA9IHJlZi5jdXJyZW50O1xuICAgICAgY29uc3Qgc2VsZWN0UHJvdG8gPSB3aW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlO1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgIHNlbGVjdFByb3RvLFxuICAgICAgICBcInZhbHVlXCJcbiAgICAgICk7XG4gICAgICBjb25zdCBzZXRWYWx1ZSA9IGRlc2NyaXB0b3Iuc2V0O1xuICAgICAgaWYgKHByZXZWYWx1ZSAhPT0gdmFsdWUgJiYgc2V0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoXCJjaGFuZ2VcIiwgeyBidWJibGVzOiB0cnVlIH0pO1xuICAgICAgICBzZXRWYWx1ZS5jYWxsKHNlbGVjdCwgdmFsdWUpO1xuICAgICAgICBzZWxlY3QuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfSwgW3ByZXZWYWx1ZSwgdmFsdWVdKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChWaXN1YWxseUhpZGRlbiwgeyBhc0NoaWxkOiB0cnVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInNlbGVjdFwiLCB7IC4uLnNlbGVjdFByb3BzLCByZWY6IGNvbXBvc2VkUmVmcywgZGVmYXVsdFZhbHVlOiB2YWx1ZSB9KSB9KTtcbiAgfVxuKTtcbkJ1YmJsZVNlbGVjdC5kaXNwbGF5TmFtZSA9IFwiQnViYmxlU2VsZWN0XCI7XG5mdW5jdGlvbiB1c2VUeXBlYWhlYWRTZWFyY2gob25TZWFyY2hDaGFuZ2UpIHtcbiAgY29uc3QgaGFuZGxlU2VhcmNoQ2hhbmdlID0gdXNlQ2FsbGJhY2tSZWYob25TZWFyY2hDaGFuZ2UpO1xuICBjb25zdCBzZWFyY2hSZWYgPSBSZWFjdC51c2VSZWYoXCJcIik7XG4gIGNvbnN0IHRpbWVyUmVmID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCBoYW5kbGVUeXBlYWhlYWRTZWFyY2ggPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoa2V5KSA9PiB7XG4gICAgICBjb25zdCBzZWFyY2ggPSBzZWFyY2hSZWYuY3VycmVudCArIGtleTtcbiAgICAgIGhhbmRsZVNlYXJjaENoYW5nZShzZWFyY2gpO1xuICAgICAgKGZ1bmN0aW9uIHVwZGF0ZVNlYXJjaCh2YWx1ZSkge1xuICAgICAgICBzZWFyY2hSZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAodmFsdWUgIT09IFwiXCIpIHRpbWVyUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB1cGRhdGVTZWFyY2goXCJcIiksIDFlMyk7XG4gICAgICB9KShzZWFyY2gpO1xuICAgIH0sXG4gICAgW2hhbmRsZVNlYXJjaENoYW5nZV1cbiAgKTtcbiAgY29uc3QgcmVzZXRUeXBlYWhlYWQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2VhcmNoUmVmLmN1cnJlbnQgPSBcIlwiO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXJSZWYuY3VycmVudCk7XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dCh0aW1lclJlZi5jdXJyZW50KTtcbiAgfSwgW10pO1xuICByZXR1cm4gW3NlYXJjaFJlZiwgaGFuZGxlVHlwZWFoZWFkU2VhcmNoLCByZXNldFR5cGVhaGVhZF07XG59XG5mdW5jdGlvbiBmaW5kTmV4dEl0ZW0oaXRlbXMsIHNlYXJjaCwgY3VycmVudEl0ZW0pIHtcbiAgY29uc3QgaXNSZXBlYXRlZCA9IHNlYXJjaC5sZW5ndGggPiAxICYmIEFycmF5LmZyb20oc2VhcmNoKS5ldmVyeSgoY2hhcikgPT4gY2hhciA9PT0gc2VhcmNoWzBdKTtcbiAgY29uc3Qgbm9ybWFsaXplZFNlYXJjaCA9IGlzUmVwZWF0ZWQgPyBzZWFyY2hbMF0gOiBzZWFyY2g7XG4gIGNvbnN0IGN1cnJlbnRJdGVtSW5kZXggPSBjdXJyZW50SXRlbSA/IGl0ZW1zLmluZGV4T2YoY3VycmVudEl0ZW0pIDogLTE7XG4gIGxldCB3cmFwcGVkSXRlbXMgPSB3cmFwQXJyYXkoaXRlbXMsIE1hdGgubWF4KGN1cnJlbnRJdGVtSW5kZXgsIDApKTtcbiAgY29uc3QgZXhjbHVkZUN1cnJlbnRJdGVtID0gbm9ybWFsaXplZFNlYXJjaC5sZW5ndGggPT09IDE7XG4gIGlmIChleGNsdWRlQ3VycmVudEl0ZW0pIHdyYXBwZWRJdGVtcyA9IHdyYXBwZWRJdGVtcy5maWx0ZXIoKHYpID0+IHYgIT09IGN1cnJlbnRJdGVtKTtcbiAgY29uc3QgbmV4dEl0ZW0gPSB3cmFwcGVkSXRlbXMuZmluZChcbiAgICAoaXRlbSkgPT4gaXRlbS50ZXh0VmFsdWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG5vcm1hbGl6ZWRTZWFyY2gudG9Mb3dlckNhc2UoKSlcbiAgKTtcbiAgcmV0dXJuIG5leHRJdGVtICE9PSBjdXJyZW50SXRlbSA/IG5leHRJdGVtIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gd3JhcEFycmF5KGFycmF5LCBzdGFydEluZGV4KSB7XG4gIHJldHVybiBhcnJheS5tYXAoKF8sIGluZGV4KSA9PiBhcnJheVsoc3RhcnRJbmRleCArIGluZGV4KSAlIGFycmF5Lmxlbmd0aF0pO1xufVxudmFyIFJvb3QyID0gU2VsZWN0O1xudmFyIFRyaWdnZXIgPSBTZWxlY3RUcmlnZ2VyO1xudmFyIFZhbHVlID0gU2VsZWN0VmFsdWU7XG52YXIgSWNvbiA9IFNlbGVjdEljb247XG52YXIgUG9ydGFsID0gU2VsZWN0UG9ydGFsO1xudmFyIENvbnRlbnQyID0gU2VsZWN0Q29udGVudDtcbnZhciBWaWV3cG9ydCA9IFNlbGVjdFZpZXdwb3J0O1xudmFyIEdyb3VwID0gU2VsZWN0R3JvdXA7XG52YXIgTGFiZWwgPSBTZWxlY3RMYWJlbDtcbnZhciBJdGVtID0gU2VsZWN0SXRlbTtcbnZhciBJdGVtVGV4dCA9IFNlbGVjdEl0ZW1UZXh0O1xudmFyIEl0ZW1JbmRpY2F0b3IgPSBTZWxlY3RJdGVtSW5kaWNhdG9yO1xudmFyIFNjcm9sbFVwQnV0dG9uID0gU2VsZWN0U2Nyb2xsVXBCdXR0b247XG52YXIgU2Nyb2xsRG93bkJ1dHRvbiA9IFNlbGVjdFNjcm9sbERvd25CdXR0b247XG52YXIgU2VwYXJhdG9yID0gU2VsZWN0U2VwYXJhdG9yO1xudmFyIEFycm93MiA9IFNlbGVjdEFycm93O1xuZXhwb3J0IHtcbiAgQXJyb3cyIGFzIEFycm93LFxuICBDb250ZW50MiBhcyBDb250ZW50LFxuICBHcm91cCxcbiAgSWNvbixcbiAgSXRlbSxcbiAgSXRlbUluZGljYXRvcixcbiAgSXRlbVRleHQsXG4gIExhYmVsLFxuICBQb3J0YWwsXG4gIFJvb3QyIGFzIFJvb3QsXG4gIFNjcm9sbERvd25CdXR0b24sXG4gIFNjcm9sbFVwQnV0dG9uLFxuICBTZWxlY3QsXG4gIFNlbGVjdEFycm93LFxuICBTZWxlY3RDb250ZW50LFxuICBTZWxlY3RHcm91cCxcbiAgU2VsZWN0SWNvbixcbiAgU2VsZWN0SXRlbSxcbiAgU2VsZWN0SXRlbUluZGljYXRvcixcbiAgU2VsZWN0SXRlbVRleHQsXG4gIFNlbGVjdExhYmVsLFxuICBTZWxlY3RQb3J0YWwsXG4gIFNlbGVjdFNjcm9sbERvd25CdXR0b24sXG4gIFNlbGVjdFNjcm9sbFVwQnV0dG9uLFxuICBTZWxlY3RTZXBhcmF0b3IsXG4gIFNlbGVjdFRyaWdnZXIsXG4gIFNlbGVjdFZhbHVlLFxuICBTZWxlY3RWaWV3cG9ydCxcbiAgU2VwYXJhdG9yLFxuICBUcmlnZ2VyLFxuICBWYWx1ZSxcbiAgVmlld3BvcnQsXG4gIGNyZWF0ZVNlbGVjdFNjb3BlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmNvbnN0IHRvS2ViYWJDYXNlID0gKHN0cmluZykgPT4gc3RyaW5nLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcbmNvbnN0IG1lcmdlQ2xhc3NlcyA9ICguLi5jbGFzc2VzKSA9PiBjbGFzc2VzLmZpbHRlcigoY2xhc3NOYW1lLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oY2xhc3NOYW1lKSAmJiBjbGFzc05hbWUudHJpbSgpICE9PSBcIlwiICYmIGFycmF5LmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gaW5kZXg7XG59KS5qb2luKFwiIFwiKS50cmltKCk7XG5cbmV4cG9ydCB7IG1lcmdlQ2xhc3NlcywgdG9LZWJhYkNhc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0QXR0cmlidXRlcyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0QXR0cmlidXRlcy5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgeyBmb3J3YXJkUmVmLCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGRlZmF1bHRBdHRyaWJ1dGVzIGZyb20gJy4vZGVmYXVsdEF0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzLmpzJztcblxuY29uc3QgSWNvbiA9IGZvcndhcmRSZWYoXG4gICh7XG4gICAgY29sb3IgPSBcImN1cnJlbnRDb2xvclwiLFxuICAgIHNpemUgPSAyNCxcbiAgICBzdHJva2VXaWR0aCA9IDIsXG4gICAgYWJzb2x1dGVTdHJva2VXaWR0aCxcbiAgICBjbGFzc05hbWUgPSBcIlwiLFxuICAgIGNoaWxkcmVuLFxuICAgIGljb25Ob2RlLFxuICAgIC4uLnJlc3RcbiAgfSwgcmVmKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICByZWYsXG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogYWJzb2x1dGVTdHJva2VXaWR0aCA/IE51bWJlcihzdHJva2VXaWR0aCkgKiAyNCAvIE51bWJlcihzaXplKSA6IHN0cm9rZVdpZHRoLFxuICAgICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcImx1Y2lkZVwiLCBjbGFzc05hbWUpLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICAuLi5pY29uTm9kZS5tYXAoKFt0YWcsIGF0dHJzXSkgPT4gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSksXG4gICAgICAgIC4uLkFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dXG4gICAgICBdXG4gICAgKTtcbiAgfVxuKTtcblxuZXhwb3J0IHsgSWNvbiBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IGZvcndhcmRSZWYsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtZXJnZUNsYXNzZXMsIHRvS2ViYWJDYXNlIH0gZnJvbSAnLi9zaGFyZWQvc3JjL3V0aWxzLmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbmNvbnN0IGNyZWF0ZUx1Y2lkZUljb24gPSAoaWNvbk5hbWUsIGljb25Ob2RlKSA9PiB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWYoXG4gICAgKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoSWNvbiwge1xuICAgICAgcmVmLFxuICAgICAgaWNvbk5vZGUsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhgbHVjaWRlLSR7dG9LZWJhYkNhc2UoaWNvbk5hbWUpfWAsIGNsYXNzTmFtZSksXG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gICk7XG4gIENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGAke2ljb25OYW1lfWA7XG4gIHJldHVybiBDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVMdWNpZGVJY29uIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUx1Y2lkZUljb24uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IENoZWNrID0gY3JlYXRlTHVjaWRlSWNvbihcIkNoZWNrXCIsIFtbXCJwYXRoXCIsIHsgZDogXCJNMjAgNiA5IDE3bC01LTVcIiwga2V5OiBcIjFnbWYyY1wiIH1dXSk7XG5cbmV4cG9ydCB7IENoZWNrIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNDY4LjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24uanMnO1xuXG5jb25zdCBDaGV2cm9uRG93biA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDaGV2cm9uRG93blwiLCBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIm02IDkgNiA2IDYtNlwiLCBrZXk6IFwicXJ1bnNsXCIgfV1cbl0pO1xuXG5leHBvcnQgeyBDaGV2cm9uRG93biBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGV2cm9uLWRvd24uanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC40NjguMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbi5qcyc7XG5cbmNvbnN0IENoZXZyb25VcCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDaGV2cm9uVXBcIiwgW1tcInBhdGhcIiwgeyBkOiBcIm0xOCAxNS02LTYtNiA2XCIsIGtleTogXCIxNTN1ZHpcIiB9XV0pO1xuXG5leHBvcnQgeyBDaGV2cm9uVXAgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hldnJvbi11cC5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjQ2OC4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uLmpzJztcblxuY29uc3QgQ29weSA9IGNyZWF0ZUx1Y2lkZUljb24oXCJDb3B5XCIsIFtcbiAgW1wicmVjdFwiLCB7IHdpZHRoOiBcIjE0XCIsIGhlaWdodDogXCIxNFwiLCB4OiBcIjhcIiwgeTogXCI4XCIsIHJ4OiBcIjJcIiwgcnk6IFwiMlwiLCBrZXk6IFwiMTdqeWVhXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk00IDE2Yy0xLjEgMC0yLS45LTItMlY0YzAtMS4xLjktMiAyLTJoMTBjMS4xIDAgMiAuOSAyIDJcIiwga2V5OiBcInppeDl1ZlwiIH1dXG5dKTtcblxuZXhwb3J0IHsgQ29weSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5LmpzLm1hcFxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgU2VsZWN0UHJpbWl0aXZlIGZyb20gXCJAcmFkaXgtdWkvcmVhY3Qtc2VsZWN0XCI7XG5pbXBvcnQgeyBDaGVjaywgQ2hldnJvbkRvd24sIENoZXZyb25VcCB9IGZyb20gXCJsdWNpZGUtcmVhY3RcIjtcbmltcG9ydCB7IGNuIH0gZnJvbSBcIkB1dGlscy9zdHJpbmdVdGlsc1wiO1xuXG5jb25zdCBTZWxlY3QgPSBTZWxlY3RQcmltaXRpdmUuUm9vdDtcblxuY29uc3QgU2VsZWN0R3JvdXAgPSBTZWxlY3RQcmltaXRpdmUuR3JvdXA7XG5cbmNvbnN0IFNlbGVjdFZhbHVlID0gU2VsZWN0UHJpbWl0aXZlLlZhbHVlO1xuXG5jb25zdCBTZWxlY3RUcmlnZ2VyID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlRyaWdnZXI+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyPlxuPigoeyBjbGFzc05hbWUsIGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyXG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwicmluZy1vZmZzZXQtYmFja2dyb3VuZCBmb2N1czpyaW5nLXJpbmcgZmxleCBoLTQgdy1mdWxsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gd2hpdGVzcGFjZS1ub3dyYXAgcm91bmRlZC1tZCBiZy10cmFuc3BhcmVudCBweC0zIHB5LTIgdGV4dC14cyBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0xIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZCBkaXNhYmxlZDpvcGFjaXR5LTUwIFsmPnNwYW5dOmxpbmUtY2xhbXAtMVwiLFxuICAgICAgXCJkYXJrOnBsYWNlaG9sZGVyLXRleHQtemluYy02MDAgdGV4dC1ibGFjayBwbGFjZWhvbGRlcjp0ZXh0LW5vaXItNDAwIGRhcms6dGV4dC13aGl0ZVwiLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICA+XG4gICAge2NoaWxkcmVufVxuICAgIDxTZWxlY3RQcmltaXRpdmUuSWNvbiBhc0NoaWxkPlxuICAgICAgPENoZXZyb25Eb3duIGNsYXNzTmFtZT1cIm1sLTEgaC00IHctNCB0ZXh0LWJsYWNrIG9wYWNpdHktNTAgZGFyazp0ZXh0LXdoaXRlXCIgLz5cbiAgICA8L1NlbGVjdFByaW1pdGl2ZS5JY29uPlxuICA8L1NlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyPlxuKSk7XG5TZWxlY3RUcmlnZ2VyLmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLlRyaWdnZXIuZGlzcGxheU5hbWU7XG5cbmNvbnN0IFNlbGVjdFNjcm9sbFVwQnV0dG9uID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbFVwQnV0dG9uPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b25cbiAgICByZWY9e3JlZn1cbiAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgXCJmbGV4IGN1cnNvci1kZWZhdWx0IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBweS0xXCIsXG4gICAgICBjbGFzc05hbWUsXG4gICAgKX1cbiAgICB7Li4ucHJvcHN9XG4gID5cbiAgICA8Q2hldnJvblVwIGNsYXNzTmFtZT1cImgtNCB3LTRcIiAvPlxuICA8L1NlbGVjdFByaW1pdGl2ZS5TY3JvbGxVcEJ1dHRvbj5cbikpO1xuU2VsZWN0U2Nyb2xsVXBCdXR0b24uZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24uZGlzcGxheU5hbWU7XG5cbmNvbnN0IFNlbGVjdFNjcm9sbERvd25CdXR0b24gPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBSZWFjdC5FbGVtZW50UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbj4sXG4gIFJlYWN0LkNvbXBvbmVudFByb3BzV2l0aG91dFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLlNjcm9sbERvd25CdXR0b24+XG4+KCh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiAoXG4gIDxTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvblxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXG4gICAgICBcImZsZXggY3Vyc29yLWRlZmF1bHQgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHB5LTFcIixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICApfVxuICAgIHsuLi5wcm9wc31cbiAgPlxuICAgIDxDaGV2cm9uRG93biBjbGFzc05hbWU9XCJoLTQgdy00XCIgLz5cbiAgPC9TZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbj5cbikpO1xuU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbi5kaXNwbGF5TmFtZSA9XG4gIFNlbGVjdFByaW1pdGl2ZS5TY3JvbGxEb3duQnV0dG9uLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RDb250ZW50ID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLkNvbnRlbnQ+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5Db250ZW50PlxuPigoeyBjbGFzc05hbWUsIGNoaWxkcmVuLCBwb3NpdGlvbiA9IFwicG9wcGVyXCIsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlBvcnRhbD5cbiAgICA8U2VsZWN0UHJpbWl0aXZlLkNvbnRlbnRcbiAgICAgIHJlZj17cmVmfVxuICAgICAgY2xhc3NOYW1lPXtjbihcbiAgICAgICAgXCJkYXRhLVtzdGF0ZT1vcGVuXTphbmltYXRlLWluIGRhdGEtW3N0YXRlPWNsb3NlZF06YW5pbWF0ZS1vdXQgZGF0YS1bc3RhdGU9Y2xvc2VkXTpmYWRlLW91dC0wIGRhdGEtW3N0YXRlPW9wZW5dOmZhZGUtaW4tMCBkYXRhLVtzdGF0ZT1jbG9zZWRdOnpvb20tb3V0LTk1IGRhdGEtW3N0YXRlPW9wZW5dOnpvb20taW4tOTUgZGF0YS1bc2lkZT1ib3R0b21dOnNsaWRlLWluLWZyb20tdG9wLTIgZGF0YS1bc2lkZT1sZWZ0XTpzbGlkZS1pbi1mcm9tLXJpZ2h0LTIgZGF0YS1bc2lkZT1yaWdodF06c2xpZGUtaW4tZnJvbS1sZWZ0LTIgZGF0YS1bc2lkZT10b3BdOnNsaWRlLWluLWZyb20tYm90dG9tLTIgcmVsYXRpdmUgei01MCBtYXgtaC05NiBtaW4tdy1bOHJlbV0gb3ZlcmZsb3ctaGlkZGVuIHJvdW5kZWQtbWQgYm9yZGVyIHNoYWRvdy1tZFwiLFxuICAgICAgICBwb3NpdGlvbiA9PT0gXCJwb3BwZXJcIiAmJlxuICAgICAgICAgIFwiZGF0YS1bc2lkZT1ib3R0b21dOnRyYW5zbGF0ZS15LTEgZGF0YS1bc2lkZT1sZWZ0XTotdHJhbnNsYXRlLXgtMSBkYXRhLVtzaWRlPXJpZ2h0XTp0cmFuc2xhdGUteC0xIGRhdGEtW3NpZGU9dG9wXTotdHJhbnNsYXRlLXktMVwiLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICApfVxuICAgICAgcG9zaXRpb249e3Bvc2l0aW9ufVxuICAgICAgey4uLnByb3BzfVxuICAgID5cbiAgICAgIDxTZWxlY3RTY3JvbGxVcEJ1dHRvbiAvPlxuICAgICAgPFNlbGVjdFByaW1pdGl2ZS5WaWV3cG9ydFxuICAgICAgICBjbGFzc05hbWU9e2NuKFxuICAgICAgICAgIFwicC0xXCIsXG4gICAgICAgICAgcG9zaXRpb24gPT09IFwicG9wcGVyXCIgJiZcbiAgICAgICAgICAgIFwiaC1bdmFyKC0tcmFkaXgtc2VsZWN0LXRyaWdnZXItaGVpZ2h0KV0gdy1mdWxsIG1pbi13LVt2YXIoLS1yYWRpeC1zZWxlY3QtdHJpZ2dlci13aWR0aCldXCIsXG4gICAgICAgICl9XG4gICAgICA+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvU2VsZWN0UHJpbWl0aXZlLlZpZXdwb3J0PlxuICAgICAgPFNlbGVjdFNjcm9sbERvd25CdXR0b24gLz5cbiAgICA8L1NlbGVjdFByaW1pdGl2ZS5Db250ZW50PlxuICA8L1NlbGVjdFByaW1pdGl2ZS5Qb3J0YWw+XG4pKTtcblNlbGVjdENvbnRlbnQuZGlzcGxheU5hbWUgPSBTZWxlY3RQcmltaXRpdmUuQ29udGVudC5kaXNwbGF5TmFtZTtcblxuY29uc3QgU2VsZWN0TGFiZWwgPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBSZWFjdC5FbGVtZW50UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuTGFiZWw+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5MYWJlbD5cbj4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5MYWJlbFxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXCJweC0yIHB5LTEuNSB0ZXh0LXNtIGZvbnQtc2VtaWJvbGRcIiwgY2xhc3NOYW1lKX1cbiAgICB7Li4ucHJvcHN9XG4gIC8+XG4pKTtcblNlbGVjdExhYmVsLmRpc3BsYXlOYW1lID0gU2VsZWN0UHJpbWl0aXZlLkxhYmVsLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RJdGVtID0gUmVhY3QuZm9yd2FyZFJlZjxcbiAgUmVhY3QuRWxlbWVudFJlZjx0eXBlb2YgU2VsZWN0UHJpbWl0aXZlLkl0ZW0+LFxuICBSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8dHlwZW9mIFNlbGVjdFByaW1pdGl2ZS5JdGVtPlxuPigoeyBjbGFzc05hbWUsIGNoaWxkcmVuLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgPFNlbGVjdFByaW1pdGl2ZS5JdGVtXG4gICAgcmVmPXtyZWZ9XG4gICAgY2xhc3NOYW1lPXtjbihcbiAgICAgIFwicmVsYXRpdmUgZmxleCB3LWZ1bGwgY3Vyc29yLWRlZmF1bHQgc2VsZWN0LW5vbmUgaXRlbXMtY2VudGVyIHJvdW5kZWQtc20gcHktMS41IHBsLTIgcHItOCB0ZXh0LXNtIG91dGxpbmUtbm9uZSBkYXRhLVtkaXNhYmxlZF06cG9pbnRlci1ldmVudHMtbm9uZSBkYXRhLVtkaXNhYmxlZF06b3BhY2l0eS01MFwiLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICl9XG4gICAgey4uLnByb3BzfVxuICA+XG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiYWJzb2x1dGUgcmlnaHQtMiBmbGV4IGgtMy41IHctMy41IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgPFNlbGVjdFByaW1pdGl2ZS5JdGVtSW5kaWNhdG9yPlxuICAgICAgICA8Q2hlY2sgY2xhc3NOYW1lPVwiaC00IHctNFwiIC8+XG4gICAgICA8L1NlbGVjdFByaW1pdGl2ZS5JdGVtSW5kaWNhdG9yPlxuICAgIDwvc3Bhbj5cbiAgICA8U2VsZWN0UHJpbWl0aXZlLkl0ZW1UZXh0PntjaGlsZHJlbn08L1NlbGVjdFByaW1pdGl2ZS5JdGVtVGV4dD5cbiAgPC9TZWxlY3RQcmltaXRpdmUuSXRlbT5cbikpO1xuU2VsZWN0SXRlbS5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5JdGVtLmRpc3BsYXlOYW1lO1xuXG5jb25zdCBTZWxlY3RTZXBhcmF0b3IgPSBSZWFjdC5mb3J3YXJkUmVmPFxuICBSZWFjdC5FbGVtZW50UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yPixcbiAgUmVhY3QuQ29tcG9uZW50UHJvcHNXaXRob3V0UmVmPHR5cGVvZiBTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yPlxuPigoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0sIHJlZikgPT4gKFxuICA8U2VsZWN0UHJpbWl0aXZlLlNlcGFyYXRvclxuICAgIHJlZj17cmVmfVxuICAgIGNsYXNzTmFtZT17Y24oXCJiZy1tdXRlZCAtbXgtMSBteS0xIGgtcHhcIiwgY2xhc3NOYW1lKX1cbiAgICB7Li4ucHJvcHN9XG4gIC8+XG4pKTtcblNlbGVjdFNlcGFyYXRvci5kaXNwbGF5TmFtZSA9IFNlbGVjdFByaW1pdGl2ZS5TZXBhcmF0b3IuZGlzcGxheU5hbWU7XG5cbmV4cG9ydCB7XG4gIFNlbGVjdCxcbiAgU2VsZWN0R3JvdXAsXG4gIFNlbGVjdFZhbHVlLFxuICBTZWxlY3RUcmlnZ2VyLFxuICBTZWxlY3RDb250ZW50LFxuICBTZWxlY3RMYWJlbCxcbiAgU2VsZWN0SXRlbSxcbiAgU2VsZWN0U2VwYXJhdG9yLFxuICBTZWxlY3RTY3JvbGxVcEJ1dHRvbixcbiAgU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbixcbn07XG4iLCJpbXBvcnQgeyBjbiB9IGZyb20gXCJAdXRpbHMvc3RyaW5nVXRpbHNcIjtcbmltcG9ydCB7IENoZWNrSWNvbiwgQ29weUljb24gfSBmcm9tIFwibHVjaWRlLXJlYWN0XCI7XG5pbXBvcnQgeyBSZWFjdE5vZGUsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCBDb3B5QnV0dG9uID0gKHtcbiAgbGFiZWwsXG4gIGJ1dHRvbkNsYXNzTmFtZSxcbiAgbG9nb0NsYXNzTmFtZSxcbiAgdGV4dFRvQ29weSxcbiAgZGlzYWJsZWQsXG59OiB7XG4gIGxhYmVsOiBSZWFjdE5vZGU7XG4gIHRleHRUb0NvcHk6ICgpID0+IHN0cmluZztcbiAgYnV0dG9uQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBsb2dvQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG59KSA9PiB7XG4gIGNvbnN0IFtsb2dvLCBzZXRMb2dvXSA9IHVzZVN0YXRlPFJlYWN0Tm9kZT4oXG4gICAgPENvcHlJY29uIGNsYXNzTmFtZT17Y24oXCJoLTMgdy0zXCIsIGxvZ29DbGFzc05hbWUpfSAvPixcbiAgKTtcbiAgY29uc3QgW2ludGVybmFsTGFiZWwsIHNldEludGVybmFsTGFiZWxdID0gdXNlU3RhdGU8UmVhY3ROb2RlPihsYWJlbCk7XG4gIGNvbnN0IG9uQ2xpcGJvYXJkQ29weSA9ICgpID0+IHtcbiAgICBzZXRMb2dvKDxDaGVja0ljb24gY2xhc3NOYW1lPXtjbihcImgtMyB3LTNcIiwgbG9nb0NsYXNzTmFtZSl9IC8+KTtcbiAgICBzZXRJbnRlcm5hbExhYmVsKFwiQ29waWVkIVwiKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldExvZ28oPENvcHlJY29uIGNsYXNzTmFtZT17Y24oXCJoLTMgdy0zXCIsIGxvZ29DbGFzc05hbWUpfSAvPik7XG4gICAgICBzZXRJbnRlcm5hbExhYmVsKGxhYmVsKTtcbiAgICB9LCAxMDAwKTtcbiAgfTtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBhcmlhLWxhYmVsPVwiQ29weSB0byBjbGlwYm9hcmRcIlxuICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgY2xhc3NOYW1lPXtjbihcbiAgICAgICAgXCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6dGV4dC1ub2lyLTQwMCBkYXJrOnRleHQtbm9pci0xMDAgZGFyazpkaXNhYmxlZDp0ZXh0LXppbmMtNjAwXCIsXG4gICAgICAgIGJ1dHRvbkNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0VG9Db3B5KCk7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpO1xuICAgICAgICBvbkNsaXBib2FyZENvcHkoKTtcbiAgICAgIH19XG4gICAgPlxuICAgICAge2xvZ299XG4gICAgICB7aW50ZXJuYWxMYWJlbH1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn07XG4iLCJpbXBvcnQge1xuICBiYXNlSW5TZWxlY3Rpb24sXG4gIGdldEFubm90YXRlZFNlcXVlbmNlLFxuICBzdGFja0Fubm90YXRpb25zTm9PdmVybGFwLFxufSBmcm9tIFwiQEFyaWFkbmUvdXRpbHNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBBbm5vdGF0ZWRCYXNlLFxuICBBbm5vdGF0aW9uLFxuICBBcmlhZG5lU2VsZWN0aW9uLFxuICBTdGFja2VkQW5ub3RhdGlvbixcbn0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmltcG9ydCB7XG4gIFNlbGVjdCxcbiAgU2VsZWN0Q29udGVudCxcbiAgU2VsZWN0SXRlbSxcbiAgU2VsZWN0VmFsdWUsXG4gIFNlbGVjdFRyaWdnZXIsXG59IGZyb20gXCJAdWkvc2VsZWN0XCI7XG5pbXBvcnQgeyBDb3B5QnV0dG9uIH0gZnJvbSBcIkB1aS9jb3B5LWJ1dHRvblwiO1xuXG5leHBvcnQgY29uc3QgU2VxdWVuY2VWaWV3ZXIgPSAoe1xuICBzZXF1ZW5jZXMsXG4gIGFubm90YXRpb25zLFxuICBzZWxlY3Rpb24sXG4gIHNldFNlbGVjdGlvbixcbiAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICBjaGFyQ2xhc3NOYW1lLFxuICBzZWxlY3Rpb25DbGFzc05hbWUsXG4gIGhpZGVNZXRhZGF0YUJhcixcbiAgbm9WYWxpZGF0ZSxcbn06IHtcbiAgc2VxdWVuY2VzOiBzdHJpbmdbXTtcbiAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgY29udGFpbmVyQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBoaWRlTWV0YWRhdGFCYXI/OiBib29sZWFuO1xuICBub1ZhbGlkYXRlPzogYm9vbGVhbjtcbn0pID0+IHtcbiAgY29uc3QgW2hvdmVyZWRQb3NpdGlvbiwgc2V0SG92ZXJlZFBvc2l0aW9uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2VxSWR4VG9Db3B5LCBzZXRTZXFJZHhUb0NvcHldID0gdXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW2FjdGl2ZUFubm90YXRpb24sIHNldEFjdGl2ZUFubm90YXRpb25dID0gdXNlU3RhdGU8QW5ub3RhdGlvbiB8IG51bGw+KFxuICAgIG51bGwsXG4gICk7XG4gIGNvbnN0IHN0YWNrZWRBbm5vdGF0aW9ucyA9IHVzZU1lbW8oXG4gICAgZnVuY3Rpb24gbWVtb2l6ZSgpIHtcbiAgICAgIHJldHVybiBzdGFja0Fubm90YXRpb25zTm9PdmVybGFwKFxuICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgTWF0aC5tYXgoLi4uc2VxdWVuY2VzLm1hcCgoc2VxKSA9PiBzZXEubGVuZ3RoKSksXG4gICAgICApO1xuICAgIH0sXG4gICAgW2Fubm90YXRpb25zXSxcbiAgKTtcbiAgY29uc3QgYW5ub3RhdGVkU2VxdWVuY2VzID0gdXNlTWVtbyhcbiAgICBmdW5jdGlvbiBtZW1vaXplKCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlcy5tYXAoKHNlcXVlbmNlKSA9PlxuICAgICAgICBnZXRBbm5vdGF0ZWRTZXF1ZW5jZSh7IHNlcXVlbmNlLCBzdGFja2VkQW5ub3RhdGlvbnMsIG5vVmFsaWRhdGUgfSksXG4gICAgICApO1xuICAgIH0sXG4gICAgW3NlcXVlbmNlcywgc3RhY2tlZEFubm90YXRpb25zXSxcbiAgKTtcblxuICBjb25zdCBtZW1vaXplZFNlcUNvbnRlbnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPFNlcUNvbnRlbnRcbiAgICAgICAgYW5ub3RhdGVkU2VxdWVuY2VzPXthbm5vdGF0ZWRTZXF1ZW5jZXN9XG4gICAgICAgIHNlbGVjdGlvbj17c2VsZWN0aW9ufVxuICAgICAgICBzZXRTZWxlY3Rpb249e3NldFNlbGVjdGlvbn1cbiAgICAgICAgc2V0SG92ZXJlZFBvc2l0aW9uPXtzZXRIb3ZlcmVkUG9zaXRpb259XG4gICAgICAgIHNldEFjdGl2ZUFubm90YXRpb249e3NldEFjdGl2ZUFubm90YXRpb259XG4gICAgICAgIHN0YWNrZWRBbm5vdGF0aW9ucz17c3RhY2tlZEFubm90YXRpb25zfVxuICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjaGFyQ2xhc3NOYW1lfVxuICAgICAgICBzZWxlY3Rpb25DbGFzc05hbWU9e3NlbGVjdGlvbkNsYXNzTmFtZX1cbiAgICAgIC8+XG4gICAgKTtcbiAgfSwgW2Fubm90YXRlZFNlcXVlbmNlcywgc2VsZWN0aW9uLCBzdGFja2VkQW5ub3RhdGlvbnNdKTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgXCJyZWxhdGl2ZSBpc29sYXRlIGZsZXggZmxleC13cmFwXCIsXG4gICAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgICApfVxuICAgICAgPlxuICAgICAgICAgIDxTZXFNZXRhZGF0YUJhclxuICAgICAgICAgICAgaG92ZXJlZFBvc2l0aW9uPXtob3ZlcmVkUG9zaXRpb259XG4gICAgICAgICAgICBhY3RpdmVBbm5vdGF0aW9uPXthY3RpdmVBbm5vdGF0aW9ufVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwic3RpY2t5IGluc2V0LXgtMCB0b3AtMCB6LVszXSB3LWZ1bGwgcHgtMiBweS0xIGJhY2tkcm9wLWJsdXItbWRcIiwgaGlkZU1ldGFkYXRhQmFyID8gJ2hpZGRlbicgOiAnJyl9XG4gICAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZXM9e2Fubm90YXRlZFNlcXVlbmNlc31cbiAgICAgICAgICAgIGNoYXJDbGFzc05hbWU9e2NoYXJDbGFzc05hbWV9XG4gICAgICAgICAgICBzZXFJZHhUb0NvcHk9e3NlcUlkeFRvQ29weX1cbiAgICAgICAgICAgIHNldFNlcUlkeFRvQ29weT17c2V0U2VxSWR4VG9Db3B5fVxuICAgICAgICAgICAgc2VsZWN0aW9uPXtzZWxlY3Rpb259XG4gICAgICAgICAgLz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBweC0yXCI+e21lbW9pemVkU2VxQ29udGVudH08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvPlxuICApO1xufTtcbmV4cG9ydCBjb25zdCBTZXFDb250ZW50ID0gKHtcbiAgYW5ub3RhdGVkU2VxdWVuY2VzLFxuICBzZWxlY3Rpb24sXG4gIHNldFNlbGVjdGlvbixcbiAgc2V0SG92ZXJlZFBvc2l0aW9uLFxuICBzZXRBY3RpdmVBbm5vdGF0aW9uLFxuICBzdGFja2VkQW5ub3RhdGlvbnMsXG4gIGNoYXJDbGFzc05hbWUsXG4gIHNlbGVjdGlvbkNsYXNzTmFtZSxcbn06IHtcbiAgYW5ub3RhdGVkU2VxdWVuY2VzOiBBbm5vdGF0ZWRCYXNlW11bXTtcbiAgc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbDtcbiAgc2V0U2VsZWN0aW9uOiAoc2VsZWN0aW9uOiBBcmlhZG5lU2VsZWN0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0SG92ZXJlZFBvc2l0aW9uOiAocG9zaXRpb246IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEFjdGl2ZUFubm90YXRpb246IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgc3RhY2tlZEFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgc2VsZWN0aW9uQ2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBtb3VzZURvd24gPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpbmRpY2VzQ2xhc3NOYW1lID0gKHtcbiAgICBiYXNlLFxuICAgIHNlcXVlbmNlSWR4LFxuICB9OiB7XG4gICAgYmFzZTogQW5ub3RhdGVkQmFzZTtcbiAgICBzZXF1ZW5jZUlkeDogbnVtYmVyO1xuICB9KSA9PiB7XG4gICAgY29uc3QgaXNOb3RGaXJzdFNlcSA9IHNlcXVlbmNlSWR4ICE9PSAwO1xuICAgIGNvbnN0IGlzTm90TXVsdGlwbGVPZlRlbiA9IGJhc2UuaW5kZXggJSAxMCAhPT0gMDtcblxuICAgIGlmIChpc05vdEZpcnN0U2VxIHx8IGlzTm90TXVsdGlwbGVPZlRlbikge1xuICAgICAgcmV0dXJuIFwib3BhY2l0eS0wXCI7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzKFxuICAgICAgXCJ0ZXh0LXhzIHotMVwiLFxuICAgICAgLy8gZG9uJ3QgYWxsb3cgc2VsZWN0aW9uIG9mIGluZGljZXNcbiAgICAgIFwiZGFyazpncm91cC1ob3Zlcjp0ZXh0LW5vaXItMzAwIGdyb3VwLWhvdmVyOnRleHQtbm9pci04MDBcIixcbiAgICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgIGJhc2VJbmRleDogYmFzZS5pbmRleCxcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBzZXF1ZW5jZUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2VzW3NlcXVlbmNlSWR4XS5sZW5ndGgsXG4gICAgICB9KVxuICAgICAgICA/IFwidGV4dC1icmFuZC03MDAgZGFyazp0ZXh0LWJyYW5kLTMwMFwiXG4gICAgICAgIDogXCJ0ZXh0LW5vaXItNDAwIGRhcms6dGV4dC1ub2lyLTYwMFwiLFxuICAgICk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgbW91c2VEb3duLmN1cnJlbnQgPSBmYWxzZTtcbiAgfTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gYWRkTW91c2VVcExpc3RlbmVyKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIGhhbmRsZU1vdXNlVXAoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTW91c2VVcExpc3RlbmVyKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgKCkgPT4ge1xuICAgICAgICBoYW5kbGVNb3VzZVVwKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2Fubm90YXRlZFNlcXVlbmNlc1swXS5tYXAoKHsgaW5kZXg6IGJhc2VJZHggfSkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgXCJyZWxhdGl2ZSBtdC00IGZsZXggZmxleC1jb2wganVzdGlmeS1iZXR3ZWVuXCIsXG4gICAgICAgICAgICAgIFwiZ3JvdXAgaG92ZXI6Ymctbm9pci0yMDAgZGFyazpob3ZlcjpiZy1ub2lyLTYwMFwiLFxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIGtleT17YGJhc2UtJHtiYXNlSWR4fWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2Fubm90YXRlZFNlcXVlbmNlcy5tYXAoXG4gICAgICAgICAgICAgIChzZXF1ZW5jZTogQW5ub3RhdGVkQmFzZVtdLCBzZXF1ZW5jZUlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBzZXF1ZW5jZS5maW5kKFxuICAgICAgICAgICAgICAgICAgKGJhc2U6IEFubm90YXRlZEJhc2UpID0+IGJhc2UuaW5kZXggPT09IGJhc2VJZHgsXG4gICAgICAgICAgICAgICAgKSB8fCB7IGJhc2U6IFwiIFwiLCBhbm5vdGF0aW9uczogW10sIGluZGV4OiBiYXNlSWR4IH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBrZXk9e2BzZXF1ZW5jZS0ke3NlcXVlbmNlSWR4fS1iYXNlLSR7YmFzZUlkeH1gfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXCJ3aGl0ZXNwYWNlLXByZSB0ZXh0LWNlbnRlclwiKX1cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SG92ZXJlZFBvc2l0aW9uKGJhc2UuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG1vdXNlIGlzIGRvd24sIHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2VEb3duLmN1cnJlbnQgJiYgc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogYmFzZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiBzZXRIb3ZlcmVkUG9zaXRpb24obnVsbCl9XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogYmFzZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogYmFzZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJmb3J3YXJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VVcD17aGFuZGxlTW91c2VVcH1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPENoYXJDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyPXtgfCAke2Jhc2UuaW5kZXh9YH1cbiAgICAgICAgICAgICAgICAgICAgICBpbmRleD17YmFzZUlkeH1cbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhYnNvbHV0ZSAtdG9wLTQgbGVmdC0wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdyb3VwLWhvdmVyOnRleHQtYnJhbmQtMjAwIGJvcmRlci1iIGJvcmRlci1ub2lyLTYwMCBncm91cC1ob3Zlcjpib3JkZXItbm9pci0zMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNDbGFzc05hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxDaGFyQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgY2hhcj17YmFzZS5iYXNlfVxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4PXtiYXNlSWR4fVxuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2xhc3NOYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VJbmRleDogYmFzZUlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZXNbc2VxdWVuY2VJZHhdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UuYmFzZSAhPT0gXCIgXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxTZXF1ZW5jZUFubm90YXRpb25cbiAgICAgICAgICAgICAgYW5ub3RhdGlvbnM9e3N0YWNrZWRBbm5vdGF0aW9uc31cbiAgICAgICAgICAgICAgaW5kZXg9e2Jhc2VJZHh9XG4gICAgICAgICAgICAgIG1heEFubm90YXRpb25TdGFjaz17TWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heCguLi5zdGFja2VkQW5ub3RhdGlvbnMubWFwKChhbm4pID0+IGFubi5zdGFjaykpLFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICBzZXRIb3ZlcmVkUG9zaXRpb249e3NldEhvdmVyZWRQb3NpdGlvbn1cbiAgICAgICAgICAgICAgc2V0QWN0aXZlQW5ub3RhdGlvbj17c2V0QWN0aXZlQW5ub3RhdGlvbn1cbiAgICAgICAgICAgICAgbWF4U2VxdWVuY2VMZW5ndGg9e01hdGgubWF4KFxuICAgICAgICAgICAgICAgIC4uLmFubm90YXRlZFNlcXVlbmNlcy5tYXAoKHNlcSkgPT4gc2VxLmxlbmd0aCksXG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgICAgfSl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgU2VxTWV0YWRhdGFCYXIgPSAoe1xuICBob3ZlcmVkUG9zaXRpb24sXG4gIGFjdGl2ZUFubm90YXRpb24sXG4gIGFubm90YXRlZFNlcXVlbmNlcyxcbiAgY2hhckNsYXNzTmFtZSxcbiAgc2VxSWR4VG9Db3B5LFxuICBzZXRTZXFJZHhUb0NvcHksXG4gIHNlbGVjdGlvbixcbiAgY2xhc3NOYW1lLFxufToge1xuICBob3ZlcmVkUG9zaXRpb246IG51bWJlciB8IG51bGw7XG4gIGFjdGl2ZUFubm90YXRpb246IEFubm90YXRpb24gfCBudWxsO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZXM6IEFubm90YXRlZEJhc2VbXVtdO1xuICBzZXFJZHhUb0NvcHk6IG51bWJlcjtcbiAgc2V0U2VxSWR4VG9Db3B5OiAoaWR4OiBudW1iZXIpID0+IHZvaWQ7XG4gIGNoYXJDbGFzc05hbWU6ICh7XG4gICAgYmFzZSxcbiAgICBzZXF1ZW5jZUlkeCxcbiAgfToge1xuICAgIGJhc2U6IEFubm90YXRlZEJhc2U7XG4gICAgc2VxdWVuY2VJZHg6IG51bWJlcjtcbiAgfSkgPT4gc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59KSA9PiB7XG4gIGNvbnN0IGFubm90YXRpb25EaXNwbGF5ID0gYWN0aXZlQW5ub3RhdGlvbiA/IChcbiAgICA8c3BhblxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICBcImZsZXggZ2FwLTIgcm91bmRlZC1mdWxsIHB4LTIgcHktcHggdGV4dC14cyAhb3BhY2l0eS0xMDBcIixcbiAgICAgICAgXCJtbC1hdXRvXCIsXG4gICAgICAgIGFjdGl2ZUFubm90YXRpb24uY2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICA+XG4gICAgICA8c3Bhbj5MYWJlbDoge2FjdGl2ZUFubm90YXRpb24udGV4dH08L3NwYW4+XG4gICAgICA8c3Bhbj5UeXBlOiB7YWN0aXZlQW5ub3RhdGlvbi50eXBlfTwvc3Bhbj5cbiAgICAgIDxzcGFuPkRpcmVjdGlvbjoge2FjdGl2ZUFubm90YXRpb24uZGlyZWN0aW9ufTwvc3Bhbj5cbiAgICAgIDxzcGFuPlxuICAgICAgICBmcm9tIHthY3RpdmVBbm5vdGF0aW9uLnN0YXJ0fSAtIHthY3RpdmVBbm5vdGF0aW9uLmVuZH1cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gICkgOiBudWxsO1xuICBjb25zdCBwb3NpdGlvbkRpc3BsYXkgPSAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwibWluLXctMTYgdGV4dC14cyB0ZXh0LWJsYWNrIGRhcms6dGV4dC13aGl0ZVwiPlxuICAgICAgUG9zOiB7aG92ZXJlZFBvc2l0aW9uID8/IDB9XG4gICAgPC9zcGFuPlxuICApO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgXCJmbGV4IGgtOCBpdGVtcy1jZW50ZXIgZ2FwLTEgcHktMSB0ZXh0LXhzXCIsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICl9XG4gICAgPlxuICAgICAge3Bvc2l0aW9uRGlzcGxheX1cbiAgICAgIDxDb3B5RGlzcGxheVxuICAgICAgICBhbm5vdGF0ZWRTZXF1ZW5jZXM9e2Fubm90YXRlZFNlcXVlbmNlc31cbiAgICAgICAgY2hhckNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZX1cbiAgICAgICAgc2VxSWR4VG9Db3B5PXtzZXFJZHhUb0NvcHl9XG4gICAgICAgIHNldFNlcUlkeFRvQ29weT17c2V0U2VxSWR4VG9Db3B5fVxuICAgICAgICBzZWxlY3Rpb249e3NlbGVjdGlvbn1cbiAgICAgIC8+XG4gICAgICB7YW5ub3RhdGlvbkRpc3BsYXl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgU2VxdWVuY2VBbm5vdGF0aW9uID0gKHtcbiAgYW5ub3RhdGlvbnMsXG4gIG1heEFubm90YXRpb25TdGFjayxcbiAgaW5kZXgsXG4gIHNldEhvdmVyZWRQb3NpdGlvbixcbiAgc2V0QWN0aXZlQW5ub3RhdGlvbixcbiAgbWF4U2VxdWVuY2VMZW5ndGgsXG59OiB7XG4gIGFubm90YXRpb25zOiBTdGFja2VkQW5ub3RhdGlvbltdO1xuICBtYXhBbm5vdGF0aW9uU3RhY2s6IG51bWJlcjtcbiAgc2V0SG92ZXJlZFBvc2l0aW9uOiAocG9zaXRpb246IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEFjdGl2ZUFubm90YXRpb246IChhbm5vdGF0aW9uOiBBbm5vdGF0aW9uIHwgbnVsbCkgPT4gdm9pZDtcbiAgbWF4U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbn0pID0+IHtcbiAgY29uc3Qgb3JkZXJlZEFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuc29ydCgoYSwgYikgPT4gYS5zdGFjayAtIGIuc3RhY2spO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cIiBcIlxuICAgICAga2V5PXtgYW5ub3RhdGlvbi0ke2luZGV4fWB9XG4gICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHNldEhvdmVyZWRQb3NpdGlvbihpbmRleCl9XG4gICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHNldEhvdmVyZWRQb3NpdGlvbihudWxsKX1cbiAgICA+XG4gICAgICB7Wy4uLkFycmF5KG1heEFubm90YXRpb25TdGFjaykua2V5cygpXS5tYXAoKGkpID0+IHtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvbiA9IG9yZGVyZWRBbm5vdGF0aW9uc1xuICAgICAgICAgIC5maWx0ZXIoKGFubikgPT5cbiAgICAgICAgICAgIGJhc2VJblNlbGVjdGlvbih7XG4gICAgICAgICAgICAgIGJhc2VJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbjogYW5uLFxuICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG4gICAgICAgICAgLmZpbmQoKGFubikgPT4gYW5uLnN0YWNrID09PSBpKTtcbiAgICAgICAgaWYgKGFubm90YXRpb24pIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhYmFzZUluU2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgYmFzZUluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uOiBhbm5vdGF0aW9uLFxuICAgICAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGtleT17YGFubm90YXRpb24tJHtpbmRleH0tJHtpfWB9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtcImgtMyBib3JkZXItYi0yIGJvcmRlci1ub2lyLTEwMCBvcGFjaXR5LTEwIFwifVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBrZXk9e2Bhbm5vdGF0aW9uLSR7aW5kZXh9LSR7aX1gfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICAgICAgICAgXCJncm91cC9hbm5vdGF0aW9uIGgtMyBib3JkZXItYmxhY2sgZ3JvdXAtaG92ZXIvYW5ub3RhdGlvbjpib3JkZXJcIixcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT5cbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLm9uQ2xpY2s/Lih7XG4gICAgICAgICAgICAgICAgICBzdGFydDogYW5ub3RhdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgIGVuZDogYW5ub3RhdGlvbi5lbmQsXG4gICAgICAgICAgICAgICAgICBkaWVjdGlvbjogYW5ub3RhdGlvbi5kaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9eygpID0+IHNldEFjdGl2ZUFubm90YXRpb24oYW5ub3RhdGlvbil9XG4gICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gc2V0QWN0aXZlQW5ub3RhdGlvbihudWxsKX1cbiAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17YHBsYWNlaG9sZGVyLSR7aW5kZXh9LSR7aX1gfSBjbGFzc05hbWU9e1wiaC0zXCJ9IC8+O1xuICAgICAgICB9XG4gICAgICB9KX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmludGVyZmFjZSBDaGFyUHJvcHMge1xuICBjaGFyOiBzdHJpbmc7XG4gIGluZGV4OiBudW1iZXI7XG4gIGNoYXJDbGFzc05hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IENoYXJDb21wb25lbnQgPSAoeyBjaGFyLCBjaGFyQ2xhc3NOYW1lIH06IENoYXJQcm9wcykgPT4ge1xuICAvLyBkb24ndCBhbGxvdyBzZWxlY3Rpb24gb2YgY2hhcnNcbiAgY29uc3Qgc2hhcmVkQ2xhc3NOYW1lID0gXCJmb250LW1vbm8gc2VsZWN0LW5vbmVcIjtcbiAgaWYgKGNoYXIgPT09IFwiIFwiKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHNoYXJlZENsYXNzTmFtZSwgY2hhckNsYXNzTmFtZSwgXCJvcGFjaXR5LTIwXCIpfT5cbiAgICAgICAgLlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHNoYXJlZENsYXNzTmFtZSwgY2hhckNsYXNzTmFtZSwgXCJtci1weFwiKX0+XG4gICAgICB7Y2hhcn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBDb3B5RGlzcGxheSA9ICh7XG4gIHNlcUlkeFRvQ29weSxcbiAgc2V0U2VxSWR4VG9Db3B5LFxuICBhbm5vdGF0ZWRTZXF1ZW5jZXMsXG4gIGNoYXJDbGFzc05hbWUsXG4gIHNlbGVjdGlvbixcbn06IHtcbiAgc2VxSWR4VG9Db3B5OiBudW1iZXI7XG4gIHNldFNlcUlkeFRvQ29weTogKGlkeDogbnVtYmVyKSA9PiB2b2lkO1xuICBzZWxlY3Rpb246IEFyaWFkbmVTZWxlY3Rpb24gfCBudWxsO1xuICBhbm5vdGF0ZWRTZXF1ZW5jZXM6IEFubm90YXRlZEJhc2VbXVtdO1xuICBjaGFyQ2xhc3NOYW1lOiAoe1xuICAgIGJhc2UsXG4gICAgc2VxdWVuY2VJZHgsXG4gIH06IHtcbiAgICBiYXNlOiBBbm5vdGF0ZWRCYXNlO1xuICAgIHNlcXVlbmNlSWR4OiBudW1iZXI7XG4gIH0pID0+IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBnZXRTdHJpbmdUb0NvcHkgPSAoKSA9PiB7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VxID0gYW5ub3RhdGVkU2VxdWVuY2VzW3NlcUlkeFRvQ29weV07XG4gICAgY29uc3Qgc3RyaW5nVG9Db3B5ID0gc2VxXG4gICAgICAuZmlsdGVyKChiYXNlKSA9PlxuICAgICAgICBiYXNlSW5TZWxlY3Rpb24oe1xuICAgICAgICAgIGJhc2VJbmRleDogYmFzZS5pbmRleCxcbiAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbixcbiAgICAgICAgICBzZXF1ZW5jZUxlbmd0aDogYW5ub3RhdGVkU2VxdWVuY2VzW3NlcUlkeFRvQ29weV0ubGVuZ3RoLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICAgIC5tYXAoKGJhc2UpID0+IGJhc2UuYmFzZSlcbiAgICAgIC5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzdHJpbmdUb0NvcHk7XG4gIH07XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBtb3VudENvcHlIYW5kbGVyKCkge1xuICAgIGNvbnN0IGNvcHlIYW5kbGVyID0gYXN5bmMgKGU6IENsaXBib2FyZEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzdHJpbmdUb0NvcHkgPSBnZXRTdHJpbmdUb0NvcHkoKTtcbiAgICAgIGlmICghc3RyaW5nVG9Db3B5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHN0cmluZ1RvQ29weSk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCBjb3B5SGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnRDb3B5SGFuZGxlcigpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIGNvcHlIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbc2VsZWN0aW9uLCBhbm5vdGF0ZWRTZXF1ZW5jZXMsIHNlcUlkeFRvQ29weV0pO1xuXG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZmxleFwiPlxuICAgICAgPFNlbGVjdFxuICAgICAgICB2YWx1ZT17c2VxSWR4VG9Db3B5LnRvU3RyaW5nKCl9XG4gICAgICAgIG9uVmFsdWVDaGFuZ2U9eyh2YWx1ZSkgPT4gc2V0U2VxSWR4VG9Db3B5KHBhcnNlSW50KHZhbHVlKSl9XG4gICAgICA+XG4gICAgICAgIDxTZWxlY3RUcmlnZ2VyIGNsYXNzTmFtZT1cInctZml0XCI+XG4gICAgICAgICAgPFNlbGVjdFZhbHVlXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NoYXJDbGFzc05hbWUoe1xuICAgICAgICAgICAgICBiYXNlOiB7IGJhc2U6IFwiQVwiLCBhbm5vdGF0aW9uczogW10sIGluZGV4OiAwIH0sXG4gICAgICAgICAgICAgIHNlcXVlbmNlSWR4OiBzZXFJZHhUb0NvcHksXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICBTZXF1ZW5jZSB7c2VxSWR4VG9Db3B5ICsgMX1cbiAgICAgICAgICA8L1NlbGVjdFZhbHVlPlxuICAgICAgICA8L1NlbGVjdFRyaWdnZXI+XG4gICAgICAgIDxTZWxlY3RDb250ZW50IGNsYXNzTmFtZT1cImJnLXdoaXRlIGRhcms6YmctYmxhY2tcIj5cbiAgICAgICAgICB7YW5ub3RhdGVkU2VxdWVuY2VzLm1hcCgoXywgaWR4KSA9PiAoXG4gICAgICAgICAgICA8U2VsZWN0SXRlbVxuICAgICAgICAgICAgICBrZXk9e2BzZXF1ZW5jZS0ke2lkeH1gfVxuICAgICAgICAgICAgICB2YWx1ZT17aWR4LnRvU3RyaW5nKCl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2hhckNsYXNzTmFtZSh7XG4gICAgICAgICAgICAgICAgYmFzZTogeyBiYXNlOiBcIkFcIiwgYW5ub3RhdGlvbnM6IFtdLCBpbmRleDogMCB9LFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlSWR4OiBpZHgsXG4gICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBTZXF1ZW5jZSB7aWR4ICsgMX17XCIgXCJ9XG4gICAgICAgICAgICA8L1NlbGVjdEl0ZW0+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvU2VsZWN0Q29udGVudD5cbiAgICAgIDwvU2VsZWN0PlxuICAgICAgPENvcHlCdXR0b25cbiAgICAgICAgdGV4dFRvQ29weT17KCkgPT4gZ2V0U3RyaW5nVG9Db3B5KCkgPz8gXCJcIn1cbiAgICAgICAgbGFiZWw9e1wiXCJ9XG4gICAgICAgIGRpc2FibGVkPXshc2VsZWN0aW9ufVxuICAgICAgLz5cbiAgICA8L3NwYW4+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgQW5ub3RhdGVkQmFzZSwgQW5ub3RhdGVkU2VxdWVuY2UgfSBmcm9tIFwiQEFyaWFkbmUvdHlwZXNcIjtcbmltcG9ydCB7IGNsYXNzTmFtZXMgfSBmcm9tIFwiQHV0aWxzL3N0cmluZ1V0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBSZWZlcmVuY2VUaWNrcyA9ICh7XG4gIHNlcXVlbmNlLFxuICBjbGFzc05hbWUsXG59OiB7XG4gIHNlcXVlbmNlOiBBbm5vdGF0ZWRTZXF1ZW5jZTtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwib3ZlcmZsb3ctaGlkZGVudGV4dC13aGl0ZSBmbGV4XCIsIGNsYXNzTmFtZSl9PlxuICAgICAge3NlcXVlbmNlLm1hcCgobnVjbDogQW5ub3RhdGVkQmFzZSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNob3dUaWNrcyA9IG51Y2wuYmFzZSAhPT0gXCItXCIgJiYgKG51Y2wuaW5kZXggKyAxKSAlIDEwID09PSAwOyAvLyB3ZSBkb24ndCB3YW50IHRvIHNob3cgdGlja3MgZm9yIGdhcHNcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZSBmbGV4IGgtMTIgZmxleC1jb2wgaXRlbXMtZW5kIGp1c3RpZnktZW5kXCJcbiAgICAgICAgICAgIGtleT17YGJhc2UtJHtpfS1pbmRleC13cmFwcGVyYH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICBcImZvbnQtbW9ubyBcIixcbiAgICAgICAgICAgICAgICBcImFic29sdXRlIGJvdHRvbS0wIGxlZnQtMCByaWdodC0wXCIsXG5cbiAgICAgICAgICAgICAgICBzaG93VGlja3MgPyBcIm9wYWNpdHktMTAwXCIgOiBcIm9wYWNpdHktMFwiLFxuICAgICAgICAgICAgICAgIG51Y2wuYmFzZSA9PT0gXCJHXCIgJiYgXCJ0ZXh0LXJlZC01MDBcIixcbiAgICAgICAgICAgICAgICBudWNsLmJhc2UgPT09IFwiQVwiICYmIFwidGV4dC15ZWxsb3ctNTAwXCIsXG4gICAgICAgICAgICAgICAgbnVjbC5iYXNlID09PSBcIlRcIiAmJiBcInRleHQtZ3JlZW4tNTAwXCIsXG4gICAgICAgICAgICAgICAgbnVjbC5iYXNlID09PSBcIkNcIiAmJiBcInRleHQtYmx1ZS01MDBcIixcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14c1wiPiB7bnVjbC5pbmRleCArIDF9PC9wPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJteC1hdXRvIHRleHQteHNcIj58PC9wPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFwibXItcHggZm9udC1tb25vIG9wYWNpdHktMFwiKX0+XG4gICAgICAgICAgICAgIHtudWNsLmJhc2V9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICAgIH0pfVxuICAgIDwvZGl2PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlJCQwIiwiUmVhY3QiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwianN4UnVudGltZU1vZHVsZSIsInJlcXVpcmUkJDEiLCJvZmZzZXQiLCJpbmRleCIsInNpemUiLCJ1dGlsIiwib2JqZWN0VXRpbCIsImVycm9yVXRpbCIsImVycm9yTWFwIiwiY3R4IiwibWluIiwibWF4IiwicmVzdWx0IiwiaXNzdWVzIiwiZWxlbWVudHMiLCJwcm9jZXNzZWQiLCJyIiwiX2EiLCJfYiIsIlpvZEZpcnN0UGFydHlUeXBlS2luZCIsImpzeCIsImpzeHMiLCJzdGFydCIsImVuZCIsIm1pc21hdGNoQ2xhc3NOYW1lIiwiRnJhZ21lbnQiLCJjbGFtcCIsIkZyYWdtZW50MiIsImNyZWF0ZUNvbGxlY3Rpb25TY29wZSIsInVzZUNvbGxlY3Rpb24iLCJOb2RlIiwidXNlQ2FsbGJhY2tSZWYiLCJjb3VudCIsInVzZUxheW91dEVmZmVjdCIsImNvbXB1dGVQb3NpdGlvbiIsInBsYXRmb3JtIiwiYXJyb3ciLCJmbGlwIiwic2lkZXMiLCJzaWRlIiwicGxhY2VtZW50Iiwib3ZlcmZsb3ciLCJoaWRlIiwic2hpZnQiLCJ4IiwieSIsImxpbWl0U2hpZnQiLCJnZXRDb21wdXRlZFN0eWxlIiwib2Zmc2V0JDEiLCJzaGlmdCQxIiwiZmxpcCQxIiwic2l6ZSQxIiwiaGlkZSQxIiwiYXJyb3ckMSIsImxpbWl0U2hpZnQkMSIsImRhdGEiLCJOQU1FIiwiQXJyb3ciLCJDT05URU5UX05BTUUiLCJmbG9hdGluZ1VJYXJyb3ciLCJBUlJPV19OQU1FIiwiQXJyb3dQcmltaXRpdmUuUm9vdCIsIlJvb3QyIiwiUE9SVEFMX05BTUUiLCJQb3J0YWwiLCJSZWFjdERPTSIsIl9fYXNzaWduIiwiY2JzIiwiU2lkZUNhciIsIlN0eWxlIiwiU2VsZWN0IiwiUG9wcGVyUHJpbWl0aXZlLlJvb3QiLCJTZWxlY3RUcmlnZ2VyIiwiUG9wcGVyUHJpbWl0aXZlLkFuY2hvciIsIlNlbGVjdFZhbHVlIiwiUG9ydGFsUHJpbWl0aXZlIiwiU2VsZWN0Q29udGVudCIsImZvY3VzRmlyc3QiLCJSZW1vdmVTY3JvbGwiLCJQb3BwZXJQcmltaXRpdmUuQ29udGVudCIsIlNlbGVjdExhYmVsIiwiU2VsZWN0SXRlbSIsIlNlbGVjdFNjcm9sbFVwQnV0dG9uIiwiU2VsZWN0U2Nyb2xsRG93bkJ1dHRvbiIsIlNlbGVjdFNlcGFyYXRvciIsIlBvcHBlclByaW1pdGl2ZS5BcnJvdyIsIkljb24iLCJTZWxlY3RQcmltaXRpdmUuUm9vdCIsIlNlbGVjdFByaW1pdGl2ZS5WYWx1ZSIsIlNlbGVjdFByaW1pdGl2ZS5UcmlnZ2VyIiwiU2VsZWN0UHJpbWl0aXZlLkljb24iLCJTZWxlY3RQcmltaXRpdmUuU2Nyb2xsVXBCdXR0b24iLCJTZWxlY3RQcmltaXRpdmUuU2Nyb2xsRG93bkJ1dHRvbiIsIlNlbGVjdFByaW1pdGl2ZS5Qb3J0YWwiLCJTZWxlY3RQcmltaXRpdmUuQ29udGVudCIsIlNlbGVjdFByaW1pdGl2ZS5WaWV3cG9ydCIsIlNlbGVjdFByaW1pdGl2ZS5MYWJlbCIsIlNlbGVjdFByaW1pdGl2ZS5JdGVtIiwiU2VsZWN0UHJpbWl0aXZlLkl0ZW1JbmRpY2F0b3IiLCJTZWxlY3RQcmltaXRpdmUuSXRlbVRleHQiLCJTZWxlY3RQcmltaXRpdmUuU2VwYXJhdG9yIiwiQ29weUljb24iLCJDaGVja0ljb24iLCJiYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU2EsTUFBSSxJQUFFQSxnQkFBaUIsSUFBRSxPQUFPLElBQUksZUFBZSxHQUFFLElBQUUsT0FBTyxJQUFJLGdCQUFnQixHQUFFLElBQUUsT0FBTyxVQUFVLGdCQUFlLElBQUUsRUFBRSxtREFBbUQsbUJBQWtCLElB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QUFVO0FBQUEsRUFDckU7QUFBQSxFQUNJLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsRUFDbEU7QUFBQSxFQUNJLElBQUksUUFBUTtBQUNSLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxLQUFLO0FBQUEsRUFDaEU7QUFBQSxFQUNJLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsRUFDbEU7QUFBQSxFQUNJLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDakU7QUFBQSxFQUNJLElBQUksV0FBVztBQUNYLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxRQUFRO0FBQUEsRUFDbkU7QUFBQSxFQUNJLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDakU7QUFBQSxFQUNJLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsRUFDbEU7QUFBQSxFQUNJLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDakU7QUFBQSxFQUNJLElBQUksT0FBTztBQUNQLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxJQUFJO0FBQUEsRUFDL0Q7QUFBQSxFQUNJLElBQUksU0FBUztB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LGNBQ0MsV0FBVztBQUFBLGdCQUNUO0FBQUEsZ0JBQ0E7QUFBQSxnQkFFQSxZQUFZLGdCQUFnQjtBQUFBLGdCQUM1QixLQUFLLFNBQVMsT0FBTztBQUFBLGdCQUNyQixLQUFLLFNBQVMsT0FBTztBQUFBLGdCQUNyQixLQUFLLFNBQVMsT0FBTztBQUFBLGdCQUNyQixLQUFLLFNBQVMsT0FBTztBQUFBLGNBQ3ZCO0FBQUEsY0FFQSxVQUFBO0FBQUEsZ0JBQUNBLGtDQUFBQSxLQUFBLEtBQUEsRUFBRSxXQUFVLFdBQVUsVUFBQTtBQUFBLGtCQUFBO0FBQUEsa0JBQUUsS0FBSyxRQUFRO0FBQUEsZ0JBQUEsR0FBRTtBQUFBLGdCQUN2Q0Qsa0NBQUEsSUFBQSxLQUFBLEVBQUUsV0FBVSxtQkFBa0IsVUFBQyxJQUFBLENBQUE7QUFBQSxjQUFBO0FBQUEsWUFBQTtBQUFBLFVBQ2xDO0FBQUEsZ0RBRUMsT0FBSSxFQUFBLFdBQVcsV0FBVywyQkFBMkIsR0FDbkQsZUFBSyxLQUNSLENBQUE7QUFBQSxRQUFBO0FBQUEsTUFBQTtBQUFBLE1BcEJLLFFBQVEsQ0FBQztBQUFBLElBcUJoQjtBQUFBLEVBRUgsQ0FBQSxHQUNIO0FBRUo7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyLDQsNSw2LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1XX0=
